L 1 "..\..\library\ms32f0xx\source\ms32f0xx_rcc.c"
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx_bus.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_bus.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_BUS_H
N#define __MS32F0XX_BUS_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
L 1 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_H
N#define __MS32F0XX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif /* __cplusplus */
N
N
N/* Includes ------------------------------------------------------------------*/
N#if defined (MS32F031)
X#if 1L
N  #include "ms32f031.h"
L 1 "..\..\chip\ms32f0xx\include\ms32f031.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F031_H
N#define __MS32F031_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif /* __cplusplus */
N
N/**
N * @brief Support for anonymous structures
N */
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION < 6000000 )
X  #if 1L && ( 5060960 < 6000000 )
N    #pragma anon_unions
N  #endif
N#endif
N
N/**
N * @brief Configuration of the Cortex-M0 Processor and Core Peripherals
N */
N#define __CM0_REV              0x0000U  /*!< Core Revision r0p0                            */
N#define __MPU_PRESENT               0U  /*!< MC60FXXXX do not provide MPU                  */
N#define __NVIC_PRIO_BITS            2U  /*!< MC60FXXXX uses 2 Bits for the Priority Levels */
N#define __Vendor_SysTickConfig      0U  /*!< Set to 1 if different SysTick Config is used  */
N
N /*!< Interrupt Number Definition */
Ntypedef enum {
N/******  Cortex-M0 Processor Exceptions Numbers **************************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                        */
N  HardFault_IRQn              = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                                */
N  SVC_IRQn                    = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                                  */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                                  */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                              */
N/******  MS32F0 specific Interrupt Numbers *******************************************************************/
N  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                                       */
N  PVD_IRQn                    = 1,      /*!< PVD Interrupt through EXTI Lines 16                             */
N  RTC_IRQn                    = 2,      /*!< RTC Interrupt through EXTI Lines 17, 19                         */
N  FLASH_IRQn                  = 3,      /*!< FLASH global Interrupt                                          */
N  RCC_IRQn                    = 4,      /*!< RCC global Interrupt                                            */
N  EXTI0_1_IRQn                = 5,      /*!< EXTI Line 0 and 1 Interrupt                                     */
N  EXTI2_3_IRQn                = 6,      /*!< EXTI Line 2 and 3 Interrupt                                     */
N  EXTI4_15_IRQn               = 7,      /*!< EXTI Line 4 to 15 Interrupt                                     */
N  DMA1_Channel1_IRQn          = 9,      /*!< DMA1 Channel 1 Interrupt                                        */
N  DMA1_Channel2_3_IRQn        = 10,     /*!< DMA1 Channel 2 and Channel 3 Interrupt                          */
N  DMA1_Channel4_5_IRQn        = 11,     /*!< DMA1 Channel 4 and Channel 5 Interrupt                          */
N  ADC1_COMP_IRQn              = 12,     /*!< ADC1 and CMP1/2 Interrupt                                       */
N  TIM1_BRK_UP_TRG_COM_IRQn    = 13,     /*!< TIM1 Break, Update, Trigger and Commutation Interrupt           */
N  TIM1_CC_IRQn                = 14,     /*!< TIM1 Capture Compare Interrupt                                  */
N  TIM2_IRQn                   = 15,     /*!< TIM2 global Interrupt                                           */
N  TIM3_IRQn                   = 16,     /*!< TIM3 global Interrupt                                           */
N  TIM14_IRQn                  = 19,     /*!< TIM14 global Interrupt                                          */
N  TIM16_IRQn                  = 21,     /*!< TIM16 global Interrupt                                          */
N  TIM17_IRQn                  = 22,     /*!< TIM17 global Interrupt                                          */
N  I2C1_IRQn                   = 23,     /*!< I2C1 Event Interrupt & EXTI Line23 Interrupt (I2C1 wakeup)      */
N  SPI1_IRQn                   = 25,     /*!< SPI1 global Interrupt                                           */
N  USART1_IRQn                 = 27      /*!< USART1 global Interrupt & EXTI Line25 Interrupt (USART1 wakeup) */
N} IRQn_Type;
N
N
N/* Includes ------------------------------------------------------------------*/
N#include "core_cm0.h"            /* Cortex-M0 processor and core peripherals */
L 1 "..\..\core\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V5.0.8
N * @date     21. August 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 35 "..\..\core\core_cm0.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M0
N  @{
N */
N
N#include "cmsis_version.h"
L 1 "..\..\core\cmsis_version.h" 1
N/**************************************************************************//**
N * @file     cmsis_version.h
N * @brief    CMSIS Core(M) Version definitions
N * @version  V5.0.4
N * @date     23. July 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CMSIS_VERSION_H
N#define __CMSIS_VERSION_H
N
N/*  CMSIS Version definitions */
N#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
N#define __CM_CMSIS_VERSION_SUB   ( 4U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
N#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
N                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
X#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) |                                    __CM_CMSIS_VERSION_SUB           )        
N#endif
L 64 "..\..\core\core_cm0.h" 2
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  CMSIS HAL sub version */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM0_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) |                                     __CM0_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                (0U)                                   /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_FP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "..\..\core\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.1.0
N * @date     09. October 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * Arm Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "..\..\core\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (Arm Compiler 5) header file
N * @version  V5.2.1
N * @date     26. March 2020
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060960 < 400677)
S  #error "Please use Arm Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (1L && (1  == 1))   )
N  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (0L && (__TARGET_ARCH_7_M  == 1))
S  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N  /* __ARM_ARCH_8_1M_MAIN__  not applicable */
N
N/* CMSIS compiler control DSP macros */
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __ARM_FEATURE_DSP         1
N#endif
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __STATIC_FORCEINLINE
N  #define __STATIC_FORCEINLINE                   static __forceinline
N#endif
N#ifndef   __NO_RETURN
N  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __PACKED_UNION
N  #define __PACKED_UNION                         __packed union
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N#ifndef   __RESTRICT
N  #define __RESTRICT                             __restrict
N#endif
N#ifndef   __COMPILER_BARRIER
N  #define __COMPILER_BARRIER()                   __memory_changed()
N#endif
N
N/* #########################  Startup and Lowlevel Init  ######################## */
N
N#ifndef __PROGRAM_START
N#define __PROGRAM_START           __main
N#endif
N
N#ifndef __INITIAL_SP
N#define __INITIAL_SP              Image$$ARM_LIB_STACK$$ZI$$Limit
N#endif
N
N#ifndef __STACK_LIMIT
N#define __STACK_LIMIT             Image$$ARM_LIB_STACK$$ZI$$Base
N#endif
N
N#ifndef __VECTOR_TABLE
N#define __VECTOR_TABLE            __Vectors
N#endif
N
N#ifndef __VECTOR_TABLE_ATTRIBUTE
N#define __VECTOR_TABLE_ATTRIBUTE  __attribute__((used, section("RESET")))
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1U);
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
N#else
N   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
N#else
N  (void)fpscr;
N#endif
N}
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int16_t __REVSH(int16_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int16_t __REVSH(int16_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value != 0U; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return result;
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#else   
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline int32_t __SSAT(int32_t val, uint32_t sat)
N{
N  if ((sat >= 1U) && (sat <= 32U))
N  {
N    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
N    const int32_t min = -1 - max ;
N    if (val > max)
N    {
N      return max;
N    }
N    else if (val < min)
N    {
N      return min;
N    }
N  }
N  return val;
N}
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline uint32_t __USAT(int32_t val, uint32_t sat)
N{
N  if (sat <= 31U)
N  {
N    const uint32_t max = ((1U << sat) - 1U);
N    if (val > (int32_t)max)
N    {
N      return max;
N    }
N    else if (val < 0)
N    {
N      return 0U;
N    }
N  }
N  return (uint32_t)val;
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
S#define __SXTB16_RORn(ARG1, ARG2)        __SXTB16(__ROR(ARG1, ARG2))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "..\..\core\cmsis_compiler.h" 2
N
N
N/*
N * Arm Compiler 6.6 LTM (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) && (__ARMCC_VERSION < 6100100)
S  #include "cmsis_armclang_ltm.h"
S
S  /*
S * Arm Compiler above 6.10.1 (armclang)
S */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6100100)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iccarm.h>
S
S
S/*
S * TI Arm Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S  #ifndef   __RESTRICT
S    #define __RESTRICT                             __restrict
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         @packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 116 "..\..\core\core_cm0.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000U
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RESERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N        uint32_t RESERVED0;
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N/*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0 */
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N/* The following EXC_RETURN values are saved the LR on exception entry */
N#define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */
N#define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */
N#define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */
N
N
N/* Interrupt Priorities are WORD accessible only under Armv6-M                  */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N#define __NVIC_SetPriorityGrouping(X) (void)(X)
N#define __NVIC_GetPriorityGrouping()  (0U)
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    __COMPILER_BARRIER();
X    __memory_changed();
N    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __COMPILER_BARRIER();
X    __memory_changed();
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __DSB();
X    __dsb(0xF);
N    __ISB();
X    __isb(0xF);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2U)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2U)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2U)));
N  }
N  else
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2U)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(2U)) ? (uint32_t)(2U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(2U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(2U));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(2U)) ? (uint32_t)(2U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(2U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(2U));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           Address 0 must be mapped to SRAM.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N  uint32_t *vectors = (uint32_t *)(NVIC_USER_IRQ_OFFSET << 2);      /* point to 1st user interrupt */
X  uint32_t *vectors = (uint32_t *)(16 << 2);       
N  *(vectors + (int32_t)IRQn) = vector;                              /* use pointer arithmetic to access vector */
N  /* ARM Application Note 321 states that the M0 does not require the architectural barrier */
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N  uint32_t *vectors = (uint32_t *)(NVIC_USER_IRQ_OFFSET << 2);      /* point to 1st user interrupt */
X  uint32_t *vectors = (uint32_t *)(16 << 2);       
N  return *(vectors + (int32_t)IRQn);                                /* use pointer arithmetic to access vector */
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
X__declspec(noreturn) static __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  __dsb(0xF);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0U == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 2U) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 62 "..\..\chip\ms32f0xx\include\ms32f031.h" 2
N#include "system_ms32f0xx.h"    /* MC60FXXXX System Header */
L 1 "..\..\chip\ms32f0xx\include\system_ms32f0xx.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __SYSTEM_MS32F0XX_H
N#define __SYSTEM_MS32F0XX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N  /* This variable is updated in three ways:
N      by calling CMSIS function SystemCoreClockUpdate()
N      Note: If you use this function to configure the system clock; then there
N            is no need to call the 2 first functions listed above, since SystemCoreClock
N            variable is updated automatically.
N  */
Nextern       uint32_t SystemCoreClock;     /*!< System Clock Frequency (Core Clock) */
Nextern const uint8_t  AHBPrescTable[16];   /*!< AHB prescalers table values */
Nextern const uint8_t  APBPrescTable[8];    /*!< APB prescalers table values */
N
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nextern void SystemInit            (void);
Nextern void SystemCoreClockUpdate (void);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif/*__SYSTEM_MS32F0XX_H */
N
N/******************************** END OF FILE *********************************/
L 63 "..\..\chip\ms32f0xx\include\ms32f031.h" 2
N#include <stdint.h>
N
N
N/* Exported types ------------------------------------------------------------*/
N/**
N  * @brief TIM(include TIM2  0x4000 0000 - 0x4000 03FF
N  *                    TIM3  0x4000 0400 - 0x4000 07FF
N  *                    TIM14 0x4000 2000 - 0x4000 23FF
N  *                    TIM1  0x4001 2C00 - 0x4001 2FFF
N  *                    TIM16 0x4001 4400 - 0x4001 47FF
N  *                    TIM17 0x4001 4800 - 0x4001 4BFF)
N  */
Ntypedef struct {
N  __IO uint32_t CEN               :  1;
X  volatile uint32_t CEN               :  1;
N  __IO uint32_t UDIS              :  1;
X  volatile uint32_t UDIS              :  1;
N  __IO uint32_t URS               :  1;
X  volatile uint32_t URS               :  1;
N  __IO uint32_t OPM               :  1;
X  volatile uint32_t OPM               :  1;
N  __IO uint32_t DIR               :  1;
X  volatile uint32_t DIR               :  1;
N  __IO uint32_t CMS               :  2;
X  volatile uint32_t CMS               :  2;
N  __IO uint32_t ARPE              :  1;
X  volatile uint32_t ARPE              :  1;
N  __IO uint32_t CKD               :  2;
X  volatile uint32_t CKD               :  2;
N  __IO uint32_t RES1              : 22;
X  volatile uint32_t RES1              : 22;
N} TIM_CR1_32Bit;
N
Ntypedef struct {
N  __IO uint32_t CCPC              :  1;
X  volatile uint32_t CCPC              :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t CCUS              :  1;
X  volatile uint32_t CCUS              :  1;
N  __IO uint32_t CCDS              :  1;
X  volatile uint32_t CCDS              :  1;
N  __IO uint32_t MMS               :  3;
X  volatile uint32_t MMS               :  3;
N  __IO uint32_t TI1S              :  1;
X  volatile uint32_t TI1S              :  1;
N  __IO uint32_t OIS1              :  1;
X  volatile uint32_t OIS1              :  1;
N  __IO uint32_t OIS1N             :  1;
X  volatile uint32_t OIS1N             :  1;
N  __IO uint32_t OIS2              :  1;
X  volatile uint32_t OIS2              :  1;
N  __IO uint32_t OIS2N             :  1;
X  volatile uint32_t OIS2N             :  1;
N  __IO uint32_t OIS3              :  1;
X  volatile uint32_t OIS3              :  1;
N  __IO uint32_t OIS3N             :  1;
X  volatile uint32_t OIS3N             :  1;
N  __IO uint32_t OIS4              :  1;
X  volatile uint32_t OIS4              :  1;
N  __IO uint32_t RES2              : 17;
X  volatile uint32_t RES2              : 17;
N} TIM_CR2_32Bit;
N
Ntypedef struct {
N  __IO uint32_t SMS               :  3;
X  volatile uint32_t SMS               :  3;
N  __IO uint32_t OCCS              :  1;
X  volatile uint32_t OCCS              :  1;
N  __IO uint32_t TS                :  3;
X  volatile uint32_t TS                :  3;
N  __IO uint32_t MSM               :  1;
X  volatile uint32_t MSM               :  1;
N  __IO uint32_t ETF               :  4;
X  volatile uint32_t ETF               :  4;
N  __IO uint32_t ETPS              :  2;
X  volatile uint32_t ETPS              :  2;
N  __IO uint32_t ECE               :  1;
X  volatile uint32_t ECE               :  1;
N  __IO uint32_t ETP               :  1;
X  volatile uint32_t ETP               :  1;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} TIM_SMCR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t UIE               :  1;
X  volatile uint32_t UIE               :  1;
N  __IO uint32_t CC1IE             :  1;
X  volatile uint32_t CC1IE             :  1;
N  __IO uint32_t CC2IE             :  1;
X  volatile uint32_t CC2IE             :  1;
N  __IO uint32_t CC3IE             :  1;
X  volatile uint32_t CC3IE             :  1;
N  __IO uint32_t CC4IE             :  1;
X  volatile uint32_t CC4IE             :  1;
N  __IO uint32_t COMIE             :  1;
X  volatile uint32_t COMIE             :  1;
N  __IO uint32_t TIE               :  1;
X  volatile uint32_t TIE               :  1;
N  __IO uint32_t BIE               :  1;
X  volatile uint32_t BIE               :  1;
N  __IO uint32_t UDE               :  1;
X  volatile uint32_t UDE               :  1;
N  __IO uint32_t CC1DE             :  1;
X  volatile uint32_t CC1DE             :  1;
N  __IO uint32_t CC2DE             :  1;
X  volatile uint32_t CC2DE             :  1;
N  __IO uint32_t CC3DE             :  1;
X  volatile uint32_t CC3DE             :  1;
N  __IO uint32_t CC4DE             :  1;
X  volatile uint32_t CC4DE             :  1;
N  __IO uint32_t COMDE             :  1;
X  volatile uint32_t COMDE             :  1;
N  __IO uint32_t TDE               :  1;
X  volatile uint32_t TDE               :  1;
N  __IO uint32_t RES1              : 17;
X  volatile uint32_t RES1              : 17;
N} TIM_DIER_32Bit;
N
Ntypedef struct {
N  __IO uint32_t UIF               :  1;
X  volatile uint32_t UIF               :  1;
N  __IO uint32_t CC1IF             :  1;
X  volatile uint32_t CC1IF             :  1;
N  __IO uint32_t CC2IF             :  1;
X  volatile uint32_t CC2IF             :  1;
N  __IO uint32_t CC3IF             :  1;
X  volatile uint32_t CC3IF             :  1;
N  __IO uint32_t CC4IF             :  1;
X  volatile uint32_t CC4IF             :  1;
N  __IO uint32_t COMIF             :  1;
X  volatile uint32_t COMIF             :  1;
N  __IO uint32_t TIF               :  1;
X  volatile uint32_t TIF               :  1;
N  __IO uint32_t BIF               :  1;
X  volatile uint32_t BIF               :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t CC1OF             :  1;
X  volatile uint32_t CC1OF             :  1;
N  __IO uint32_t CC2OF             :  1;
X  volatile uint32_t CC2OF             :  1;
N  __IO uint32_t CC3OF             :  1;
X  volatile uint32_t CC3OF             :  1;
N  __IO uint32_t CC4OF             :  1;
X  volatile uint32_t CC4OF             :  1;
N  __IO uint32_t RES2              : 19;
X  volatile uint32_t RES2              : 19;
N} TIM_SR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t UG                :  1;
X  volatile uint32_t UG                :  1;
N  __IO uint32_t CC1G              :  1;
X  volatile uint32_t CC1G              :  1;
N  __IO uint32_t CC2G              :  1;
X  volatile uint32_t CC2G              :  1;
N  __IO uint32_t CC3G              :  1;
X  volatile uint32_t CC3G              :  1;
N  __IO uint32_t CC4G              :  1;
X  volatile uint32_t CC4G              :  1;
N  __IO uint32_t COMG              :  1;
X  volatile uint32_t COMG              :  1;
N  __IO uint32_t TG                :  1;
X  volatile uint32_t TG                :  1;
N  __IO uint32_t BG                :  1;
X  volatile uint32_t BG                :  1;
N  __IO uint32_t RES1              : 24;
X  volatile uint32_t RES1              : 24;
N} TIM_EGR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t CC1S              :  2;
X  volatile uint32_t CC1S              :  2;
N  __IO uint32_t OC1FE             :  1;
X  volatile uint32_t OC1FE             :  1;
N  __IO uint32_t OC1PE             :  1;
X  volatile uint32_t OC1PE             :  1;
N  __IO uint32_t OC1M              :  3;
X  volatile uint32_t OC1M              :  3;
N  __IO uint32_t OC1CE             :  1;
X  volatile uint32_t OC1CE             :  1;
N  __IO uint32_t CC2S              :  2;
X  volatile uint32_t CC2S              :  2;
N  __IO uint32_t OC2FE             :  1;
X  volatile uint32_t OC2FE             :  1;
N  __IO uint32_t OC2PE             :  1;
X  volatile uint32_t OC2PE             :  1;
N  __IO uint32_t OC2M              :  3;
X  volatile uint32_t OC2M              :  3;
N  __IO uint32_t OC2CE             :  1;
X  volatile uint32_t OC2CE             :  1;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} TIM_CCMR1_OC_32Bit;
N
Ntypedef struct {
N  __IO uint32_t CC1S              :  2;
X  volatile uint32_t CC1S              :  2;
N  __IO uint32_t IC1PSC            :  2;
X  volatile uint32_t IC1PSC            :  2;
N  __IO uint32_t IC1F              :  4;
X  volatile uint32_t IC1F              :  4;
N  __IO uint32_t CC2S              :  2;
X  volatile uint32_t CC2S              :  2;
N  __IO uint32_t IC2PSC            :  2;
X  volatile uint32_t IC2PSC            :  2;
N  __IO uint32_t IC2F              :  4;
X  volatile uint32_t IC2F              :  4;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} TIM_CCMR1_IC_32Bit;
N
Ntypedef struct {
N  __IO uint32_t CC3S              :  2;
X  volatile uint32_t CC3S              :  2;
N  __IO uint32_t OC3FE             :  1;
X  volatile uint32_t OC3FE             :  1;
N  __IO uint32_t OC3PE             :  1;
X  volatile uint32_t OC3PE             :  1;
N  __IO uint32_t OC3M              :  3;
X  volatile uint32_t OC3M              :  3;
N  __IO uint32_t OC3CE             :  1;
X  volatile uint32_t OC3CE             :  1;
N  __IO uint32_t CC4S              :  2;
X  volatile uint32_t CC4S              :  2;
N  __IO uint32_t OC4FE             :  1;
X  volatile uint32_t OC4FE             :  1;
N  __IO uint32_t OC4PE             :  1;
X  volatile uint32_t OC4PE             :  1;
N  __IO uint32_t OC4M              :  3;
X  volatile uint32_t OC4M              :  3;
N  __IO uint32_t OC4CE             :  1;
X  volatile uint32_t OC4CE             :  1;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} TIM_CCMR2_OC_32Bit;
N
Ntypedef struct {
N  __IO uint32_t CC3S              :  2;
X  volatile uint32_t CC3S              :  2;
N  __IO uint32_t IC3PSC            :  2;
X  volatile uint32_t IC3PSC            :  2;
N  __IO uint32_t IC3F              :  4;
X  volatile uint32_t IC3F              :  4;
N  __IO uint32_t CC4S              :  2;
X  volatile uint32_t CC4S              :  2;
N  __IO uint32_t IC4PSC            :  2;
X  volatile uint32_t IC4PSC            :  2;
N  __IO uint32_t IC4F              :  4;
X  volatile uint32_t IC4F              :  4;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} TIM_CCMR2_IC_32Bit;
N
Ntypedef struct {
N  __IO uint32_t CC1E              :  1;
X  volatile uint32_t CC1E              :  1;
N  __IO uint32_t CC1P              :  1;
X  volatile uint32_t CC1P              :  1;
N  __IO uint32_t CC1NE             :  1;
X  volatile uint32_t CC1NE             :  1;
N  __IO uint32_t CC1NP             :  1;
X  volatile uint32_t CC1NP             :  1;
N  __IO uint32_t CC2E              :  1;
X  volatile uint32_t CC2E              :  1;
N  __IO uint32_t CC2P              :  1;
X  volatile uint32_t CC2P              :  1;
N  __IO uint32_t CC2NE             :  1;
X  volatile uint32_t CC2NE             :  1;
N  __IO uint32_t CC2NP             :  1;
X  volatile uint32_t CC2NP             :  1;
N  __IO uint32_t CC3E              :  1;
X  volatile uint32_t CC3E              :  1;
N  __IO uint32_t CC3P              :  1;
X  volatile uint32_t CC3P              :  1;
N  __IO uint32_t CC3NE             :  1;
X  volatile uint32_t CC3NE             :  1;
N  __IO uint32_t CC3NP             :  1;
X  volatile uint32_t CC3NP             :  1;
N  __IO uint32_t CC4E              :  1;
X  volatile uint32_t CC4E              :  1;
N  __IO uint32_t CC4P              :  1;
X  volatile uint32_t CC4P              :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t CC4NP             :  1;
X  volatile uint32_t CC4NP             :  1;
N  __IO uint32_t RES2              : 16;
X  volatile uint32_t RES2              : 16;
N} TIM_CCER_32Bit;
N
Ntypedef struct {
N  __IO uint32_t PSC               : 16;
X  volatile uint32_t PSC               : 16;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} TIM_PSC_32Bit;
N
Ntypedef struct {
N  __IO uint32_t REP               :  8;
X  volatile uint32_t REP               :  8;
N  __IO uint32_t RES1              : 24;
X  volatile uint32_t RES1              : 24;
N} TIM_RCR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t DTG               :  8;
X  volatile uint32_t DTG               :  8;
N  __IO uint32_t LOCK              :  2;
X  volatile uint32_t LOCK              :  2;
N  __IO uint32_t OSSI              :  1;
X  volatile uint32_t OSSI              :  1;
N  __IO uint32_t OSSR              :  1;
X  volatile uint32_t OSSR              :  1;
N  __IO uint32_t BKE               :  1;
X  volatile uint32_t BKE               :  1;
N  __IO uint32_t BKP               :  1;
X  volatile uint32_t BKP               :  1;
N  __IO uint32_t AOE               :  1;
X  volatile uint32_t AOE               :  1;
N  __IO uint32_t MOE               :  1;
X  volatile uint32_t MOE               :  1;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} TIM_BDTR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t DBA               :  5;
X  volatile uint32_t DBA               :  5;
N  __IO uint32_t RES1              :  3;
X  volatile uint32_t RES1              :  3;
N  __IO uint32_t DBL               :  5;
X  volatile uint32_t DBL               :  5;
N  __IO uint32_t RES2              : 19;
X  volatile uint32_t RES2              : 19;
N} TIM_DCR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t DMAB              : 16;
X  volatile uint32_t DMAB              : 16;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} TIM_DMAR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t TI1_RMP           :  2;
X  volatile uint32_t TI1_RMP           :  2;
N  __IO uint32_t RES1              : 30;
X  volatile uint32_t RES1              : 30;
N} TIM_OR_32Bit;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t CR1;          /*!< TIM control register 1,                      Address offset: 0x00 */
X    volatile uint32_t CR1;           
N    TIM_CR1_32Bit CR1_BIT;
N  };
N  union {
N    __IO uint32_t CR2;          /*!< TIM control register 2,                      Address offset: 0x04 */
X    volatile uint32_t CR2;           
N    TIM_CR2_32Bit CR2_BIT;
N  };
N  union {
N    __IO uint32_t SMCR;         /*!< TIM slave Mode Control register,             Address offset: 0x08 */
X    volatile uint32_t SMCR;          
N    TIM_SMCR_32Bit SMCR_BIT;
N  };
N  union {
N    __IO uint32_t DIER;         /*!< TIM DMA/interrupt enable register,           Address offset: 0x0C */
X    volatile uint32_t DIER;          
N    TIM_DIER_32Bit DIER_BIT;
N  };
N  union {
N    __IO uint32_t SR;           /*!< TIM status register,                         Address offset: 0x10 */
X    volatile uint32_t SR;            
N    TIM_SR_32Bit SR_BIT;
N  };
N  union {
N    __IO uint32_t EGR;          /*!< TIM event generation register,               Address offset: 0x14 */
X    volatile uint32_t EGR;           
N    TIM_EGR_32Bit EGR_BIT;
N  };
N  union {
N    __IO uint32_t CCMR1;        /*!< TIM capture/compare mode register 1,         Address offset: 0x18 */
X    volatile uint32_t CCMR1;         
N    TIM_CCMR1_OC_32Bit CCMR1_OC_BIT;
N    TIM_CCMR1_IC_32Bit CCMR1_IC_BIT;
N  };
N  union {
N    __IO uint32_t CCMR2;        /*!< TIM capture/compare mode register 2,         Address offset: 0x1C */
X    volatile uint32_t CCMR2;         
N    TIM_CCMR2_OC_32Bit CCMR2_OC_BIT;
N    TIM_CCMR2_IC_32Bit CCMR2_IC_BIT;
N  };
N  union {
N    __IO uint32_t CCER;         /*!< TIM capture/compare enable register,         Address offset: 0x20 */
X    volatile uint32_t CCER;          
N    TIM_CCER_32Bit CCER_BIT;
N  };
N    __IO uint32_t CNT;          /*!< TIM counter register,                        Address offset: 0x24 */
X    volatile uint32_t CNT;           
N  union {
N    __IO uint32_t PSC;          /*!< TIM prescaler register,                      Address offset: 0x28 */
X    volatile uint32_t PSC;           
N    TIM_PSC_32Bit PSC_BIT;
N  };
N    __IO uint32_t ARR;          /*!< TIM auto-reload register,                    Address offset: 0x2C */
X    volatile uint32_t ARR;           
N  union {
N    __IO uint32_t RCR;          /*!< TIM  repetition counter register,            Address offset: 0x30 */
X    volatile uint32_t RCR;           
N    TIM_RCR_32Bit RCR_BIT;
N  };
N    __IO uint32_t CCR1;         /*!< TIM capture/compare register 1,              Address offset: 0x34 */
X    volatile uint32_t CCR1;          
N    __IO uint32_t CCR2;         /*!< TIM capture/compare register 2,              Address offset: 0x38 */
X    volatile uint32_t CCR2;          
N    __IO uint32_t CCR3;         /*!< TIM capture/compare register 3,              Address offset: 0x3C */
X    volatile uint32_t CCR3;          
N    __IO uint32_t CCR4;         /*!< TIM capture/compare register 4,              Address offset: 0x40 */
X    volatile uint32_t CCR4;          
N  union {
N    __IO uint32_t BDTR;         /*!< TIM break and dead-time register,            Address offset: 0x44 */
X    volatile uint32_t BDTR;          
N    TIM_BDTR_32Bit BDTR_BIT;
N  };
N  union {
N    __IO uint32_t DCR;          /*!< TIM DMA control register,                    Address offset: 0x48 */
X    volatile uint32_t DCR;           
N    TIM_DCR_32Bit DCR_BIT;
N  };
N  union {
N    __IO uint32_t DMAR;         /*!< TIM DMA address for full transfer register,  Address offset: 0x4C */
X    volatile uint32_t DMAR;          
N    TIM_DMAR_32Bit DMAR_BIT;
N  };
N  union {
N    __IO uint32_t OR;           /*!< TIM option register,                         Address offset: 0x50 */
X    volatile uint32_t OR;            
N    TIM_OR_32Bit OR_BIT;
N  };
N} TIM_TypeDef;
N
N
N/**
N  * @brief Real-Time Clock(include RTC  0x4000 2800 - 0x4000 2BFF)
N  */
Ntypedef struct {
N  __IO uint32_t SU                :  4;
X  volatile uint32_t SU                :  4;
N  __IO uint32_t ST                :  3;
X  volatile uint32_t ST                :  3;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t MNU               :  4;
X  volatile uint32_t MNU               :  4;
N  __IO uint32_t MNT               :  3;
X  volatile uint32_t MNT               :  3;
N  __IO uint32_t RES2              :  1;
X  volatile uint32_t RES2              :  1;
N  __IO uint32_t HU                :  4;
X  volatile uint32_t HU                :  4;
N  __IO uint32_t HT                :  2;
X  volatile uint32_t HT                :  2;
N  __IO uint32_t PM                :  1;
X  volatile uint32_t PM                :  1;
N  __IO uint32_t RES3              :  9;
X  volatile uint32_t RES3              :  9;
N} RTC_TR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t DU                :  4;
X  volatile uint32_t DU                :  4;
N  __IO uint32_t DT                :  2;
X  volatile uint32_t DT                :  2;
N  __IO uint32_t RES1              :  2;
X  volatile uint32_t RES1              :  2;
N  __IO uint32_t MU                :  4;
X  volatile uint32_t MU                :  4;
N  __IO uint32_t MT                :  1;
X  volatile uint32_t MT                :  1;
N  __IO uint32_t WDU               :  3;
X  volatile uint32_t WDU               :  3;
N  __IO uint32_t YU                :  4;
X  volatile uint32_t YU                :  4;
N  __IO uint32_t YT                :  4;
X  volatile uint32_t YT                :  4;
N  __IO uint32_t RES2              :  8;
X  volatile uint32_t RES2              :  8;
N} RTC_DR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t RES1              :  3;
X  volatile uint32_t RES1              :  3;
N  __IO uint32_t TSEDGE            :  1;
X  volatile uint32_t TSEDGE            :  1;
N  __IO uint32_t PEFCKON           :  1;
X  volatile uint32_t PEFCKON           :  1;
N  __IO uint32_t BYPSHAD           :  1;
X  volatile uint32_t BYPSHAD           :  1;
N  __IO uint32_t FMT               :  1;
X  volatile uint32_t FMT               :  1;
N  __IO uint32_t RES2              :  1;
X  volatile uint32_t RES2              :  1;
N  __IO uint32_t ALRAE             :  1;
X  volatile uint32_t ALRAE             :  1;
N  __IO uint32_t RES3              :  1;
X  volatile uint32_t RES3              :  1;
N  __IO uint32_t WUTE              :  1;
X  volatile uint32_t WUTE              :  1;
N  __IO uint32_t TSE               :  1;
X  volatile uint32_t TSE               :  1;
N  __IO uint32_t ALRAIE            :  1;
X  volatile uint32_t ALRAIE            :  1;
N  __IO uint32_t RES4              :  1;
X  volatile uint32_t RES4              :  1;
N  __IO uint32_t WUTIE             :  1;
X  volatile uint32_t WUTIE             :  1;
N  __IO uint32_t TSIE              :  1;
X  volatile uint32_t TSIE              :  1;
N  __IO uint32_t ADD1H             :  1;
X  volatile uint32_t ADD1H             :  1;
N  __IO uint32_t SUB1H             :  1;
X  volatile uint32_t SUB1H             :  1;
N  __IO uint32_t BKP               :  1;
X  volatile uint32_t BKP               :  1;
N  __IO uint32_t COSEL             :  1;
X  volatile uint32_t COSEL             :  1;
N  __IO uint32_t POL               :  1;
X  volatile uint32_t POL               :  1;
N  __IO uint32_t OSEL              :  2;
X  volatile uint32_t OSEL              :  2;
N  __IO uint32_t COE               :  1;
X  volatile uint32_t COE               :  1;
N  __IO uint32_t RES5              :  8;
X  volatile uint32_t RES5              :  8;
N} RTC_CR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t ALRAWF            :  1;
X  volatile uint32_t ALRAWF            :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t WUTWF             :  1;
X  volatile uint32_t WUTWF             :  1;
N  __IO uint32_t SHPF              :  1;
X  volatile uint32_t SHPF              :  1;
N  __IO uint32_t INITS             :  1;
X  volatile uint32_t INITS             :  1;
N  __IO uint32_t RSF               :  1;
X  volatile uint32_t RSF               :  1;
N  __IO uint32_t INITF             :  1;
X  volatile uint32_t INITF             :  1;
N  __IO uint32_t INIT              :  1;
X  volatile uint32_t INIT              :  1;
N  __IO uint32_t ALRAF             :  1;
X  volatile uint32_t ALRAF             :  1;
N  __IO uint32_t RES2              :  1;
X  volatile uint32_t RES2              :  1;
N  __IO uint32_t WUTF              :  1;
X  volatile uint32_t WUTF              :  1;
N  __IO uint32_t TSF               :  1;
X  volatile uint32_t TSF               :  1;
N  __IO uint32_t TSOVF             :  1;
X  volatile uint32_t TSOVF             :  1;
N  __IO uint32_t TAMP1F            :  1;
X  volatile uint32_t TAMP1F            :  1;
N  __IO uint32_t TAMP2F            :  1;
X  volatile uint32_t TAMP2F            :  1;
N  __IO uint32_t TAMP3F            :  1;
X  volatile uint32_t TAMP3F            :  1;
N  __IO uint32_t RECALPE           :  1;
X  volatile uint32_t RECALPE           :  1;
N  __IO uint32_t RES3              : 15;
X  volatile uint32_t RES3              : 15;
N} RTC_ISR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t PREDIV_S          : 15;
X  volatile uint32_t PREDIV_S          : 15;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t PREDIV_A          :  7;
X  volatile uint32_t PREDIV_A          :  7;
N  __IO uint32_t RES2              :  9;
X  volatile uint32_t RES2              :  9;
N} RTC_PRER_32Bit;
N
Ntypedef struct {
N  __IO uint32_t WUT               : 16;
X  volatile uint32_t WUT               : 16;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} RTC_WUTR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t SU                :  4;
X  volatile uint32_t SU                :  4;
N  __IO uint32_t ST                :  3;
X  volatile uint32_t ST                :  3;
N  __IO uint32_t MSK1              :  1;
X  volatile uint32_t MSK1              :  1;
N  __IO uint32_t MNU               :  4;
X  volatile uint32_t MNU               :  4;
N  __IO uint32_t MNT               :  3;
X  volatile uint32_t MNT               :  3;
N  __IO uint32_t MSK2              :  1;
X  volatile uint32_t MSK2              :  1;
N  __IO uint32_t HU                :  4;
X  volatile uint32_t HU                :  4;
N  __IO uint32_t HY                :  2;
X  volatile uint32_t HY                :  2;
N  __IO uint32_t PM                :  1;
X  volatile uint32_t PM                :  1;
N  __IO uint32_t MSK3              :  1;
X  volatile uint32_t MSK3              :  1;
N  __IO uint32_t DU                :  4;
X  volatile uint32_t DU                :  4;
N  __IO uint32_t DT                :  2;
X  volatile uint32_t DT                :  2;
N  __IO uint32_t WDSEL             :  1;
X  volatile uint32_t WDSEL             :  1;
N  __IO uint32_t MSK4              :  1;
X  volatile uint32_t MSK4              :  1;
N} RTC_ALRMAR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t KEY               :  8;
X  volatile uint32_t KEY               :  8;
N  __IO uint32_t RES1              : 24;
X  volatile uint32_t RES1              : 24;
N} RTC_WPR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t SS                : 16;
X  volatile uint32_t SS                : 16;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} RTC_SSR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t SUBFS             : 15;
X  volatile uint32_t SUBFS             : 15;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N  __IO uint32_t ADD1S             :  1;
X  volatile uint32_t ADD1S             :  1;
N} RTC_SHIFTR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t CALM              :  9;
X  volatile uint32_t CALM              :  9;
N  __IO uint32_t RES1              :  4;
X  volatile uint32_t RES1              :  4;
N  __IO uint32_t CALW16            :  1;
X  volatile uint32_t CALW16            :  1;
N  __IO uint32_t CALW8             :  1;
X  volatile uint32_t CALW8             :  1;
N  __IO uint32_t CALP              :  1;
X  volatile uint32_t CALP              :  1;
N  __IO uint32_t RES2              : 16;
X  volatile uint32_t RES2              : 16;
N} RTC_CALR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t TAMP1E            :  1;
X  volatile uint32_t TAMP1E            :  1;
N  __IO uint32_t TAMP1TRG          :  1;
X  volatile uint32_t TAMP1TRG          :  1;
N  __IO uint32_t TAMPIE            :  1;
X  volatile uint32_t TAMPIE            :  1;
N  __IO uint32_t TAMP2E            :  1;
X  volatile uint32_t TAMP2E            :  1;
N  __IO uint32_t TAMP2TRG          :  1;
X  volatile uint32_t TAMP2TRG          :  1;
N  __IO uint32_t TAMP3E            :  1;
X  volatile uint32_t TAMP3E            :  1;
N  __IO uint32_t TAMP3TRG          :  1;
X  volatile uint32_t TAMP3TRG          :  1;
N  __IO uint32_t TAMPTS            :  1;
X  volatile uint32_t TAMPTS            :  1;
N  __IO uint32_t TAMPFREQ          :  3;
X  volatile uint32_t TAMPFREQ          :  3;
N  __IO uint32_t TAMPFL            :  2;
X  volatile uint32_t TAMPFL            :  2;
N  __IO uint32_t TAMPPRCH          :  2;
X  volatile uint32_t TAMPPRCH          :  2;
N  __IO uint32_t TAMPPUDIS         :  1;
X  volatile uint32_t TAMPPUDIS         :  1;
N  __IO uint32_t RES1              :  2;
X  volatile uint32_t RES1              :  2;
N  __IO uint32_t PC13VALUE         :  1;
X  volatile uint32_t PC13VALUE         :  1;
N  __IO uint32_t PC13MODE          :  1;
X  volatile uint32_t PC13MODE          :  1;
N  __IO uint32_t PC14VALUE         :  1;
X  volatile uint32_t PC14VALUE         :  1;
N  __IO uint32_t PC14MODE          :  1;
X  volatile uint32_t PC14MODE          :  1;
N  __IO uint32_t PC15VALUE         :  1;
X  volatile uint32_t PC15VALUE         :  1;
N  __IO uint32_t PC15MODE          :  1;
X  volatile uint32_t PC15MODE          :  1;
N  __IO uint32_t RES2              :  8;
X  volatile uint32_t RES2              :  8;
N} RTC_TAFCR_32Bit;
N
Ntypedef struct {
N  __IO uint32_t SS                : 15;
X  volatile uint32_t SS                : 15;
N  __IO uint32_t RES1              :  9;
X  volatile uint32_t RES1              :  9;
N  __IO uint32_t MASKSS            :  4;
X  volatile uint32_t MASKSS            :  4;
N  __IO uint32_t RES2              :  4;
X  volatile uint32_t RES2              :  4;
N} RTC_ALRMASSR_32Bit;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t TR;            /*!< RTC time register,                                         Address offset: 0x00 */
X    volatile uint32_t TR;             
N    RTC_TR_32Bit TR_BIT;
N  };
N  union {
N    __IO uint32_t DR;            /*!< RTC date register,                                         Address offset: 0x04 */
X    volatile uint32_t DR;             
N    RTC_DR_32Bit DR_BIT;
N  };
N  union {
N    __IO uint32_t CR;            /*!< RTC control register,                                      Address offset: 0x08 */
X    volatile uint32_t CR;             
N    RTC_CR_32Bit CR_BIT;
N  };
N  union {
N    __IO uint32_t ISR;           /*!< RTC initialization and status register,                    Address offset: 0x0C */
X    volatile uint32_t ISR;            
N    RTC_ISR_32Bit ISR_BIT;
N  };
N  union {
N    __IO uint32_t PRER;          /*!< RTC prescaler register,                                    Address offset: 0x10 */
X    volatile uint32_t PRER;           
N    RTC_PRER_32Bit PRER_BIT;
N  };
N  union {
N    __IO uint32_t WUTR;          /*!< RTC wakeup timer register,                                 Address offset: 0x14 */
X    volatile uint32_t WUTR;           
N    RTC_WUTR_32Bit WUTR_BIT;
N  };
N         uint32_t RESERVED1;     /*!< Reserved,                                                  Address offset: 0x18 */
N  union {
N    __IO uint32_t ALRMAR;        /*!< RTC alarm A register,                                      Address offset: 0x1C */
X    volatile uint32_t ALRMAR;         
N    RTC_ALRMAR_32Bit ALRMAR_BIT;
N  };
N         uint32_t RESERVED2;     /*!< Reserved,                                                  Address offset: 0x20 */
N  union {
N    __IO uint32_t WPR;           /*!< RTC write protection register,                             Address offset: 0x24 */
X    volatile uint32_t WPR;            
N    RTC_WPR_32Bit WPR_BIT;
N  };
N  union {
N    __IO uint32_t SSR;           /*!< RTC sub second register,                                   Address offset: 0x28 */
X    volatile uint32_t SSR;            
N    RTC_SSR_32Bit SSR_BIT;
N  };
N  union {
N    __IO uint32_t SHIFTR;        /*!< RTC shift control register,                                Address offset: 0x2C */
X    volatile uint32_t SHIFTR;         
N    RTC_SHIFTR_32Bit SHIFTR_BIT;
N  };
N  union {
N    __IO uint32_t TSTR;          /*!< RTC time stamp time register,                              Address offset: 0x30 */
X    volatile uint32_t TSTR;           
N    RTC_TR_32Bit TSTR_BIT;
N  };
N  union {
N    __IO uint32_t TSDR;          /*!< RTC time stamp date register,                              Address offset: 0x34 */
X    volatile uint32_t TSDR;           
N    RTC_DR_32Bit TSDR_BIT;
N  };
N  union {
N    __IO uint32_t TSSSR;         /*!< RTC time-stamp sub second register,                        Address offset: 0x38 */
X    volatile uint32_t TSSSR;          
N    RTC_SSR_32Bit TSSSR_BIT;
N  };
N  union {
N    __IO uint32_t CALR;          /*!< RTC calibration register,                                  Address offset: 0x3C */
X    volatile uint32_t CALR;           
N    RTC_CALR_32Bit CALR_BIT;
N  };
N  union {
N    __IO uint32_t TAFCR;         /*!< RTC tamper and alternate function configuration register,  Address offset: 0x40 */
X    volatile uint32_t TAFCR;          
N    RTC_TAFCR_32Bit TAFCR_BIT;
N  };
N  union {
N    __IO uint32_t ALRMASSR;      /*!< RTC alarm A sub second register,                           Address offset: 0x44 */
X    volatile uint32_t ALRMASSR;       
N    RTC_ALRMASSR_32Bit ALRMASSR_BIT;
N  };
N         uint32_t RESERVED3[2];  /*!< Reserved,                                                  Address offset: 0x48/0x4C */
N    __IO uint32_t BKP0R;         /*!< RTC backup register 0,                                     Address offset: 0x50 */
X    volatile uint32_t BKP0R;          
N    __IO uint32_t BKP1R;         /*!< RTC backup register 1,                                     Address offset: 0x54 */
X    volatile uint32_t BKP1R;          
N    __IO uint32_t BKP2R;         /*!< RTC backup register 2,                                     Address offset: 0x58 */
X    volatile uint32_t BKP2R;          
N    __IO uint32_t BKP3R;         /*!< RTC backup register 3,                                     Address offset: 0x5C */
X    volatile uint32_t BKP3R;          
N    __IO uint32_t BKP4R;         /*!< RTC backup register 4,                                     Address offset: 0x60 */
X    volatile uint32_t BKP4R;          
N} RTC_TypeDef;
N
N
N/**
N  * @brief Window WATCHDOG(include WWDG  0x4000 2C00 - 0x4000 2FFF)
N  */
Ntypedef struct {
N  __IO uint32_t T                 :  7;
X  volatile uint32_t T                 :  7;
N  __IO uint32_t WDGA              :  1;
X  volatile uint32_t WDGA              :  1;
N  __IO uint32_t RES1              : 24;
X  volatile uint32_t RES1              : 24;
N} WWDG_CR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t W                 :  7;
X  volatile uint32_t W                 :  7;
N  __IO uint32_t WDGTB             :  2;
X  volatile uint32_t WDGTB             :  2;
N  __IO uint32_t EWI               :  1;
X  volatile uint32_t EWI               :  1;
N  __IO uint32_t RES1              : 22;
X  volatile uint32_t RES1              : 22;
N} WWDG_CFR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t EWIF              :  1;
X  volatile uint32_t EWIF              :  1;
N  __IO uint32_t RES1              : 31;
X  volatile uint32_t RES1              : 31;
N} WWDG_SR_32BIT;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t CR;   /*!< WWDG Control register,       Address offset: 0x00 */
X    volatile uint32_t CR;    
N    WWDG_CR_32BIT CR_BIT;
N  };
N  union {
N    __IO uint32_t CFR;  /*!< WWDG Configuration register, Address offset: 0x04 */
X    volatile uint32_t CFR;   
N    WWDG_CFR_32BIT CFR_BIT;
N  };
N  union {
N    __IO uint32_t SR;   /*!< WWDG Status register,        Address offset: 0x08 */
X    volatile uint32_t SR;    
N    WWDG_SR_32BIT SR_BIT;
N  };
N} WWDG_TypeDef;
N
N
N/**
N  * @brief Independent WATCHDOG(include IWDG  0x4000 3000 - 0x4000 33FF)
N  */
Ntypedef struct {
N  __IO uint32_t KEY               : 16;
X  volatile uint32_t KEY               : 16;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} IWDG_KR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t PR                :  3;
X  volatile uint32_t PR                :  3;
N  __IO uint32_t RES1              : 29;
X  volatile uint32_t RES1              : 29;
N} IWDG_PR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t RL                : 12;
X  volatile uint32_t RL                : 12;
N  __IO uint32_t RES1              : 20;
X  volatile uint32_t RES1              : 20;
N} IWDG_RLR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t PVU               :  1;
X  volatile uint32_t PVU               :  1;
N  __IO uint32_t RVU               :  1;
X  volatile uint32_t RVU               :  1;
N  __IO uint32_t WVU               :  1;
X  volatile uint32_t WVU               :  1;
N  __IO uint32_t RES1              : 29;
X  volatile uint32_t RES1              : 29;
N} IWDG_SR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t WIN               : 12;
X  volatile uint32_t WIN               : 12;
N  __IO uint32_t RES1              : 20;
X  volatile uint32_t RES1              : 20;
N} IWDG_WINR_32BIT;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t KR;    /*!< IWDG Key register,       Address offset: 0x00 */
X    volatile uint32_t KR;     
N    IWDG_KR_32BIT KR_BIT;
N  };
N  union {
N    __IO uint32_t PR;    /*!< IWDG Prescaler register, Address offset: 0x04 */
X    volatile uint32_t PR;     
N    IWDG_PR_32BIT PR_BIT;
N  };
N  union {
N    __IO uint32_t RLR;   /*!< IWDG Reload register,    Address offset: 0x08 */
X    volatile uint32_t RLR;    
N    IWDG_RLR_32BIT RLR_BIT;
N  };
N  union {
N    __IO uint32_t SR;    /*!< IWDG Status register,    Address offset: 0x0C */
X    volatile uint32_t SR;     
N    IWDG_SR_32BIT SR_BIT;
N  };
N  union {
N    __IO uint32_t WINR;  /*!< IWDG Window register,    Address offset: 0x10 */
X    volatile uint32_t WINR;   
N    IWDG_WINR_32BIT WINR_BIT;
N  };
N} IWDG_TypeDef;
N
N
N/**
N  * @brief Inter-integrated Circuit Interface(include I2C  0x4000 5400 - 0x4000 57FF)
N  */
Ntypedef struct {
N  __IO uint32_t PE                :  1;
X  volatile uint32_t PE                :  1;
N  __IO uint32_t TXIE              :  1;
X  volatile uint32_t TXIE              :  1;
N  __IO uint32_t RXIE              :  1;
X  volatile uint32_t RXIE              :  1;
N  __IO uint32_t ADDRIE            :  1;
X  volatile uint32_t ADDRIE            :  1;
N  __IO uint32_t NACKIE            :  1;
X  volatile uint32_t NACKIE            :  1;
N  __IO uint32_t STOPIE            :  1;
X  volatile uint32_t STOPIE            :  1;
N  __IO uint32_t TCIE              :  1;
X  volatile uint32_t TCIE              :  1;
N  __IO uint32_t ERRIR             :  1;
X  volatile uint32_t ERRIR             :  1;
N  __IO uint32_t DNF               :  4;
X  volatile uint32_t DNF               :  4;
N  __IO uint32_t ANFOFF            :  1;
X  volatile uint32_t ANFOFF            :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t TXDMAEN           :  1;
X  volatile uint32_t TXDMAEN           :  1;
N  __IO uint32_t RXDMAEN           :  1;
X  volatile uint32_t RXDMAEN           :  1;
N  __IO uint32_t SBC               :  1;
X  volatile uint32_t SBC               :  1;
N  __IO uint32_t NOSTRETCH         :  1;
X  volatile uint32_t NOSTRETCH         :  1;
N  __IO uint32_t WUPEN             :  1;
X  volatile uint32_t WUPEN             :  1;
N  __IO uint32_t GCEN              :  1;
X  volatile uint32_t GCEN              :  1;
N  __IO uint32_t SMBHEN            :  1;
X  volatile uint32_t SMBHEN            :  1;
N  __IO uint32_t SMBDEN            :  1;
X  volatile uint32_t SMBDEN            :  1;
N  __IO uint32_t ALERTEN           :  1;
X  volatile uint32_t ALERTEN           :  1;
N  __IO uint32_t PECEN             :  1;
X  volatile uint32_t PECEN             :  1;
N  __IO uint32_t RES2              :  8;
X  volatile uint32_t RES2              :  8;
N} I2C_CR1_32BIT;
N
Ntypedef struct {
N  __IO uint32_t SADD              : 10;
X  volatile uint32_t SADD              : 10;
N  __IO uint32_t RD_WRN            :  1;
X  volatile uint32_t RD_WRN            :  1;
N  __IO uint32_t ADD10             :  1;
X  volatile uint32_t ADD10             :  1;
N  __IO uint32_t HEAD10R           :  1;
X  volatile uint32_t HEAD10R           :  1;
N  __IO uint32_t START             :  1;
X  volatile uint32_t START             :  1;
N  __IO uint32_t STOP              :  1;
X  volatile uint32_t STOP              :  1;
N  __IO uint32_t NACK              :  1;
X  volatile uint32_t NACK              :  1;
N  __IO uint32_t NBYTES            :  8;
X  volatile uint32_t NBYTES            :  8;
N  __IO uint32_t RELOAD            :  1;
X  volatile uint32_t RELOAD            :  1;
N  __IO uint32_t AUTOEND           :  1;
X  volatile uint32_t AUTOEND           :  1;
N  __IO uint32_t PECBYTE           :  1;
X  volatile uint32_t PECBYTE           :  1;
N  __IO uint32_t RES1              :  5;
X  volatile uint32_t RES1              :  5;
N} I2C_CR2_32BIT;
N
Ntypedef struct {
N  __IO uint32_t OA1               : 10;
X  volatile uint32_t OA1               : 10;
N  __IO uint32_t OA1MODE           :  1;
X  volatile uint32_t OA1MODE           :  1;
N  __IO uint32_t RES1              :  4;
X  volatile uint32_t RES1              :  4;
N  __IO uint32_t OA1EN             :  1;
X  volatile uint32_t OA1EN             :  1;
N  __IO uint32_t RES2              : 16;
X  volatile uint32_t RES2              : 16;
N} I2C_OAR1_32BIT;
N
Ntypedef struct {
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t OA2               :  7;
X  volatile uint32_t OA2               :  7;
N  __IO uint32_t OA2MSK            :  3;
X  volatile uint32_t OA2MSK            :  3;
N  __IO uint32_t RES2              :  4;
X  volatile uint32_t RES2              :  4;
N  __IO uint32_t OA2EN             :  1;
X  volatile uint32_t OA2EN             :  1;
N  __IO uint32_t RES3              : 16;
X  volatile uint32_t RES3              : 16;
N} I2C_OAR2_32BIT;
N
Ntypedef struct {
N  __IO uint32_t SCLL              :  8;
X  volatile uint32_t SCLL              :  8;
N  __IO uint32_t SCLH              :  8;
X  volatile uint32_t SCLH              :  8;
N  __IO uint32_t SDADEL            :  4;
X  volatile uint32_t SDADEL            :  4;
N  __IO uint32_t SCLDEL            :  4;
X  volatile uint32_t SCLDEL            :  4;
N  __IO uint32_t RES1              :  4;
X  volatile uint32_t RES1              :  4;
N  __IO uint32_t RRESC             :  4;
X  volatile uint32_t RRESC             :  4;
N} I2C_TIMINGR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t TIMEOUTA          : 12;
X  volatile uint32_t TIMEOUTA          : 12;
N  __IO uint32_t TIDLE             :  1;
X  volatile uint32_t TIDLE             :  1;
N  __IO uint32_t RES1              :  2;
X  volatile uint32_t RES1              :  2;
N  __IO uint32_t TIMEOUTEN         :  1;
X  volatile uint32_t TIMEOUTEN         :  1;
N  __IO uint32_t TIMEOUTB          : 12;
X  volatile uint32_t TIMEOUTB          : 12;
N  __IO uint32_t RES2              :  3;
X  volatile uint32_t RES2              :  3;
N  __IO uint32_t TEXTEN            :  1;
X  volatile uint32_t TEXTEN            :  1;
N} I2C_TIMEOUTR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t TXE               :  1;
X  volatile uint32_t TXE               :  1;
N  __IO uint32_t TXIS              :  1;
X  volatile uint32_t TXIS              :  1;
N  __IO uint32_t RXNE              :  1;
X  volatile uint32_t RXNE              :  1;
N  __IO uint32_t ADDR              :  1;
X  volatile uint32_t ADDR              :  1;
N  __IO uint32_t NACKF             :  1;
X  volatile uint32_t NACKF             :  1;
N  __IO uint32_t STOPF             :  1;
X  volatile uint32_t STOPF             :  1;
N  __IO uint32_t TC                :  1;
X  volatile uint32_t TC                :  1;
N  __IO uint32_t TCR               :  1;
X  volatile uint32_t TCR               :  1;
N  __IO uint32_t BERR              :  1;
X  volatile uint32_t BERR              :  1;
N  __IO uint32_t ARLO              :  1;
X  volatile uint32_t ARLO              :  1;
N  __IO uint32_t OVR               :  1;
X  volatile uint32_t OVR               :  1;
N  __IO uint32_t PECERR            :  1;
X  volatile uint32_t PECERR            :  1;
N  __IO uint32_t TIMEOUT           :  1;
X  volatile uint32_t TIMEOUT           :  1;
N  __IO uint32_t ALERT             :  1;
X  volatile uint32_t ALERT             :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t BUSY              :  1;
X  volatile uint32_t BUSY              :  1;
N  __IO uint32_t DIR               :  1;
X  volatile uint32_t DIR               :  1;
N  __IO uint32_t ADDCODE           :  7;
X  volatile uint32_t ADDCODE           :  7;
N  __IO uint32_t RES2              :  8;
X  volatile uint32_t RES2              :  8;
N} I2C_ISR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t RES1              :  3;
X  volatile uint32_t RES1              :  3;
N  __IO uint32_t ADDRCF            :  1;
X  volatile uint32_t ADDRCF            :  1;
N  __IO uint32_t NACKCF            :  1;
X  volatile uint32_t NACKCF            :  1;
N  __IO uint32_t STOPCF            :  1;
X  volatile uint32_t STOPCF            :  1;
N  __IO uint32_t RES2              :  2;
X  volatile uint32_t RES2              :  2;
N  __IO uint32_t BERRCF            :  1;
X  volatile uint32_t BERRCF            :  1;
N  __IO uint32_t ARLOCF            :  1;
X  volatile uint32_t ARLOCF            :  1;
N  __IO uint32_t OVRCF             :  1;
X  volatile uint32_t OVRCF             :  1;
N  __IO uint32_t PECCF             :  1;
X  volatile uint32_t PECCF             :  1;
N  __IO uint32_t TIMOUTCF          :  1;
X  volatile uint32_t TIMOUTCF          :  1;
N  __IO uint32_t ALERTCF           :  1;
X  volatile uint32_t ALERTCF           :  1;
N  __IO uint32_t RES3              : 18;
X  volatile uint32_t RES3              : 18;
N} I2C_ICR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t PEC               :  8;
X  volatile uint32_t PEC               :  8;
N  __IO uint32_t RES1              : 24;
X  volatile uint32_t RES1              : 24;
N} I2C_PECR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t DATA              :  8;
X  volatile uint32_t DATA              :  8;
N  __IO uint32_t RES1              : 24;
X  volatile uint32_t RES1              : 24;
N} I2C_DR_32BIT;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t CR1;      /*!< I2C Control register 1,             Address offset: 0x00 */
X    volatile uint32_t CR1;       
N    I2C_CR1_32BIT CR1_BIT;
N  };
N  union {
N    __IO uint32_t CR2;      /*!< I2C Control register 2,             Address offset: 0x04 */
X    volatile uint32_t CR2;       
N    I2C_CR2_32BIT CR2_BIT;
N  };
N  union {
N    __IO uint32_t OAR1;     /*!< I2C Own address 1 register,         Address offset: 0x08 */
X    volatile uint32_t OAR1;      
N    I2C_OAR1_32BIT OAR1_BIT;
N  };
N  union {
N    __IO uint32_t OAR2;     /*!< I2C Own address 2 register,         Address offset: 0x0C */
X    volatile uint32_t OAR2;      
N    I2C_OAR2_32BIT OAR2_BIT;
N  };
N  union {
N    __IO uint32_t TIMINGR;  /*!< I2C Timing register,                Address offset: 0x10 */
X    volatile uint32_t TIMINGR;   
N    I2C_TIMINGR_32BIT TIMINGR_BIT;
N  };
N  union {
N    __IO uint32_t TIMEOUTR; /*!< I2C Timeout register,               Address offset: 0x14 */
X    volatile uint32_t TIMEOUTR;  
N    I2C_TIMEOUTR_32BIT TIMEOUTR_BIT;
N  };
N  union {
N    __IO uint32_t ISR;      /*!< I2C Interrupt and status register,  Address offset: 0x18 */
X    volatile uint32_t ISR;       
N    I2C_ISR_32BIT ISR_BIT;
N  };
N  union {
N    __IO uint32_t ICR;      /*!< I2C Interrupt clear register,       Address offset: 0x1C */
X    volatile uint32_t ICR;       
N    I2C_ICR_32BIT ICR_BIT;
N  };
N  union {
N    __IO uint32_t PECR;     /*!< I2C PEC register,                   Address offset: 0x20 */
X    volatile uint32_t PECR;      
N    I2C_PECR_32BIT PECR_BIT;
N  };
N  union {
N    __IO uint32_t RXDR;     /*!< I2C Receive data register,          Address offset: 0x24 */
X    volatile uint32_t RXDR;      
N    I2C_DR_32BIT RXDR_BIT;
N  };
N  union {
N    __IO uint32_t TXDR;     /*!< I2C Transmit data register,         Address offset: 0x28 */
X    volatile uint32_t TXDR;      
N    I2C_DR_32BIT TXDR_BIT;
N  };
N} I2C_TypeDef;
N
N
N/**
N  * @brief Power Control(include PWR  0x4000 7000 - 0x4000 73FF)
N  */
Ntypedef struct {
N  __IO uint32_t LPDS              :  1;
X  volatile uint32_t LPDS              :  1;
N  __IO uint32_t PDDS              :  1;
X  volatile uint32_t PDDS              :  1;
N  __IO uint32_t CWUF              :  1;
X  volatile uint32_t CWUF              :  1;
N  __IO uint32_t CSBF              :  1;
X  volatile uint32_t CSBF              :  1;
N  __IO uint32_t PVDE              :  1;
X  volatile uint32_t PVDE              :  1;
N  __IO uint32_t PLS               :  3;
X  volatile uint32_t PLS               :  3;
N  __IO uint32_t DBP               :  1;
X  volatile uint32_t DBP               :  1;
N  __IO uint32_t RES1              : 23;
X  volatile uint32_t RES1              : 23;
N} PWR_CR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t WUF               :  1;
X  volatile uint32_t WUF               :  1;
N  __IO uint32_t SBF               :  1;
X  volatile uint32_t SBF               :  1;
N  __IO uint32_t PVDO              :  1;
X  volatile uint32_t PVDO              :  1;
N  __IO uint32_t RES1              :  5;
X  volatile uint32_t RES1              :  5;
N  __IO uint32_t EWUP1             :  1;
X  volatile uint32_t EWUP1             :  1;
N  __IO uint32_t EWUP2             :  1;
X  volatile uint32_t EWUP2             :  1;
N  __IO uint32_t RES2              : 22;
X  volatile uint32_t RES2              : 22;
N} PWR_CSR_32BIT;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t CR;   /*!< PWR power control register,                          Address offset: 0x00 */
X    volatile uint32_t CR;    
N    PWR_CR_32BIT CR_BIT;
N  };
N  union {
N    __IO uint32_t CSR;  /*!< PWR power control/status register,                   Address offset: 0x04 */
X    volatile uint32_t CSR;   
N    PWR_CSR_32BIT CSR_BIT;
N  };
N} PWR_TypeDef;
N
N
N/**
N  * @brief SysTem Configuration(include SYSCFG  0x4001 0000 - 0x4001 03FF)
N  */
Ntypedef struct {
N  __IO uint32_t MEM_MODE          :  2;
X  volatile uint32_t MEM_MODE          :  2;
N  __IO uint32_t RES1              :  6;
X  volatile uint32_t RES1              :  6;
N  __IO uint32_t ADC_DMA_RMP       :  1;
X  volatile uint32_t ADC_DMA_RMP       :  1;
N  __IO uint32_t USART1_TX_DMA_RMP :  1;
X  volatile uint32_t USART1_TX_DMA_RMP :  1;
N  __IO uint32_t USART1_RX_DMA_RMP :  1;
X  volatile uint32_t USART1_RX_DMA_RMP :  1;
N  __IO uint32_t TIM16_DMA_RMP     :  1;
X  volatile uint32_t TIM16_DMA_RMP     :  1;
N  __IO uint32_t TIM17_DMA_RMP     :  1;
X  volatile uint32_t TIM17_DMA_RMP     :  1;
N  __IO uint32_t RES2              :  3;
X  volatile uint32_t RES2              :  3;
N  __IO uint32_t I2C_PB6_FMP       :  1;
X  volatile uint32_t I2C_PB6_FMP       :  1;
N  __IO uint32_t I2C_PB7_FMP       :  1;
X  volatile uint32_t I2C_PB7_FMP       :  1;
N  __IO uint32_t I2C_PB8_FMP       :  1;
X  volatile uint32_t I2C_PB8_FMP       :  1;
N  __IO uint32_t I2C_PB9_FMP       :  1;
X  volatile uint32_t I2C_PB9_FMP       :  1;
N  __IO uint32_t I2C1_FMP          :  1;
X  volatile uint32_t I2C1_FMP          :  1;
N  __IO uint32_t RES3              :  1;
X  volatile uint32_t RES3              :  1;
N  __IO uint32_t I2C_PA9_FMP       :  1;
X  volatile uint32_t I2C_PA9_FMP       :  1;
N  __IO uint32_t I2C_PA10_FMP      :  1;
X  volatile uint32_t I2C_PA10_FMP      :  1;
N  __IO uint32_t RES4              :  8;
X  volatile uint32_t RES4              :  8;
N} SYSCFG_CFGR1_32BIT;
N
Ntypedef struct {
N  __IO uint32_t LOCKUP_LOCK       :  1;
X  volatile uint32_t LOCKUP_LOCK       :  1;
N  __IO uint32_t SRAM_PARITY_LOCK  :  1;
X  volatile uint32_t SRAM_PARITY_LOCK  :  1;
N  __IO uint32_t PVD_LOCK          :  1;
X  volatile uint32_t PVD_LOCK          :  1;
N  __IO uint32_t RES1              :  5;
X  volatile uint32_t RES1              :  5;
N  __IO uint32_t SRAM_REF          :  1;
X  volatile uint32_t SRAM_REF          :  1;
N  __IO uint32_t RES2              : 23;
X  volatile uint32_t RES2              : 23;
N} SYSCFG_CFGR2_32BIT;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t CFGR1;       /*!< SYSCFG configuration register 1,                           Address offset: 0x00 */
X    volatile uint32_t CFGR1;        
N    SYSCFG_CFGR1_32BIT CFGR1_BIT;
N  };
N         uint32_t RESERVED1;   /*!< Reserved,                                                  Address offset: 0x04 */
N    __IO uint32_t EXTICR[4];   /*!< SYSCFG external interrupt configuration register 1-4,      Address offset: 0x08-0x14 */
X    volatile uint32_t EXTICR[4];    
N  union {
N    __IO uint32_t CFGR2;       /*!< SYSCFG configuration register 2,                           Address offset: 0x18 */
X    volatile uint32_t CFGR2;        
N    SYSCFG_CFGR2_32BIT CFGR2_BIT;
N  };
N} SYSCFG_TypeDef;
N
N
N/**
N  * @brief External Interrupt/Event Controller(include EXTI  0x4001 0400 - 0x4001 07FF)
N  */
Ntypedef struct {
N  __IO uint32_t IM0               :  1;
X  volatile uint32_t IM0               :  1;
N  __IO uint32_t IM1               :  1;
X  volatile uint32_t IM1               :  1;
N  __IO uint32_t IM2               :  1;
X  volatile uint32_t IM2               :  1;
N  __IO uint32_t IM3               :  1;
X  volatile uint32_t IM3               :  1;
N  __IO uint32_t IM4               :  1;
X  volatile uint32_t IM4               :  1;
N  __IO uint32_t IM5               :  1;
X  volatile uint32_t IM5               :  1;
N  __IO uint32_t IM6               :  1;
X  volatile uint32_t IM6               :  1;
N  __IO uint32_t IM7               :  1;
X  volatile uint32_t IM7               :  1;
N  __IO uint32_t IM8               :  1;
X  volatile uint32_t IM8               :  1;
N  __IO uint32_t IM9               :  1;
X  volatile uint32_t IM9               :  1;
N  __IO uint32_t IM10              :  1;
X  volatile uint32_t IM10              :  1;
N  __IO uint32_t IM11              :  1;
X  volatile uint32_t IM11              :  1;
N  __IO uint32_t IM12              :  1;
X  volatile uint32_t IM12              :  1;
N  __IO uint32_t IM13              :  1;
X  volatile uint32_t IM13              :  1;
N  __IO uint32_t IM14              :  1;
X  volatile uint32_t IM14              :  1;
N  __IO uint32_t IM15              :  1;
X  volatile uint32_t IM15              :  1;
N  __IO uint32_t IM16              :  1;
X  volatile uint32_t IM16              :  1;
N  __IO uint32_t IM17              :  1;
X  volatile uint32_t IM17              :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t IM19              :  1;
X  volatile uint32_t IM19              :  1;
N  __IO uint32_t RES2              :  1;
X  volatile uint32_t RES2              :  1;
N  __IO uint32_t IM21              :  1;
X  volatile uint32_t IM21              :  1;
N  __IO uint32_t IM22              :  1;
X  volatile uint32_t IM22              :  1;
N  __IO uint32_t IM23              :  1;
X  volatile uint32_t IM23              :  1;
N  __IO uint32_t RES3              :  1;
X  volatile uint32_t RES3              :  1;
N  __IO uint32_t IM25              :  1;
X  volatile uint32_t IM25              :  1;
N  __IO uint32_t RES4              :  6;
X  volatile uint32_t RES4              :  6;
N} EXTI_IMR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t EM0               :  1;
X  volatile uint32_t EM0               :  1;
N  __IO uint32_t EM1               :  1;
X  volatile uint32_t EM1               :  1;
N  __IO uint32_t EM2               :  1;
X  volatile uint32_t EM2               :  1;
N  __IO uint32_t EM3               :  1;
X  volatile uint32_t EM3               :  1;
N  __IO uint32_t EM4               :  1;
X  volatile uint32_t EM4               :  1;
N  __IO uint32_t EM5               :  1;
X  volatile uint32_t EM5               :  1;
N  __IO uint32_t EM6               :  1;
X  volatile uint32_t EM6               :  1;
N  __IO uint32_t EM7               :  1;
X  volatile uint32_t EM7               :  1;
N  __IO uint32_t EM8               :  1;
X  volatile uint32_t EM8               :  1;
N  __IO uint32_t EM9               :  1;
X  volatile uint32_t EM9               :  1;
N  __IO uint32_t EM10              :  1;
X  volatile uint32_t EM10              :  1;
N  __IO uint32_t EM11              :  1;
X  volatile uint32_t EM11              :  1;
N  __IO uint32_t EM12              :  1;
X  volatile uint32_t EM12              :  1;
N  __IO uint32_t EM13              :  1;
X  volatile uint32_t EM13              :  1;
N  __IO uint32_t EM14              :  1;
X  volatile uint32_t EM14              :  1;
N  __IO uint32_t EM15              :  1;
X  volatile uint32_t EM15              :  1;
N  __IO uint32_t EM16              :  1;
X  volatile uint32_t EM16              :  1;
N  __IO uint32_t EM17              :  1;
X  volatile uint32_t EM17              :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t EM19              :  1;
X  volatile uint32_t EM19              :  1;
N  __IO uint32_t RES2              :  1;
X  volatile uint32_t RES2              :  1;
N  __IO uint32_t EM21              :  1;
X  volatile uint32_t EM21              :  1;
N  __IO uint32_t EM22              :  1;
X  volatile uint32_t EM22              :  1;
N  __IO uint32_t EM23              :  1;
X  volatile uint32_t EM23              :  1;
N  __IO uint32_t RES3              :  1;
X  volatile uint32_t RES3              :  1;
N  __IO uint32_t EM25              :  1;
X  volatile uint32_t EM25              :  1;
N  __IO uint32_t RES4              :  6;
X  volatile uint32_t RES4              :  6;
N} EXTI_EMR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t RT0               :  1;
X  volatile uint32_t RT0               :  1;
N  __IO uint32_t RT1               :  1;
X  volatile uint32_t RT1               :  1;
N  __IO uint32_t RT2               :  1;
X  volatile uint32_t RT2               :  1;
N  __IO uint32_t RT3               :  1;
X  volatile uint32_t RT3               :  1;
N  __IO uint32_t RT4               :  1;
X  volatile uint32_t RT4               :  1;
N  __IO uint32_t RT5               :  1;
X  volatile uint32_t RT5               :  1;
N  __IO uint32_t RT6               :  1;
X  volatile uint32_t RT6               :  1;
N  __IO uint32_t RT7               :  1;
X  volatile uint32_t RT7               :  1;
N  __IO uint32_t RT8               :  1;
X  volatile uint32_t RT8               :  1;
N  __IO uint32_t RT9               :  1;
X  volatile uint32_t RT9               :  1;
N  __IO uint32_t RT10              :  1;
X  volatile uint32_t RT10              :  1;
N  __IO uint32_t RT11              :  1;
X  volatile uint32_t RT11              :  1;
N  __IO uint32_t RT12              :  1;
X  volatile uint32_t RT12              :  1;
N  __IO uint32_t RT13              :  1;
X  volatile uint32_t RT13              :  1;
N  __IO uint32_t RT14              :  1;
X  volatile uint32_t RT14              :  1;
N  __IO uint32_t RT15              :  1;
X  volatile uint32_t RT15              :  1;
N  __IO uint32_t RT16              :  1;
X  volatile uint32_t RT16              :  1;
N  __IO uint32_t RT17              :  1;
X  volatile uint32_t RT17              :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t RT19              :  1;
X  volatile uint32_t RT19              :  1;
N  __IO uint32_t RES2              :  1;
X  volatile uint32_t RES2              :  1;
N  __IO uint32_t RT21              :  1;
X  volatile uint32_t RT21              :  1;
N  __IO uint32_t RT22              :  1;
X  volatile uint32_t RT22              :  1;
N  __IO uint32_t RES3              :  9;
X  volatile uint32_t RES3              :  9;
N} EXTI_RTSR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t FT0               :  1;
X  volatile uint32_t FT0               :  1;
N  __IO uint32_t FT1               :  1;
X  volatile uint32_t FT1               :  1;
N  __IO uint32_t FT2               :  1;
X  volatile uint32_t FT2               :  1;
N  __IO uint32_t FT3               :  1;
X  volatile uint32_t FT3               :  1;
N  __IO uint32_t FT4               :  1;
X  volatile uint32_t FT4               :  1;
N  __IO uint32_t FT5               :  1;
X  volatile uint32_t FT5               :  1;
N  __IO uint32_t FT6               :  1;
X  volatile uint32_t FT6               :  1;
N  __IO uint32_t FT7               :  1;
X  volatile uint32_t FT7               :  1;
N  __IO uint32_t FT8               :  1;
X  volatile uint32_t FT8               :  1;
N  __IO uint32_t FT9               :  1;
X  volatile uint32_t FT9               :  1;
N  __IO uint32_t FT10              :  1;
X  volatile uint32_t FT10              :  1;
N  __IO uint32_t FT11              :  1;
X  volatile uint32_t FT11              :  1;
N  __IO uint32_t FT12              :  1;
X  volatile uint32_t FT12              :  1;
N  __IO uint32_t FT13              :  1;
X  volatile uint32_t FT13              :  1;
N  __IO uint32_t FT14              :  1;
X  volatile uint32_t FT14              :  1;
N  __IO uint32_t FT15              :  1;
X  volatile uint32_t FT15              :  1;
N  __IO uint32_t FT16              :  1;
X  volatile uint32_t FT16              :  1;
N  __IO uint32_t FT17              :  1;
X  volatile uint32_t FT17              :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t FT19              :  1;
X  volatile uint32_t FT19              :  1;
N  __IO uint32_t RES2              :  1;
X  volatile uint32_t RES2              :  1;
N  __IO uint32_t FT21              :  1;
X  volatile uint32_t FT21              :  1;
N  __IO uint32_t FT22              :  1;
X  volatile uint32_t FT22              :  1;
N  __IO uint32_t RES3              :  9;
X  volatile uint32_t RES3              :  9;
N} EXTI_FTSR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t SWI0              :  1;
X  volatile uint32_t SWI0              :  1;
N  __IO uint32_t SWI1              :  1;
X  volatile uint32_t SWI1              :  1;
N  __IO uint32_t SWI2              :  1;
X  volatile uint32_t SWI2              :  1;
N  __IO uint32_t SWI3              :  1;
X  volatile uint32_t SWI3              :  1;
N  __IO uint32_t SWI4              :  1;
X  volatile uint32_t SWI4              :  1;
N  __IO uint32_t SWI5              :  1;
X  volatile uint32_t SWI5              :  1;
N  __IO uint32_t SWI6              :  1;
X  volatile uint32_t SWI6              :  1;
N  __IO uint32_t SWI7              :  1;
X  volatile uint32_t SWI7              :  1;
N  __IO uint32_t SWI8              :  1;
X  volatile uint32_t SWI8              :  1;
N  __IO uint32_t SWI9              :  1;
X  volatile uint32_t SWI9              :  1;
N  __IO uint32_t SWI10             :  1;
X  volatile uint32_t SWI10             :  1;
N  __IO uint32_t SWI11             :  1;
X  volatile uint32_t SWI11             :  1;
N  __IO uint32_t SWI12             :  1;
X  volatile uint32_t SWI12             :  1;
N  __IO uint32_t SWI13             :  1;
X  volatile uint32_t SWI13             :  1;
N  __IO uint32_t SWI14             :  1;
X  volatile uint32_t SWI14             :  1;
N  __IO uint32_t SWI15             :  1;
X  volatile uint32_t SWI15             :  1;
N  __IO uint32_t SWI16             :  1;
X  volatile uint32_t SWI16             :  1;
N  __IO uint32_t SWI17             :  1;
X  volatile uint32_t SWI17             :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t SWI19             :  1;
X  volatile uint32_t SWI19             :  1;
N  __IO uint32_t RES2              :  1;
X  volatile uint32_t RES2              :  1;
N  __IO uint32_t SWI21             :  1;
X  volatile uint32_t SWI21             :  1;
N  __IO uint32_t SWI22             :  1;
X  volatile uint32_t SWI22             :  1;
N  __IO uint32_t RES3              :  9;
X  volatile uint32_t RES3              :  9;
N} EXTI_SWIER_32BIT;
N
Ntypedef struct {
N  __IO uint32_t PIF0              :  1;
X  volatile uint32_t PIF0              :  1;
N  __IO uint32_t PIF1              :  1;
X  volatile uint32_t PIF1              :  1;
N  __IO uint32_t PIF2              :  1;
X  volatile uint32_t PIF2              :  1;
N  __IO uint32_t PIF3              :  1;
X  volatile uint32_t PIF3              :  1;
N  __IO uint32_t PIF4              :  1;
X  volatile uint32_t PIF4              :  1;
N  __IO uint32_t PIF5              :  1;
X  volatile uint32_t PIF5              :  1;
N  __IO uint32_t PIF6              :  1;
X  volatile uint32_t PIF6              :  1;
N  __IO uint32_t PIF7              :  1;
X  volatile uint32_t PIF7              :  1;
N  __IO uint32_t PIF8              :  1;
X  volatile uint32_t PIF8              :  1;
N  __IO uint32_t PIF9              :  1;
X  volatile uint32_t PIF9              :  1;
N  __IO uint32_t PIF10             :  1;
X  volatile uint32_t PIF10             :  1;
N  __IO uint32_t PIF11             :  1;
X  volatile uint32_t PIF11             :  1;
N  __IO uint32_t PIF12             :  1;
X  volatile uint32_t PIF12             :  1;
N  __IO uint32_t PIF13             :  1;
X  volatile uint32_t PIF13             :  1;
N  __IO uint32_t PIF14             :  1;
X  volatile uint32_t PIF14             :  1;
N  __IO uint32_t PIF15             :  1;
X  volatile uint32_t PIF15             :  1;
N  __IO uint32_t PIF16             :  1;
X  volatile uint32_t PIF16             :  1;
N  __IO uint32_t PIF17             :  1;
X  volatile uint32_t PIF17             :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t PIF19             :  1;
X  volatile uint32_t PIF19             :  1;
N  __IO uint32_t RES2              :  1;
X  volatile uint32_t RES2              :  1;
N  __IO uint32_t PIF21             :  1;
X  volatile uint32_t PIF21             :  1;
N  __IO uint32_t PIF22             :  1;
X  volatile uint32_t PIF22             :  1;
N  __IO uint32_t RES3              :  9;
X  volatile uint32_t RES3              :  9;
N} EXTI_PR_32BIT;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t IMR;          /*!<EXTI Interrupt mask register,                 Address offset: 0x00 */
X    volatile uint32_t IMR;           
N    EXTI_IMR_32BIT IMR_BIT;
N  };
N  union {
N    __IO uint32_t EMR;          /*!<EXTI Event mask register,                     Address offset: 0x04 */
X    volatile uint32_t EMR;           
N    EXTI_EMR_32BIT EMR_BIT;
N  };
N  union {
N    __IO uint32_t RTSR;         /*!<EXTI Rising trigger selection register ,      Address offset: 0x08 */
X    volatile uint32_t RTSR;          
N    EXTI_RTSR_32BIT RTSR_BIT;
N  };
N  union {
N    __IO uint32_t FTSR;         /*!<EXTI Falling trigger selection register,      Address offset: 0x0C */
X    volatile uint32_t FTSR;          
N    EXTI_FTSR_32BIT FTSR_BIT;
N  };
N  union {
N    __IO uint32_t SWIER;        /*!<EXTI Software interrupt event register,       Address offset: 0x10 */
X    volatile uint32_t SWIER;         
N    EXTI_SWIER_32BIT SWIER_BIT;
N  };
N  union {
N    __IO uint32_t PR;           /*!<EXTI Pending register,                        Address offset: 0x14 */
X    volatile uint32_t PR;            
N    EXTI_PR_32BIT PR_BIT;
N  };
N} EXTI_TypeDef;
N
N
N/**
N  * @brief Analog to Digital Converter(include ADC  0x4001 2400 - 0x4001 27FF)
N  */
Ntypedef struct {
N  __IO uint32_t ADRDY             :  1;
X  volatile uint32_t ADRDY             :  1;
N  __IO uint32_t EOSMP             :  1;
X  volatile uint32_t EOSMP             :  1;
N  __IO uint32_t EOC               :  1;
X  volatile uint32_t EOC               :  1;
N  __IO uint32_t EOSEQ             :  1;
X  volatile uint32_t EOSEQ             :  1;
N  __IO uint32_t OVR               :  1;
X  volatile uint32_t OVR               :  1;
N  __IO uint32_t RES1              :  2;
X  volatile uint32_t RES1              :  2;
N  __IO uint32_t AWD               :  1;
X  volatile uint32_t AWD               :  1;
N  __IO uint32_t RES2              : 24;
X  volatile uint32_t RES2              : 24;
N} ADC_ISR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t ADRDYIE           :  1;
X  volatile uint32_t ADRDYIE           :  1;
N  __IO uint32_t EOSMPIE           :  1;
X  volatile uint32_t EOSMPIE           :  1;
N  __IO uint32_t EOCIE             :  1;
X  volatile uint32_t EOCIE             :  1;
N  __IO uint32_t EOSEQIE           :  1;
X  volatile uint32_t EOSEQIE           :  1;
N  __IO uint32_t OVERIE            :  1;
X  volatile uint32_t OVERIE            :  1;
N  __IO uint32_t RES1              :  2;
X  volatile uint32_t RES1              :  2;
N  __IO uint32_t AWDIE             :  1;
X  volatile uint32_t AWDIE             :  1;
N  __IO uint32_t RES2              : 24;
X  volatile uint32_t RES2              : 24;
N} ADC_IER_32BIT;
N
Ntypedef struct {
N  __IO uint32_t ADEN              :  1;
X  volatile uint32_t ADEN              :  1;
N  __IO uint32_t ADDIS             :  1;
X  volatile uint32_t ADDIS             :  1;
N  __IO uint32_t ADSTART           :  1;
X  volatile uint32_t ADSTART           :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t ADSTP             :  1;
X  volatile uint32_t ADSTP             :  1;
N  __IO uint32_t RES2              : 26;
X  volatile uint32_t RES2              : 26;
N  __IO uint32_t ADCAL             :  1;
X  volatile uint32_t ADCAL             :  1;
N} ADC_CR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t DMAEN             :  1;
X  volatile uint32_t DMAEN             :  1;
N  __IO uint32_t DMACFG            :  1;
X  volatile uint32_t DMACFG            :  1;
N  __IO uint32_t SCANDIR           :  1;
X  volatile uint32_t SCANDIR           :  1;
N  __IO uint32_t RES               :  2;
X  volatile uint32_t RES               :  2;
N  __IO uint32_t ALIGN             :  1;
X  volatile uint32_t ALIGN             :  1;
N  __IO uint32_t EXTSEL            :  3;
X  volatile uint32_t EXTSEL            :  3;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t EXTEN             :  2;
X  volatile uint32_t EXTEN             :  2;
N  __IO uint32_t OVRMOD            :  1;
X  volatile uint32_t OVRMOD            :  1;
N  __IO uint32_t CONT              :  1;
X  volatile uint32_t CONT              :  1;
N  __IO uint32_t WAIT              :  1;
X  volatile uint32_t WAIT              :  1;
N  __IO uint32_t AUTOFF            :  1;
X  volatile uint32_t AUTOFF            :  1;
N  __IO uint32_t DISCEN            :  1;
X  volatile uint32_t DISCEN            :  1;
N  __IO uint32_t RES2              :  5;
X  volatile uint32_t RES2              :  5;
N  __IO uint32_t AWDSEGL           :  1;
X  volatile uint32_t AWDSEGL           :  1;
N  __IO uint32_t AWDEN             :  1;
X  volatile uint32_t AWDEN             :  1;
N  __IO uint32_t RES3              :  2;
X  volatile uint32_t RES3              :  2;
N  __IO uint32_t AWDCH             :  5;
X  volatile uint32_t AWDCH             :  5;
N  __IO uint32_t RES4              :  1;
X  volatile uint32_t RES4              :  1;
N} ADC_CFGR1_32BIT;
N
Ntypedef struct {
N  __IO uint32_t RES1              : 30;
X  volatile uint32_t RES1              : 30;
N  __IO uint32_t CKMODE            :  2;
X  volatile uint32_t CKMODE            :  2;
N} ADC_CFGR2_32BIT;
N
Ntypedef struct {
N  __IO uint32_t SMP               :  3;
X  volatile uint32_t SMP               :  3;
N  __IO uint32_t RES1              : 29;
X  volatile uint32_t RES1              : 29;
N} ADC_SMPR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t LT                : 12;
X  volatile uint32_t LT                : 12;
N  __IO uint32_t RES1              :  4;
X  volatile uint32_t RES1              :  4;
N  __IO uint32_t HT                : 12;
X  volatile uint32_t HT                : 12;
N  __IO uint32_t RES2              :  4;
X  volatile uint32_t RES2              :  4;
N} ADC_TR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t CHSEL             : 19;
X  volatile uint32_t CHSEL             : 19;
N  __IO uint32_t RES1              : 13;
X  volatile uint32_t RES1              : 13;
N} ADC_CHSELR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t DATA              : 16;
X  volatile uint32_t DATA              : 16;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} ADC_DR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t RES1              : 22;
X  volatile uint32_t RES1              : 22;
N  __IO uint32_t VERFEN            :  1;
X  volatile uint32_t VERFEN            :  1;
N  __IO uint32_t TSEN              :  1;
X  volatile uint32_t TSEN              :  1;
N  __IO uint32_t VBATEN            :  1;
X  volatile uint32_t VBATEN            :  1;
N  __IO uint32_t RES2              :  7;
X  volatile uint32_t RES2              :  7;
N} ADC_CCR_32BIT;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t ISR;             /*!< ADC interrupt and status register,             Address offset: 0x00 */
X    volatile uint32_t ISR;              
N    ADC_ISR_32BIT ISR_BIT;
N  };
N  union {
N    __IO uint32_t IER;             /*!< ADC interrupt enable register,                 Address offset: 0x04 */
X    volatile uint32_t IER;              
N    ADC_IER_32BIT IER_BIT;
N  };
N  union {
N    __IO uint32_t CR;              /*!< ADC  control register,                          Address offset: 0x08 */
X    volatile uint32_t CR;               
N    ADC_CR_32BIT CR_BIT;
N  };
N  union {
N    __IO uint32_t CFGR1;           /*!< ADC configuration register 1,                  Address offset: 0x0C */
X    volatile uint32_t CFGR1;            
N    ADC_CFGR1_32BIT CFGR1_BIT;
N  };
N  union {
N    __IO uint32_t CFGR2;           /*!< ADC configuration register 2,                  Address offset: 0x10 */
X    volatile uint32_t CFGR2;            
N    ADC_CFGR2_32BIT CFGR2_BIT;
N  };
N  union {
N    __IO uint32_t SMPR;            /*!< ADC sampling time register,                    Address offset: 0x14 */
X    volatile uint32_t SMPR;             
N    ADC_SMPR_32BIT SMPR_BIT;
N  };
N         uint32_t RESERVED1[2];    /*!< Reserved,                                      Address offset: 0x18/0x1C */
N  union {
N    __IO uint32_t TR;              /*!< ADC analog watchdog 1 threshold register,      Address offset: 0x20 */
X    volatile uint32_t TR;               
N    ADC_TR_32BIT TR_BIT;
N  };
N         uint32_t RESERVED2;       /*!< Reserved,                                      Address offset: 0x24 */
N  union {
N    __IO uint32_t CHSELR;          /*!< ADC group regular sequencer register,          Address offset: 0x28 */
X    volatile uint32_t CHSELR;           
N    ADC_CHSELR_32BIT CHSELR_BIT;
N  };
N         uint32_t RESERVED3[5];    /*!< Reserved,                                      Address offset: 0x2C-0x3C */
N  union {
N    __IO uint32_t DR;              /*!< ADC group regular data register,               Address offset: 0x40 */
X    volatile uint32_t DR;               
N    ADC_DR_32BIT DR_BIT;
N  };
N         uint32_t RESERVED4[177];  /*!< Reserved,                                      Address offset: 0x44-0x304 */
N  union {
N    __IO uint32_t CCR;             /*!< ADC common configuration register,             Address offset: 0x308 */
X    volatile uint32_t CCR;              
N    ADC_CCR_32BIT CCR_BIT;
N  };
N} ADC_TypeDef;
N
Ntypedef struct {
N  __IO uint32_t CCR;          /*!< ADC common configuration register,             Address offset: ADC1 base address + 0x308 */
X  volatile uint32_t CCR;           
N} ADC_Common_TypeDef;
N
N
N/**
N  * @brief Serial Peripheral Interface(include SPI/I2S  0x4001 3000 - 0x4001 33FF)
N  */
Ntypedef struct {
N  __IO uint32_t CPHA              :  1;
X  volatile uint32_t CPHA              :  1;
N  __IO uint32_t CPOL              :  1;
X  volatile uint32_t CPOL              :  1;
N  __IO uint32_t MSTR              :  1;
X  volatile uint32_t MSTR              :  1;
N  __IO uint32_t BR                :  3;
X  volatile uint32_t BR                :  3;
N  __IO uint32_t SPE               :  1;
X  volatile uint32_t SPE               :  1;
N  __IO uint32_t LSBFIRST          :  1;
X  volatile uint32_t LSBFIRST          :  1;
N  __IO uint32_t SSI               :  1;
X  volatile uint32_t SSI               :  1;
N  __IO uint32_t SSM               :  1;
X  volatile uint32_t SSM               :  1;
N  __IO uint32_t RXONLY            :  1;
X  volatile uint32_t RXONLY            :  1;
N  __IO uint32_t CRCL              :  1;
X  volatile uint32_t CRCL              :  1;
N  __IO uint32_t CRCNEXT           :  1;
X  volatile uint32_t CRCNEXT           :  1;
N  __IO uint32_t CRCEN             :  1;
X  volatile uint32_t CRCEN             :  1;
N  __IO uint32_t BIDIOE            :  1;
X  volatile uint32_t BIDIOE            :  1;
N  __IO uint32_t BIDIMODE          :  1;
X  volatile uint32_t BIDIMODE          :  1;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} SPI_CR1_32BIT;
N
Ntypedef struct {
N  __IO uint32_t RXDMAE            :  1;
X  volatile uint32_t RXDMAE            :  1;
N  __IO uint32_t TXDMAE            :  1;
X  volatile uint32_t TXDMAE            :  1;
N  __IO uint32_t SSOE              :  1;
X  volatile uint32_t SSOE              :  1;
N  __IO uint32_t NSSP              :  1;
X  volatile uint32_t NSSP              :  1;
N  __IO uint32_t FRF               :  1;
X  volatile uint32_t FRF               :  1;
N  __IO uint32_t ERRIE             :  1;
X  volatile uint32_t ERRIE             :  1;
N  __IO uint32_t RXNEIE            :  1;
X  volatile uint32_t RXNEIE            :  1;
N  __IO uint32_t TXEIE             :  1;
X  volatile uint32_t TXEIE             :  1;
N  __IO uint32_t DS                :  4;
X  volatile uint32_t DS                :  4;
N  __IO uint32_t FRXTH             :  1;
X  volatile uint32_t FRXTH             :  1;
N  __IO uint32_t LDMA_RX           :  1;
X  volatile uint32_t LDMA_RX           :  1;
N  __IO uint32_t LDMA_TX           :  1;
X  volatile uint32_t LDMA_TX           :  1;
N  __IO uint32_t RES1              : 17;
X  volatile uint32_t RES1              : 17;
N} SPI_CR2_32BIT;
N
Ntypedef struct {
N  __IO uint32_t RXNE              :  1;
X  volatile uint32_t RXNE              :  1;
N  __IO uint32_t TXE               :  1;
X  volatile uint32_t TXE               :  1;
N  __IO uint32_t CHSIDE            :  1;
X  volatile uint32_t CHSIDE            :  1;
N  __IO uint32_t UDR               :  1;
X  volatile uint32_t UDR               :  1;
N  __IO uint32_t CRCERR            :  1;
X  volatile uint32_t CRCERR            :  1;
N  __IO uint32_t MODF              :  1;
X  volatile uint32_t MODF              :  1;
N  __IO uint32_t OVR               :  1;
X  volatile uint32_t OVR               :  1;
N  __IO uint32_t BSY               :  1;
X  volatile uint32_t BSY               :  1;
N  __IO uint32_t FRE               :  1;
X  volatile uint32_t FRE               :  1;
N  __IO uint32_t FRLVL             :  2;
X  volatile uint32_t FRLVL             :  2;
N  __IO uint32_t FTLVL             :  2;
X  volatile uint32_t FTLVL             :  2;
N  __IO uint32_t RES1              : 19;
X  volatile uint32_t RES1              : 19;
N} SPI_SR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t DR                : 16;
X  volatile uint32_t DR                : 16;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} SPI_DR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t CRCPOLY           : 16;
X  volatile uint32_t CRCPOLY           : 16;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} SPI_CRCPR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t CRC               : 16;
X  volatile uint32_t CRC               : 16;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} SPI_CRCR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t CHLEN             :  1;
X  volatile uint32_t CHLEN             :  1;
N  __IO uint32_t DATLEN            :  2;
X  volatile uint32_t DATLEN            :  2;
N  __IO uint32_t CKPOL             :  1;
X  volatile uint32_t CKPOL             :  1;
N  __IO uint32_t I2SSTD            :  2;
X  volatile uint32_t I2SSTD            :  2;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t PCMSY             :  1;
X  volatile uint32_t PCMSY             :  1;
N  __IO uint32_t I2SCFG            :  2;
X  volatile uint32_t I2SCFG            :  2;
N  __IO uint32_t I2SE              :  1;
X  volatile uint32_t I2SE              :  1;
N  __IO uint32_t I2SMOD            :  1;
X  volatile uint32_t I2SMOD            :  1;
N  __IO uint32_t RES2              : 20;
X  volatile uint32_t RES2              : 20;
N} SPI_I2SCFGR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t I2SDIV            :  8;
X  volatile uint32_t I2SDIV            :  8;
N  __IO uint32_t ODD               :  1;
X  volatile uint32_t ODD               :  1;
N  __IO uint32_t MCKOE             :  1;
X  volatile uint32_t MCKOE             :  1;
N  __IO uint32_t RES2              : 22;
X  volatile uint32_t RES2              : 22;
N} SPI_I2SPR_32BIT;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t CR1;        /*!< SPI Control register 1 (not used in I2S mode),      Address offset: 0x00 */
X    volatile uint32_t CR1;         
N    SPI_CR1_32BIT CR1_BIT;
N  };
N  union {
N    __IO uint32_t CR2;        /*!< SPI Control register 2,                             Address offset: 0x04 */
X    volatile uint32_t CR2;         
N    SPI_CR2_32BIT CR2_BIT;
N  };
N  union {
N    __IO uint32_t SR;         /*!< SPI Status register,                                Address offset: 0x08 */
X    volatile uint32_t SR;          
N    SPI_SR_32BIT SR_BIT;
N  };
N  union {
N    __IO uint32_t DR;         /*!< SPI data register,                                  Address offset: 0x0C */
X    volatile uint32_t DR;          
N    SPI_DR_32BIT DR_BIT;
N  };
N  union {
N    __IO uint32_t CRCPR;      /*!< SPI CRC polynomial register (not used in I2S mode), Address offset: 0x10 */
X    volatile uint32_t CRCPR;       
N    SPI_CRCPR_32BIT CRCPR_BIT;
N  };
N  union {
N    __IO uint32_t RXCRCR;     /*!< SPI Rx CRC register (not used in I2S mode),         Address offset: 0x14 */
X    volatile uint32_t RXCRCR;      
N    SPI_CRCR_32BIT RXCRCR_BIT;
N  };
N  union {
N    __IO uint32_t TXCRCR;     /*!< SPI Tx CRC register (not used in I2S mode),         Address offset: 0x18 */
X    volatile uint32_t TXCRCR;      
N    SPI_CRCR_32BIT TXCRCR_BIT;
N  };
N  union {
N    __IO uint32_t I2SCFGR;    /*!< SPI_I2S configuration register,                     Address offset: 0x1C */
X    volatile uint32_t I2SCFGR;     
N    SPI_I2SCFGR_32BIT I2SCFGR_BIT;
N  };
N  union {
N    __IO uint32_t I2SPR;      /*!< SPI_I2S prescaler register,                         Address offset: 0x20 */
X    volatile uint32_t I2SPR;       
N    SPI_I2SPR_32BIT I2SPR_BIT;
N  };
N} SPI_TypeDef;
N
N
N/**
N  * @brief Universal Synchronous Asynchronous Receiver Transmitter(include USART  0x4001 3800 - 0x4001 3BFF)
N  */
Ntypedef struct {
N  __IO uint32_t UE                :  1;
X  volatile uint32_t UE                :  1;
N  __IO uint32_t UESM              :  1;
X  volatile uint32_t UESM              :  1;
N  __IO uint32_t RE                :  1;
X  volatile uint32_t RE                :  1;
N  __IO uint32_t TE                :  1;
X  volatile uint32_t TE                :  1;
N  __IO uint32_t IDLEIE            :  1;
X  volatile uint32_t IDLEIE            :  1;
N  __IO uint32_t RXNEIE            :  1;
X  volatile uint32_t RXNEIE            :  1;
N  __IO uint32_t TCIE              :  1;
X  volatile uint32_t TCIE              :  1;
N  __IO uint32_t TXEIE             :  1;
X  volatile uint32_t TXEIE             :  1;
N  __IO uint32_t PEIE              :  1;
X  volatile uint32_t PEIE              :  1;
N  __IO uint32_t PS                :  1;
X  volatile uint32_t PS                :  1;
N  __IO uint32_t PCE               :  1;
X  volatile uint32_t PCE               :  1;
N  __IO uint32_t WAKE              :  1;
X  volatile uint32_t WAKE              :  1;
N  __IO uint32_t M0                :  1;
X  volatile uint32_t M0                :  1;
N  __IO uint32_t MME               :  1;
X  volatile uint32_t MME               :  1;
N  __IO uint32_t CMIE              :  1;
X  volatile uint32_t CMIE              :  1;
N  __IO uint32_t OVER8             :  1;
X  volatile uint32_t OVER8             :  1;
N  __IO uint32_t DEDT              :  5;
X  volatile uint32_t DEDT              :  5;
N  __IO uint32_t DEAT              :  5;
X  volatile uint32_t DEAT              :  5;
N  __IO uint32_t RTOIE             :  1;
X  volatile uint32_t RTOIE             :  1;
N  __IO uint32_t EOBIE             :  1;
X  volatile uint32_t EOBIE             :  1;
N  __IO uint32_t RES1              :  4;
X  volatile uint32_t RES1              :  4;
N} USART_CR1_32BIT;
N
Ntypedef struct {
N  __IO uint32_t RES1              :  4;
X  volatile uint32_t RES1              :  4;
N  __IO uint32_t ADDM7             :  1;
X  volatile uint32_t ADDM7             :  1;
N  __IO uint32_t LBDL              :  1;
X  volatile uint32_t LBDL              :  1;
N  __IO uint32_t LBDIE             :  1;
X  volatile uint32_t LBDIE             :  1;
N  __IO uint32_t RES2              :  1;
X  volatile uint32_t RES2              :  1;
N  __IO uint32_t LBCL              :  1;
X  volatile uint32_t LBCL              :  1;
N  __IO uint32_t CPHA              :  1;
X  volatile uint32_t CPHA              :  1;
N  __IO uint32_t CPOL              :  1;
X  volatile uint32_t CPOL              :  1;
N  __IO uint32_t CLKEN             :  1;
X  volatile uint32_t CLKEN             :  1;
N  __IO uint32_t STOP              :  2;
X  volatile uint32_t STOP              :  2;
N  __IO uint32_t LINEN             :  1;
X  volatile uint32_t LINEN             :  1;
N  __IO uint32_t SWAP              :  1;
X  volatile uint32_t SWAP              :  1;
N  __IO uint32_t RXINV             :  1;
X  volatile uint32_t RXINV             :  1;
N  __IO uint32_t TXINV             :  1;
X  volatile uint32_t TXINV             :  1;
N  __IO uint32_t DATAINV           :  1;
X  volatile uint32_t DATAINV           :  1;
N  __IO uint32_t MSBFIRST          :  1;
X  volatile uint32_t MSBFIRST          :  1;
N  __IO uint32_t ABREN             :  1;
X  volatile uint32_t ABREN             :  1;
N  __IO uint32_t ABRMOD            :  2;
X  volatile uint32_t ABRMOD            :  2;
N  __IO uint32_t RTOEN             :  1;
X  volatile uint32_t RTOEN             :  1;
N  __IO uint32_t ADD               :  8;
X  volatile uint32_t ADD               :  8;
N} USART_CR2_32BIT;
N
Ntypedef struct {
N  __IO uint32_t EIE               :  1;
X  volatile uint32_t EIE               :  1;
N  __IO uint32_t IREN              :  1;
X  volatile uint32_t IREN              :  1;
N  __IO uint32_t IRLP              :  1;
X  volatile uint32_t IRLP              :  1;
N  __IO uint32_t HDSEL             :  1;
X  volatile uint32_t HDSEL             :  1;
N  __IO uint32_t NACK              :  1;
X  volatile uint32_t NACK              :  1;
N  __IO uint32_t SCEN              :  1;
X  volatile uint32_t SCEN              :  1;
N  __IO uint32_t DMAR              :  1;
X  volatile uint32_t DMAR              :  1;
N  __IO uint32_t DMAT              :  1;
X  volatile uint32_t DMAT              :  1;
N  __IO uint32_t RTSE              :  1;
X  volatile uint32_t RTSE              :  1;
N  __IO uint32_t CTSE              :  1;
X  volatile uint32_t CTSE              :  1;
N  __IO uint32_t CTSIE             :  1;
X  volatile uint32_t CTSIE             :  1;
N  __IO uint32_t ONEBIT            :  1;
X  volatile uint32_t ONEBIT            :  1;
N  __IO uint32_t OVRDIS            :  1;
X  volatile uint32_t OVRDIS            :  1;
N  __IO uint32_t DDRE              :  1;
X  volatile uint32_t DDRE              :  1;
N  __IO uint32_t DEM               :  1;
X  volatile uint32_t DEM               :  1;
N  __IO uint32_t DEP               :  1;
X  volatile uint32_t DEP               :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t SCARCNT           :  3;
X  volatile uint32_t SCARCNT           :  3;
N  __IO uint32_t WUS               :  1;
X  volatile uint32_t WUS               :  1;
N  __IO uint32_t WUFIE             :  1;
X  volatile uint32_t WUFIE             :  1;
N  __IO uint32_t RES2              :  9;
X  volatile uint32_t RES2              :  9;
N} USART_CR3_32BIT;
N
Ntypedef struct {
N  __IO uint32_t BRR_DEC           :  4;
X  volatile uint32_t BRR_DEC           :  4;
N  __IO uint32_t BRR_INT           : 12;
X  volatile uint32_t BRR_INT           : 12;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} USART_BRR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t PSC               :  8;
X  volatile uint32_t PSC               :  8;
N  __IO uint32_t GT                :  8;
X  volatile uint32_t GT                :  8;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} USART_GTPR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t RTO               : 24;
X  volatile uint32_t RTO               : 24;
N  __IO uint32_t BLEN              :  8;
X  volatile uint32_t BLEN              :  8;
N} USART_RTOR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t ABRRQ             :  1;
X  volatile uint32_t ABRRQ             :  1;
N  __IO uint32_t SBKRQ             :  1;
X  volatile uint32_t SBKRQ             :  1;
N  __IO uint32_t MMRQ              :  1;
X  volatile uint32_t MMRQ              :  1;
N  __IO uint32_t RXFRQ             :  1;
X  volatile uint32_t RXFRQ             :  1;
N  __IO uint32_t TXFRQ             :  1;
X  volatile uint32_t TXFRQ             :  1;
N  __IO uint32_t RES1              : 27;
X  volatile uint32_t RES1              : 27;
N} USART_RQR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t PE                :  1;
X  volatile uint32_t PE                :  1;
N  __IO uint32_t FE                :  1;
X  volatile uint32_t FE                :  1;
N  __IO uint32_t NF                :  1;
X  volatile uint32_t NF                :  1;
N  __IO uint32_t ORE               :  1;
X  volatile uint32_t ORE               :  1;
N  __IO uint32_t IDLE              :  1;
X  volatile uint32_t IDLE              :  1;
N  __IO uint32_t RXNE              :  1;
X  volatile uint32_t RXNE              :  1;
N  __IO uint32_t TC                :  1;
X  volatile uint32_t TC                :  1;
N  __IO uint32_t TXE               :  1;
X  volatile uint32_t TXE               :  1;
N  __IO uint32_t LBDF              :  1;
X  volatile uint32_t LBDF              :  1;
N  __IO uint32_t CTSIF             :  1;
X  volatile uint32_t CTSIF             :  1;
N  __IO uint32_t CTS               :  1;
X  volatile uint32_t CTS               :  1;
N  __IO uint32_t RTOF              :  1;
X  volatile uint32_t RTOF              :  1;
N  __IO uint32_t EOBF              :  1;
X  volatile uint32_t EOBF              :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t ANRE              :  1;
X  volatile uint32_t ANRE              :  1;
N  __IO uint32_t ABRF              :  1;
X  volatile uint32_t ABRF              :  1;
N  __IO uint32_t BUSY              :  1;
X  volatile uint32_t BUSY              :  1;
N  __IO uint32_t CMF               :  1;
X  volatile uint32_t CMF               :  1;
N  __IO uint32_t SBKF              :  1;
X  volatile uint32_t SBKF              :  1;
N  __IO uint32_t RWU               :  1;
X  volatile uint32_t RWU               :  1;
N  __IO uint32_t WUF               :  1;
X  volatile uint32_t WUF               :  1;
N  __IO uint32_t TEACK             :  1;
X  volatile uint32_t TEACK             :  1;
N  __IO uint32_t REACK             :  1;
X  volatile uint32_t REACK             :  1;
N  __IO uint32_t RES2              :  9;
X  volatile uint32_t RES2              :  9;
N} USART_ISR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t PECF              :  1;
X  volatile uint32_t PECF              :  1;
N  __IO uint32_t FECF              :  1;
X  volatile uint32_t FECF              :  1;
N  __IO uint32_t NCF               :  1;
X  volatile uint32_t NCF               :  1;
N  __IO uint32_t ORECF             :  1;
X  volatile uint32_t ORECF             :  1;
N  __IO uint32_t IDLECF            :  1;
X  volatile uint32_t IDLECF            :  1;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t TCCF              :  1;
X  volatile uint32_t TCCF              :  1;
N  __IO uint32_t RES2              :  1;
X  volatile uint32_t RES2              :  1;
N  __IO uint32_t LBDCF             :  1;
X  volatile uint32_t LBDCF             :  1;
N  __IO uint32_t CTSCF             :  1;
X  volatile uint32_t CTSCF             :  1;
N  __IO uint32_t RES3              :  1;
X  volatile uint32_t RES3              :  1;
N  __IO uint32_t RTOCF             :  1;
X  volatile uint32_t RTOCF             :  1;
N  __IO uint32_t EOBCF             :  1;
X  volatile uint32_t EOBCF             :  1;
N  __IO uint32_t RES4              :  4;
X  volatile uint32_t RES4              :  4;
N  __IO uint32_t CMCF              :  1;
X  volatile uint32_t CMCF              :  1;
N  __IO uint32_t RES5              :  2;
X  volatile uint32_t RES5              :  2;
N  __IO uint32_t WUCF              :  1;
X  volatile uint32_t WUCF              :  1;
N  __IO uint32_t RES6              : 11;
X  volatile uint32_t RES6              : 11;
N} USART_ICR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t DR                :  8;
X  volatile uint32_t DR                :  8;
N  __IO uint32_t RES1              : 24;
X  volatile uint32_t RES1              : 24;
N} USART_DR_32BIT;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t CR1;    /*!< USART Control register 1,                 Address offset: 0x00 */
X    volatile uint32_t CR1;     
N    USART_CR1_32BIT CR1_BIT;
N  };
N  union {
N    __IO uint32_t CR2;    /*!< USART Control register 2,                 Address offset: 0x04 */
X    volatile uint32_t CR2;     
N    USART_CR2_32BIT CR2_BIT;
N  };
N  union {
N    __IO uint32_t CR3;    /*!< USART Control register 3,                 Address offset: 0x08 */
X    volatile uint32_t CR3;     
N    USART_CR3_32BIT CR3_BIT;
N  };
N  union {
N    __IO uint32_t BRR;    /*!< USART Baud rate register,                 Address offset: 0x0C */
X    volatile uint32_t BRR;     
N    USART_BRR_32BIT BRR_BIT;
N  };
N  union {
N    __IO uint32_t GTPR;   /*!< USART Guard time and prescaler register,  Address offset: 0x10 */
X    volatile uint32_t GTPR;    
N    USART_GTPR_32BIT GTPR_BIT;
N  };
N  union {
N    __IO uint32_t RTOR;   /*!< USART Receiver Time Out register,         Address offset: 0x14 */
X    volatile uint32_t RTOR;    
N    USART_RTOR_32BIT RTOR_BIT;
N  };
N  union {
N    __IO uint32_t RQR;    /*!< USART Request register,                   Address offset: 0x18 */
X    volatile uint32_t RQR;     
N    USART_RQR_32BIT RQR_BIT;
N  };
N  union {
N    __IO uint32_t ISR;    /*!< USART Interrupt and status register,      Address offset: 0x1C */
X    volatile uint32_t ISR;     
N    USART_ISR_32BIT ISR_BIT;
N  };
N  union {
N    __IO uint32_t ICR;    /*!< USART Interrupt flag Clear register,      Address offset: 0x20 */
X    volatile uint32_t ICR;     
N    USART_ICR_32BIT ICR_BIT;
N  };
N  union {
N    __IO uint32_t RDR;    /*!< USART Receive Data register,              Address offset: 0x24 */
X    volatile uint32_t RDR;     
N    USART_DR_32BIT RDR_BIT;
N  };
N  union {
N    __IO uint16_t TDR;    /*!< USART Transmit Data register,             Address offset: 0x28 */
X    volatile uint16_t TDR;     
N    USART_DR_32BIT TDR_BIT;
N  };
N} USART_TypeDef;
N
N
N/**
N  * @brief Operational Amplifier and Voltage Comparator(include CMP/OPAMP  0x4001 3C00 - 0x4001 3FFF)
N  */
Ntypedef struct {
N  __IO uint32_t EN                :  1;
X  volatile uint32_t EN                :  1;
N  __IO uint32_t HYST              :  2;
X  volatile uint32_t HYST              :  2;
N  __IO uint32_t PSEL              :  3;
X  volatile uint32_t PSEL              :  3;
N  __IO uint32_t NSEL              :  1;
X  volatile uint32_t NSEL              :  1;
N  __IO uint32_t RVSEL             :  3;
X  volatile uint32_t RVSEL             :  3;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t OFLT              :  3;
X  volatile uint32_t OFLT              :  3;
N  __IO uint32_t RES2              :  1;
X  volatile uint32_t RES2              :  1;
N  __IO uint32_t POL               :  1;
X  volatile uint32_t POL               :  1;
N  __IO uint32_t OUTSEL            :  3;
X  volatile uint32_t OUTSEL            :  3;
N  __IO uint32_t RES3              : 11;
X  volatile uint32_t RES3              : 11;
N  __IO uint32_t OUT               :  1;
X  volatile uint32_t OUT               :  1;
N  __IO uint32_t LCK               :  1;
X  volatile uint32_t LCK               :  1;
N} CMP_CR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t CPVREFEN          :  1;
X  volatile uint32_t CPVREFEN          :  1;
N  __IO uint32_t CP1VOLT           :  1;
X  volatile uint32_t CP1VOLT           :  1;
N  __IO uint32_t CP2VOLT           :  1;
X  volatile uint32_t CP2VOLT           :  1;
N  __IO uint32_t RES1              : 29;
X  volatile uint32_t RES1              : 29;
N} CMP_ANA_32BIT;
N
Ntypedef struct {
N  __IO uint32_t OPAMP1EN          :  1;
X  volatile uint32_t OPAMP1EN          :  1;
N  __IO uint32_t OPAMP1NSEL        :  2;
X  volatile uint32_t OPAMP1NSEL        :  2;
N  __IO uint32_t RES1              :  1;
X  volatile uint32_t RES1              :  1;
N  __IO uint32_t OPAMP1GAIN        :  2;
X  volatile uint32_t OPAMP1GAIN        :  2;
N  __IO uint32_t RES2              :  1;
X  volatile uint32_t RES2              :  1;
N  __IO uint32_t OPAMP1OUTEN       :  1;
X  volatile uint32_t OPAMP1OUTEN       :  1;
N  __IO uint32_t OPAMP2EN          :  1;
X  volatile uint32_t OPAMP2EN          :  1;
N  __IO uint32_t OPAMP2NSEL        :  2;
X  volatile uint32_t OPAMP2NSEL        :  2;
N  __IO uint32_t RES3              :  1;
X  volatile uint32_t RES3              :  1;
N  __IO uint32_t OPAMP2GAIN        :  2;
X  volatile uint32_t OPAMP2GAIN        :  2;
N  __IO uint32_t RES4              :  1;
X  volatile uint32_t RES4              :  1;
N  __IO uint32_t OPAMP2OUTEN       :  1;
X  volatile uint32_t OPAMP2OUTEN       :  1;
N  __IO uint32_t OPAMP3EN           :  1;
X  volatile uint32_t OPAMP3EN           :  1;
N  __IO uint32_t OPAMP3NSEL        :  2;
X  volatile uint32_t OPAMP3NSEL        :  2;
N  __IO uint32_t RES5              :  1;
X  volatile uint32_t RES5              :  1;
N  __IO uint32_t OPAMP3GAIN        :  2;
X  volatile uint32_t OPAMP3GAIN        :  2;
N  __IO uint32_t RES6              :  1;
X  volatile uint32_t RES6              :  1;
N  __IO uint32_t OPAMP3OUTEN       :  1;
X  volatile uint32_t OPAMP3OUTEN       :  1;
N  __IO uint32_t RES7              :  7;
X  volatile uint32_t RES7              :  7;
N  __IO uint32_t OPAMPLCK          :  1;
X  volatile uint32_t OPAMPLCK          :  1;
N} OP_CR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t CALDATN           :  6;
X  volatile uint32_t CALDATN           :  6;
N  __IO uint32_t RES1              :  2;
X  volatile uint32_t RES1              :  2;
N  __IO uint32_t CALDATP           :  6;
X  volatile uint32_t CALDATP           :  6;
N  __IO uint32_t RES2              : 16;
X  volatile uint32_t RES2              : 16;
N  __IO uint32_t SYNC              :  1;
X  volatile uint32_t SYNC              :  1;
N  __IO uint32_t CALEN             :  1;
X  volatile uint32_t CALEN             :  1;
N} CMP_OP_CAL_32BIT;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t CP1CR;       /*!< Comparator 1 Control register,                 Address offset: 0x00 */
X    volatile uint32_t CP1CR;        
N    CMP_CR_32BIT CP1CR_BIT;
N  };
N  union {
N    __IO uint32_t CP2CR;       /*!< Comparator 2 Control register,                 Address offset: 0x04 */
X    volatile uint32_t CP2CR;        
N    CMP_CR_32BIT CP2CR_BIT;
N  };
N  union {
N    __IO uint32_t CPANA;       /*!< Comparator analog register,                    Address offset: 0x08 */
X    volatile uint32_t CPANA;        
N    CMP_ANA_32BIT CPANA_BIT;
N  };
N  union {
N    __IO uint32_t CP1CAL;      /*!< Comparator 1 calibration register,             Address offset: 0x0C */
X    volatile uint32_t CP1CAL;       
N    CMP_OP_CAL_32BIT CP1CAL_BIT;
N  };
N  union {
N    __IO uint32_t CP2CAL;      /*!< Comparator 2 calibration register,             Address offset: 0x10 */
X    volatile uint32_t CP2CAL;       
N    CMP_OP_CAL_32BIT CP2CAL_BIT;
N  };
N  union {
N    __IO uint32_t OPCR;        /*!< Operational Amplifier Control register,        Address offset: 0x14 */
X    volatile uint32_t OPCR;         
N    OP_CR_32BIT OPCR_BIT;
N  };
N  union {
N    __IO uint32_t OP1CAL;      /*!< Operational Amplifier 1 calibration register,  Address offset: 0x18 */
X    volatile uint32_t OP1CAL;       
N    CMP_OP_CAL_32BIT OP1CAL_BIT;
N  };
N  union {
N    __IO uint32_t OP2CAL;      /*!< Operational Amplifier 2 calibration register,  Address offset: 0x1C */
X    volatile uint32_t OP2CAL;       
N    CMP_OP_CAL_32BIT OP2CAL_BIT;
N  };
N  union {
N    __IO uint32_t OP3CAL;      /*!< Operational Amplifier 3 calibration register,  Address offset: 0x20 */
X    volatile uint32_t OP3CAL;       
N    CMP_OP_CAL_32BIT OP3CAL_BIT;
N  };
N}CMP_OP_TypeDef;
N
N
N/**
N  * @brief Debug MCU(include DBGMCU  0x4001 5800 - 0x4001 5BFF)
N  */
Ntypedef struct {
N  __IO uint32_t RES1                :  1;
X  volatile uint32_t RES1                :  1;
N  __IO uint32_t STOP                :  1;
X  volatile uint32_t STOP                :  1;
N  __IO uint32_t STANDBY             :  1;
X  volatile uint32_t STANDBY             :  1;
N  __IO uint32_t RES2                : 29;
X  volatile uint32_t RES2                : 29;
N} DBGMCU_CR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t TIM2_STOP           :  1;
X  volatile uint32_t TIM2_STOP           :  1;
N  __IO uint32_t TIM3_STOP           :  1;
X  volatile uint32_t TIM3_STOP           :  1;
N  __IO uint32_t RES1                :  6;
X  volatile uint32_t RES1                :  6;
N  __IO uint32_t TIM14_STOP          :  1;
X  volatile uint32_t TIM14_STOP          :  1;
N  __IO uint32_t RES2                :  1;
X  volatile uint32_t RES2                :  1;
N  __IO uint32_t RTC_STOP            :  1;
X  volatile uint32_t RTC_STOP            :  1;
N  __IO uint32_t WWDG_STOP           :  1;
X  volatile uint32_t WWDG_STOP           :  1;
N  __IO uint32_t IWDG_STOP           :  1;
X  volatile uint32_t IWDG_STOP           :  1;
N  __IO uint32_t RES3                :  8;
X  volatile uint32_t RES3                :  8;
N  __IO uint32_t I2C1_SMBUS_TIMEOUT  :  1;
X  volatile uint32_t I2C1_SMBUS_TIMEOUT  :  1;
N  __IO uint32_t RES4                : 10;
X  volatile uint32_t RES4                : 10;
N} DBGMCU_APB1FZ_32BIT;
N
Ntypedef struct {
N  __IO uint32_t RES1                : 11;
X  volatile uint32_t RES1                : 11;
N  __IO uint32_t TIM1_STOP           :  1;
X  volatile uint32_t TIM1_STOP           :  1;
N  __IO uint32_t RES2                :  5;
X  volatile uint32_t RES2                :  5;
N  __IO uint32_t TIM16_STOP          :  1;
X  volatile uint32_t TIM16_STOP          :  1;
N  __IO uint32_t TIM17_STOP          :  1;
X  volatile uint32_t TIM17_STOP          :  1;
N  __IO uint32_t RES3                : 13;
X  volatile uint32_t RES3                : 13;
N} DBGMCU_APB2FZ_32BIT;
N
N
Ntypedef struct {
N    __IO uint32_t IDCODE;       /*!< MCU device ID code,                          Address offset: 0x00 */
X    volatile uint32_t IDCODE;        
N  union {
N    __IO uint32_t CR;           /*!< Debug MCU configuration register,            Address offset: 0x04 */
X    volatile uint32_t CR;            
N    DBGMCU_CR_32BIT CR_BIT;
N  };
N  union {
N    __IO uint32_t APB1FZ;       /*!< Debug MCU APB1 freeze register,              Address offset: 0x08 */
X    volatile uint32_t APB1FZ;        
N    DBGMCU_APB1FZ_32BIT APB1FZ_BIT;
N  };
N  union {
N    __IO uint32_t APB2FZ;       /*!< Debug MCU APB2 freeze register,              Address offset: 0x0C */
X    volatile uint32_t APB2FZ;        
N    DBGMCU_APB2FZ_32BIT APB2FZ_BIT;
N  };
N}DBGMCU_TypeDef;
N
N
N/**
N  * @brief DMA Controller(include DMA  0x4002 0000 - 0x4002 03FF)
N  */
Ntypedef struct {
N  __IO uint32_t GIF1              :  1;
X  volatile uint32_t GIF1              :  1;
N  __IO uint32_t TCIF1             :  1;
X  volatile uint32_t TCIF1             :  1;
N  __IO uint32_t HTIF1             :  1;
X  volatile uint32_t HTIF1             :  1;
N  __IO uint32_t TEIF1             :  1;
X  volatile uint32_t TEIF1             :  1;
N  __IO uint32_t GIF2              :  1;
X  volatile uint32_t GIF2              :  1;
N  __IO uint32_t TCIF2             :  1;
X  volatile uint32_t TCIF2             :  1;
N  __IO uint32_t HTIF2             :  1;
X  volatile uint32_t HTIF2             :  1;
N  __IO uint32_t TEIF2             :  1;
X  volatile uint32_t TEIF2             :  1;
N  __IO uint32_t GIF3              :  1;
X  volatile uint32_t GIF3              :  1;
N  __IO uint32_t TCIF3             :  1;
X  volatile uint32_t TCIF3             :  1;
N  __IO uint32_t HTIF3             :  1;
X  volatile uint32_t HTIF3             :  1;
N  __IO uint32_t TEIF3             :  1;
X  volatile uint32_t TEIF3             :  1;
N  __IO uint32_t GIF4              :  1;
X  volatile uint32_t GIF4              :  1;
N  __IO uint32_t TCIF4             :  1;
X  volatile uint32_t TCIF4             :  1;
N  __IO uint32_t HTIF4             :  1;
X  volatile uint32_t HTIF4             :  1;
N  __IO uint32_t TEIF4             :  1;
X  volatile uint32_t TEIF4             :  1;
N  __IO uint32_t GIF5              :  1;
X  volatile uint32_t GIF5              :  1;
N  __IO uint32_t TCIF5             :  1;
X  volatile uint32_t TCIF5             :  1;
N  __IO uint32_t HTIF5             :  1;
X  volatile uint32_t HTIF5             :  1;
N  __IO uint32_t TEIF5             :  1;
X  volatile uint32_t TEIF5             :  1;
N  __IO uint32_t RES1              : 12;
X  volatile uint32_t RES1              : 12;
N} DMA_SR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t EN                :  1;
X  volatile uint32_t EN                :  1;
N  __IO uint32_t TCIE              :  1;
X  volatile uint32_t TCIE              :  1;
N  __IO uint32_t HTIE              :  1;
X  volatile uint32_t HTIE              :  1;
N  __IO uint32_t TEIE              :  1;
X  volatile uint32_t TEIE              :  1;
N  __IO uint32_t DIR               :  1;
X  volatile uint32_t DIR               :  1;
N  __IO uint32_t CIRC              :  1;
X  volatile uint32_t CIRC              :  1;
N  __IO uint32_t PINC              :  1;
X  volatile uint32_t PINC              :  1;
N  __IO uint32_t MINC              :  1;
X  volatile uint32_t MINC              :  1;
N  __IO uint32_t PSIZE             :  2;
X  volatile uint32_t PSIZE             :  2;
N  __IO uint32_t MSIZE             :  2;
X  volatile uint32_t MSIZE             :  2;
N  __IO uint32_t PL                :  2;
X  volatile uint32_t PL                :  2;
N  __IO uint32_t MEM2MEM           :  1;
X  volatile uint32_t MEM2MEM           :  1;
N  __IO uint32_t RES1              : 17;
X  volatile uint32_t RES1              : 17;
N} DMA_CHN_CCR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t NDT               : 16;
X  volatile uint32_t NDT               : 16;
N  __IO uint32_t RES1              : 16;
X  volatile uint32_t RES1              : 16;
N} DMA_CHN_CNDTR_32BIT;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t CCR;          /*!< DMA channel x configuration register        */
X    volatile uint32_t CCR;           
N    DMA_CHN_CCR_32BIT CCR_BIT;
N  };
N  union {
N    __IO uint32_t CNDTR;        /*!< DMA channel x number of data register       */
X    volatile uint32_t CNDTR;         
N    DMA_CHN_CNDTR_32BIT CNDTR_BIT;
N  };
N    __IO uint32_t CPAR;         /*!< DMA channel x peripheral address register   */
X    volatile uint32_t CPAR;          
N    __IO uint32_t CMAR;         /*!< DMA channel x memory address register       */
X    volatile uint32_t CMAR;          
N} DMA_Channel_TypeDef;
N
Ntypedef struct {
N  union {
N    __IO uint32_t ISR;             /*!< DMA interrupt status register,               Address offset: 0x00 */
X    volatile uint32_t ISR;              
N    DMA_SR_32BIT ISR_BIT;
N  };
N  union {
N    __IO uint32_t IFCR;            /*!< DMA interrupt flag clear register,           Address offset: 0x04 */
X    volatile uint32_t IFCR;             
N    DMA_SR_32BIT IFCR_BIT;
N  };
N    DMA_Channel_TypeDef DMA_CHN1;  /*!< DMA channel 1 all register,                  Address offset: 0x08 */
N    DMA_Channel_TypeDef DMA_CHN2;  /*!< DMA channel 2 all register,                  Address offset: 0x1C */
N    DMA_Channel_TypeDef DMA_CHN3;  /*!< DMA channel 3 all register,                  Address offset: 0x30 */
N    DMA_Channel_TypeDef DMA_CHN4;  /*!< DMA channel 4 all register,                  Address offset: 0x44 */
N    DMA_Channel_TypeDef DMA_CHN5;  /*!< DMA channel 5 all register,                  Address offset: 0x58 */
N} DMA_TypeDef;
N
N
N/**
N  * @brief Reset and Clock Control(include RCC  0x4002 1000 - 0x4002 13FF)
N  */
Ntypedef struct {
N  __IO uint32_t HSION               :  1;
X  volatile uint32_t HSION               :  1;
N  __IO uint32_t HSIRDY              :  1;
X  volatile uint32_t HSIRDY              :  1;
N  __IO uint32_t RES1                :  1;
X  volatile uint32_t RES1                :  1;
N  __IO uint32_t HSITRIM             :  5;
X  volatile uint32_t HSITRIM             :  5;
N  __IO uint32_t HSICAL              :  8;
X  volatile uint32_t HSICAL              :  8;
N  __IO uint32_t HSEON               :  1;
X  volatile uint32_t HSEON               :  1;
N  __IO uint32_t HSERDY              :  1;
X  volatile uint32_t HSERDY              :  1;
N  __IO uint32_t HSEBYP              :  1;
X  volatile uint32_t HSEBYP              :  1;
N  __IO uint32_t CSSON               :  1;
X  volatile uint32_t CSSON               :  1;
N  __IO uint32_t RES2                :  4;
X  volatile uint32_t RES2                :  4;
N  __IO uint32_t PLLON               :  1;
X  volatile uint32_t PLLON               :  1;
N  __IO uint32_t PLLRDY              :  1;
X  volatile uint32_t PLLRDY              :  1;
N  __IO uint32_t RES3                :  6;
X  volatile uint32_t RES3                :  6;
N} RCC_CR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t SW                  :  2;
X  volatile uint32_t SW                  :  2;
N  __IO uint32_t SWS                 :  2;
X  volatile uint32_t SWS                 :  2;
N  __IO uint32_t HPRE                :  4;
X  volatile uint32_t HPRE                :  4;
N  __IO uint32_t PPRE                :  3;
X  volatile uint32_t PPRE                :  3;
N  __IO uint32_t RES1                :  5;
X  volatile uint32_t RES1                :  5;
N  __IO uint32_t PLLSRC              :  1;
X  volatile uint32_t PLLSRC              :  1;
N  __IO uint32_t PLLXTPRE            :  1;
X  volatile uint32_t PLLXTPRE            :  1;
N  __IO uint32_t PLLMUL              :  4;
X  volatile uint32_t PLLMUL              :  4;
N  __IO uint32_t RES2                :  2;
X  volatile uint32_t RES2                :  2;
N  __IO uint32_t MCO                 :  4;
X  volatile uint32_t MCO                 :  4;
N  __IO uint32_t MCOPRE              :  3;
X  volatile uint32_t MCOPRE              :  3;
N  __IO uint32_t PLLNODIV            :  1;
X  volatile uint32_t PLLNODIV            :  1;
N} RCC_CFGR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t LSIRDYF             :  1;
X  volatile uint32_t LSIRDYF             :  1;
N  __IO uint32_t LSERDYF             :  1;
X  volatile uint32_t LSERDYF             :  1;
N  __IO uint32_t HSIRDYF             :  1;
X  volatile uint32_t HSIRDYF             :  1;
N  __IO uint32_t HSERDYF             :  1;
X  volatile uint32_t HSERDYF             :  1;
N  __IO uint32_t PLLRDYF             :  1;
X  volatile uint32_t PLLRDYF             :  1;
N  __IO uint32_t HSI16RDYF           :  1;
X  volatile uint32_t HSI16RDYF           :  1;
N  __IO uint32_t RES1                :  1;
X  volatile uint32_t RES1                :  1;
N  __IO uint32_t CSSF                :  1;
X  volatile uint32_t CSSF                :  1;
N  __IO uint32_t LSIRDYIE            :  1;
X  volatile uint32_t LSIRDYIE            :  1;
N  __IO uint32_t LSERDYIE            :  1;
X  volatile uint32_t LSERDYIE            :  1;
N  __IO uint32_t HSIRDYIE            :  1;
X  volatile uint32_t HSIRDYIE            :  1;
N  __IO uint32_t HSERDYIE            :  1;
X  volatile uint32_t HSERDYIE            :  1;
N  __IO uint32_t PLLRDYIE            :  1;
X  volatile uint32_t PLLRDYIE            :  1;
N  __IO uint32_t HSI16RDYIE          :  1;
X  volatile uint32_t HSI16RDYIE          :  1;
N  __IO uint32_t RES2                :  2;
X  volatile uint32_t RES2                :  2;
N  __IO uint32_t LSIRDYC             :  1;
X  volatile uint32_t LSIRDYC             :  1;
N  __IO uint32_t LSERDYC             :  1;
X  volatile uint32_t LSERDYC             :  1;
N  __IO uint32_t HSIRDYC             :  1;
X  volatile uint32_t HSIRDYC             :  1;
N  __IO uint32_t HSERDYC             :  1;
X  volatile uint32_t HSERDYC             :  1;
N  __IO uint32_t PLLRDYC             :  1;
X  volatile uint32_t PLLRDYC             :  1;
N  __IO uint32_t HSI16RDYC           :  1;
X  volatile uint32_t HSI16RDYC           :  1;
N  __IO uint32_t RES3                :  1;
X  volatile uint32_t RES3                :  1;
N  __IO uint32_t CSSC                :  1;
X  volatile uint32_t CSSC                :  1;
N  __IO uint32_t RES4                :  8;
X  volatile uint32_t RES4                :  8;
N} RCC_CIR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t SYSCFGRST           :  1;
X  volatile uint32_t SYSCFGRST           :  1;
N  __IO uint32_t RES1                :  8;
X  volatile uint32_t RES1                :  8;
N  __IO uint32_t ADCRST              :  1;
X  volatile uint32_t ADCRST              :  1;
N  __IO uint32_t RES2                :  1;
X  volatile uint32_t RES2                :  1;
N  __IO uint32_t TIM1RST             :  1;
X  volatile uint32_t TIM1RST             :  1;
N  __IO uint32_t SPI1RST             :  1;
X  volatile uint32_t SPI1RST             :  1;
N  __IO uint32_t RES3                :  1;
X  volatile uint32_t RES3                :  1;
N  __IO uint32_t USART1RST           :  1;
X  volatile uint32_t USART1RST           :  1;
N  __IO uint32_t RES4                :  2;
X  volatile uint32_t RES4                :  2;
N  __IO uint32_t TIM16RST            :  1;
X  volatile uint32_t TIM16RST            :  1;
N  __IO uint32_t TIM17RST            :  1;
X  volatile uint32_t TIM17RST            :  1;
N  __IO uint32_t RES5                :  3;
X  volatile uint32_t RES5                :  3;
N  __IO uint32_t DBGMCURST           :  1;
X  volatile uint32_t DBGMCURST           :  1;
N  __IO uint32_t RES6                :  9;
X  volatile uint32_t RES6                :  9;
N} RCC_APB2RSTR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t TIM2RST             :  1;
X  volatile uint32_t TIM2RST             :  1;
N  __IO uint32_t TIM3RST             :  1;
X  volatile uint32_t TIM3RST             :  1;
N  __IO uint32_t RES1                :  6;
X  volatile uint32_t RES1                :  6;
N  __IO uint32_t TIM14RST            :  1;
X  volatile uint32_t TIM14RST            :  1;
N  __IO uint32_t RES2                :  2;
X  volatile uint32_t RES2                :  2;
N  __IO uint32_t WWDGRST             :  1;
X  volatile uint32_t WWDGRST             :  1;
N  __IO uint32_t RES3                :  9;
X  volatile uint32_t RES3                :  9;
N  __IO uint32_t I2C1RST             :  1;
X  volatile uint32_t I2C1RST             :  1;
N  __IO uint32_t RES4                :  6;
X  volatile uint32_t RES4                :  6;
N  __IO uint32_t PWRRST              :  1;
X  volatile uint32_t PWRRST              :  1;
N  __IO uint32_t RES5                :  3;
X  volatile uint32_t RES5                :  3;
N} RCC_APB1RSTR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t DMAEN               :  1;
X  volatile uint32_t DMAEN               :  1;
N  __IO uint32_t RES1                :  1;
X  volatile uint32_t RES1                :  1;
N  __IO uint32_t SRAMEN              :  1;
X  volatile uint32_t SRAMEN              :  1;
N  __IO uint32_t RES2                :  1;
X  volatile uint32_t RES2                :  1;
N  __IO uint32_t FLITEN              :  1;
X  volatile uint32_t FLITEN              :  1;
N  __IO uint32_t RES3                :  1;
X  volatile uint32_t RES3                :  1;
N  __IO uint32_t CRCEN               :  1;
X  volatile uint32_t CRCEN               :  1;
N  __IO uint32_t RES4                : 10;
X  volatile uint32_t RES4                : 10;
N  __IO uint32_t IOPAEN              :  1;
X  volatile uint32_t IOPAEN              :  1;
N  __IO uint32_t IOPBEN              :  1;
X  volatile uint32_t IOPBEN              :  1;
N  __IO uint32_t IOPCEN              :  1;
X  volatile uint32_t IOPCEN              :  1;
N  __IO uint32_t RES5                :  2;
X  volatile uint32_t RES5                :  2;
N  __IO uint32_t IOPFEN              :  1;
X  volatile uint32_t IOPFEN              :  1;
N  __IO uint32_t RES6                :  9;
X  volatile uint32_t RES6                :  9;
N} RCC_AHBENR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t SYSCFGEN            :  1;
X  volatile uint32_t SYSCFGEN            :  1;
N  __IO uint32_t RES1                :  8;
X  volatile uint32_t RES1                :  8;
N  __IO uint32_t ADCEN               :  1;
X  volatile uint32_t ADCEN               :  1;
N  __IO uint32_t RES2                :  1;
X  volatile uint32_t RES2                :  1;
N  __IO uint32_t TIM1EN              :  1;
X  volatile uint32_t TIM1EN              :  1;
N  __IO uint32_t SPI1EN              :  1;
X  volatile uint32_t SPI1EN              :  1;
N  __IO uint32_t RES3                :  1;
X  volatile uint32_t RES3                :  1;
N  __IO uint32_t USART1EN            :  1;
X  volatile uint32_t USART1EN            :  1;
N  __IO uint32_t RES4                :  2;
X  volatile uint32_t RES4                :  2;
N  __IO uint32_t TIM16EN             :  1;
X  volatile uint32_t TIM16EN             :  1;
N  __IO uint32_t TIM17EN             :  1;
X  volatile uint32_t TIM17EN             :  1;
N  __IO uint32_t RES5                :  3;
X  volatile uint32_t RES5                :  3;
N  __IO uint32_t DBGMCUEN            :  1;
X  volatile uint32_t DBGMCUEN            :  1;
N  __IO uint32_t RES6                :  9;
X  volatile uint32_t RES6                :  9;
N} RCC_APB2ENR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t TIM2EN              :  1;
X  volatile uint32_t TIM2EN              :  1;
N  __IO uint32_t TIM3EN              :  1;
X  volatile uint32_t TIM3EN              :  1;
N  __IO uint32_t RES1                :  6;
X  volatile uint32_t RES1                :  6;
N  __IO uint32_t TIM14EN             :  1;
X  volatile uint32_t TIM14EN             :  1;
N  __IO uint32_t RES2                :  2;
X  volatile uint32_t RES2                :  2;
N  __IO uint32_t WWDGEN              :  1;
X  volatile uint32_t WWDGEN              :  1;
N  __IO uint32_t RES3                :  9;
X  volatile uint32_t RES3                :  9;
N  __IO uint32_t I2C1EN              :  1;
X  volatile uint32_t I2C1EN              :  1;
N  __IO uint32_t RES4                :  6;
X  volatile uint32_t RES4                :  6;
N  __IO uint32_t PWREN               :  1;
X  volatile uint32_t PWREN               :  1;
N  __IO uint32_t RES5                :  3;
X  volatile uint32_t RES5                :  3;
N} RCC_APB1ENR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t LSEON               :  1;
X  volatile uint32_t LSEON               :  1;
N  __IO uint32_t LSERDY              :  1;
X  volatile uint32_t LSERDY              :  1;
N  __IO uint32_t LSEBYP              :  1;
X  volatile uint32_t LSEBYP              :  1;
N  __IO uint32_t LSEDRV              :  2;
X  volatile uint32_t LSEDRV              :  2;
N  __IO uint32_t RES1                :  3;
X  volatile uint32_t RES1                :  3;
N  __IO uint32_t RTCSEL              :  2;
X  volatile uint32_t RTCSEL              :  2;
N  __IO uint32_t RES2                :  5;
X  volatile uint32_t RES2                :  5;
N  __IO uint32_t RTCEN               :  1;
X  volatile uint32_t RTCEN               :  1;
N  __IO uint32_t BDRST               :  1;
X  volatile uint32_t BDRST               :  1;
N  __IO uint32_t RES3                : 15;
X  volatile uint32_t RES3                : 15;
N} RCC_BDCR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t LSION               :  1;
X  volatile uint32_t LSION               :  1;
N  __IO uint32_t LSIRDY              :  1;
X  volatile uint32_t LSIRDY              :  1;
N  __IO uint32_t RES1                : 21;
X  volatile uint32_t RES1                : 21;
N  __IO uint32_t V15PWRRSTF          :  1;
X  volatile uint32_t V15PWRRSTF          :  1;
N  __IO uint32_t RMVF                :  1;
X  volatile uint32_t RMVF                :  1;
N  __IO uint32_t OBLRSTF             :  1;
X  volatile uint32_t OBLRSTF             :  1;
N  __IO uint32_t PINRSTF             :  1;
X  volatile uint32_t PINRSTF             :  1;
N  __IO uint32_t PORRSTF             :  1;
X  volatile uint32_t PORRSTF             :  1;
N  __IO uint32_t SFTRSTF             :  1;
X  volatile uint32_t SFTRSTF             :  1;
N  __IO uint32_t IWDGRSTF            :  1;
X  volatile uint32_t IWDGRSTF            :  1;
N  __IO uint32_t WWDGRSTF            :  1;
X  volatile uint32_t WWDGRSTF            :  1;
N  __IO uint32_t LPWRRSTF            :  1;
X  volatile uint32_t LPWRRSTF            :  1;
N} RCC_CSR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t RES1                : 17;
X  volatile uint32_t RES1                : 17;
N  __IO uint32_t IOPARST             :  1;
X  volatile uint32_t IOPARST             :  1;
N  __IO uint32_t IOPBRST             :  1;
X  volatile uint32_t IOPBRST             :  1;
N  __IO uint32_t IOPCRST             :  1;
X  volatile uint32_t IOPCRST             :  1;
N  __IO uint32_t RES2                :  2;
X  volatile uint32_t RES2                :  2;
N  __IO uint32_t IOPFRST             :  1;
X  volatile uint32_t IOPFRST             :  1;
N  __IO uint32_t RES3                :  9;
X  volatile uint32_t RES3                :  9;
N} RCC_AHBRSTR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t PREDIV              :  4;
X  volatile uint32_t PREDIV              :  4;
N  __IO uint32_t RES1                : 28;
X  volatile uint32_t RES1                : 28;
N} RCC_CFGR2_32BIT;
N
Ntypedef struct {
N  __IO uint32_t USART1SW            :  2;
X  volatile uint32_t USART1SW            :  2;
N  __IO uint32_t RES1                :  2;
X  volatile uint32_t RES1                :  2;
N  __IO uint32_t I2C1SW              :  1;
X  volatile uint32_t I2C1SW              :  1;
N  __IO uint32_t RES2                : 27;
X  volatile uint32_t RES2                : 27;
N} RCC_CFGR3_32BIT;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t CR;         /*!< RCC clock control register,                                  Address offset: 0x00 */
X    volatile uint32_t CR;          
N    RCC_CR_32BIT CR_BIT;
N  };
N  union {
N    __IO uint32_t CFGR;       /*!< RCC clock configuration register,                            Address offset: 0x04 */
X    volatile uint32_t CFGR;        
N    RCC_CFGR_32BIT CFGR_BIT;
N  };
N  union {
N    __IO uint32_t CIR;        /*!< RCC clock interrupt register,                                Address offset: 0x08 */
X    volatile uint32_t CIR;         
N    RCC_CIR_32BIT CIR_BIT;
N  };
N  union {
N    __IO uint32_t APB2RSTR;   /*!< RCC APB2 peripheral reset register,                          Address offset: 0x0C */
X    volatile uint32_t APB2RSTR;    
N    RCC_APB2RSTR_32BIT APB2RSTR_BIT;
N  };
N  union {
N    __IO uint32_t APB1RSTR;   /*!< RCC APB1 peripheral reset register,                          Address offset: 0x10 */
X    volatile uint32_t APB1RSTR;    
N    RCC_APB1RSTR_32BIT APB1RSTR_BIT;
N  };
N  union {
N    __IO uint32_t AHBENR;     /*!< RCC AHB peripheral clock register,                           Address offset: 0x14 */
X    volatile uint32_t AHBENR;      
N    RCC_AHBENR_32BIT AHBENR_BIT;
N  };
N  union {
N    __IO uint32_t APB2ENR;    /*!< RCC APB2 peripheral clock enable register,                   Address offset: 0x18 */
X    volatile uint32_t APB2ENR;     
N    RCC_APB2ENR_32BIT APB2ENR_BIT;
N  };
N  union {
N    __IO uint32_t APB1ENR;    /*!< RCC APB1 peripheral clock enable register,                   Address offset: 0x1C */
X    volatile uint32_t APB1ENR;     
N    RCC_APB1ENR_32BIT APB1ENR_BIT;
N  };
N  union {
N    __IO uint32_t BDCR;       /*!< RCC Backup domain control register,                          Address offset: 0x20 */
X    volatile uint32_t BDCR;        
N    RCC_BDCR_32BIT BDCR_BIT;
N  };
N  union {
N    __IO uint32_t CSR;        /*!< RCC clock control & status register,                         Address offset: 0x24 */
X    volatile uint32_t CSR;         
N    RCC_CSR_32BIT CSR_BIT;
N  };
N  union {
N    __IO uint32_t AHBRSTR;    /*!< RCC AHB peripheral reset register,                           Address offset: 0x28 */
X    volatile uint32_t AHBRSTR;     
N    RCC_AHBRSTR_32BIT AHBRSTR_BIT;
N  };
N  union {
N    __IO uint32_t CFGR2;      /*!< RCC clock configuration register 2,                          Address offset: 0x2C */
X    volatile uint32_t CFGR2;       
N    RCC_CFGR2_32BIT CFGR2_BIT;
N  };
N  union {
N    __IO uint32_t CFGR3;      /*!< RCC clock configuration register 3,                          Address offset: 0x30 */
X    volatile uint32_t CFGR3;       
N    RCC_CFGR3_32BIT CFGR3_BIT;
N  };
N} RCC_TypeDef;
N
N
N/**
N  * @brief FLASH Registers(include FLASH  0x4002 2000 - 0x4002 23FF)
N  */
Ntypedef struct {
N  __IO uint32_t LATENCY             :  3;
X  volatile uint32_t LATENCY             :  3;
N  __IO uint32_t RES1                :  1;
X  volatile uint32_t RES1                :  1;
N  __IO uint32_t PRFTBE              :  1;
X  volatile uint32_t PRFTBE              :  1;
N  __IO uint32_t PRFTBS              :  1;
X  volatile uint32_t PRFTBS              :  1;
N  __IO uint32_t RES2                : 26;
X  volatile uint32_t RES2                : 26;
N} FLASH_ACR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t BSY                 :  1;
X  volatile uint32_t BSY                 :  1;
N  __IO uint32_t RES1                :  1;
X  volatile uint32_t RES1                :  1;
N  __IO uint32_t PGERR               :  1;
X  volatile uint32_t PGERR               :  1;
N  __IO uint32_t RES2                :  1;
X  volatile uint32_t RES2                :  1;
N  __IO uint32_t WRPRTERR            :  1;
X  volatile uint32_t WRPRTERR            :  1;
N  __IO uint32_t EOP                 :  1;
X  volatile uint32_t EOP                 :  1;
N  __IO uint32_t RES3                : 26;
X  volatile uint32_t RES3                : 26;
N} FLASH_SR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t PG                  :  1;
X  volatile uint32_t PG                  :  1;
N  __IO uint32_t PER                 :  1;
X  volatile uint32_t PER                 :  1;
N  __IO uint32_t MER                 :  1;
X  volatile uint32_t MER                 :  1;
N  __IO uint32_t RES1                :  1;
X  volatile uint32_t RES1                :  1;
N  __IO uint32_t OPTPG               :  1;
X  volatile uint32_t OPTPG               :  1;
N  __IO uint32_t OPTER               :  1;
X  volatile uint32_t OPTER               :  1;
N  __IO uint32_t STRT                :  1;
X  volatile uint32_t STRT                :  1;
N  __IO uint32_t LOCK                :  1;
X  volatile uint32_t LOCK                :  1;
N  __IO uint32_t RES2                :  1;
X  volatile uint32_t RES2                :  1;
N  __IO uint32_t OPTWRE              :  1;
X  volatile uint32_t OPTWRE              :  1;
N  __IO uint32_t ERRIE               :  1;
X  volatile uint32_t ERRIE               :  1;
N  __IO uint32_t RES3                :  1;
X  volatile uint32_t RES3                :  1;
N  __IO uint32_t EOPIE               :  1;
X  volatile uint32_t EOPIE               :  1;
N  __IO uint32_t OBL_LAUNCH          :  1;
X  volatile uint32_t OBL_LAUNCH          :  1;
N  __IO uint32_t RES4                : 18;
X  volatile uint32_t RES4                : 18;
N} FLASH_CR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t OPTERR              :  1;
X  volatile uint32_t OPTERR              :  1;
N  __IO uint32_t RDPRT               :  2;
X  volatile uint32_t RDPRT               :  2;
N  __IO uint32_t RES1                :  5;
X  volatile uint32_t RES1                :  5;
N  __IO uint32_t WDG_SW              :  1;
X  volatile uint32_t WDG_SW              :  1;
N  __IO uint32_t nRST_STOP           :  1;
X  volatile uint32_t nRST_STOP           :  1;
N  __IO uint32_t nRST_STDBY          :  1;
X  volatile uint32_t nRST_STDBY          :  1;
N  __IO uint32_t RES2                :  1;
X  volatile uint32_t RES2                :  1;
N  __IO uint32_t nBOOT1              :  1;
X  volatile uint32_t nBOOT1              :  1;
N  __IO uint32_t VDDA_MONITOR        :  1;
X  volatile uint32_t VDDA_MONITOR        :  1;
N  __IO uint32_t RAM_PARITY_CHECK    :  1;
X  volatile uint32_t RAM_PARITY_CHECK    :  1;
N  __IO uint32_t RES3                :  1;
X  volatile uint32_t RES3                :  1;
N  __IO uint32_t DATA0               :  8;
X  volatile uint32_t DATA0               :  8;
N  __IO uint32_t DATA1               :  8;
X  volatile uint32_t DATA1               :  8;
N} FLASH_OBR_32BIT;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t ACR;          /*!<FLASH access control register,                 Address offset: 0x00 */
X    volatile uint32_t ACR;           
N    FLASH_ACR_32BIT ACR_BIT;
N  };
N    __IO uint32_t KEYR;         /*!<FLASH key register,                            Address offset: 0x04 */
X    volatile uint32_t KEYR;          
N    __IO uint32_t OPTKEYR;      /*!<FLASH OPT key register,                        Address offset: 0x08 */
X    volatile uint32_t OPTKEYR;       
N  union {
N    __IO uint32_t SR;           /*!<FLASH status register,                         Address offset: 0x0C */
X    volatile uint32_t SR;            
N    FLASH_SR_32BIT SR_BIT;
N  };
N  union {
N    __IO uint32_t CR;           /*!<FLASH control register,                        Address offset: 0x10 */
X    volatile uint32_t CR;            
N    FLASH_CR_32BIT CR_BIT;
N  };
N    __IO uint32_t AR;           /*!<FLASH address register,                        Address offset: 0x14 */
X    volatile uint32_t AR;            
N    __IO uint32_t RESERVED;     /*!< Reserved,                                                     0x18 */
X    volatile uint32_t RESERVED;      
N  union {
N    __IO uint32_t OBR;          /*!<FLASH option bytes register,                   Address offset: 0x1C */
X    volatile uint32_t OBR;           
N    FLASH_OBR_32BIT OBR_BIT;
N  };
N    __IO uint32_t WRPR;         /*!<FLASH option bytes register,                   Address offset: 0x20 */
X    volatile uint32_t WRPR;          
N} FLASH_TypeDef;
N
N
N/**
N  * @brief CRC calculation unit(include CRC  0x4002 3000 - 0x4002 33FF)
N  */
Ntypedef struct {
N  __IO uint32_t IDR                 :  8;
X  volatile uint32_t IDR                 :  8;
N  __IO uint32_t RES1                : 24;
X  volatile uint32_t RES1                : 24;
N} CRC_IDR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t RESET               :  1;
X  volatile uint32_t RESET               :  1;
N  __IO uint32_t RES1                :  4;
X  volatile uint32_t RES1                :  4;
N  __IO uint32_t REV_IN              :  2;
X  volatile uint32_t REV_IN              :  2;
N  __IO uint32_t REV_OUT             :  1;
X  volatile uint32_t REV_OUT             :  1;
N  __IO uint32_t RES2                : 24;
X  volatile uint32_t RES2                : 24;
N} CRC_CR_32BIT;
N
N
Ntypedef struct {
N    __IO uint32_t DR;          /*!< CRC Data register,                           Address offset: 0x00 */
X    volatile uint32_t DR;           
N  union {
N    __IO uint32_t IDR;         /*!< CRC Independent data register,               Address offset: 0x04 */
X    volatile uint32_t IDR;          
N    CRC_IDR_32BIT IDR_BIT;
N  };
N  union {
N    __IO uint32_t CR;          /*!< CRC Control register,                        Address offset: 0x08 */
X    volatile uint32_t CR;           
N    CRC_CR_32BIT CR_BIT;
N  };
N
N         uint32_t RESERVED1;   /*!< Reserved,                                    Address offset: 0x0C */
N    __IO uint32_t INIT;        /*!< Initial CRC value register,                  Address offset: 0x10 */
X    volatile uint32_t INIT;         
N    __IO uint32_t POL;         /*!< CRC Polynomial register,                     Address offset: 0x14 */
X    volatile uint32_t POL;          
N} CRC_TypeDef;
N
N
N/**
N  * @brief General Purpose I/O(include GPIOA  0x4800 0000 - 0x4800 03FF
N  *                                    GPIOB  0x4800 0400 - 0x4800 07FF
N  *                                    GPIOC  0x4800 0800 - 0x4800 0BFF
N  *                                    GPIOF  0x4800 1400 - 0x4800 17FF)
N  */
Ntypedef struct {
N  __IO uint32_t PIN0                :  2;
X  volatile uint32_t PIN0                :  2;
N  __IO uint32_t PIN1                :  2;
X  volatile uint32_t PIN1                :  2;
N  __IO uint32_t PIN2                :  2;
X  volatile uint32_t PIN2                :  2;
N  __IO uint32_t PIN3                :  2;
X  volatile uint32_t PIN3                :  2;
N  __IO uint32_t PIN4                :  2;
X  volatile uint32_t PIN4                :  2;
N  __IO uint32_t PIN5                :  2;
X  volatile uint32_t PIN5                :  2;
N  __IO uint32_t PIN6                :  2;
X  volatile uint32_t PIN6                :  2;
N  __IO uint32_t PIN7                :  2;
X  volatile uint32_t PIN7                :  2;
N  __IO uint32_t PIN8                :  2;
X  volatile uint32_t PIN8                :  2;
N  __IO uint32_t PIN9                :  2;
X  volatile uint32_t PIN9                :  2;
N  __IO uint32_t PIN10               :  2;
X  volatile uint32_t PIN10               :  2;
N  __IO uint32_t PIN11               :  2;
X  volatile uint32_t PIN11               :  2;
N  __IO uint32_t PIN12               :  2;
X  volatile uint32_t PIN12               :  2;
N  __IO uint32_t PIN13               :  2;
X  volatile uint32_t PIN13               :  2;
N  __IO uint32_t PIN14               :  2;
X  volatile uint32_t PIN14               :  2;
N  __IO uint32_t PIN15               :  2;
X  volatile uint32_t PIN15               :  2;
N} GPIO_NBIT_32BIT;
N
Ntypedef struct {
N  __IO uint32_t PIN0                :  1;
X  volatile uint32_t PIN0                :  1;
N  __IO uint32_t PIN1                :  1;
X  volatile uint32_t PIN1                :  1;
N  __IO uint32_t PIN2                :  1;
X  volatile uint32_t PIN2                :  1;
N  __IO uint32_t PIN3                :  1;
X  volatile uint32_t PIN3                :  1;
N  __IO uint32_t PIN4                :  1;
X  volatile uint32_t PIN4                :  1;
N  __IO uint32_t PIN5                :  1;
X  volatile uint32_t PIN5                :  1;
N  __IO uint32_t PIN6                :  1;
X  volatile uint32_t PIN6                :  1;
N  __IO uint32_t PIN7                :  1;
X  volatile uint32_t PIN7                :  1;
N  __IO uint32_t PIN8                :  1;
X  volatile uint32_t PIN8                :  1;
N  __IO uint32_t PIN9                :  1;
X  volatile uint32_t PIN9                :  1;
N  __IO uint32_t PIN10               :  1;
X  volatile uint32_t PIN10               :  1;
N  __IO uint32_t PIN11               :  1;
X  volatile uint32_t PIN11               :  1;
N  __IO uint32_t PIN12               :  1;
X  volatile uint32_t PIN12               :  1;
N  __IO uint32_t PIN13               :  1;
X  volatile uint32_t PIN13               :  1;
N  __IO uint32_t PIN14               :  1;
X  volatile uint32_t PIN14               :  1;
N  __IO uint32_t PIN15               :  1;
X  volatile uint32_t PIN15               :  1;
N  __IO uint32_t RES1                : 16;
X  volatile uint32_t RES1                : 16;
N} GPIO_BIT_32BIT;
N
Ntypedef struct {
N  __IO uint32_t PIN0_SET           :  1;
X  volatile uint32_t PIN0_SET           :  1;
N  __IO uint32_t PIN1_SET           :  1;
X  volatile uint32_t PIN1_SET           :  1;
N  __IO uint32_t PIN2_SET           :  1;
X  volatile uint32_t PIN2_SET           :  1;
N  __IO uint32_t PIN3_SET           :  1;
X  volatile uint32_t PIN3_SET           :  1;
N  __IO uint32_t PIN4_SET           :  1;
X  volatile uint32_t PIN4_SET           :  1;
N  __IO uint32_t PIN5_SET           :  1;
X  volatile uint32_t PIN5_SET           :  1;
N  __IO uint32_t PIN6_SET           :  1;
X  volatile uint32_t PIN6_SET           :  1;
N  __IO uint32_t PIN7_SET           :  1;
X  volatile uint32_t PIN7_SET           :  1;
N  __IO uint32_t PIN8_SET           :  1;
X  volatile uint32_t PIN8_SET           :  1;
N  __IO uint32_t PIN9_SET           :  1;
X  volatile uint32_t PIN9_SET           :  1;
N  __IO uint32_t PIN10_SET          :  1;
X  volatile uint32_t PIN10_SET          :  1;
N  __IO uint32_t PIN11_SET          :  1;
X  volatile uint32_t PIN11_SET          :  1;
N  __IO uint32_t PIN12_SET          :  1;
X  volatile uint32_t PIN12_SET          :  1;
N  __IO uint32_t PIN13_SET          :  1;
X  volatile uint32_t PIN13_SET          :  1;
N  __IO uint32_t PIN14_SET          :  1;
X  volatile uint32_t PIN14_SET          :  1;
N  __IO uint32_t PIN15_SET          :  1;
X  volatile uint32_t PIN15_SET          :  1;
N  __IO uint32_t PIN0_RESET         :  1;
X  volatile uint32_t PIN0_RESET         :  1;
N  __IO uint32_t PIN1_RESET         :  1;
X  volatile uint32_t PIN1_RESET         :  1;
N  __IO uint32_t PIN2_RESET         :  1;
X  volatile uint32_t PIN2_RESET         :  1;
N  __IO uint32_t PIN3_RESET         :  1;
X  volatile uint32_t PIN3_RESET         :  1;
N  __IO uint32_t PIN4_RESET         :  1;
X  volatile uint32_t PIN4_RESET         :  1;
N  __IO uint32_t PIN5_RESET         :  1;
X  volatile uint32_t PIN5_RESET         :  1;
N  __IO uint32_t PIN6_RESET         :  1;
X  volatile uint32_t PIN6_RESET         :  1;
N  __IO uint32_t PIN7_RESET         :  1;
X  volatile uint32_t PIN7_RESET         :  1;
N  __IO uint32_t PIN8_RESET         :  1;
X  volatile uint32_t PIN8_RESET         :  1;
N  __IO uint32_t PIN9_RESET         :  1;
X  volatile uint32_t PIN9_RESET         :  1;
N  __IO uint32_t PIN10_RESET        :  1;
X  volatile uint32_t PIN10_RESET        :  1;
N  __IO uint32_t PIN11_RESET        :  1;
X  volatile uint32_t PIN11_RESET        :  1;
N  __IO uint32_t PIN12_RESET        :  1;
X  volatile uint32_t PIN12_RESET        :  1;
N  __IO uint32_t PIN13_RESET        :  1;
X  volatile uint32_t PIN13_RESET        :  1;
N  __IO uint32_t PIN14_RESET        :  1;
X  volatile uint32_t PIN14_RESET        :  1;
N  __IO uint32_t PIN15_RESET        :  1;
X  volatile uint32_t PIN15_RESET        :  1;
N} GPIO_SR_32BIT;
N
Ntypedef struct {
N  __IO uint32_t PIN0                :  1;
X  volatile uint32_t PIN0                :  1;
N  __IO uint32_t PIN1                :  1;
X  volatile uint32_t PIN1                :  1;
N  __IO uint32_t PIN2                :  1;
X  volatile uint32_t PIN2                :  1;
N  __IO uint32_t PIN3                :  1;
X  volatile uint32_t PIN3                :  1;
N  __IO uint32_t PIN4                :  1;
X  volatile uint32_t PIN4                :  1;
N  __IO uint32_t PIN5                :  1;
X  volatile uint32_t PIN5                :  1;
N  __IO uint32_t PIN6                :  1;
X  volatile uint32_t PIN6                :  1;
N  __IO uint32_t PIN7                :  1;
X  volatile uint32_t PIN7                :  1;
N  __IO uint32_t PIN8                :  1;
X  volatile uint32_t PIN8                :  1;
N  __IO uint32_t PIN9                :  1;
X  volatile uint32_t PIN9                :  1;
N  __IO uint32_t PIN10               :  1;
X  volatile uint32_t PIN10               :  1;
N  __IO uint32_t PIN11               :  1;
X  volatile uint32_t PIN11               :  1;
N  __IO uint32_t PIN12               :  1;
X  volatile uint32_t PIN12               :  1;
N  __IO uint32_t PIN13               :  1;
X  volatile uint32_t PIN13               :  1;
N  __IO uint32_t PIN14               :  1;
X  volatile uint32_t PIN14               :  1;
N  __IO uint32_t PIN15               :  1;
X  volatile uint32_t PIN15               :  1;
N  __IO uint32_t LCKK                :  1;
X  volatile uint32_t LCKK                :  1;
N  __IO uint32_t RES1                : 15;
X  volatile uint32_t RES1                : 15;
N} GPIO_LCK_32BIT;
N
Ntypedef struct {
N  __IO uint32_t PIN0                :  4;
X  volatile uint32_t PIN0                :  4;
N  __IO uint32_t PIN1                :  4;
X  volatile uint32_t PIN1                :  4;
N  __IO uint32_t PIN2                :  4;
X  volatile uint32_t PIN2                :  4;
N  __IO uint32_t PIN3                :  4;
X  volatile uint32_t PIN3                :  4;
N  __IO uint32_t PIN4                :  4;
X  volatile uint32_t PIN4                :  4;
N  __IO uint32_t PIN5                :  4;
X  volatile uint32_t PIN5                :  4;
N  __IO uint32_t PIN6                :  4;
X  volatile uint32_t PIN6                :  4;
N  __IO uint32_t PIN7                :  4;
X  volatile uint32_t PIN7                :  4;
N} GPIO_AFRL_32BIT;
N
Ntypedef struct {
N  __IO uint32_t PIN8                :  4;
X  volatile uint32_t PIN8                :  4;
N  __IO uint32_t PIN9                :  4;
X  volatile uint32_t PIN9                :  4;
N  __IO uint32_t PIN10               :  4;
X  volatile uint32_t PIN10               :  4;
N  __IO uint32_t PIN11               :  4;
X  volatile uint32_t PIN11               :  4;
N  __IO uint32_t PIN12               :  4;
X  volatile uint32_t PIN12               :  4;
N  __IO uint32_t PIN13               :  4;
X  volatile uint32_t PIN13               :  4;
N  __IO uint32_t PIN14               :  4;
X  volatile uint32_t PIN14               :  4;
N  __IO uint32_t PIN15               :  4;
X  volatile uint32_t PIN15               :  4;
N} GPIO_AFRH_32BIT;
N
N
Ntypedef struct {
N  union {
N    __IO uint32_t MODER;        /*!< GPIO port mode register,                     Address offset: 0x00 */
X    volatile uint32_t MODER;         
N    GPIO_NBIT_32BIT MODER_BIT;
N  };
N  union {
N    __IO uint32_t OTYPER;       /*!< GPIO port output type register,              Address offset: 0x04 */
X    volatile uint32_t OTYPER;        
N    GPIO_BIT_32BIT OTYPER_BIT;
N  };
N  union {
N    __IO uint32_t OSPEEDR;      /*!< GPIO port output speed register,             Address offset: 0x08 */
X    volatile uint32_t OSPEEDR;       
N    GPIO_NBIT_32BIT OSPEEDR_BIT;
N  };
N  union {
N    __IO uint32_t PUPDR;        /*!< GPIO port pull-up/pull-down register,        Address offset: 0x0C */
X    volatile uint32_t PUPDR;         
N    GPIO_NBIT_32BIT PUPDR_BIT;
N  };
N  union {
N    __IO uint32_t IDR;          /*!< GPIO port input data register,               Address offset: 0x10 */
X    volatile uint32_t IDR;           
N    GPIO_BIT_32BIT IDR_BIT;
N  };
N  union {
N    __IO uint32_t ODR;          /*!< GPIO port output data register,              Address offset: 0x14 */
X    volatile uint32_t ODR;           
N    GPIO_BIT_32BIT ODR_BIT;
N  };
N  union {
N    __IO uint32_t BSRR;         /*!< GPIO port bit set/reset register,            Address offset: 0x1A */
X    volatile uint32_t BSRR;          
N    GPIO_SR_32BIT BSRR_BIT;
N  };
N  union {
N    __IO uint32_t LCKR;         /*!< GPIO port configuration lock register,       Address offset: 0x1C */
X    volatile uint32_t LCKR;          
N    GPIO_LCK_32BIT LCKR_BIT;
N  };
N  union {
N    __IO uint32_t AFRL;         /*!< GPIO alternate function low register,        Address offset: 0x20 */
X    volatile uint32_t AFRL;          
N    GPIO_AFRL_32BIT AFRL_BIT;
N  };
N  union {
N    __IO uint32_t AFRH;         /*!< GPIO alternate function high register,       Address offset: 0x24 */
X    volatile uint32_t AFRH;          
N    GPIO_AFRH_32BIT AFRH_BIT;
N  };
N  union {
N    __IO uint32_t BRR;          /*!< GPIO bit reset register,                     Address offset: 0x28 */
X    volatile uint32_t BRR;           
N    GPIO_BIT_32BIT BRR_BIT;
N  };
N} GPIO_TypeDef;
N
N
N/**
N  * @brief Option Bytes Registers(include OPTION  0x1FFF F800 - 0x1FFF FBFF)
N  */
Ntypedef struct {
N  __IO uint16_t RDP;          /*!< FLASH option byte Read protection,             Address offset: 0x00 */
X  volatile uint16_t RDP;           
N  __IO uint16_t USER;         /*!< FLASH option byte user options,                Address offset: 0x02 */
X  volatile uint16_t USER;          
N  __IO uint16_t DATA0;        /*!< User data byte 0 (stored in FLASH_OBR[23:16]), Address offset: 0x04 */
X  volatile uint16_t DATA0;         
N  __IO uint16_t DATA1;        /*!< User data byte 1 (stored in FLASH_OBR[31:24]), Address offset: 0x06 */
X  volatile uint16_t DATA1;         
N  __IO uint16_t WRP0;         /*!< FLASH option byte write protection 0,          Address offset: 0x08 */
X  volatile uint16_t WRP0;          
N} OB_TypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @addtogroup Peripheral_memory_map
N  * @{
N  */
N
N#define FLASH_BASE            0x08000000UL              /*!< FLASH base address in the alias region */
N#define FLASH_BANK1_END       0x08007FFFUL /*!< FLASH END address of bank1 */
N#define SRAM_BASE             0x20000000UL              /*!< SRAM base address in the alias region */
N#define PERIPH_BASE           0x40000000UL              /*!< Peripheral base address in the alias region */
N
N/*!< Peripheral memory map */
N#define APBPERIPH_BASE        PERIPH_BASE
N#define AHBPERIPH_BASE        (PERIPH_BASE + 0x00020000UL)
N#define AHB2PERIPH_BASE       (PERIPH_BASE + 0x08000000UL)
N
N/*!< APB peripherals */
N#define TIM2_BASE             (APBPERIPH_BASE + 0x00000000UL)
N#define TIM3_BASE             (APBPERIPH_BASE + 0x00000400UL)
N#define TIM14_BASE            (APBPERIPH_BASE + 0x00002000UL)
N#define RTC_BASE              (APBPERIPH_BASE + 0x00002800UL)
N#define WWDG_BASE             (APBPERIPH_BASE + 0x00002C00UL)
N#define IWDG_BASE             (APBPERIPH_BASE + 0x00003000UL)
N#define I2C1_BASE             (APBPERIPH_BASE + 0x00005400UL)
N#define PWR_BASE              (APBPERIPH_BASE + 0x00007000UL)
N#define SYSCFG_BASE           (APBPERIPH_BASE + 0x00010000UL)
N#define EXTI_BASE             (APBPERIPH_BASE + 0x00010400UL)
N#define ADC1_BASE             (APBPERIPH_BASE + 0x00012400UL)
N#define ADC_BASE              (APBPERIPH_BASE + 0x00012400UL + 0x308UL)
N#define TIM1_BASE             (APBPERIPH_BASE + 0x00012C00UL)
N#define SPI1_BASE             (APBPERIPH_BASE + 0x00013000UL)
N#define USART1_BASE           (APBPERIPH_BASE + 0x00013800UL)
N#define CMP_OP_BASE           (APBPERIPH_BASE + 0x00013C00UL)
N#define TIM16_BASE            (APBPERIPH_BASE + 0x00014400UL)
N#define TIM17_BASE            (APBPERIPH_BASE + 0x00014800UL)
N#define DBGMCU_BASE           (APBPERIPH_BASE + 0x00015800UL)
N
N/*!< AHB peripherals */
N#define DMA1_BASE             (AHBPERIPH_BASE + 0x00000000UL)
N#define DMA1_Channel1_BASE    (DMA1_BASE + 0x00000008UL)
N#define DMA1_Channel2_BASE    (DMA1_BASE + 0x0000001CUL)
N#define DMA1_Channel3_BASE    (DMA1_BASE + 0x00000030UL)
N#define DMA1_Channel4_BASE    (DMA1_BASE + 0x00000044UL)
N#define DMA1_Channel5_BASE    (DMA1_BASE + 0x00000058UL)
N
N#define RCC_BASE              (AHBPERIPH_BASE + 0x00001000UL)
N#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x00002000UL) /*!< FLASH registers base address */
N#define OB_BASE               0x1FFFF800UL       /*!< FLASH Option Bytes base address */
N#define FLASHSIZE_BASE        0x1FFFF7CCUL       /*!< FLASH Size register base address */
N#define UID_BASE              0x1FFFF7ACUL       /*!< Unique device ID register base address */
N#define CRC_BASE              (AHBPERIPH_BASE + 0x00003000UL)
N
N/*!< AHB2 peripherals */
N#define GPIOA_BASE            (AHB2PERIPH_BASE + 0x00000000UL)
N#define GPIOB_BASE            (AHB2PERIPH_BASE + 0x00000400UL)
N#define GPIOC_BASE            (AHB2PERIPH_BASE + 0x00000800UL)
N#define GPIOF_BASE            (AHB2PERIPH_BASE + 0x00001400UL)
N
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_declaration
N  * @{
N  */
N
N#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#define TIM14               ((TIM_TypeDef *) TIM14_BASE)
N#define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#define SYSCFG              ((SYSCFG_TypeDef *) SYSCFG_BASE)
N#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#define ADC                 ((ADC_Common_TypeDef *) ADC_BASE)
N#define TIM1                ((TIM_TypeDef *) TIM1_BASE)
N#define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#define USART1              ((USART_TypeDef *) USART1_BASE)
N#define CMP_OP              ((CMP_OP_TypeDef *) CMP_OP_BASE)
N#define TIM16               ((TIM_TypeDef *) TIM16_BASE)
N#define TIM17               ((TIM_TypeDef *) TIM17_BASE)
N#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N#define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
N#define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
N#define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
N#define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
N#define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
N#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N#define OB                  ((OB_TypeDef *) OB_BASE)
N#define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N
N
N/******************************************************************************/
N/*                         Peripheral Registers Bits Definition               */
N/******************************************************************************/
N/******************************************************************************/
N/*                                                                            */
N/*                      Analog to Digital Converter (ADC)                     */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for ADC_ISR register  ******************/
N#define ADC_ISR_ADRDY_Pos         (0U)
N#define ADC_ISR_ADRDY_Msk         (0x1UL << ADC_ISR_ADRDY_Pos)                  /*!< 0x00000001 */
N#define ADC_ISR_ADRDY             ADC_ISR_ADRDY_Msk                             /*!< ADC ready flag */
N#define ADC_ISR_EOSMP_Pos         (1U)
N#define ADC_ISR_EOSMP_Msk         (0x1UL << ADC_ISR_EOSMP_Pos)                  /*!< 0x00000002 */
N#define ADC_ISR_EOSMP             ADC_ISR_EOSMP_Msk                             /*!< ADC group regular end of sampling flag */
N#define ADC_ISR_EOC_Pos           (2U)
N#define ADC_ISR_EOC_Msk           (0x1UL << ADC_ISR_EOC_Pos)                    /*!< 0x00000004 */
N#define ADC_ISR_EOC               ADC_ISR_EOC_Msk                               /*!< ADC group regular end of unitary conversion flag */
N#define ADC_ISR_EOS_Pos           (3U)
N#define ADC_ISR_EOS_Msk           (0x1UL << ADC_ISR_EOS_Pos)                    /*!< 0x00000008 */
N#define ADC_ISR_EOS               ADC_ISR_EOS_Msk                               /*!< ADC group regular end of sequence conversions flag */
N#define ADC_ISR_OVR_Pos           (4U)
N#define ADC_ISR_OVR_Msk           (0x1UL << ADC_ISR_OVR_Pos)                    /*!< 0x00000010 */
N#define ADC_ISR_OVR               ADC_ISR_OVR_Msk                               /*!< ADC group regular overrun flag */
N#define ADC_ISR_AWD_Pos           (7U)
N#define ADC_ISR_AWD_Msk           (0x1UL << ADC_ISR_AWD_Pos)                    /*!< 0x00000080 */
N#define ADC_ISR_AWD               ADC_ISR_AWD_Msk                               /*!< ADC analog watchdog flag */
N
N/********************  Bits definition for ADC_IER register  ******************/
N#define ADC_IER_ADRDYIE_Pos       (0U)
N#define ADC_IER_ADRDYIE_Msk       (0x1UL << ADC_IER_ADRDYIE_Pos)                /*!< 0x00000001 */
N#define ADC_IER_ADRDYIE           ADC_IER_ADRDYIE_Msk                           /*!< ADC ready interrupt */
N#define ADC_IER_EOSMPIE_Pos       (1U)
N#define ADC_IER_EOSMPIE_Msk       (0x1UL << ADC_IER_EOSMPIE_Pos)                /*!< 0x00000002 */
N#define ADC_IER_EOSMPIE           ADC_IER_EOSMPIE_Msk                           /*!< ADC group regular end of sampling interrupt */
N#define ADC_IER_EOCIE_Pos         (2U)
N#define ADC_IER_EOCIE_Msk         (0x1UL << ADC_IER_EOCIE_Pos)                  /*!< 0x00000004 */
N#define ADC_IER_EOCIE             ADC_IER_EOCIE_Msk                             /*!< ADC group regular end of unitary conversion interrupt */
N#define ADC_IER_EOSEQIE_Pos       (3U)
N#define ADC_IER_EOSEQIE_Msk       (0x1UL << ADC_IER_EOSEQIE_Pos)                /*!< 0x00000008 */
N#define ADC_IER_EOSEQIE           ADC_IER_EOSEQIE_Msk                           /*!< ADC group regular end of sequence conversions interrupt */
N#define ADC_IER_OVRIE_Pos         (4U)
N#define ADC_IER_OVRIE_Msk         (0x1UL << ADC_IER_OVRIE_Pos)                  /*!< 0x00000010 */
N#define ADC_IER_OVRIE             ADC_IER_OVRIE_Msk                             /*!< ADC group regular overrun interrupt */
N#define ADC_IER_AWDIE_Pos         (7U)
N#define ADC_IER_AWDIE_Msk         (0x1UL << ADC_IER_AWDIE_Pos)                  /*!< 0x00000080 */
N#define ADC_IER_AWDIE             ADC_IER_AWDIE_Msk                             /*!< ADC analog watchdog interrupt */
N
N/********************  Bits definition for ADC_CR register  *******************/
N#define ADC_CR_ADEN_Pos           (0U)
N#define ADC_CR_ADEN_Msk           (0x1UL << ADC_CR_ADEN_Pos)                    /*!< 0x00000001 */
N#define ADC_CR_ADEN               ADC_CR_ADEN_Msk                               /*!< ADC enable */
N#define ADC_CR_ADDIS_Pos          (1U)
N#define ADC_CR_ADDIS_Msk          (0x1UL << ADC_CR_ADDIS_Pos)                   /*!< 0x00000002 */
N#define ADC_CR_ADDIS              ADC_CR_ADDIS_Msk                              /*!< ADC disable */
N#define ADC_CR_ADSTART_Pos        (2U)
N#define ADC_CR_ADSTART_Msk        (0x1UL << ADC_CR_ADSTART_Pos)                 /*!< 0x00000004 */
N#define ADC_CR_ADSTART            ADC_CR_ADSTART_Msk                            /*!< ADC group regular conversion start */
N#define ADC_CR_ADSTP_Pos          (4U)
N#define ADC_CR_ADSTP_Msk          (0x1UL << ADC_CR_ADSTP_Pos)                   /*!< 0x00000010 */
N#define ADC_CR_ADSTP              ADC_CR_ADSTP_Msk                              /*!< ADC group regular conversion stop */
N#define ADC_CR_ADCAL_Pos          (31U)
N#define ADC_CR_ADCAL_Msk          (0x1UL << ADC_CR_ADCAL_Pos)                   /*!< 0x80000000 */
N#define ADC_CR_ADCAL              ADC_CR_ADCAL_Msk                              /*!< ADC calibration */
N
N/*******************  Bits definition for ADC_CFGR1 register  *****************/
N#define ADC_CFGR1_DMAEN_Pos       (0U)
N#define ADC_CFGR1_DMAEN_Msk       (0x1UL << ADC_CFGR1_DMAEN_Pos)                /*!< 0x00000001 */
N#define ADC_CFGR1_DMAEN           ADC_CFGR1_DMAEN_Msk                           /*!< ADC DMA transfer enable */
N
N#define ADC_CFGR1_DMACFG_Pos      (1U)
N#define ADC_CFGR1_DMACFG_Msk      (0x1UL << ADC_CFGR1_DMACFG_Pos)               /*!< 0x00000002 */
N#define ADC_CFGR1_DMACFG          ADC_CFGR1_DMACFG_Msk                          /*!< ADC DMA transfer configuration */
N
N#define ADC_CFGR1_SCANDIR_Pos     (2U)
N#define ADC_CFGR1_SCANDIR_Msk     (0x1UL << ADC_CFGR1_SCANDIR_Pos)              /*!< 0x00000004 */
N#define ADC_CFGR1_SCANDIR         ADC_CFGR1_SCANDIR_Msk                         /*!< ADC group regular sequencer scan direction */
N
N#define ADC_CFGR1_RES_Pos         (3U)
N#define ADC_CFGR1_RES_Msk         (0x3UL << ADC_CFGR1_RES_Pos)                  /*!< 0x00000018 */
N#define ADC_CFGR1_RES             ADC_CFGR1_RES_Msk                             /*!< ADC data resolution */
N#define ADC_CFGR1_RES_0           (0x1UL << ADC_CFGR1_RES_Pos)                  /*!< 0x00000008 */
N#define ADC_CFGR1_RES_1           (0x2UL << ADC_CFGR1_RES_Pos)                  /*!< 0x00000010 */
N
N#define ADC_CFGR1_ALIGN_Pos       (5U)
N#define ADC_CFGR1_ALIGN_Msk       (0x1UL << ADC_CFGR1_ALIGN_Pos)                /*!< 0x00000020 */
N#define ADC_CFGR1_ALIGN           ADC_CFGR1_ALIGN_Msk                           /*!< ADC data alignement */
N
N#define ADC_CFGR1_EXTSEL_Pos      (6U)
N#define ADC_CFGR1_EXTSEL_Msk      (0x7UL << ADC_CFGR1_EXTSEL_Pos)               /*!< 0x000001C0 */
N#define ADC_CFGR1_EXTSEL          ADC_CFGR1_EXTSEL_Msk                          /*!< ADC group regular external trigger source */
N#define ADC_CFGR1_EXTSEL_0        (0x1UL << ADC_CFGR1_EXTSEL_Pos)               /*!< 0x00000040 */
N#define ADC_CFGR1_EXTSEL_1        (0x2UL << ADC_CFGR1_EXTSEL_Pos)               /*!< 0x00000080 */
N#define ADC_CFGR1_EXTSEL_2        (0x4UL << ADC_CFGR1_EXTSEL_Pos)               /*!< 0x00000100 */
N
N#define ADC_CFGR1_EXTEN_Pos       (10U)
N#define ADC_CFGR1_EXTEN_Msk       (0x3UL << ADC_CFGR1_EXTEN_Pos)                /*!< 0x00000C00 */
N#define ADC_CFGR1_EXTEN           ADC_CFGR1_EXTEN_Msk                           /*!< ADC group regular external trigger polarity */
N#define ADC_CFGR1_EXTEN_0         (0x1UL << ADC_CFGR1_EXTEN_Pos)                /*!< 0x00000400 */
N#define ADC_CFGR1_EXTEN_1         (0x2UL << ADC_CFGR1_EXTEN_Pos)                /*!< 0x00000800 */
N
N#define ADC_CFGR1_OVRMOD_Pos      (12U)
N#define ADC_CFGR1_OVRMOD_Msk      (0x1UL << ADC_CFGR1_OVRMOD_Pos)               /*!< 0x00001000 */
N#define ADC_CFGR1_OVRMOD          ADC_CFGR1_OVRMOD_Msk                          /*!< ADC group regular overrun configuration */
N
N#define ADC_CFGR1_CONT_Pos        (13U)
N#define ADC_CFGR1_CONT_Msk        (0x1UL << ADC_CFGR1_CONT_Pos)                 /*!< 0x00002000 */
N#define ADC_CFGR1_CONT            ADC_CFGR1_CONT_Msk                            /*!< ADC group regular continuous conversion mode */
N
N#define ADC_CFGR1_WAIT_Pos        (14U)
N#define ADC_CFGR1_WAIT_Msk        (0x1UL << ADC_CFGR1_WAIT_Pos)                 /*!< 0x00004000 */
N#define ADC_CFGR1_WAIT            ADC_CFGR1_WAIT_Msk                            /*!< ADC low power auto wait */
N
N#define ADC_CFGR1_AUTOFF_Pos      (15U)
N#define ADC_CFGR1_AUTOFF_Msk      (0x1UL << ADC_CFGR1_AUTOFF_Pos)               /*!< 0x00008000 */
N#define ADC_CFGR1_AUTOFF          ADC_CFGR1_AUTOFF_Msk                          /*!< ADC low power auto power off */
N
N#define ADC_CFGR1_DISCEN_Pos      (16U)
N#define ADC_CFGR1_DISCEN_Msk      (0x1UL << ADC_CFGR1_DISCEN_Pos)               /*!< 0x00010000 */
N#define ADC_CFGR1_DISCEN          ADC_CFGR1_DISCEN_Msk                          /*!< ADC group regular sequencer discontinuous mode */
N
N#define ADC_CFGR1_AWDSGL_Pos      (22U)
N#define ADC_CFGR1_AWDSGL_Msk      (0x1UL << ADC_CFGR1_AWDSGL_Pos)               /*!< 0x00400000 */
N#define ADC_CFGR1_AWDSGL          ADC_CFGR1_AWDSGL_Msk                          /*!< ADC analog watchdog monitoring a single channel or all channels */
N
N#define ADC_CFGR1_AWDEN_Pos       (23U)
N#define ADC_CFGR1_AWDEN_Msk       (0x1UL << ADC_CFGR1_AWDEN_Pos)                /*!< 0x00800000 */
N#define ADC_CFGR1_AWDEN           ADC_CFGR1_AWDEN_Msk                           /*!< ADC analog watchdog enable on scope ADC group regular */
N
N#define ADC_CFGR1_AWDCH_Pos       (26U)
N#define ADC_CFGR1_AWDCH_Msk       (0x1FUL << ADC_CFGR1_AWDCH_Pos)               /*!< 0x7C000000 */
N#define ADC_CFGR1_AWDCH           ADC_CFGR1_AWDCH_Msk                           /*!< ADC analog watchdog monitored channel selection */
N#define ADC_CFGR1_AWDCH_0         (0x01UL << ADC_CFGR1_AWDCH_Pos)               /*!< 0x04000000 */
N#define ADC_CFGR1_AWDCH_1         (0x02UL << ADC_CFGR1_AWDCH_Pos)               /*!< 0x08000000 */
N#define ADC_CFGR1_AWDCH_2         (0x04UL << ADC_CFGR1_AWDCH_Pos)               /*!< 0x10000000 */
N#define ADC_CFGR1_AWDCH_3         (0x08UL << ADC_CFGR1_AWDCH_Pos)               /*!< 0x20000000 */
N#define ADC_CFGR1_AWDCH_4         (0x10UL << ADC_CFGR1_AWDCH_Pos)               /*!< 0x40000000 */
N
N/*******************  Bits definition for ADC_CFGR2 register  *****************/
N#define ADC_CFGR2_CKMODE_Pos      (30U)
N#define ADC_CFGR2_CKMODE_Msk      (0x3UL << ADC_CFGR2_CKMODE_Pos)               /*!< 0xC0000000 */
N#define ADC_CFGR2_CKMODE          ADC_CFGR2_CKMODE_Msk                          /*!< ADC clock source and prescaler (prescaler only for clock source synchronous) */
N#define ADC_CFGR2_CKMODE_1        (0x2UL << ADC_CFGR2_CKMODE_Pos)               /*!< 0x80000000 */
N#define ADC_CFGR2_CKMODE_0        (0x1UL << ADC_CFGR2_CKMODE_Pos)               /*!< 0x40000000 */
N
N/******************  Bit definition for ADC_SMPR register  ********************/
N#define ADC_SMPR_SMP_Pos          (0U)
N#define ADC_SMPR_SMP_Msk          (0x7UL << ADC_SMPR_SMP_Pos)                   /*!< 0x00000007 */
N#define ADC_SMPR_SMP              ADC_SMPR_SMP_Msk                              /*!< ADC group of channels sampling time 2 */
N#define ADC_SMPR_SMP_0            (0x1UL << ADC_SMPR_SMP_Pos)                   /*!< 0x00000001 */
N#define ADC_SMPR_SMP_1            (0x2UL << ADC_SMPR_SMP_Pos)                   /*!< 0x00000002 */
N#define ADC_SMPR_SMP_2            (0x4UL << ADC_SMPR_SMP_Pos)                   /*!< 0x00000004 */
N
N/*******************  Bit definition for ADC_TR register  ********************/
N#define ADC_TR_LT_Pos             (0U)
N#define ADC_TR_LT_Msk             (0xFFFUL << ADC_TR_LT_Pos)                    /*!< 0x00000FFF */
N#define ADC_TR_LT                 ADC_TR_LT_Msk                                 /*!< ADC analog watchdog threshold low */
N#define ADC_TR_LT_0               (0x001UL << ADC_TR_LT_Pos)                    /*!< 0x00000001 */
N#define ADC_TR_LT_1               (0x002UL << ADC_TR_LT_Pos)                    /*!< 0x00000002 */
N#define ADC_TR_LT_2               (0x004UL << ADC_TR_LT_Pos)                    /*!< 0x00000004 */
N#define ADC_TR_LT_3               (0x008UL << ADC_TR_LT_Pos)                    /*!< 0x00000008 */
N#define ADC_TR_LT_4               (0x010UL << ADC_TR_LT_Pos)                    /*!< 0x00000010 */
N#define ADC_TR_LT_5               (0x020UL << ADC_TR_LT_Pos)                    /*!< 0x00000020 */
N#define ADC_TR_LT_6               (0x040UL << ADC_TR_LT_Pos)                    /*!< 0x00000040 */
N#define ADC_TR_LT_7               (0x080UL << ADC_TR_LT_Pos)                    /*!< 0x00000080 */
N#define ADC_TR_LT_8               (0x100UL << ADC_TR_LT_Pos)                    /*!< 0x00000100 */
N#define ADC_TR_LT_9               (0x200UL << ADC_TR_LT_Pos)                    /*!< 0x00000200 */
N#define ADC_TR_LT_10              (0x400UL << ADC_TR_LT_Pos)                    /*!< 0x00000400 */
N#define ADC_TR_LT_11              (0x800UL << ADC_TR_LT_Pos)                    /*!< 0x00000800 */
N
N#define ADC_TR_HT_Pos             (16U)
N#define ADC_TR_HT_Msk             (0xFFFUL << ADC_TR_HT_Pos)                    /*!< 0x0FFF0000 */
N#define ADC_TR_HT                 ADC_TR_HT_Msk                                 /*!< ADC Analog watchdog threshold high */
N#define ADC_TR_HT_0               (0x001UL << ADC_TR_HT_Pos)                    /*!< 0x00010000 */
N#define ADC_TR_HT_1               (0x002UL << ADC_TR_HT_Pos)                    /*!< 0x00020000 */
N#define ADC_TR_HT_2               (0x004UL << ADC_TR_HT_Pos)                    /*!< 0x00040000 */
N#define ADC_TR_HT_3               (0x008UL << ADC_TR_HT_Pos)                    /*!< 0x00080000 */
N#define ADC_TR_HT_4               (0x010UL << ADC_TR_HT_Pos)                    /*!< 0x00100000 */
N#define ADC_TR_HT_5               (0x020UL << ADC_TR_HT_Pos)                    /*!< 0x00200000 */
N#define ADC_TR_HT_6               (0x040UL << ADC_TR_HT_Pos)                    /*!< 0x00400000 */
N#define ADC_TR_HT_7               (0x080UL << ADC_TR_HT_Pos)                    /*!< 0x00800000 */
N#define ADC_TR_HT_8               (0x100UL << ADC_TR_HT_Pos)                    /*!< 0x01000000 */
N#define ADC_TR_HT_9               (0x200UL << ADC_TR_HT_Pos)                    /*!< 0x02000000 */
N#define ADC_TR_HT_10              (0x400UL << ADC_TR_HT_Pos)                    /*!< 0x04000000 */
N#define ADC_TR_HT_11              (0x800UL << ADC_TR_HT_Pos)                    /*!< 0x08000000 */
N
N/******************  Bit definition for ADC_CHSELR register  ******************/
N#define ADC_CHSELR_CHSEL_Pos      (0U)
N#define ADC_CHSELR_CHSEL_Msk      (0x3FFFFFUL << ADC_CHSELR_CHSEL_Pos)          /*!< 0x003FFFFF */
N#define ADC_CHSELR_CHSEL          ADC_CHSELR_CHSEL_Msk                          /*!< ADC group regular sequencer channels, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL0_Pos     (0U)
N#define ADC_CHSELR_CHSEL0_Msk     (0x1UL << ADC_CHSELR_CHSEL0_Pos)              /*!< 0x00000001 */
N#define ADC_CHSELR_CHSEL0         ADC_CHSELR_CHSEL0_Msk                         /*!< ADC group regular sequencer channel 0, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL1_Pos     (1U)
N#define ADC_CHSELR_CHSEL1_Msk     (0x1UL << ADC_CHSELR_CHSEL1_Pos)              /*!< 0x00000002 */
N#define ADC_CHSELR_CHSEL1         ADC_CHSELR_CHSEL1_Msk                         /*!< ADC group regular sequencer channel 1, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL2_Pos     (2U)
N#define ADC_CHSELR_CHSEL2_Msk     (0x1UL << ADC_CHSELR_CHSEL2_Pos)              /*!< 0x00000004 */
N#define ADC_CHSELR_CHSEL2         ADC_CHSELR_CHSEL2_Msk                         /*!< ADC group regular sequencer channel 2, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL3_Pos     (3U)
N#define ADC_CHSELR_CHSEL3_Msk     (0x1UL << ADC_CHSELR_CHSEL3_Pos)              /*!< 0x00000008 */
N#define ADC_CHSELR_CHSEL3         ADC_CHSELR_CHSEL3_Msk                         /*!< ADC group regular sequencer channel 3, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL4_Pos     (4U)
N#define ADC_CHSELR_CHSEL4_Msk     (0x1UL << ADC_CHSELR_CHSEL4_Pos)              /*!< 0x00000010 */
N#define ADC_CHSELR_CHSEL4         ADC_CHSELR_CHSEL4_Msk                         /*!< ADC group regular sequencer channel 4, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL5_Pos     (5U)
N#define ADC_CHSELR_CHSEL5_Msk     (0x1UL << ADC_CHSELR_CHSEL5_Pos)              /*!< 0x00000020 */
N#define ADC_CHSELR_CHSEL5         ADC_CHSELR_CHSEL5_Msk                         /*!< ADC group regular sequencer channel 5, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL6_Pos     (6U)
N#define ADC_CHSELR_CHSEL6_Msk     (0x1UL << ADC_CHSELR_CHSEL6_Pos)              /*!< 0x00000040 */
N#define ADC_CHSELR_CHSEL6         ADC_CHSELR_CHSEL6_Msk                         /*!< ADC group regular sequencer channel 6, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL7_Pos     (7U)
N#define ADC_CHSELR_CHSEL7_Msk     (0x1UL << ADC_CHSELR_CHSEL7_Pos)              /*!< 0x00000080 */
N#define ADC_CHSELR_CHSEL7         ADC_CHSELR_CHSEL7_Msk                         /*!< ADC group regular sequencer channel 7, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL8_Pos     (8U)
N#define ADC_CHSELR_CHSEL8_Msk     (0x1UL << ADC_CHSELR_CHSEL8_Pos)              /*!< 0x00000100 */
N#define ADC_CHSELR_CHSEL8         ADC_CHSELR_CHSEL8_Msk                         /*!< ADC group regular sequencer channel 8, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL9_Pos     (9U)
N#define ADC_CHSELR_CHSEL9_Msk     (0x1UL << ADC_CHSELR_CHSEL9_Pos)              /*!< 0x00000200 */
N#define ADC_CHSELR_CHSEL9         ADC_CHSELR_CHSEL9_Msk                         /*!< ADC group regular sequencer channel 9, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL10_Pos    (10U)
N#define ADC_CHSELR_CHSEL10_Msk    (0x1UL << ADC_CHSELR_CHSEL10_Pos)             /*!< 0x00000400 */
N#define ADC_CHSELR_CHSEL10        ADC_CHSELR_CHSEL10_Msk                        /*!< ADC group regular sequencer channel 10, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL11_Pos    (11U)
N#define ADC_CHSELR_CHSEL11_Msk    (0x1UL << ADC_CHSELR_CHSEL11_Pos)             /*!< 0x00000800 */
N#define ADC_CHSELR_CHSEL11        ADC_CHSELR_CHSEL11_Msk                        /*!< ADC group regular sequencer channel 11, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL12_Pos    (12U)
N#define ADC_CHSELR_CHSEL12_Msk    (0x1UL << ADC_CHSELR_CHSEL12_Pos)             /*!< 0x00001000 */
N#define ADC_CHSELR_CHSEL12        ADC_CHSELR_CHSEL12_Msk                        /*!< ADC group regular sequencer channel 12, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL13_Pos    (13U)
N#define ADC_CHSELR_CHSEL13_Msk    (0x1UL << ADC_CHSELR_CHSEL13_Pos)             /*!< 0x00002000 */
N#define ADC_CHSELR_CHSEL13        ADC_CHSELR_CHSEL13_Msk                        /*!< ADC group regular sequencer channel 13, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL14_Pos    (14U)
N#define ADC_CHSELR_CHSEL14_Msk    (0x1UL << ADC_CHSELR_CHSEL14_Pos)             /*!< 0x00004000 */
N#define ADC_CHSELR_CHSEL14        ADC_CHSELR_CHSEL14_Msk                        /*!< ADC group regular sequencer channel 14, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL15_Pos    (15U)
N#define ADC_CHSELR_CHSEL15_Msk    (0x1UL << ADC_CHSELR_CHSEL15_Pos)             /*!< 0x00008000 */
N#define ADC_CHSELR_CHSEL15        ADC_CHSELR_CHSEL15_Msk                        /*!< ADC group regular sequencer channel 15, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL16_Pos    (16U)
N#define ADC_CHSELR_CHSEL16_Msk    (0x1UL << ADC_CHSELR_CHSEL16_Pos)             /*!< 0x00010000 */
N#define ADC_CHSELR_CHSEL16        ADC_CHSELR_CHSEL16_Msk                        /*!< ADC group regular sequencer channel 16, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL17_Pos    (17U)
N#define ADC_CHSELR_CHSEL17_Msk    (0x1UL << ADC_CHSELR_CHSEL17_Pos)             /*!< 0x00020000 */
N#define ADC_CHSELR_CHSEL17        ADC_CHSELR_CHSEL17_Msk                        /*!< ADC group regular sequencer channel 17, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL18_Pos    (18U)
N#define ADC_CHSELR_CHSEL18_Msk    (0x1UL << ADC_CHSELR_CHSEL18_Pos)             /*!< 0x00040000 */
N#define ADC_CHSELR_CHSEL18        ADC_CHSELR_CHSEL18_Msk                        /*!< ADC group regular sequencer channel 18, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL19_Pos    (19U)
N#define ADC_CHSELR_CHSEL19_Msk    (0x1UL << ADC_CHSELR_CHSEL19_Pos)             /*!< 0x00040000 */
N#define ADC_CHSELR_CHSEL19        ADC_CHSELR_CHSEL19_Msk                        /*!< ADC group regular sequencer channel 19, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL20_Pos    (20U)
N#define ADC_CHSELR_CHSEL20_Msk    (0x1UL << ADC_CHSELR_CHSEL20_Pos)             /*!< 0x00040000 */
N#define ADC_CHSELR_CHSEL20        ADC_CHSELR_CHSEL20_Msk                        /*!< ADC group regular sequencer channel 20, available when ADC_CFGR1_CHSELRMOD is reset */
N
N#define ADC_CHSELR_CHSEL21_Pos    (21U)
N#define ADC_CHSELR_CHSEL21_Msk    (0x1UL << ADC_CHSELR_CHSEL21_Pos)             /*!< 0x00040000 */
N#define ADC_CHSELR_CHSEL21        ADC_CHSELR_CHSEL21_Msk                        /*!< ADC group regular sequencer channel 21, available when ADC_CFGR1_CHSELRMOD is reset */
N
N/********************  Bit definition for ADC_DR register  ********************/
N#define ADC_DR_DATA_Pos           (0U)
N#define ADC_DR_DATA_Msk           (0xFFFFUL << ADC_DR_DATA_Pos)                 /*!< 0x0000FFFF */
N#define ADC_DR_DATA               ADC_DR_DATA_Msk                               /*!< ADC group regular conversion data */
N#define ADC_DR_DATA_0             (0x0001UL << ADC_DR_DATA_Pos)                 /*!< 0x00000001 */
N#define ADC_DR_DATA_1             (0x0002UL << ADC_DR_DATA_Pos)                 /*!< 0x00000002 */
N#define ADC_DR_DATA_2             (0x0004UL << ADC_DR_DATA_Pos)                 /*!< 0x00000004 */
N#define ADC_DR_DATA_3             (0x0008UL << ADC_DR_DATA_Pos)                 /*!< 0x00000008 */
N#define ADC_DR_DATA_4             (0x0010UL << ADC_DR_DATA_Pos)                 /*!< 0x00000010 */
N#define ADC_DR_DATA_5             (0x0020UL << ADC_DR_DATA_Pos)                 /*!< 0x00000020 */
N#define ADC_DR_DATA_6             (0x0040UL << ADC_DR_DATA_Pos)                 /*!< 0x00000040 */
N#define ADC_DR_DATA_7             (0x0080UL << ADC_DR_DATA_Pos)                 /*!< 0x00000080 */
N#define ADC_DR_DATA_8             (0x0100UL << ADC_DR_DATA_Pos)                 /*!< 0x00000100 */
N#define ADC_DR_DATA_9             (0x0200UL << ADC_DR_DATA_Pos)                 /*!< 0x00000200 */
N#define ADC_DR_DATA_10            (0x0400UL << ADC_DR_DATA_Pos)                 /*!< 0x00000400 */
N#define ADC_DR_DATA_11            (0x0800UL << ADC_DR_DATA_Pos)                 /*!< 0x00000800 */
N#define ADC_DR_DATA_12            (0x1000UL << ADC_DR_DATA_Pos)                 /*!< 0x00001000 */
N#define ADC_DR_DATA_13            (0x2000UL << ADC_DR_DATA_Pos)                 /*!< 0x00002000 */
N#define ADC_DR_DATA_14            (0x4000UL << ADC_DR_DATA_Pos)                 /*!< 0x00004000 */
N#define ADC_DR_DATA_15            (0x8000UL << ADC_DR_DATA_Pos)                 /*!< 0x00008000 */
N
N/*******************  Bit definition for ADC_CCR register  ********************/
N#define ADC_CCR_VREFEN_Pos        (22U)
N#define ADC_CCR_VREFEN_Msk        (0x1UL << ADC_CCR_VREFEN_Pos)                 /*!< 0x00400000 */
N#define ADC_CCR_VREFEN            ADC_CCR_VREFEN_Msk                            /*!< ADC internal path to VrefInt enable */
N
N#define ADC_CCR_TSEN_Pos          (23U)
N#define ADC_CCR_TSEN_Msk          (0x1UL << ADC_CCR_TSEN_Pos)                   /*!< 0x00800000 */
N#define ADC_CCR_TSEN              ADC_CCR_TSEN_Msk                              /*!< ADC internal path to temperature sensor enable */
N
N#define ADC_CCR_VBATEN_Pos        (24U)
N#define ADC_CCR_VBATEN_Msk        (0x1UL << ADC_CCR_VBATEN_Pos)                 /*!< 0x01000000 */
N#define ADC_CCR_VBATEN            ADC_CCR_VBATEN_Msk                            /*!< ADC internal path to battery voltage enable */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                       Voltage Comparator  (COMP)                           */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for CMP_CPxCR register  *******************/
N#define CMP_CPxCR_CPxEN_Pos        (0U)
N#define CMP_CPxCR_CPxEN_Msk        (0x1UL << CMP_CPxCR_CPxEN_Pos)               /*!< 0x00000001 */
N#define CMP_CPxCR_CPxEN            CMP_CPxCR_CPxEN_Msk
N
N#define CMP_CPxCR_CPxHYST_Pos      (1U)
N#define CMP_CPxCR_CPxHYST_Msk      (0x3UL << CMP_CPxCR_CPxHYST_Pos)             /*!< 0x00000006 */
N#define CMP_CPxCR_CPxHYST          CMP_CPxCR_CPxHYST_Msk
N#define CMP_CPxCR_CPxHYST_0        (0x01UL << CMP_CPxCR_CPxHYST_Pos)
N#define CMP_CPxCR_CPxHYST_1        (0x02UL << CMP_CPxCR_CPxHYST_Pos)
N
N#define CMP_CPxCR_CPxPSEL_Pos      (3U)
N#define CMP_CPxCR_CPxPSEL_Msk      (0x7UL << CMP_CPxCR_CPxPSEL_Pos)             /*!< 0x00000038 */
N#define CMP_CPxCR_CPxPSEL          CMP_CPxCR_CPxPSEL_Msk
N#define CMP_CPxCR_CPxPSEL_0        (0x01UL << CMP_CPxCR_CPxPSEL_Pos)
N#define CMP_CPxCR_CPxPSEL_1        (0x02UL << CMP_CPxCR_CPxPSEL_Pos)
N#define CMP_CPxCR_CPxPSEL_2        (0x04UL << CMP_CPxCR_CPxPSEL_Pos)
N
N#define CMP_CPxCR_CPxNSEL_Pos      (6U)
N#define CMP_CPxCR_CPxNSEL_Msk      (0x1UL << CMP_CPxCR_CPxNSEL_Pos)             /*!< 0x00000040 */
N#define CMP_CPxCR_CPxNSEL          CMP_CPxCR_CPxNSEL_Msk
N
N#define CMP_CPxCR_CPxRVSEL_Pos     (7U)
N#define CMP_CPxCR_CPxRVSEL_Msk     (0x7UL << CMP_CPxCR_CPxRVSEL_Pos)            /*!< 0x00000380 */
N#define CMP_CPxCR_CPxRVSEL         CMP_CPxCR_CPxRVSEL_Msk
N#define CMP_CPxCR_CPxRVSEL_0       (0x01UL << CMP_CPxCR_CPxRVSEL_Pos)
N#define CMP_CPxCR_CPxRVSEL_1       (0x02UL << CMP_CPxCR_CPxRVSEL_Pos)
N#define CMP_CPxCR_CPxRVSEL_2       (0x04UL << CMP_CPxCR_CPxRVSEL_Pos)
N
N#define CMP_CPxCR_CPxOFLT_Pos      (11U)
N#define CMP_CPxCR_CPxOFLT_Msk      (0x7UL << CMP_CPxCR_CPxOFLT_Pos)             /*!< 0x00003800 */
N#define CMP_CPxCR_CPxOFLT          CMP_CPxCR_CPxOFLT_Msk
N#define CMP_CPxCR_CPxOFLT_0        (0x01UL << CMP_CPxCR_CPxOFLT_Pos)
N#define CMP_CPxCR_CPxOFLT_1        (0x02UL << CMP_CPxCR_CPxOFLT_Pos)
N#define CMP_CPxCR_CPxOFLT_2        (0x04UL << CMP_CPxCR_CPxOFLT_Pos)
N
N#define CMP_CPxCR_CPxPOL_Pos       (15U)
N#define CMP_CPxCR_CPxPOL_Msk       (0x1UL << CMP_CPxCR_CPxPOL_Pos)              /*!< 0x00008000 */
N#define CMP_CPxCR_CPxPOL           CMP_CPxCR_CPxPOL_Msk
N
N#define CMP_CPxCR_CPxOUTSEL_Pos    (16U)
N#define CMP_CPxCR_CPxOUTSEL_Msk    (0x7UL << CMP_CPxCR_CPxOUTSEL_Pos)           /*!< 0x00070000 */
N#define CMP_CPxCR_CPxOUTSEL        CMP_CPxCR_CPxOUTSEL_Msk
N#define CMP_CPxCR_CPxOUTSEL_0      (0x01UL << CMP_CPxCR_CPxOUTSEL_Pos)
N#define CMP_CPxCR_CPxOUTSEL_1      (0x02UL << CMP_CPxCR_CPxOUTSEL_Pos)
N#define CMP_CPxCR_CPxOUTSEL_2      (0x04UL << CMP_CPxCR_CPxOUTSEL_Pos)
N
N#define CMP_CPxCR_CPxOUT_Pos       (30U)
N#define CMP_CPxCR_CPxOUT_Msk       (0x1UL << CMP_CPxCR_CPxOUT_Pos)              /*!< 0x40000000 */
N#define CMP_CPxCR_CPxOUT           CMP_CPxCR_CPxOUT_Msk
N
N#define CMP_CPxCR_CPxLCK_Pos       (31U)
N#define CMP_CPxCR_CPxLCK_Msk       (0x1UL << CMP_CPxCR_CPxLCK_Pos)              /*!< 0x80000000 */
N#define CMP_CPxCR_CPxLCK           CMP_CPxCR_CPxLCK_Msk
N   
N/******************  Bit definition for CMP_CPANA register  *******************/
N#define CMP_CPANA_CPVREFEN_Pos     (0U)
N#define CMP_CPANA_CPVREFEN_Msk     (0x1UL << CMP_CPANA_CPVREFEN_Pos)            /*!< 0x00000001 */
N#define CMP_CPANA_CPVREFEN         CMP_CPANA_CPVREFEN_Msk
N
N#define CMP_CPANA_CP1VOLT_Pos      (1U)
N#define CMP_CPANA_CP1VOLT_Msk      (0x1UL << CMP_CPANA_CP1VOLT_Pos)             /*!< 0x00000002 */
N#define CMP_CPANA_CP1VOLT          CMP_CPANA_CP1VOLT_Msk
N
N#define CMP_CPANA_CP2VOLT_Pos      (2U)
N#define CMP_CPANA_CP2VOLT_Msk      (0x1UL << CMP_CPANA_CP2VOLT_Pos)             /*!< 0x00000004 */
N#define CMP_CPANA_CP2VOLT          CMP_CPANA_CP2VOLT_Msk
N
N/******************  Bit definition for CMP_CPxCAL register  ******************/
N#define CMP_CPxCAL_CPxCALDATN_Pos  (0U)
N#define CMP_CPxCAL_CPxCALDATN_Msk  (0x3FUL << CMP_CPxCAL_CPxCALDATN_Pos)        /*!< 0x0000003F */
N#define CMP_CPxCAL_CPxCALDATN      CMP_CPxCAL_CPxCALDATN_Msk
N#define CMP_CPxCAL_CPxCALDATN_0    (0x01UL << CMP_CPxCAL_CPxCALDATN_Pos)
N#define CMP_CPxCAL_CPxCALDATN_1    (0x02UL << CMP_CPxCAL_CPxCALDATN_Pos)
N#define CMP_CPxCAL_CPxCALDATN_2    (0x04UL << CMP_CPxCAL_CPxCALDATN_Pos)
N#define CMP_CPxCAL_CPxCALDATN_3    (0x08UL << CMP_CPxCAL_CPxCALDATN_Pos)
N#define CMP_CPxCAL_CPxCALDATN_4    (0x10UL << CMP_CPxCAL_CPxCALDATN_Pos)
N#define CMP_CPxCAL_CPxCALDATN_5    (0x20UL << CMP_CPxCAL_CPxCALDATN_Pos)
N
N#define CMP_CPxCAL_CPxCALDATP_Pos  (8U)
N#define CMP_CPxCAL_CPxCALDATP_Msk  (0x3FUL << CMP_CPxCAL_CPxCALDATP_Pos)        /*!< 0x00003F00 */
N#define CMP_CPxCAL_CPxCALDATP      CMP_CPxCAL_CPxCALDATP_Msk
N#define CMP_CPxCAL_CPxCALDATP_0    (0x01UL << CMP_CPxCAL_CPxCALDATP_Pos)
N#define CMP_CPxCAL_CPxCALDATP_1    (0x02UL << CMP_CPxCAL_CPxCALDATP_Pos)
N#define CMP_CPxCAL_CPxCALDATP_2    (0x04UL << CMP_CPxCAL_CPxCALDATP_Pos)
N#define CMP_CPxCAL_CPxCALDATP_3    (0x08UL << CMP_CPxCAL_CPxCALDATP_Pos)
N#define CMP_CPxCAL_CPxCALDATP_4    (0x10UL << CMP_CPxCAL_CPxCALDATP_Pos)
N#define CMP_CPxCAL_CPxCALDATP_5    (0x20UL << CMP_CPxCAL_CPxCALDATP_Pos)
N
N#define CMP_CPxCAL_CPxSYNC_Pos     (30U)
N#define CMP_CPxCAL_CPxSYNC_Msk     (0x1UL << CMP_CPxCAL_CPxSYNC_Pos)            /*!< 0x40000000 */
N#define CMP_CPxCAL_CPxSYNC         CMP_CPxCAL_CPxSYNC_Msk
N
N#define CMP_CPxCAL_CPxCALEN_Pos    (31U)
N#define CMP_CPxCAL_CPxCALEN_Msk    (0x1UL << CMP_CPxCAL_CPxCALEN_Pos)           /*!< 0x80000000 */
N#define CMP_CPxCAL_CPxCALEN        CMP_CPxCAL_CPxCALEN_Msk
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                       CRC calculation unit (CRC)                           */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for CRC_DR register  *********************/
N#define CRC_DR_DR_Pos            (0U)
N#define CRC_DR_DR_Msk            (0xFFFFFFFFUL << CRC_DR_DR_Pos)                /*!< 0xFFFFFFFF */
N#define CRC_DR_DR                CRC_DR_DR_Msk                                  /*!< Data register bits */
N#define CRC_DR_DR_0              (0x00000001UL << CRC_DR_DR_Pos)                /*!< 0x00000001 */
N#define CRC_DR_DR_1              (0x00000002UL << CRC_DR_DR_Pos)                /*!< 0x00000002 */
N#define CRC_DR_DR_2              (0x00000004UL << CRC_DR_DR_Pos)                /*!< 0x00000004 */
N#define CRC_DR_DR_3              (0x00000008UL << CRC_DR_DR_Pos)                /*!< 0x00000008 */
N#define CRC_DR_DR_4              (0x00000010UL << CRC_DR_DR_Pos)                /*!< 0x00000010 */
N#define CRC_DR_DR_5              (0x00000020UL << CRC_DR_DR_Pos)                /*!< 0x00000020 */
N#define CRC_DR_DR_6              (0x00000040UL << CRC_DR_DR_Pos)                /*!< 0x00000040 */
N#define CRC_DR_DR_7              (0x00000080UL << CRC_DR_DR_Pos)                /*!< 0x00000080 */
N#define CRC_DR_DR_8              (0x00000100UL << CRC_DR_DR_Pos)                /*!< 0x00000100 */
N#define CRC_DR_DR_9              (0x00000200UL << CRC_DR_DR_Pos)                /*!< 0x00000200 */
N#define CRC_DR_DR_10             (0x00000400UL << CRC_DR_DR_Pos)                /*!< 0x00000400 */
N#define CRC_DR_DR_11             (0x00000800UL << CRC_DR_DR_Pos)                /*!< 0x00000800 */
N#define CRC_DR_DR_12             (0x00001000UL << CRC_DR_DR_Pos)                /*!< 0x00001000 */
N#define CRC_DR_DR_13             (0x00002000UL << CRC_DR_DR_Pos)                /*!< 0x00002000 */
N#define CRC_DR_DR_14             (0x00004000UL << CRC_DR_DR_Pos)                /*!< 0x00004000 */
N#define CRC_DR_DR_15             (0x00008000UL << CRC_DR_DR_Pos)                /*!< 0x00008000 */
N#define CRC_DR_DR_16             (0x00010000UL << CRC_DR_DR_Pos)                /*!< 0x00010000 */
N#define CRC_DR_DR_17             (0x00020000UL << CRC_DR_DR_Pos)                /*!< 0x00020000 */
N#define CRC_DR_DR_18             (0x00040000UL << CRC_DR_DR_Pos)                /*!< 0x00040000 */
N#define CRC_DR_DR_19             (0x00080000UL << CRC_DR_DR_Pos)                /*!< 0x00080000 */
N#define CRC_DR_DR_20             (0x00100000UL << CRC_DR_DR_Pos)                /*!< 0x00100000 */
N#define CRC_DR_DR_21             (0x00200000UL << CRC_DR_DR_Pos)                /*!< 0x00200000 */
N#define CRC_DR_DR_22             (0x00400000UL << CRC_DR_DR_Pos)                /*!< 0x00400000 */
N#define CRC_DR_DR_23             (0x00800000UL << CRC_DR_DR_Pos)                /*!< 0x00800000 */
N#define CRC_DR_DR_24             (0x01000000UL << CRC_DR_DR_Pos)                /*!< 0x01000000 */
N#define CRC_DR_DR_25             (0x02000000UL << CRC_DR_DR_Pos)                /*!< 0x02000000 */
N#define CRC_DR_DR_26             (0x04000000UL << CRC_DR_DR_Pos)                /*!< 0x04000000 */
N#define CRC_DR_DR_27             (0x08000000UL << CRC_DR_DR_Pos)                /*!< 0x08000000 */
N#define CRC_DR_DR_28             (0x10000000UL << CRC_DR_DR_Pos)                /*!< 0x10000000 */
N#define CRC_DR_DR_29             (0x20000000UL << CRC_DR_DR_Pos)                /*!< 0x20000000 */
N#define CRC_DR_DR_30             (0x40000000UL << CRC_DR_DR_Pos)                /*!< 0x40000000 */
N#define CRC_DR_DR_31             (0x80000000UL << CRC_DR_DR_Pos)                /*!< 0x80000000 */
N
N/*******************  Bit definition for CRC_IDR register  ********************/
N#define CRC_IDR_IDR_Pos          (0U)
N#define CRC_IDR_IDR_Msk          (0xFFUL << CRC_IDR_IDR_Pos)                    /*!< 0x000000FF */
N#define CRC_IDR_IDR              CRC_IDR_IDR_Msk                                /*!< Independent Data register bits */
N#define CRC_IDR_IDR_0            (0x01UL << CRC_IDR_IDR_Pos)                    /*!< 0x00000001 */
N#define CRC_IDR_IDR_1            (0x02UL << CRC_IDR_IDR_Pos)                    /*!< 0x00000002 */
N#define CRC_IDR_IDR_2            (0x04UL << CRC_IDR_IDR_Pos)                    /*!< 0x00000004 */
N#define CRC_IDR_IDR_3            (0x08UL << CRC_IDR_IDR_Pos)                    /*!< 0x00000008 */
N#define CRC_IDR_IDR_4            (0x10UL << CRC_IDR_IDR_Pos)                    /*!< 0x00000010 */
N#define CRC_IDR_IDR_5            (0x20UL << CRC_IDR_IDR_Pos)                    /*!< 0x00000020 */
N#define CRC_IDR_IDR_6            (0x40UL << CRC_IDR_IDR_Pos)                    /*!< 0x00000040 */
N#define CRC_IDR_IDR_7            (0x80UL << CRC_IDR_IDR_Pos)                    /*!< 0x00000080 */
N
N/********************  Bit definition for CRC_CR register  ********************/
N#define CRC_CR_RESET_Pos         (0U)
N#define CRC_CR_RESET_Msk         (0x1UL << CRC_CR_RESET_Pos)                    /*!< 0x00000001 */
N#define CRC_CR_RESET             CRC_CR_RESET_Msk                               /*!< RESET the CRC computation unit bit */
N
N#define CRC_CR_REV_IN_Pos        (5U)
N#define CRC_CR_REV_IN_Msk        (0x3UL << CRC_CR_REV_IN_Pos)                   /*!< 0x00000060 */
N#define CRC_CR_REV_IN            CRC_CR_REV_IN_Msk                              /*!< REV_IN Reverse Input Data bits */
N#define CRC_CR_REV_IN_0          (0x1UL << CRC_CR_REV_IN_Pos)                   /*!< 0x00000020 */
N#define CRC_CR_REV_IN_1          (0x2UL << CRC_CR_REV_IN_Pos)                   /*!< 0x00000040 */
N
N#define CRC_CR_REV_OUT_Pos       (7U)
N#define CRC_CR_REV_OUT_Msk       (0x1UL << CRC_CR_REV_OUT_Pos)                  /*!< 0x00000080 */
N#define CRC_CR_REV_OUT           CRC_CR_REV_OUT_Msk                             /*!< REV_OUT Reverse Output Data bits */
N
N/*******************  Bit definition for CRC_INIT register  *******************/
N#define CRC_INIT_INIT_Pos        (0U)
N#define CRC_INIT_INIT_Msk        (0xFFFFFFFFUL << CRC_INIT_INIT_Pos)            /*!< 0xFFFFFFFF */
N#define CRC_INIT_INIT            CRC_INIT_INIT_Msk                              /*!< Initial CRC value bits */
N#define CRC_INIT_INIT_0          (0x00000001UL << CRC_INIT_INIT_Pos)            /*!< 0x00000001 */
N#define CRC_INIT_INIT_1          (0x00000002UL << CRC_INIT_INIT_Pos)            /*!< 0x00000002 */
N#define CRC_INIT_INIT_2          (0x00000004UL << CRC_INIT_INIT_Pos)            /*!< 0x00000004 */
N#define CRC_INIT_INIT_3          (0x00000008UL << CRC_INIT_INIT_Pos)            /*!< 0x00000008 */
N#define CRC_INIT_INIT_4          (0x00000010UL << CRC_INIT_INIT_Pos)            /*!< 0x00000010 */
N#define CRC_INIT_INIT_5          (0x00000020UL << CRC_INIT_INIT_Pos)            /*!< 0x00000020 */
N#define CRC_INIT_INIT_6          (0x00000040UL << CRC_INIT_INIT_Pos)            /*!< 0x00000040 */
N#define CRC_INIT_INIT_7          (0x00000080UL << CRC_INIT_INIT_Pos)            /*!< 0x00000080 */
N#define CRC_INIT_INIT_8          (0x00000100UL << CRC_INIT_INIT_Pos)            /*!< 0x00000100 */
N#define CRC_INIT_INIT_9          (0x00000200UL << CRC_INIT_INIT_Pos)            /*!< 0x00000200 */
N#define CRC_INIT_INIT_10         (0x00000400UL << CRC_INIT_INIT_Pos)            /*!< 0x00000400 */
N#define CRC_INIT_INIT_11         (0x00000800UL << CRC_INIT_INIT_Pos)            /*!< 0x00000800 */
N#define CRC_INIT_INIT_12         (0x00001000UL << CRC_INIT_INIT_Pos)            /*!< 0x00001000 */
N#define CRC_INIT_INIT_13         (0x00002000UL << CRC_INIT_INIT_Pos)            /*!< 0x00002000 */
N#define CRC_INIT_INIT_14         (0x00004000UL << CRC_INIT_INIT_Pos)            /*!< 0x00004000 */
N#define CRC_INIT_INIT_15         (0x00008000UL << CRC_INIT_INIT_Pos)            /*!< 0x00008000 */
N#define CRC_INIT_INIT_16         (0x00010000UL << CRC_INIT_INIT_Pos)            /*!< 0x00010000 */
N#define CRC_INIT_INIT_17         (0x00020000UL << CRC_INIT_INIT_Pos)            /*!< 0x00020000 */
N#define CRC_INIT_INIT_18         (0x00040000UL << CRC_INIT_INIT_Pos)            /*!< 0x00040000 */
N#define CRC_INIT_INIT_19         (0x00080000UL << CRC_INIT_INIT_Pos)            /*!< 0x00080000 */
N#define CRC_INIT_INIT_20         (0x00100000UL << CRC_INIT_INIT_Pos)            /*!< 0x00100000 */
N#define CRC_INIT_INIT_21         (0x00200000UL << CRC_INIT_INIT_Pos)            /*!< 0x00200000 */
N#define CRC_INIT_INIT_22         (0x00400000UL << CRC_INIT_INIT_Pos)            /*!< 0x00400000 */
N#define CRC_INIT_INIT_23         (0x00800000UL << CRC_INIT_INIT_Pos)            /*!< 0x00800000 */
N#define CRC_INIT_INIT_24         (0x01000000UL << CRC_INIT_INIT_Pos)            /*!< 0x01000000 */
N#define CRC_INIT_INIT_25         (0x02000000UL << CRC_INIT_INIT_Pos)            /*!< 0x02000000 */
N#define CRC_INIT_INIT_26         (0x04000000UL << CRC_INIT_INIT_Pos)            /*!< 0x04000000 */
N#define CRC_INIT_INIT_27         (0x08000000UL << CRC_INIT_INIT_Pos)            /*!< 0x08000000 */
N#define CRC_INIT_INIT_28         (0x10000000UL << CRC_INIT_INIT_Pos)            /*!< 0x10000000 */
N#define CRC_INIT_INIT_29         (0x20000000UL << CRC_INIT_INIT_Pos)            /*!< 0x20000000 */
N#define CRC_INIT_INIT_30         (0x40000000UL << CRC_INIT_INIT_Pos)            /*!< 0x40000000 */
N#define CRC_INIT_INIT_31         (0x80000000UL << CRC_INIT_INIT_Pos)            /*!< 0x80000000 */
N
N/*******************  Bit definition for CRC_POL register  ********************/
N#define CRC_POL_POL_Pos          (0U)
N#define CRC_POL_POL_Msk          (0xFFFFFFFFUL << CRC_POL_POL_Pos)              /*!< 0xFFFFFFFF */
N#define CRC_POL_POL              CRC_POL_POL_Msk                                /*!< CRC polynomial value bits */
N#define CRC_POL_POL_0            (0x00000001UL << CRC_POL_POL_Pos)              /*!< 0x00000001 */
N#define CRC_POL_POL_1            (0x00000002UL << CRC_POL_POL_Pos)              /*!< 0x00000002 */
N#define CRC_POL_POL_2            (0x00000004UL << CRC_POL_POL_Pos)              /*!< 0x00000004 */
N#define CRC_POL_POL_3            (0x00000008UL << CRC_POL_POL_Pos)              /*!< 0x00000008 */
N#define CRC_POL_POL_4            (0x00000010UL << CRC_POL_POL_Pos)              /*!< 0x00000010 */
N#define CRC_POL_POL_5            (0x00000020UL << CRC_POL_POL_Pos)              /*!< 0x00000020 */
N#define CRC_POL_POL_6            (0x00000040UL << CRC_POL_POL_Pos)              /*!< 0x00000040 */
N#define CRC_POL_POL_7            (0x00000080UL << CRC_POL_POL_Pos)              /*!< 0x00000080 */
N#define CRC_POL_POL_8            (0x00000100UL << CRC_POL_POL_Pos)              /*!< 0x00000100 */
N#define CRC_POL_POL_9            (0x00000200UL << CRC_POL_POL_Pos)              /*!< 0x00000200 */
N#define CRC_POL_POL_10           (0x00000400UL << CRC_POL_POL_Pos)              /*!< 0x00000400 */
N#define CRC_POL_POL_11           (0x00000800UL << CRC_POL_POL_Pos)              /*!< 0x00000800 */
N#define CRC_POL_POL_12           (0x00001000UL << CRC_POL_POL_Pos)              /*!< 0x00001000 */
N#define CRC_POL_POL_13           (0x00002000UL << CRC_POL_POL_Pos)              /*!< 0x00002000 */
N#define CRC_POL_POL_14           (0x00004000UL << CRC_POL_POL_Pos)              /*!< 0x00004000 */
N#define CRC_POL_POL_15           (0x00008000UL << CRC_POL_POL_Pos)              /*!< 0x00008000 */
N#define CRC_POL_POL_16           (0x00010000UL << CRC_POL_POL_Pos)              /*!< 0x00010000 */
N#define CRC_POL_POL_17           (0x00020000UL << CRC_POL_POL_Pos)              /*!< 0x00020000 */
N#define CRC_POL_POL_18           (0x00040000UL << CRC_POL_POL_Pos)              /*!< 0x00040000 */
N#define CRC_POL_POL_19           (0x00080000UL << CRC_POL_POL_Pos)              /*!< 0x00080000 */
N#define CRC_POL_POL_20           (0x00100000UL << CRC_POL_POL_Pos)              /*!< 0x00100000 */
N#define CRC_POL_POL_21           (0x00200000UL << CRC_POL_POL_Pos)              /*!< 0x00200000 */
N#define CRC_POL_POL_22           (0x00400000UL << CRC_POL_POL_Pos)              /*!< 0x00400000 */
N#define CRC_POL_POL_23           (0x00800000UL << CRC_POL_POL_Pos)              /*!< 0x00800000 */
N#define CRC_POL_POL_24           (0x01000000UL << CRC_POL_POL_Pos)              /*!< 0x01000000 */
N#define CRC_POL_POL_25           (0x02000000UL << CRC_POL_POL_Pos)              /*!< 0x02000000 */
N#define CRC_POL_POL_26           (0x04000000UL << CRC_POL_POL_Pos)              /*!< 0x04000000 */
N#define CRC_POL_POL_27           (0x08000000UL << CRC_POL_POL_Pos)              /*!< 0x08000000 */
N#define CRC_POL_POL_28           (0x10000000UL << CRC_POL_POL_Pos)              /*!< 0x10000000 */
N#define CRC_POL_POL_29           (0x20000000UL << CRC_POL_POL_Pos)              /*!< 0x20000000 */
N#define CRC_POL_POL_30           (0x40000000UL << CRC_POL_POL_Pos)              /*!< 0x40000000 */
N#define CRC_POL_POL_31           (0x80000000UL << CRC_POL_POL_Pos)              /*!< 0x80000000 */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Debug MCU (DBGMCU)                               */
N/*                                                                            */
N/******************************************************************************/
N/****************  Bit definition for DBGMCU_IDCODE register  *****************/
N#define DBGMCU_IDCODE_DEV_ID_Pos                     (0U)
N#define DBGMCU_IDCODE_DEV_ID_Msk                     (0xFFFUL << DBGMCU_IDCODE_DEV_ID_Pos)                /*!< 0x00000FFF */
N#define DBGMCU_IDCODE_DEV_ID                         DBGMCU_IDCODE_DEV_ID_Msk                             /*!< Device Identifier */
N
N#define DBGMCU_IDCODE_REV_ID_Pos                     (16U)
N#define DBGMCU_IDCODE_REV_ID_Msk                     (0xFFFFUL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0xFFFF0000 */
N#define DBGMCU_IDCODE_REV_ID                         DBGMCU_IDCODE_REV_ID_Msk                             /*!< REV_ID[15:0] bits (Revision Identifier) */
N#define DBGMCU_IDCODE_REV_ID_0                       (0x0001UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x00010000 */
N#define DBGMCU_IDCODE_REV_ID_1                       (0x0002UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x00020000 */
N#define DBGMCU_IDCODE_REV_ID_2                       (0x0004UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x00040000 */
N#define DBGMCU_IDCODE_REV_ID_3                       (0x0008UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x00080000 */
N#define DBGMCU_IDCODE_REV_ID_4                       (0x0010UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x00100000 */
N#define DBGMCU_IDCODE_REV_ID_5                       (0x0020UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x00200000 */
N#define DBGMCU_IDCODE_REV_ID_6                       (0x0040UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x00400000 */
N#define DBGMCU_IDCODE_REV_ID_7                       (0x0080UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x00800000 */
N#define DBGMCU_IDCODE_REV_ID_8                       (0x0100UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x01000000 */
N#define DBGMCU_IDCODE_REV_ID_9                       (0x0200UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x02000000 */
N#define DBGMCU_IDCODE_REV_ID_10                      (0x0400UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x04000000 */
N#define DBGMCU_IDCODE_REV_ID_11                      (0x0800UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x08000000 */
N#define DBGMCU_IDCODE_REV_ID_12                      (0x1000UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x10000000 */
N#define DBGMCU_IDCODE_REV_ID_13                      (0x2000UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x20000000 */
N#define DBGMCU_IDCODE_REV_ID_14                      (0x4000UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x40000000 */
N#define DBGMCU_IDCODE_REV_ID_15                      (0x8000UL << DBGMCU_IDCODE_REV_ID_Pos)               /*!< 0x80000000 */
N
N/******************  Bit definition for DBGMCU_CR register  *******************/
N#define DBGMCU_CR_DBG_STOP_Pos                       (1U)
N#define DBGMCU_CR_DBG_STOP_Msk                       (0x1UL << DBGMCU_CR_DBG_STOP_Pos)                    /*!< 0x00000002 */
N#define DBGMCU_CR_DBG_STOP                           DBGMCU_CR_DBG_STOP_Msk                               /*!< Debug Stop Mode */
N
N#define DBGMCU_CR_DBG_STANDBY_Pos                    (2U)
N#define DBGMCU_CR_DBG_STANDBY_Msk                    (0x1UL << DBGMCU_CR_DBG_STANDBY_Pos)                 /*!< 0x00000004 */
N#define DBGMCU_CR_DBG_STANDBY                        DBGMCU_CR_DBG_STANDBY_Msk                            /*!< Debug Standby mode */
N
N/******************  Bit definition for DBGMCU_APB1_FZ register  **************/
N#define DBGMCU_APB1_FZ_DBG_TIM2_STOP_Pos             (0U)
N#define DBGMCU_APB1_FZ_DBG_TIM2_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_TIM2_STOP_Pos)          /*!< 0x00000001 */
N#define DBGMCU_APB1_FZ_DBG_TIM2_STOP                 DBGMCU_APB1_FZ_DBG_TIM2_STOP_Msk                     /*!< TIM2 counter stopped when core is halted */
N
N#define DBGMCU_APB1_FZ_DBG_TIM3_STOP_Pos             (1U)
N#define DBGMCU_APB1_FZ_DBG_TIM3_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_TIM3_STOP_Pos)          /*!< 0x00000002 */
N#define DBGMCU_APB1_FZ_DBG_TIM3_STOP                 DBGMCU_APB1_FZ_DBG_TIM3_STOP_Msk                     /*!< TIM3 counter stopped when core is halted */
N
N#define DBGMCU_APB1_FZ_DBG_TIM14_STOP_Pos            (8U)
N#define DBGMCU_APB1_FZ_DBG_TIM14_STOP_Msk            (0x1UL << DBGMCU_APB1_FZ_DBG_TIM14_STOP_Pos)         /*!< 0x00000100 */
N#define DBGMCU_APB1_FZ_DBG_TIM14_STOP                DBGMCU_APB1_FZ_DBG_TIM14_STOP_Msk                    /*!< TIM14 counter stopped when core is halted */
N
N#define DBGMCU_APB1_FZ_DBG_RTC_STOP_Pos              (10U)
N#define DBGMCU_APB1_FZ_DBG_RTC_STOP_Msk              (0x1UL << DBGMCU_APB1_FZ_DBG_RTC_STOP_Pos)           /*!< 0x00000400 */
N#define DBGMCU_APB1_FZ_DBG_RTC_STOP                  DBGMCU_APB1_FZ_DBG_RTC_STOP_Msk                      /*!< RTC Calendar frozen when core is halted */
N
N#define DBGMCU_APB1_FZ_DBG_WWDG_STOP_Pos             (11U)
N#define DBGMCU_APB1_FZ_DBG_WWDG_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_WWDG_STOP_Pos)          /*!< 0x00000800 */
N#define DBGMCU_APB1_FZ_DBG_WWDG_STOP                 DBGMCU_APB1_FZ_DBG_WWDG_STOP_Msk                     /*!< Debug Window Watchdog stopped when Core is halted */
N
N#define DBGMCU_APB1_FZ_DBG_IWDG_STOP_Pos             (12U)
N#define DBGMCU_APB1_FZ_DBG_IWDG_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_IWDG_STOP_Pos)          /*!< 0x00001000 */
N#define DBGMCU_APB1_FZ_DBG_IWDG_STOP                 DBGMCU_APB1_FZ_DBG_IWDG_STOP_Msk                     /*!< Debug Independent Watchdog stopped when Core is halted */
N
N#define DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Pos    (21U)
N#define DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Msk    (0x1UL << DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Pos) /*!< 0x00200000 */
N#define DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT        DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Msk            /*!< I2C1 SMBUS timeout mode stopped when Core is halted */
N
N/******************  Bit definition for DBGMCU_APB2_FZ register  **************/
N#define DBGMCU_APB2_FZ_DBG_TIM1_STOP_Pos             (11U)
N#define DBGMCU_APB2_FZ_DBG_TIM1_STOP_Msk             (0x1UL << DBGMCU_APB2_FZ_DBG_TIM1_STOP_Pos)          /*!< 0x00000800 */
N#define DBGMCU_APB2_FZ_DBG_TIM1_STOP                 DBGMCU_APB2_FZ_DBG_TIM1_STOP_Msk                     /*!< TIM1 counter stopped when core is halted */
N
N#define DBGMCU_APB2_FZ_DBG_TIM16_STOP_Pos            (17U)
N#define DBGMCU_APB2_FZ_DBG_TIM16_STOP_Msk            (0x1UL << DBGMCU_APB2_FZ_DBG_TIM16_STOP_Pos)         /*!< 0x00020000 */
N#define DBGMCU_APB2_FZ_DBG_TIM16_STOP                DBGMCU_APB2_FZ_DBG_TIM16_STOP_Msk                    /*!< TIM16 counter stopped when core is halted */
N
N#define DBGMCU_APB2_FZ_DBG_TIM17_STOP_Pos            (18U)
N#define DBGMCU_APB2_FZ_DBG_TIM17_STOP_Msk            (0x1UL << DBGMCU_APB2_FZ_DBG_TIM17_STOP_Pos)         /*!< 0x00040000 */
N#define DBGMCU_APB2_FZ_DBG_TIM17_STOP                DBGMCU_APB2_FZ_DBG_TIM17_STOP_Msk                    /*!< TIM17 counter stopped when core is halted */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                           DMA Controller (DMA)                             */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for DMA_ISR register  ********************/
N#define DMA_ISR_GIF1_Pos       (0U)
N#define DMA_ISR_GIF1_Msk       (0x1UL << DMA_ISR_GIF1_Pos)                      /*!< 0x00000001 */
N#define DMA_ISR_GIF1           DMA_ISR_GIF1_Msk                                 /*!< Channel 1 Global interrupt flag    */
N
N#define DMA_ISR_TCIF1_Pos      (1U)
N#define DMA_ISR_TCIF1_Msk      (0x1UL << DMA_ISR_TCIF1_Pos)                     /*!< 0x00000002 */
N#define DMA_ISR_TCIF1          DMA_ISR_TCIF1_Msk                                /*!< Channel 1 Transfer Complete flag   */
N
N#define DMA_ISR_HTIF1_Pos      (2U)
N#define DMA_ISR_HTIF1_Msk      (0x1UL << DMA_ISR_HTIF1_Pos)                     /*!< 0x00000004 */
N#define DMA_ISR_HTIF1          DMA_ISR_HTIF1_Msk                                /*!< Channel 1 Half Transfer flag       */
N
N#define DMA_ISR_TEIF1_Pos      (3U)
N#define DMA_ISR_TEIF1_Msk      (0x1UL << DMA_ISR_TEIF1_Pos)                     /*!< 0x00000008 */
N#define DMA_ISR_TEIF1          DMA_ISR_TEIF1_Msk                                /*!< Channel 1 Transfer Error flag      */
N
N#define DMA_ISR_GIF2_Pos       (4U)
N#define DMA_ISR_GIF2_Msk       (0x1UL << DMA_ISR_GIF2_Pos)                      /*!< 0x00000010 */
N#define DMA_ISR_GIF2           DMA_ISR_GIF2_Msk                                 /*!< Channel 2 Global interrupt flag    */
N
N#define DMA_ISR_TCIF2_Pos      (5U)
N#define DMA_ISR_TCIF2_Msk      (0x1UL << DMA_ISR_TCIF2_Pos)                     /*!< 0x00000020 */
N#define DMA_ISR_TCIF2          DMA_ISR_TCIF2_Msk                                /*!< Channel 2 Transfer Complete flag   */
N
N#define DMA_ISR_HTIF2_Pos      (6U)
N#define DMA_ISR_HTIF2_Msk      (0x1UL << DMA_ISR_HTIF2_Pos)                     /*!< 0x00000040 */
N#define DMA_ISR_HTIF2          DMA_ISR_HTIF2_Msk                                /*!< Channel 2 Half Transfer flag       */
N
N#define DMA_ISR_TEIF2_Pos      (7U)
N#define DMA_ISR_TEIF2_Msk      (0x1UL << DMA_ISR_TEIF2_Pos)                     /*!< 0x00000080 */
N#define DMA_ISR_TEIF2          DMA_ISR_TEIF2_Msk                                /*!< Channel 2 Transfer Error flag      */
N
N#define DMA_ISR_GIF3_Pos       (8U)
N#define DMA_ISR_GIF3_Msk       (0x1UL << DMA_ISR_GIF3_Pos)                      /*!< 0x00000100 */
N#define DMA_ISR_GIF3           DMA_ISR_GIF3_Msk                                 /*!< Channel 3 Global interrupt flag    */
N
N#define DMA_ISR_TCIF3_Pos      (9U)
N#define DMA_ISR_TCIF3_Msk      (0x1UL << DMA_ISR_TCIF3_Pos)                     /*!< 0x00000200 */
N#define DMA_ISR_TCIF3          DMA_ISR_TCIF3_Msk                                /*!< Channel 3 Transfer Complete flag   */
N
N#define DMA_ISR_HTIF3_Pos      (10U)
N#define DMA_ISR_HTIF3_Msk      (0x1UL << DMA_ISR_HTIF3_Pos)                     /*!< 0x00000400 */
N#define DMA_ISR_HTIF3          DMA_ISR_HTIF3_Msk                                /*!< Channel 3 Half Transfer flag       */
N
N#define DMA_ISR_TEIF3_Pos      (11U)
N#define DMA_ISR_TEIF3_Msk      (0x1UL << DMA_ISR_TEIF3_Pos)                     /*!< 0x00000800 */
N#define DMA_ISR_TEIF3          DMA_ISR_TEIF3_Msk                                /*!< Channel 3 Transfer Error flag      */
N
N#define DMA_ISR_GIF4_Pos       (12U)
N#define DMA_ISR_GIF4_Msk       (0x1UL << DMA_ISR_GIF4_Pos)                      /*!< 0x00001000 */
N#define DMA_ISR_GIF4           DMA_ISR_GIF4_Msk                                 /*!< Channel 4 Global interrupt flag    */
N
N#define DMA_ISR_TCIF4_Pos      (13U)
N#define DMA_ISR_TCIF4_Msk      (0x1UL << DMA_ISR_TCIF4_Pos)                     /*!< 0x00002000 */
N#define DMA_ISR_TCIF4          DMA_ISR_TCIF4_Msk                                /*!< Channel 4 Transfer Complete flag   */
N
N#define DMA_ISR_HTIF4_Pos      (14U)
N#define DMA_ISR_HTIF4_Msk      (0x1UL << DMA_ISR_HTIF4_Pos)                     /*!< 0x00004000 */
N#define DMA_ISR_HTIF4          DMA_ISR_HTIF4_Msk                                /*!< Channel 4 Half Transfer flag       */
N
N#define DMA_ISR_TEIF4_Pos      (15U)
N#define DMA_ISR_TEIF4_Msk      (0x1UL << DMA_ISR_TEIF4_Pos)                     /*!< 0x00008000 */
N#define DMA_ISR_TEIF4          DMA_ISR_TEIF4_Msk                                /*!< Channel 4 Transfer Error flag      */
N
N#define DMA_ISR_GIF5_Pos       (16U)
N#define DMA_ISR_GIF5_Msk       (0x1UL << DMA_ISR_GIF5_Pos)                      /*!< 0x00010000 */
N#define DMA_ISR_GIF5           DMA_ISR_GIF5_Msk                                 /*!< Channel 5 Global interrupt flag    */
N
N#define DMA_ISR_TCIF5_Pos      (17U)
N#define DMA_ISR_TCIF5_Msk      (0x1UL << DMA_ISR_TCIF5_Pos)                     /*!< 0x00020000 */
N#define DMA_ISR_TCIF5          DMA_ISR_TCIF5_Msk                                /*!< Channel 5 Transfer Complete flag   */
N
N#define DMA_ISR_HTIF5_Pos      (18U)
N#define DMA_ISR_HTIF5_Msk      (0x1UL << DMA_ISR_HTIF5_Pos)                     /*!< 0x00040000 */
N#define DMA_ISR_HTIF5          DMA_ISR_HTIF5_Msk                                /*!< Channel 5 Half Transfer flag       */
N
N#define DMA_ISR_TEIF5_Pos      (19U)
N#define DMA_ISR_TEIF5_Msk      (0x1UL << DMA_ISR_TEIF5_Pos)                     /*!< 0x00080000 */
N#define DMA_ISR_TEIF5          DMA_ISR_TEIF5_Msk                                /*!< Channel 5 Transfer Error flag      */
N
N/*******************  Bit definition for DMA_IFCR register  *******************/
N#define DMA_IFCR_CGIF1_Pos     (0U)
N#define DMA_IFCR_CGIF1_Msk     (0x1UL << DMA_IFCR_CGIF1_Pos)                    /*!< 0x00000001 */
N#define DMA_IFCR_CGIF1         DMA_IFCR_CGIF1_Msk                               /*!< Channel 1 Global interrupt clear    */
N
N#define DMA_IFCR_CTCIF1_Pos    (1U)
N#define DMA_IFCR_CTCIF1_Msk    (0x1UL << DMA_IFCR_CTCIF1_Pos)                   /*!< 0x00000002 */
N#define DMA_IFCR_CTCIF1        DMA_IFCR_CTCIF1_Msk                              /*!< Channel 1 Transfer Complete clear   */
N
N#define DMA_IFCR_CHTIF1_Pos    (2U)
N#define DMA_IFCR_CHTIF1_Msk    (0x1UL << DMA_IFCR_CHTIF1_Pos)                   /*!< 0x00000004 */
N#define DMA_IFCR_CHTIF1        DMA_IFCR_CHTIF1_Msk                              /*!< Channel 1 Half Transfer clear       */
N
N#define DMA_IFCR_CTEIF1_Pos    (3U)
N#define DMA_IFCR_CTEIF1_Msk    (0x1UL << DMA_IFCR_CTEIF1_Pos)                   /*!< 0x00000008 */
N#define DMA_IFCR_CTEIF1        DMA_IFCR_CTEIF1_Msk                              /*!< Channel 1 Transfer Error clear      */
N
N#define DMA_IFCR_CGIF2_Pos     (4U)
N#define DMA_IFCR_CGIF2_Msk     (0x1UL << DMA_IFCR_CGIF2_Pos)                    /*!< 0x00000010 */
N#define DMA_IFCR_CGIF2         DMA_IFCR_CGIF2_Msk                               /*!< Channel 2 Global interrupt clear    */
N
N#define DMA_IFCR_CTCIF2_Pos    (5U)
N#define DMA_IFCR_CTCIF2_Msk    (0x1UL << DMA_IFCR_CTCIF2_Pos)                   /*!< 0x00000020 */
N#define DMA_IFCR_CTCIF2        DMA_IFCR_CTCIF2_Msk                              /*!< Channel 2 Transfer Complete clear   */
N
N#define DMA_IFCR_CHTIF2_Pos    (6U)
N#define DMA_IFCR_CHTIF2_Msk    (0x1UL << DMA_IFCR_CHTIF2_Pos)                   /*!< 0x00000040 */
N#define DMA_IFCR_CHTIF2        DMA_IFCR_CHTIF2_Msk                              /*!< Channel 2 Half Transfer clear       */
N
N#define DMA_IFCR_CTEIF2_Pos    (7U)
N#define DMA_IFCR_CTEIF2_Msk    (0x1UL << DMA_IFCR_CTEIF2_Pos)                   /*!< 0x00000080 */
N#define DMA_IFCR_CTEIF2        DMA_IFCR_CTEIF2_Msk                              /*!< Channel 2 Transfer Error clear      */
N
N#define DMA_IFCR_CGIF3_Pos     (8U)
N#define DMA_IFCR_CGIF3_Msk     (0x1UL << DMA_IFCR_CGIF3_Pos)                    /*!< 0x00000100 */
N#define DMA_IFCR_CGIF3         DMA_IFCR_CGIF3_Msk                               /*!< Channel 3 Global interrupt clear    */
N
N#define DMA_IFCR_CTCIF3_Pos    (9U)
N#define DMA_IFCR_CTCIF3_Msk    (0x1UL << DMA_IFCR_CTCIF3_Pos)                   /*!< 0x00000200 */
N#define DMA_IFCR_CTCIF3        DMA_IFCR_CTCIF3_Msk                              /*!< Channel 3 Transfer Complete clear   */
N
N#define DMA_IFCR_CHTIF3_Pos    (10U)
N#define DMA_IFCR_CHTIF3_Msk    (0x1UL << DMA_IFCR_CHTIF3_Pos)                   /*!< 0x00000400 */
N#define DMA_IFCR_CHTIF3        DMA_IFCR_CHTIF3_Msk                              /*!< Channel 3 Half Transfer clear       */
N
N#define DMA_IFCR_CTEIF3_Pos    (11U)
N#define DMA_IFCR_CTEIF3_Msk    (0x1UL << DMA_IFCR_CTEIF3_Pos)                   /*!< 0x00000800 */
N#define DMA_IFCR_CTEIF3        DMA_IFCR_CTEIF3_Msk                              /*!< Channel 3 Transfer Error clear      */
N
N#define DMA_IFCR_CGIF4_Pos     (12U)
N#define DMA_IFCR_CGIF4_Msk     (0x1UL << DMA_IFCR_CGIF4_Pos)                    /*!< 0x00001000 */
N#define DMA_IFCR_CGIF4         DMA_IFCR_CGIF4_Msk                               /*!< Channel 4 Global interrupt clear    */
N
N#define DMA_IFCR_CTCIF4_Pos    (13U)
N#define DMA_IFCR_CTCIF4_Msk    (0x1UL << DMA_IFCR_CTCIF4_Pos)                   /*!< 0x00002000 */
N#define DMA_IFCR_CTCIF4        DMA_IFCR_CTCIF4_Msk                              /*!< Channel 4 Transfer Complete clear   */
N
N#define DMA_IFCR_CHTIF4_Pos    (14U)
N#define DMA_IFCR_CHTIF4_Msk    (0x1UL << DMA_IFCR_CHTIF4_Pos)                   /*!< 0x00004000 */
N#define DMA_IFCR_CHTIF4        DMA_IFCR_CHTIF4_Msk                              /*!< Channel 4 Half Transfer clear       */
N
N#define DMA_IFCR_CTEIF4_Pos    (15U)
N#define DMA_IFCR_CTEIF4_Msk    (0x1UL << DMA_IFCR_CTEIF4_Pos)                   /*!< 0x00008000 */
N#define DMA_IFCR_CTEIF4        DMA_IFCR_CTEIF4_Msk                              /*!< Channel 4 Transfer Error clear      */
N
N#define DMA_IFCR_CGIF5_Pos     (16U)
N#define DMA_IFCR_CGIF5_Msk     (0x1UL << DMA_IFCR_CGIF5_Pos)                    /*!< 0x00010000 */
N#define DMA_IFCR_CGIF5         DMA_IFCR_CGIF5_Msk                               /*!< Channel 5 Global interrupt clear    */
N
N#define DMA_IFCR_CTCIF5_Pos    (17U)
N#define DMA_IFCR_CTCIF5_Msk    (0x1UL << DMA_IFCR_CTCIF5_Pos)                   /*!< 0x00020000 */
N#define DMA_IFCR_CTCIF5        DMA_IFCR_CTCIF5_Msk                              /*!< Channel 5 Transfer Complete clear   */
N
N#define DMA_IFCR_CHTIF5_Pos    (18U)
N#define DMA_IFCR_CHTIF5_Msk    (0x1UL << DMA_IFCR_CHTIF5_Pos)                   /*!< 0x00040000 */
N#define DMA_IFCR_CHTIF5        DMA_IFCR_CHTIF5_Msk                              /*!< Channel 5 Half Transfer clear       */
N
N#define DMA_IFCR_CTEIF5_Pos    (19U)
N#define DMA_IFCR_CTEIF5_Msk    (0x1UL << DMA_IFCR_CTEIF5_Pos)                   /*!< 0x00080000 */
N#define DMA_IFCR_CTEIF5        DMA_IFCR_CTEIF5_Msk                              /*!< Channel 5 Transfer Error clear      */
N
N/*******************  Bit definition for DMA_CCR register  ********************/
N#define DMA_CCR_EN_Pos         (0U)
N#define DMA_CCR_EN_Msk         (0x1UL << DMA_CCR_EN_Pos)                        /*!< 0x00000001 */
N#define DMA_CCR_EN             DMA_CCR_EN_Msk                                   /*!< Channel enable                      */
N
N#define DMA_CCR_TCIE_Pos       (1U)
N#define DMA_CCR_TCIE_Msk       (0x1UL << DMA_CCR_TCIE_Pos)                      /*!< 0x00000002 */
N#define DMA_CCR_TCIE           DMA_CCR_TCIE_Msk                                 /*!< Transfer complete interrupt enable  */
N
N#define DMA_CCR_HTIE_Pos       (2U)
N#define DMA_CCR_HTIE_Msk       (0x1UL << DMA_CCR_HTIE_Pos)                      /*!< 0x00000004 */
N#define DMA_CCR_HTIE           DMA_CCR_HTIE_Msk                                 /*!< Half Transfer interrupt enable      */
N
N#define DMA_CCR_TEIE_Pos       (3U)
N#define DMA_CCR_TEIE_Msk       (0x1UL << DMA_CCR_TEIE_Pos)                      /*!< 0x00000008 */
N#define DMA_CCR_TEIE           DMA_CCR_TEIE_Msk                                 /*!< Transfer error interrupt enable     */
N
N#define DMA_CCR_DIR_Pos        (4U)
N#define DMA_CCR_DIR_Msk        (0x1UL << DMA_CCR_DIR_Pos)                       /*!< 0x00000010 */
N#define DMA_CCR_DIR            DMA_CCR_DIR_Msk                                  /*!< Data transfer direction             */
N
N#define DMA_CCR_CIRC_Pos       (5U)
N#define DMA_CCR_CIRC_Msk       (0x1UL << DMA_CCR_CIRC_Pos)                      /*!< 0x00000020 */
N#define DMA_CCR_CIRC           DMA_CCR_CIRC_Msk                                 /*!< Circular mode                       */
N
N#define DMA_CCR_PINC_Pos       (6U)
N#define DMA_CCR_PINC_Msk       (0x1UL << DMA_CCR_PINC_Pos)                      /*!< 0x00000040 */
N#define DMA_CCR_PINC           DMA_CCR_PINC_Msk                                 /*!< Peripheral increment mode           */
N
N#define DMA_CCR_MINC_Pos       (7U)
N#define DMA_CCR_MINC_Msk       (0x1UL << DMA_CCR_MINC_Pos)                      /*!< 0x00000080 */
N#define DMA_CCR_MINC           DMA_CCR_MINC_Msk                                 /*!< Memory increment mode               */
N
N#define DMA_CCR_PSIZE_Pos      (8U)
N#define DMA_CCR_PSIZE_Msk      (0x3UL << DMA_CCR_PSIZE_Pos)                     /*!< 0x00000300 */
N#define DMA_CCR_PSIZE          DMA_CCR_PSIZE_Msk                                /*!< PSIZE[1:0] bits (Peripheral size)   */
N#define DMA_CCR_PSIZE_0        (0x1UL << DMA_CCR_PSIZE_Pos)                     /*!< 0x00000100 */
N#define DMA_CCR_PSIZE_1        (0x2UL << DMA_CCR_PSIZE_Pos)                     /*!< 0x00000200 */
N
N#define DMA_CCR_MSIZE_Pos      (10U)
N#define DMA_CCR_MSIZE_Msk      (0x3UL << DMA_CCR_MSIZE_Pos)                     /*!< 0x00000C00 */
N#define DMA_CCR_MSIZE          DMA_CCR_MSIZE_Msk                                /*!< MSIZE[1:0] bits (Memory size)       */
N#define DMA_CCR_MSIZE_0        (0x1UL << DMA_CCR_MSIZE_Pos)                     /*!< 0x00000400 */
N#define DMA_CCR_MSIZE_1        (0x2UL << DMA_CCR_MSIZE_Pos)                     /*!< 0x00000800 */
N
N#define DMA_CCR_PL_Pos         (12U)
N#define DMA_CCR_PL_Msk         (0x3UL << DMA_CCR_PL_Pos)                        /*!< 0x00003000 */
N#define DMA_CCR_PL             DMA_CCR_PL_Msk                                   /*!< PL[1:0] bits(Channel Priority level)*/
N#define DMA_CCR_PL_0           (0x1UL << DMA_CCR_PL_Pos)                        /*!< 0x00001000 */
N#define DMA_CCR_PL_1           (0x2UL << DMA_CCR_PL_Pos)                        /*!< 0x00002000 */
N
N#define DMA_CCR_MEM2MEM_Pos    (14U)
N#define DMA_CCR_MEM2MEM_Msk    (0x1UL << DMA_CCR_MEM2MEM_Pos)                   /*!< 0x00004000 */
N#define DMA_CCR_MEM2MEM        DMA_CCR_MEM2MEM_Msk                              /*!< Memory to memory mode               */
N
N/******************  Bit definition for DMA_CNDTR register  *******************/
N#define DMA_CNDTR_NDT_Pos      (0U)
N#define DMA_CNDTR_NDT_Msk      (0xFFFFUL << DMA_CNDTR_NDT_Pos)                  /*!< 0x0000FFFF */
N#define DMA_CNDTR_NDT          DMA_CNDTR_NDT_Msk                                /*!< Number of data to Transfer          */
N
N/******************  Bit definition for DMA_CPAR register  ********************/
N#define DMA_CPAR_PA_Pos        (0U)
N#define DMA_CPAR_PA_Msk        (0xFFFFFFFFUL << DMA_CPAR_PA_Pos)                /*!< 0xFFFFFFFF */
N#define DMA_CPAR_PA            DMA_CPAR_PA_Msk                                  /*!< Peripheral Address                  */
N
N/******************  Bit definition for DMA_CMAR register  ********************/
N#define DMA_CMAR_MA_Pos        (0U)
N#define DMA_CMAR_MA_Msk        (0xFFFFFFFFUL << DMA_CMAR_MA_Pos)                /*!< 0xFFFFFFFF */
N#define DMA_CMAR_MA            DMA_CMAR_MA_Msk                                  /*!< Memory Address                      */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                 External Interrupt/Event Controller (EXTI)                 */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for EXTI_IMR register  *******************/
N#define EXTI_IMR_IM0_Pos          (0U)
N#define EXTI_IMR_IM0_Msk          (0x1UL << EXTI_IMR_IM0_Pos)                   /*!< 0x00000001 */
N#define EXTI_IMR_IM0              EXTI_IMR_IM0_Msk                              /*!< Interrupt Mask on line 0  */
N
N#define EXTI_IMR_IM1_Pos          (1U)
N#define EXTI_IMR_IM1_Msk          (0x1UL << EXTI_IMR_IM1_Pos)                   /*!< 0x00000002 */
N#define EXTI_IMR_IM1              EXTI_IMR_IM1_Msk                              /*!< Interrupt Mask on line 1  */
N
N#define EXTI_IMR_IM2_Pos          (2U)
N#define EXTI_IMR_IM2_Msk          (0x1UL << EXTI_IMR_IM2_Pos)                   /*!< 0x00000004 */
N#define EXTI_IMR_IM2              EXTI_IMR_IM2_Msk                              /*!< Interrupt Mask on line 2  */
N
N#define EXTI_IMR_IM3_Pos          (3U)
N#define EXTI_IMR_IM3_Msk          (0x1UL << EXTI_IMR_IM3_Pos)                   /*!< 0x00000008 */
N#define EXTI_IMR_IM3              EXTI_IMR_IM3_Msk                              /*!< Interrupt Mask on line 3  */
N
N#define EXTI_IMR_IM4_Pos          (4U)
N#define EXTI_IMR_IM4_Msk          (0x1UL << EXTI_IMR_IM4_Pos)                   /*!< 0x00000010 */
N#define EXTI_IMR_IM4              EXTI_IMR_IM4_Msk                              /*!< Interrupt Mask on line 4  */
N
N#define EXTI_IMR_IM5_Pos          (5U)
N#define EXTI_IMR_IM5_Msk          (0x1UL << EXTI_IMR_IM5_Pos)                   /*!< 0x00000020 */
N#define EXTI_IMR_IM5              EXTI_IMR_IM5_Msk                              /*!< Interrupt Mask on line 5  */
N
N#define EXTI_IMR_IM6_Pos          (6U)
N#define EXTI_IMR_IM6_Msk          (0x1UL << EXTI_IMR_IM6_Pos)                   /*!< 0x00000040 */
N#define EXTI_IMR_IM6              EXTI_IMR_IM6_Msk                              /*!< Interrupt Mask on line 6  */
N
N#define EXTI_IMR_IM7_Pos          (7U)
N#define EXTI_IMR_IM7_Msk          (0x1UL << EXTI_IMR_IM7_Pos)                   /*!< 0x00000080 */
N#define EXTI_IMR_IM7              EXTI_IMR_IM7_Msk                              /*!< Interrupt Mask on line 7  */
N
N#define EXTI_IMR_IM8_Pos          (8U)
N#define EXTI_IMR_IM8_Msk          (0x1UL << EXTI_IMR_IM8_Pos)                   /*!< 0x00000100 */
N#define EXTI_IMR_IM8              EXTI_IMR_IM8_Msk                              /*!< Interrupt Mask on line 8  */
N
N#define EXTI_IMR_IM9_Pos          (9U)
N#define EXTI_IMR_IM9_Msk          (0x1UL << EXTI_IMR_IM9_Pos)                   /*!< 0x00000200 */
N#define EXTI_IMR_IM9              EXTI_IMR_IM9_Msk                              /*!< Interrupt Mask on line 9  */
N
N#define EXTI_IMR_IM10_Pos         (10U)
N#define EXTI_IMR_IM10_Msk         (0x1UL << EXTI_IMR_IM10_Pos)                  /*!< 0x00000400 */
N#define EXTI_IMR_IM10             EXTI_IMR_IM10_Msk                             /*!< Interrupt Mask on line 10 */
N
N#define EXTI_IMR_IM11_Pos         (11U)
N#define EXTI_IMR_IM11_Msk         (0x1UL << EXTI_IMR_IM11_Pos)                  /*!< 0x00000800 */
N#define EXTI_IMR_IM11             EXTI_IMR_IM11_Msk                             /*!< Interrupt Mask on line 11 */
N
N#define EXTI_IMR_IM12_Pos         (12U)
N#define EXTI_IMR_IM12_Msk         (0x1UL << EXTI_IMR_IM12_Pos)                  /*!< 0x00001000 */
N#define EXTI_IMR_IM12             EXTI_IMR_IM12_Msk                             /*!< Interrupt Mask on line 12 */
N
N#define EXTI_IMR_IM13_Pos         (13U)
N#define EXTI_IMR_IM13_Msk         (0x1UL << EXTI_IMR_IM13_Pos)                  /*!< 0x00002000 */
N#define EXTI_IMR_IM13             EXTI_IMR_IM13_Msk                             /*!< Interrupt Mask on line 13 */
N
N#define EXTI_IMR_IM14_Pos         (14U)
N#define EXTI_IMR_IM14_Msk         (0x1UL << EXTI_IMR_IM14_Pos)                  /*!< 0x00004000 */
N#define EXTI_IMR_IM14             EXTI_IMR_IM14_Msk                             /*!< Interrupt Mask on line 14 */
N
N#define EXTI_IMR_IM15_Pos         (15U)
N#define EXTI_IMR_IM15_Msk         (0x1UL << EXTI_IMR_IM15_Pos)                  /*!< 0x00008000 */
N#define EXTI_IMR_IM15             EXTI_IMR_IM15_Msk                             /*!< Interrupt Mask on line 15 */
N
N#define EXTI_IMR_IM16_Pos         (16U)
N#define EXTI_IMR_IM16_Msk         (0x1UL << EXTI_IMR_IM16_Pos)                  /*!< 0x00010000 */
N#define EXTI_IMR_IM16             EXTI_IMR_IM16_Msk                             /*!< Interrupt Mask on line 16 */
N
N#define EXTI_IMR_IM17_Pos         (17U)
N#define EXTI_IMR_IM17_Msk         (0x1UL << EXTI_IMR_IM17_Pos)                  /*!< 0x00020000 */
N#define EXTI_IMR_IM17             EXTI_IMR_IM17_Msk                             /*!< Interrupt Mask on line 17 */
N
N#define EXTI_IMR_IM19_Pos         (19U)
N#define EXTI_IMR_IM19_Msk         (0x1UL << EXTI_IMR_IM19_Pos)                  /*!< 0x00080000 */
N#define EXTI_IMR_IM19             EXTI_IMR_IM19_Msk                             /*!< Interrupt Mask on line 19 */
N
N#define EXTI_IMR_IM21_Pos         (21U)
N#define EXTI_IMR_IM21_Msk         (0x1UL << EXTI_IMR_IM21_Pos)                  /*!< 0x00200000 */
N#define EXTI_IMR_IM21             EXTI_IMR_IM21_Msk                             /*!< Interrupt Mask on line 21 */
N
N#define EXTI_IMR_IM22_Pos         (22U)
N#define EXTI_IMR_IM22_Msk         (0x1UL << EXTI_IMR_IM22_Pos)                  /*!< 0x00400000 */
N#define EXTI_IMR_IM22             EXTI_IMR_IM22_Msk                             /*!< Interrupt Mask on line 22 */
N
N#define EXTI_IMR_IM23_Pos         (23U)
N#define EXTI_IMR_IM23_Msk         (0x1UL << EXTI_IMR_IM23_Pos)                  /*!< 0x00800000 */
N#define EXTI_IMR_IM23             EXTI_IMR_IM23_Msk                             /*!< Interrupt Mask on line 23 */
N
N#define EXTI_IMR_IM25_Pos         (25U)
N#define EXTI_IMR_IM25_Msk         (0x1UL << EXTI_IMR_IM25_Pos)                  /*!< 0x02000000 */
N#define EXTI_IMR_IM25             EXTI_IMR_IM25_Msk                             /*!< Interrupt Mask on line 25 */
N
N#define EXTI_IMR_IM_Pos           (0U)
N#define EXTI_IMR_IM_Msk           (0x02EBFFFFUL << EXTI_IMR_IM_Pos)             /*!< 0x0AEBFFFF */
N#define EXTI_IMR_IM               EXTI_IMR_IM_Msk                               /*!< Interrupt Mask All */
N
N/*****************  Bit definition for EXTI_EMR register  ********************/
N#define EXTI_EMR_EM0_Pos          (0U)
N#define EXTI_EMR_EM0_Msk          (0x1UL << EXTI_EMR_EM0_Pos)                   /*!< 0x00000001 */
N#define EXTI_EMR_EM0              EXTI_EMR_EM0_Msk                              /*!< Event Mask on line 0  */
N
N#define EXTI_EMR_EM1_Pos          (1U)
N#define EXTI_EMR_EM1_Msk          (0x1UL << EXTI_EMR_EM1_Pos)                   /*!< 0x00000002 */
N#define EXTI_EMR_EM1              EXTI_EMR_EM1_Msk                              /*!< Event Mask on line 1  */
N
N#define EXTI_EMR_EM2_Pos          (2U)
N#define EXTI_EMR_EM2_Msk          (0x1UL << EXTI_EMR_EM2_Pos)                   /*!< 0x00000004 */
N#define EXTI_EMR_EM2              EXTI_EMR_EM2_Msk                              /*!< Event Mask on line 2  */
N
N#define EXTI_EMR_EM3_Pos          (3U)
N#define EXTI_EMR_EM3_Msk          (0x1UL << EXTI_EMR_EM3_Pos)                   /*!< 0x00000008 */
N#define EXTI_EMR_EM3              EXTI_EMR_EM3_Msk                              /*!< Event Mask on line 3  */
N
N#define EXTI_EMR_EM4_Pos          (4U)
N#define EXTI_EMR_EM4_Msk          (0x1UL << EXTI_EMR_EM4_Pos)                   /*!< 0x00000010 */
N#define EXTI_EMR_EM4              EXTI_EMR_EM4_Msk                              /*!< Event Mask on line 4  */
N
N#define EXTI_EMR_EM5_Pos          (5U)
N#define EXTI_EMR_EM5_Msk          (0x1UL << EXTI_EMR_EM5_Pos)                   /*!< 0x00000020 */
N#define EXTI_EMR_EM5              EXTI_EMR_EM5_Msk                              /*!< Event Mask on line 5  */
N
N#define EXTI_EMR_EM6_Pos          (6U)
N#define EXTI_EMR_EM6_Msk          (0x1UL << EXTI_EMR_EM6_Pos)                   /*!< 0x00000040 */
N#define EXTI_EMR_EM6              EXTI_EMR_EM6_Msk                              /*!< Event Mask on line 6  */
N
N#define EXTI_EMR_EM7_Pos          (7U)
N#define EXTI_EMR_EM7_Msk          (0x1UL << EXTI_EMR_EM7_Pos)                   /*!< 0x00000080 */
N#define EXTI_EMR_EM7              EXTI_EMR_EM7_Msk                              /*!< Event Mask on line 7  */
N
N#define EXTI_EMR_EM8_Pos          (8U)
N#define EXTI_EMR_EM8_Msk          (0x1UL << EXTI_EMR_EM8_Pos)                   /*!< 0x00000100 */
N#define EXTI_EMR_EM8              EXTI_EMR_EM8_Msk                              /*!< Event Mask on line 8  */
N
N#define EXTI_EMR_EM9_Pos          (9U)
N#define EXTI_EMR_EM9_Msk          (0x1UL << EXTI_EMR_EM9_Pos)                   /*!< 0x00000200 */
N#define EXTI_EMR_EM9              EXTI_EMR_EM9_Msk                              /*!< Event Mask on line 9  */
N
N#define EXTI_EMR_EM10_Pos         (10U)
N#define EXTI_EMR_EM10_Msk         (0x1UL << EXTI_EMR_EM10_Pos)                  /*!< 0x00000400 */
N#define EXTI_EMR_EM10             EXTI_EMR_EM10_Msk                             /*!< Event Mask on line 10 */
N
N#define EXTI_EMR_EM11_Pos         (11U)
N#define EXTI_EMR_EM11_Msk         (0x1UL << EXTI_EMR_EM11_Pos)                  /*!< 0x00000800 */
N#define EXTI_EMR_EM11             EXTI_EMR_EM11_Msk                             /*!< Event Mask on line 11 */
N
N#define EXTI_EMR_EM12_Pos         (12U)
N#define EXTI_EMR_EM12_Msk         (0x1UL << EXTI_EMR_EM12_Pos)                  /*!< 0x00001000 */
N#define EXTI_EMR_EM12             EXTI_EMR_EM12_Msk                             /*!< Event Mask on line 12 */
N
N#define EXTI_EMR_EM13_Pos         (13U)
N#define EXTI_EMR_EM13_Msk         (0x1UL << EXTI_EMR_EM13_Pos)                  /*!< 0x00002000 */
N#define EXTI_EMR_EM13             EXTI_EMR_EM13_Msk                             /*!< Event Mask on line 13 */
N
N#define EXTI_EMR_EM14_Pos         (14U)
N#define EXTI_EMR_EM14_Msk         (0x1UL << EXTI_EMR_EM14_Pos)                  /*!< 0x00004000 */
N#define EXTI_EMR_EM14             EXTI_EMR_EM14_Msk                             /*!< Event Mask on line 14 */
N
N#define EXTI_EMR_EM15_Pos         (15U)
N#define EXTI_EMR_EM15_Msk         (0x1UL << EXTI_EMR_EM15_Pos)                  /*!< 0x00008000 */
N#define EXTI_EMR_EM15             EXTI_EMR_EM15_Msk                             /*!< Event Mask on line 15 */
N
N#define EXTI_EMR_EM16_Pos         (16U)
N#define EXTI_EMR_EM16_Msk         (0x1UL << EXTI_EMR_EM16_Pos)                  /*!< 0x00010000 */
N#define EXTI_EMR_EM16             EXTI_EMR_EM16_Msk                             /*!< Event Mask on line 16 */
N
N#define EXTI_EMR_EM17_Pos         (17U)
N#define EXTI_EMR_EM17_Msk         (0x1UL << EXTI_EMR_EM17_Pos)                  /*!< 0x00020000 */
N#define EXTI_EMR_EM17             EXTI_EMR_EM17_Msk                             /*!< Event Mask on line 17 */
N
N#define EXTI_EMR_EM19_Pos         (19U)
N#define EXTI_EMR_EM19_Msk         (0x1UL << EXTI_EMR_EM19_Pos)                  /*!< 0x00080000 */
N#define EXTI_EMR_EM19             EXTI_EMR_EM19_Msk                             /*!< Event Mask on line 19 */
N
N#define EXTI_EMR_EM21_Pos         (21U)
N#define EXTI_EMR_EM21_Msk         (0x1UL << EXTI_EMR_EM21_Pos)                  /*!< 0x00200000 */
N#define EXTI_EMR_EM21             EXTI_EMR_EM21_Msk                             /*!< Event Mask on line 21 */
N
N#define EXTI_EMR_EM22_Pos         (22U)
N#define EXTI_EMR_EM22_Msk         (0x1UL << EXTI_EMR_EM22_Pos)                  /*!< 0x00400000 */
N#define EXTI_EMR_EM22             EXTI_EMR_EM22_Msk                             /*!< Event Mask on line 22 */
N
N#define EXTI_EMR_EM23_Pos         (23U)
N#define EXTI_EMR_EM23_Msk         (0x1UL << EXTI_EMR_EM23_Pos)                  /*!< 0x00800000 */
N#define EXTI_EMR_EM23             EXTI_EMR_EM23_Msk                             /*!< Event Mask on line 23 */
N
N#define EXTI_EMR_EM25_Pos         (25U)
N#define EXTI_EMR_EM25_Msk         (0x1UL << EXTI_EMR_EM25_Pos)                  /*!< 0x02000000 */
N#define EXTI_EMR_EM25             EXTI_EMR_EM25_Msk                             /*!< Event Mask on line 25 */
N
N#define EXTI_EMR_EM_Pos           (0U)
N#define EXTI_EMR_EM_Msk           (0x0AEBFFFFUL << EXTI_EMR_EM_Pos)             /*!< 0x0AEBFFFF */
N#define EXTI_EMR_EM               EXTI_EMR_EM_Msk                               /*!< Event Mask All */
N
N/*******************  Bit definition for EXTI_RTSR register  ******************/
N#define EXTI_RTSR_RT0_Pos         (0U)
N#define EXTI_RTSR_RT0_Msk         (0x1UL << EXTI_RTSR_RT0_Pos)                  /*!< 0x00000001 */
N#define EXTI_RTSR_RT0             EXTI_RTSR_RT0_Msk                             /*!< Rising trigger event configuration bit of line 0 */
N
N#define EXTI_RTSR_RT1_Pos         (1U)
N#define EXTI_RTSR_RT1_Msk         (0x1UL << EXTI_RTSR_RT1_Pos)                  /*!< 0x00000002 */
N#define EXTI_RTSR_RT1             EXTI_RTSR_RT1_Msk                             /*!< Rising trigger event configuration bit of line 1 */
N
N#define EXTI_RTSR_RT2_Pos         (2U)
N#define EXTI_RTSR_RT2_Msk         (0x1UL << EXTI_RTSR_RT2_Pos)                  /*!< 0x00000004 */
N#define EXTI_RTSR_RT2             EXTI_RTSR_RT2_Msk                             /*!< Rising trigger event configuration bit of line 2 */
N
N#define EXTI_RTSR_RT3_Pos         (3U)
N#define EXTI_RTSR_RT3_Msk         (0x1UL << EXTI_RTSR_RT3_Pos)                  /*!< 0x00000008 */
N#define EXTI_RTSR_RT3             EXTI_RTSR_RT3_Msk                             /*!< Rising trigger event configuration bit of line 3 */
N
N#define EXTI_RTSR_RT4_Pos         (4U)
N#define EXTI_RTSR_RT4_Msk         (0x1UL << EXTI_RTSR_RT4_Pos)                  /*!< 0x00000010 */
N#define EXTI_RTSR_RT4             EXTI_RTSR_RT4_Msk                             /*!< Rising trigger event configuration bit of line 4 */
N
N#define EXTI_RTSR_RT5_Pos         (5U)
N#define EXTI_RTSR_RT5_Msk         (0x1UL << EXTI_RTSR_RT5_Pos)                  /*!< 0x00000020 */
N#define EXTI_RTSR_RT5             EXTI_RTSR_RT5_Msk                             /*!< Rising trigger event configuration bit of line 5 */
N
N#define EXTI_RTSR_RT6_Pos         (6U)
N#define EXTI_RTSR_RT6_Msk         (0x1UL << EXTI_RTSR_RT6_Pos)                  /*!< 0x00000040 */
N#define EXTI_RTSR_RT6             EXTI_RTSR_RT6_Msk                             /*!< Rising trigger event configuration bit of line 6 */
N
N#define EXTI_RTSR_RT7_Pos         (7U)
N#define EXTI_RTSR_RT7_Msk         (0x1UL << EXTI_RTSR_RT7_Pos)                  /*!< 0x00000080 */
N#define EXTI_RTSR_RT7             EXTI_RTSR_RT7_Msk                             /*!< Rising trigger event configuration bit of line 7 */
N
N#define EXTI_RTSR_RT8_Pos         (8U)
N#define EXTI_RTSR_RT8_Msk         (0x1UL << EXTI_RTSR_RT8_Pos)                  /*!< 0x00000100 */
N#define EXTI_RTSR_RT8             EXTI_RTSR_RT8_Msk                             /*!< Rising trigger event configuration bit of line 8 */
N
N#define EXTI_RTSR_RT9_Pos         (9U)
N#define EXTI_RTSR_RT9_Msk         (0x1UL << EXTI_RTSR_RT9_Pos)                  /*!< 0x00000200 */
N#define EXTI_RTSR_RT9             EXTI_RTSR_RT9_Msk                             /*!< Rising trigger event configuration bit of line 9 */
N
N#define EXTI_RTSR_RT10_Pos        (10U)
N#define EXTI_RTSR_RT10_Msk        (0x1UL << EXTI_RTSR_RT10_Pos)                 /*!< 0x00000400 */
N#define EXTI_RTSR_RT10            EXTI_RTSR_RT10_Msk                            /*!< Rising trigger event configuration bit of line 10 */
N
N#define EXTI_RTSR_RT11_Pos        (11U)
N#define EXTI_RTSR_RT11_Msk        (0x1UL << EXTI_RTSR_RT11_Pos)                 /*!< 0x00000800 */
N#define EXTI_RTSR_RT11            EXTI_RTSR_RT11_Msk                            /*!< Rising trigger event configuration bit of line 11 */
N
N#define EXTI_RTSR_RT12_Pos        (12U)
N#define EXTI_RTSR_RT12_Msk        (0x1UL << EXTI_RTSR_RT12_Pos)                 /*!< 0x00001000 */
N#define EXTI_RTSR_RT12            EXTI_RTSR_RT12_Msk                            /*!< Rising trigger event configuration bit of line 12 */
N
N#define EXTI_RTSR_RT13_Pos        (13U)
N#define EXTI_RTSR_RT13_Msk        (0x1UL << EXTI_RTSR_RT13_Pos)                 /*!< 0x00002000 */
N#define EXTI_RTSR_RT13            EXTI_RTSR_RT13_Msk                            /*!< Rising trigger event configuration bit of line 13 */
N
N#define EXTI_RTSR_RT14_Pos        (14U)
N#define EXTI_RTSR_RT14_Msk        (0x1UL << EXTI_RTSR_RT14_Pos)                 /*!< 0x00004000 */
N#define EXTI_RTSR_RT14            EXTI_RTSR_RT14_Msk                            /*!< Rising trigger event configuration bit of line 14 */
N
N#define EXTI_RTSR_RT15_Pos        (15U)
N#define EXTI_RTSR_RT15_Msk        (0x1UL << EXTI_RTSR_RT15_Pos)                 /*!< 0x00008000 */
N#define EXTI_RTSR_RT15            EXTI_RTSR_RT15_Msk                            /*!< Rising trigger event configuration bit of line 15 */
N
N#define EXTI_RTSR_RT16_Pos        (16U)
N#define EXTI_RTSR_RT16_Msk        (0x1UL << EXTI_RTSR_RT16_Pos)                 /*!< 0x00010000 */
N#define EXTI_RTSR_RT16            EXTI_RTSR_RT16_Msk                            /*!< Rising trigger event configuration bit of line 16 */
N
N#define EXTI_RTSR_RT17_Pos        (17U)
N#define EXTI_RTSR_RT17_Msk        (0x1UL << EXTI_RTSR_RT17_Pos)                 /*!< 0x00020000 */
N#define EXTI_RTSR_RT17            EXTI_RTSR_RT17_Msk                            /*!< Rising trigger event configuration bit of line 17 */
N
N#define EXTI_RTSR_RT19_Pos        (19U)
N#define EXTI_RTSR_RT19_Msk        (0x1UL << EXTI_RTSR_RT19_Pos)                 /*!< 0x00080000 */
N#define EXTI_RTSR_RT19            EXTI_RTSR_RT19_Msk                            /*!< Rising trigger event configuration bit of line 19 */
N
N#define EXTI_RTSR_RT21_Pos        (21U)
N#define EXTI_RTSR_RT21_Msk        (0x1UL << EXTI_RTSR_RT21_Pos)                 /*!< 0x00200000 */
N#define EXTI_RTSR_RT21            EXTI_RTSR_RT21_Msk                            /*!< Rising trigger event configuration bit of line 21 */
N
N#define EXTI_RTSR_RT22_Pos        (22U)
N#define EXTI_RTSR_RT22_Msk        (0x1UL << EXTI_RTSR_RT22_Pos)                 /*!< 0x00400000 */
N#define EXTI_RTSR_RT22            EXTI_RTSR_RT22_Msk                            /*!< Rising trigger event configuration bit of line 22 */
N
N#define EXTI_RTSR_RT_Pos          (0U)
N#define EXTI_RTSR_RT_Msk          (0x006BFFFFUL << EXTI_RTSR_RT_Pos)            /*!< 0x006BFFFF */
N#define EXTI_RTSR_RT              EXTI_RTSR_RT_Msk                              /*!< Rising trigger event configuration All */
N
N/*******************  Bit definition for EXTI_FTSR register *******************/
N#define EXTI_FTSR_FT0_Pos         (0U)
N#define EXTI_FTSR_FT0_Msk         (0x1UL << EXTI_FTSR_FT0_Pos)                  /*!< 0x00000001 */
N#define EXTI_FTSR_FT0             EXTI_FTSR_FT0_Msk                             /*!< Falling trigger event configuration bit of line 0 */
N
N#define EXTI_FTSR_FT1_Pos         (1U)
N#define EXTI_FTSR_FT1_Msk         (0x1UL << EXTI_FTSR_FT1_Pos)                  /*!< 0x00000002 */
N#define EXTI_FTSR_FT1             EXTI_FTSR_FT1_Msk                             /*!< Falling trigger event configuration bit of line 1 */
N
N#define EXTI_FTSR_FT2_Pos         (2U)
N#define EXTI_FTSR_FT2_Msk         (0x1UL << EXTI_FTSR_FT2_Pos)                  /*!< 0x00000004 */
N#define EXTI_FTSR_FT2             EXTI_FTSR_FT2_Msk                             /*!< Falling trigger event configuration bit of line 2 */
N
N#define EXTI_FTSR_FT3_Pos         (3U)
N#define EXTI_FTSR_FT3_Msk         (0x1UL << EXTI_FTSR_FT3_Pos)                  /*!< 0x00000008 */
N#define EXTI_FTSR_FT3             EXTI_FTSR_FT3_Msk                             /*!< Falling trigger event configuration bit of line 3 */
N
N#define EXTI_FTSR_FT4_Pos         (4U)
N#define EXTI_FTSR_FT4_Msk         (0x1UL << EXTI_FTSR_FT4_Pos)                  /*!< 0x00000010 */
N#define EXTI_FTSR_FT4             EXTI_FTSR_FT4_Msk                             /*!< Falling trigger event configuration bit of line 4 */
N
N#define EXTI_FTSR_FT5_Pos         (5U)
N#define EXTI_FTSR_FT5_Msk         (0x1UL << EXTI_FTSR_FT5_Pos)                  /*!< 0x00000020 */
N#define EXTI_FTSR_FT5             EXTI_FTSR_FT5_Msk                             /*!< Falling trigger event configuration bit of line 5 */
N
N#define EXTI_FTSR_FT6_Pos         (6U)
N#define EXTI_FTSR_FT6_Msk         (0x1UL << EXTI_FTSR_FT6_Pos)                  /*!< 0x00000040 */
N#define EXTI_FTSR_FT6             EXTI_FTSR_FT6_Msk                             /*!< Falling trigger event configuration bit of line 6 */
N
N#define EXTI_FTSR_FT7_Pos         (7U)
N#define EXTI_FTSR_FT7_Msk         (0x1UL << EXTI_FTSR_FT7_Pos)                  /*!< 0x00000080 */
N#define EXTI_FTSR_FT7             EXTI_FTSR_FT7_Msk                             /*!< Falling trigger event configuration bit of line 7 */
N
N#define EXTI_FTSR_FT8_Pos         (8U)
N#define EXTI_FTSR_FT8_Msk         (0x1UL << EXTI_FTSR_FT8_Pos)                  /*!< 0x00000100 */
N#define EXTI_FTSR_FT8             EXTI_FTSR_FT8_Msk                             /*!< Falling trigger event configuration bit of line 8 */
N
N#define EXTI_FTSR_FT9_Pos         (9U)
N#define EXTI_FTSR_FT9_Msk         (0x1UL << EXTI_FTSR_FT9_Pos)                  /*!< 0x00000200 */
N#define EXTI_FTSR_FT9             EXTI_FTSR_FT9_Msk                             /*!< Falling trigger event configuration bit of line 9 */
N
N#define EXTI_FTSR_FT10_Pos        (10U)
N#define EXTI_FTSR_FT10_Msk        (0x1UL << EXTI_FTSR_FT10_Pos)                 /*!< 0x00000400 */
N#define EXTI_FTSR_FT10            EXTI_FTSR_FT10_Msk                            /*!< Falling trigger event configuration bit of line 10 */
N
N#define EXTI_FTSR_FT11_Pos        (11U)
N#define EXTI_FTSR_FT11_Msk        (0x1UL << EXTI_FTSR_FT11_Pos)                 /*!< 0x00000800 */
N#define EXTI_FTSR_FT11            EXTI_FTSR_FT11_Msk                            /*!< Falling trigger event configuration bit of line 11 */
N
N#define EXTI_FTSR_FT12_Pos        (12U)
N#define EXTI_FTSR_FT12_Msk        (0x1UL << EXTI_FTSR_FT12_Pos)                 /*!< 0x00001000 */
N#define EXTI_FTSR_FT12            EXTI_FTSR_FT12_Msk                            /*!< Falling trigger event configuration bit of line 12 */
N
N#define EXTI_FTSR_FT13_Pos        (13U)
N#define EXTI_FTSR_FT13_Msk        (0x1UL << EXTI_FTSR_FT13_Pos)                 /*!< 0x00002000 */
N#define EXTI_FTSR_FT13            EXTI_FTSR_FT13_Msk                            /*!< Falling trigger event configuration bit of line 13 */
N
N#define EXTI_FTSR_FT14_Pos        (14U)
N#define EXTI_FTSR_FT14_Msk        (0x1UL << EXTI_FTSR_FT14_Pos)                 /*!< 0x00004000 */
N#define EXTI_FTSR_FT14            EXTI_FTSR_FT14_Msk                            /*!< Falling trigger event configuration bit of line 14 */
N
N#define EXTI_FTSR_FT15_Pos        (15U)
N#define EXTI_FTSR_FT15_Msk        (0x1UL << EXTI_FTSR_FT15_Pos)                 /*!< 0x00008000 */
N#define EXTI_FTSR_FT15            EXTI_FTSR_FT15_Msk                            /*!< Falling trigger event configuration bit of line 15 */
N
N#define EXTI_FTSR_FT16_Pos        (16U)
N#define EXTI_FTSR_FT16_Msk        (0x1UL << EXTI_FTSR_FT16_Pos)                 /*!< 0x00010000 */
N#define EXTI_FTSR_FT16            EXTI_FTSR_FT16_Msk                            /*!< Falling trigger event configuration bit of line 16 */
N
N#define EXTI_FTSR_FT17_Pos        (17U)
N#define EXTI_FTSR_FT17_Msk        (0x1UL << EXTI_FTSR_FT17_Pos)                 /*!< 0x00020000 */
N#define EXTI_FTSR_FT17            EXTI_FTSR_FT17_Msk                            /*!< Falling trigger event configuration bit of line 17 */
N
N#define EXTI_FTSR_FT19_Pos        (19U)
N#define EXTI_FTSR_FT19_Msk        (0x1UL << EXTI_FTSR_FT19_Pos)                 /*!< 0x00080000 */
N#define EXTI_FTSR_FT19            EXTI_FTSR_FT19_Msk                            /*!< Falling trigger event configuration bit of line 19 */
N
N#define EXTI_FTSR_FT21_Pos        (21U)
N#define EXTI_FTSR_FT21_Msk        (0x1UL << EXTI_FTSR_FT21_Pos)                 /*!< 0x00200000 */
N#define EXTI_FTSR_FT21            EXTI_FTSR_FT21_Msk                            /*!< Falling trigger event configuration bit of line 21 */
N
N#define EXTI_FTSR_FT22_Pos        (22U)
N#define EXTI_FTSR_FT22_Msk        (0x1UL << EXTI_FTSR_FT22_Pos)                 /*!< 0x00400000 */
N#define EXTI_FTSR_FT22            EXTI_FTSR_FT22_Msk                            /*!< Falling trigger event configuration bit of line 22 */
N
N#define EXTI_FTSR_FT_Pos          (0U)
N#define EXTI_FTSR_FT_Msk          (0x006BFFFFUL << EXTI_FTSR_FT_Pos)            /*!< 0x006BFFFF */
N#define EXTI_FTSR_FT              EXTI_FTSR_FT_Msk                              /*!< Falling trigger event configuration All */
N
N/******************* Bit definition for EXTI_SWIER register *******************/
N#define EXTI_SWIER_SWI0_Pos       (0U)
N#define EXTI_SWIER_SWI0_Msk       (0x1UL << EXTI_SWIER_SWI0_Pos)                /*!< 0x00000001 */
N#define EXTI_SWIER_SWI0           EXTI_SWIER_SWI0_Msk                           /*!< Software Interrupt on line 0  */
N
N#define EXTI_SWIER_SWI1_Pos       (1U)
N#define EXTI_SWIER_SWI1_Msk       (0x1UL << EXTI_SWIER_SWI1_Pos)                /*!< 0x00000002 */
N#define EXTI_SWIER_SWI1           EXTI_SWIER_SWI1_Msk                           /*!< Software Interrupt on line 1  */
N
N#define EXTI_SWIER_SWI2_Pos       (2U)
N#define EXTI_SWIER_SWI2_Msk       (0x1UL << EXTI_SWIER_SWI2_Pos)                /*!< 0x00000004 */
N#define EXTI_SWIER_SWI2           EXTI_SWIER_SWI2_Msk                           /*!< Software Interrupt on line 2  */
N
N#define EXTI_SWIER_SWI3_Pos       (3U)
N#define EXTI_SWIER_SWI3_Msk       (0x1UL << EXTI_SWIER_SWI3_Pos)                /*!< 0x00000008 */
N#define EXTI_SWIER_SWI3           EXTI_SWIER_SWI3_Msk                           /*!< Software Interrupt on line 3  */
N
N#define EXTI_SWIER_SWI4_Pos       (4U)
N#define EXTI_SWIER_SWI4_Msk       (0x1UL << EXTI_SWIER_SWI4_Pos)                /*!< 0x00000010 */
N#define EXTI_SWIER_SWI4           EXTI_SWIER_SWI4_Msk                           /*!< Software Interrupt on line 4  */
N
N#define EXTI_SWIER_SWI5_Pos       (5U)
N#define EXTI_SWIER_SWI5_Msk       (0x1UL << EXTI_SWIER_SWI5_Pos)                /*!< 0x00000020 */
N#define EXTI_SWIER_SWI5           EXTI_SWIER_SWI5_Msk                           /*!< Software Interrupt on line 5  */
N
N#define EXTI_SWIER_SWI6_Pos       (6U)
N#define EXTI_SWIER_SWI6_Msk       (0x1UL << EXTI_SWIER_SWI6_Pos)                /*!< 0x00000040 */
N#define EXTI_SWIER_SWI6           EXTI_SWIER_SWI6_Msk                           /*!< Software Interrupt on line 6  */
N
N#define EXTI_SWIER_SWI7_Pos       (7U)
N#define EXTI_SWIER_SWI7_Msk       (0x1UL << EXTI_SWIER_SWI7_Pos)                /*!< 0x00000080 */
N#define EXTI_SWIER_SWI7           EXTI_SWIER_SWI7_Msk                           /*!< Software Interrupt on line 7  */
N
N#define EXTI_SWIER_SWI8_Pos       (8U)
N#define EXTI_SWIER_SWI8_Msk       (0x1UL << EXTI_SWIER_SWI8_Pos)                /*!< 0x00000100 */
N#define EXTI_SWIER_SWI8           EXTI_SWIER_SWI8_Msk                           /*!< Software Interrupt on line 8  */
N
N#define EXTI_SWIER_SWI9_Pos       (9U)
N#define EXTI_SWIER_SWI9_Msk       (0x1UL << EXTI_SWIER_SWI9_Pos)                /*!< 0x00000200 */
N#define EXTI_SWIER_SWI9           EXTI_SWIER_SWI9_Msk                           /*!< Software Interrupt on line 9  */
N
N#define EXTI_SWIER_SWI10_Pos      (10U)
N#define EXTI_SWIER_SWI10_Msk      (0x1UL << EXTI_SWIER_SWI10_Pos)               /*!< 0x00000400 */
N#define EXTI_SWIER_SWI10          EXTI_SWIER_SWI10_Msk                          /*!< Software Interrupt on line 10 */
N
N#define EXTI_SWIER_SWI11_Pos      (11U)
N#define EXTI_SWIER_SWI11_Msk      (0x1UL << EXTI_SWIER_SWI11_Pos)               /*!< 0x00000800 */
N#define EXTI_SWIER_SWI11          EXTI_SWIER_SWI11_Msk                          /*!< Software Interrupt on line 11 */
N
N#define EXTI_SWIER_SWI12_Pos      (12U)
N#define EXTI_SWIER_SWI12_Msk      (0x1UL << EXTI_SWIER_SWI12_Pos)               /*!< 0x00001000 */
N#define EXTI_SWIER_SWI12          EXTI_SWIER_SWI12_Msk                          /*!< Software Interrupt on line 12 */
N
N#define EXTI_SWIER_SWI13_Pos      (13U)
N#define EXTI_SWIER_SWI13_Msk      (0x1UL << EXTI_SWIER_SWI13_Pos)               /*!< 0x00002000 */
N#define EXTI_SWIER_SWI13          EXTI_SWIER_SWI13_Msk                          /*!< Software Interrupt on line 13 */
N
N#define EXTI_SWIER_SWI14_Pos      (14U)
N#define EXTI_SWIER_SWI14_Msk      (0x1UL << EXTI_SWIER_SWI14_Pos)               /*!< 0x00004000 */
N#define EXTI_SWIER_SWI14          EXTI_SWIER_SWI14_Msk                          /*!< Software Interrupt on line 14 */
N
N#define EXTI_SWIER_SWI15_Pos      (15U)
N#define EXTI_SWIER_SWI15_Msk      (0x1UL << EXTI_SWIER_SWI15_Pos)               /*!< 0x00008000 */
N#define EXTI_SWIER_SWI15          EXTI_SWIER_SWI15_Msk                          /*!< Software Interrupt on line 15 */
N
N#define EXTI_SWIER_SWI16_Pos      (16U)
N#define EXTI_SWIER_SWI16_Msk      (0x1UL << EXTI_SWIER_SWI16_Pos)               /*!< 0x00010000 */
N#define EXTI_SWIER_SWI16          EXTI_SWIER_SWI16_Msk                          /*!< Software Interrupt on line 16 */
N
N#define EXTI_SWIER_SWI17_Pos      (17U)
N#define EXTI_SWIER_SWI17_Msk      (0x1UL << EXTI_SWIER_SWI17_Pos)               /*!< 0x00020000 */
N#define EXTI_SWIER_SWI17          EXTI_SWIER_SWI17_Msk                          /*!< Software Interrupt on line 17 */
N
N#define EXTI_SWIER_SWI19_Pos      (19U)
N#define EXTI_SWIER_SWI19_Msk      (0x1UL << EXTI_SWIER_SWI19_Pos)               /*!< 0x00080000 */
N#define EXTI_SWIER_SWI19          EXTI_SWIER_SWI19_Msk                          /*!< Software Interrupt on line 19 */
N
N#define EXTI_SWIER_SWI21_Pos      (21U)
N#define EXTI_SWIER_SWI21_Msk      (0x1UL << EXTI_SWIER_SWI21_Pos)               /*!< 0x00200000 */
N#define EXTI_SWIER_SWI21          EXTI_SWIER_SWI21_Msk                          /*!< Software Interrupt on line 21 */
N
N#define EXTI_SWIER_SWI22_Pos      (22U)
N#define EXTI_SWIER_SWI22_Msk      (0x1UL << EXTI_SWIER_SWI22_Pos)               /*!< 0x00400000 */
N#define EXTI_SWIER_SWI22          EXTI_SWIER_SWI22_Msk                          /*!< Software Interrupt on line 22 */
N
N#define EXTI_SWIER_SWI_Pos        (0U)
N#define EXTI_SWIER_SWI_Msk        (0x006BFFFFUL << EXTI_SWIER_SWI_Pos)          /*!< 0x006BFFFF */
N#define EXTI_SWIER_SWI            EXTI_SWIER_SWI_Msk                            /*!< Software Interrupt All */
N
N/******************  Bit definition for EXTI_PR register  *********************/
N#define EXTI_PR_PIF0_Pos          (0U)
N#define EXTI_PR_PIF0_Msk          (0x1UL << EXTI_PR_PIF0_Pos)                   /*!< 0x00000001 */
N#define EXTI_PR_PIF0              EXTI_PR_PIF0_Msk                              /*!< Pending bit 0  */
N
N#define EXTI_PR_PIF1_Pos          (1U)
N#define EXTI_PR_PIF1_Msk          (0x1UL << EXTI_PR_PIF1_Pos)                   /*!< 0x00000002 */
N#define EXTI_PR_PIF1              EXTI_PR_PIF1_Msk                              /*!< Pending bit 1  */
N
N#define EXTI_PR_PIF2_Pos          (2U)
N#define EXTI_PR_PIF2_Msk          (0x1UL << EXTI_PR_PIF2_Pos)                   /*!< 0x00000004 */
N#define EXTI_PR_PIF2              EXTI_PR_PIF2_Msk                              /*!< Pending bit 2  */
N
N#define EXTI_PR_PIF3_Pos          (3U)
N#define EXTI_PR_PIF3_Msk          (0x1UL << EXTI_PR_PIF3_Pos)                   /*!< 0x00000008 */
N#define EXTI_PR_PIF3              EXTI_PR_PIF3_Msk                              /*!< Pending bit 3  */
N
N#define EXTI_PR_PIF4_Pos          (4U)
N#define EXTI_PR_PIF4_Msk          (0x1UL << EXTI_PR_PIF4_Pos)                   /*!< 0x00000010 */
N#define EXTI_PR_PIF4              EXTI_PR_PIF4_Msk                              /*!< Pending bit 4  */
N
N#define EXTI_PR_PIF5_Pos          (5U)
N#define EXTI_PR_PIF5_Msk          (0x1UL << EXTI_PR_PIF5_Pos)                   /*!< 0x00000020 */
N#define EXTI_PR_PIF5              EXTI_PR_PIF5_Msk                              /*!< Pending bit 5  */
N
N#define EXTI_PR_PIF6_Pos          (6U)
N#define EXTI_PR_PIF6_Msk          (0x1UL << EXTI_PR_PIF6_Pos)                   /*!< 0x00000040 */
N#define EXTI_PR_PIF6              EXTI_PR_PIF6_Msk                              /*!< Pending bit 6  */
N
N#define EXTI_PR_PIF7_Pos          (7U)
N#define EXTI_PR_PIF7_Msk          (0x1UL << EXTI_PR_PIF7_Pos)                   /*!< 0x00000080 */
N#define EXTI_PR_PIF7              EXTI_PR_PIF7_Msk                              /*!< Pending bit 7  */
N
N#define EXTI_PR_PIF8_Pos          (8U)
N#define EXTI_PR_PIF8_Msk          (0x1UL << EXTI_PR_PIF8_Pos)                   /*!< 0x00000100 */
N#define EXTI_PR_PIF8              EXTI_PR_PIF8_Msk                              /*!< Pending bit 8  */
N
N#define EXTI_PR_PIF9_Pos          (9U)
N#define EXTI_PR_PIF9_Msk          (0x1UL << EXTI_PR_PIF9_Pos)                   /*!< 0x00000200 */
N#define EXTI_PR_PIF9              EXTI_PR_PIF9_Msk                              /*!< Pending bit 9  */
N
N#define EXTI_PR_PIF10_Pos         (10U)
N#define EXTI_PR_PIF10_Msk         (0x1UL << EXTI_PR_PIF10_Pos)                  /*!< 0x00000400 */
N#define EXTI_PR_PIF10             EXTI_PR_PIF10_Msk                             /*!< Pending bit 10 */
N
N#define EXTI_PR_PIF11_Pos         (11U)
N#define EXTI_PR_PIF11_Msk         (0x1UL << EXTI_PR_PIF11_Pos)                  /*!< 0x00000800 */
N#define EXTI_PR_PIF11             EXTI_PR_PIF11_Msk                             /*!< Pending bit 11 */
N
N#define EXTI_PR_PIF12_Pos         (12U)
N#define EXTI_PR_PIF12_Msk         (0x1UL << EXTI_PR_PIF12_Pos)                  /*!< 0x00001000 */
N#define EXTI_PR_PIF12             EXTI_PR_PIF12_Msk                             /*!< Pending bit 12 */
N
N#define EXTI_PR_PIF13_Pos         (13U)
N#define EXTI_PR_PIF13_Msk         (0x1UL << EXTI_PR_PIF13_Pos)                  /*!< 0x00002000 */
N#define EXTI_PR_PIF13             EXTI_PR_PIF13_Msk                             /*!< Pending bit 13 */
N
N#define EXTI_PR_PIF14_Pos         (14U)
N#define EXTI_PR_PIF14_Msk         (0x1UL << EXTI_PR_PIF14_Pos)                  /*!< 0x00004000 */
N#define EXTI_PR_PIF14             EXTI_PR_PIF14_Msk                             /*!< Pending bit 14 */
N
N#define EXTI_PR_PIF15_Pos         (15U)
N#define EXTI_PR_PIF15_Msk         (0x1UL << EXTI_PR_PIF15_Pos)                  /*!< 0x00008000 */
N#define EXTI_PR_PIF15             EXTI_PR_PIF15_Msk                             /*!< Pending bit 15 */
N
N#define EXTI_PR_PIF16_Pos         (16U)
N#define EXTI_PR_PIF16_Msk         (0x1UL << EXTI_PR_PIF16_Pos)                  /*!< 0x00010000 */
N#define EXTI_PR_PIF16             EXTI_PR_PIF16_Msk                             /*!< Pending bit 16 */
N
N#define EXTI_PR_PIF17_Pos         (17U)
N#define EXTI_PR_PIF17_Msk         (0x1UL << EXTI_PR_PIF17_Pos)                  /*!< 0x00020000 */
N#define EXTI_PR_PIF17             EXTI_PR_PIF17_Msk                             /*!< Pending bit 17 */
N
N#define EXTI_PR_PIF19_Pos         (19U)
N#define EXTI_PR_PIF19_Msk         (0x1UL << EXTI_PR_PIF19_Pos)                  /*!< 0x00080000 */
N#define EXTI_PR_PIF19             EXTI_PR_PIF19_Msk                             /*!< Pending bit 19 */
N
N#define EXTI_PR_PIF21_Pos         (21U)
N#define EXTI_PR_PIF21_Msk         (0x1UL << EXTI_PR_PIF21_Pos)                  /*!< 0x00200000 */
N#define EXTI_PR_PIF21             EXTI_PR_PIF21_Msk                             /*!< Pending bit 21 */
N
N#define EXTI_PR_PIF22_Pos         (22U)
N#define EXTI_PR_PIF22_Msk         (0x1UL << EXTI_PR_PIF22_Pos)                  /*!< 0x00400000 */
N#define EXTI_PR_PIF22             EXTI_PR_PIF22_Msk                             /*!< Pending bit 22 */
N
N#define EXTI_PR_PIF_Pos           (0U)
N#define EXTI_PR_PIF_Msk           (0x006BFFFFUL << EXTI_PR_PIF_Pos)             /*!< 0x006BFFFF */
N#define EXTI_PR_PIF               EXTI_PR_PIF_Msk                               /*!< Pending All */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                      FLASH and Option Bytes Registers                      */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for FLASH_ACR register  ******************/
N#define FLASH_ACR_LATENCY_Pos             (0U)
N#define FLASH_ACR_LATENCY_Msk             (0x1UL << FLASH_ACR_LATENCY_Pos)            /*!< 0x00000001 */
N#define FLASH_ACR_LATENCY                 FLASH_ACR_LATENCY_Msk                       /*!< LATENCY bit (Latency) */
N
N#define FLASH_ACR_PRFTBE_Pos              (4U)
N#define FLASH_ACR_PRFTBE_Msk              (0x1UL << FLASH_ACR_PRFTBE_Pos)             /*!< 0x00000010 */
N#define FLASH_ACR_PRFTBE                  FLASH_ACR_PRFTBE_Msk                        /*!< Prefetch Buffer Enable */
N
N#define FLASH_ACR_PRFTBS_Pos              (5U)
N#define FLASH_ACR_PRFTBS_Msk              (0x1UL << FLASH_ACR_PRFTBS_Pos)             /*!< 0x00000020 */
N#define FLASH_ACR_PRFTBS                  FLASH_ACR_PRFTBS_Msk                        /*!< Prefetch Buffer Status */
N
N/******************  Bit definition for FLASH_KEYR register  ******************/
N#define FLASH_KEYR_FKEYR_Pos              (0U)
N#define FLASH_KEYR_FKEYR_Msk              (0xFFFFFFFFUL << FLASH_KEYR_FKEYR_Pos)      /*!< 0xFFFFFFFF */
N#define FLASH_KEYR_FKEYR                  FLASH_KEYR_FKEYR_Msk                        /*!< FPEC Key */
N
N/*****************  Bit definition for FLASH_OPTKEYR register  ****************/
N#define FLASH_OPTKEYR_OPTKEYR_Pos         (0U)
N#define FLASH_OPTKEYR_OPTKEYR_Msk         (0xFFFFFFFFUL << FLASH_OPTKEYR_OPTKEYR_Pos) /*!< 0xFFFFFFFF */
N#define FLASH_OPTKEYR_OPTKEYR             FLASH_OPTKEYR_OPTKEYR_Msk                   /*!< Option Byte Key */
N
N/******************  FLASH Keys  **********************************************/
N#define FLASH_KEY1_Pos                    (0U)
N#define FLASH_KEY1_Msk                    (0x45670123UL << FLASH_KEY1_Pos)            /*!< 0x45670123 */
N#define FLASH_KEY1                        FLASH_KEY1_Msk                              /*!< Flash program erase key1 */
N
N#define FLASH_KEY2_Pos                    (0U)
N#define FLASH_KEY2_Msk                    (0xCDEF89ABUL << FLASH_KEY2_Pos)            /*!< 0xCDEF89AB */
N#define FLASH_KEY2                        FLASH_KEY2_Msk                              /*!< Flash program erase key2: used with FLASH_PEKEY1 to unlock the write access to the FPEC. */
N
N#define FLASH_OPTKEY1_Pos                 (0U)
N#define FLASH_OPTKEY1_Msk                 (0x45670123UL << FLASH_OPTKEY1_Pos)         /*!< 0x45670123 */
N#define FLASH_OPTKEY1                     FLASH_OPTKEY1_Msk                           /*!< Flash option key1 */
N
N#define FLASH_OPTKEY2_Pos                 (0U)
N#define FLASH_OPTKEY2_Msk                 (0xCDEF89ABUL << FLASH_OPTKEY2_Pos)         /*!< 0xCDEF89AB */
N#define FLASH_OPTKEY2                     FLASH_OPTKEY2_Msk                           /*!< Flash option key2: used with FLASH_OPTKEY1 to unlock the write access to the option byte block */
N
N/******************  Bit definition for FLASH_SR register  *******************/
N#define FLASH_SR_BSY_Pos                  (0U)
N#define FLASH_SR_BSY_Msk                  (0x1UL << FLASH_SR_BSY_Pos)                 /*!< 0x00000001 */
N#define FLASH_SR_BSY                      FLASH_SR_BSY_Msk                            /*!< Busy */
N
N#define FLASH_SR_PGERR_Pos                (2U)
N#define FLASH_SR_PGERR_Msk                (0x1UL << FLASH_SR_PGERR_Pos)               /*!< 0x00000004 */
N#define FLASH_SR_PGERR                    FLASH_SR_PGERR_Msk                          /*!< Programming Error */
N
N#define FLASH_SR_WRPRTERR_Pos             (4U)
N#define FLASH_SR_WRPRTERR_Msk             (0x1UL << FLASH_SR_WRPRTERR_Pos)            /*!< 0x00000010 */
N#define FLASH_SR_WRPRTERR                 FLASH_SR_WRPRTERR_Msk                       /*!< Write Protection Error */
N
N#define FLASH_SR_EOP_Pos                  (5U)
N#define FLASH_SR_EOP_Msk                  (0x1UL << FLASH_SR_EOP_Pos)                 /*!< 0x00000020 */
N#define FLASH_SR_EOP                      FLASH_SR_EOP_Msk                            /*!< End of operation */
N
N/*******************  Bit definition for FLASH_CR register  *******************/
N#define FLASH_CR_PG_Pos                   (0U)
N#define FLASH_CR_PG_Msk                   (0x1UL << FLASH_CR_PG_Pos)                  /*!< 0x00000001 */
N#define FLASH_CR_PG                       FLASH_CR_PG_Msk                             /*!< Programming */
N
N#define FLASH_CR_PER_Pos                  (1U)
N#define FLASH_CR_PER_Msk                  (0x1UL << FLASH_CR_PER_Pos)                 /*!< 0x00000002 */
N#define FLASH_CR_PER                      FLASH_CR_PER_Msk                            /*!< Page Erase */
N
N#define FLASH_CR_MER_Pos                  (2U)
N#define FLASH_CR_MER_Msk                  (0x1UL << FLASH_CR_MER_Pos)                 /*!< 0x00000004 */
N#define FLASH_CR_MER                      FLASH_CR_MER_Msk                            /*!< Mass Erase */
N
N#define FLASH_CR_OPTPG_Pos                (4U)
N#define FLASH_CR_OPTPG_Msk                (0x1UL << FLASH_CR_OPTPG_Pos)               /*!< 0x00000010 */
N#define FLASH_CR_OPTPG                    FLASH_CR_OPTPG_Msk                          /*!< Option Byte Programming */
N
N#define FLASH_CR_OPTER_Pos                (5U)
N#define FLASH_CR_OPTER_Msk                (0x1UL << FLASH_CR_OPTER_Pos)               /*!< 0x00000020 */
N#define FLASH_CR_OPTER                    FLASH_CR_OPTER_Msk                          /*!< Option Byte Erase */
N
N#define FLASH_CR_STRT_Pos                 (6U)
N#define FLASH_CR_STRT_Msk                 (0x1UL << FLASH_CR_STRT_Pos)                /*!< 0x00000040 */
N#define FLASH_CR_STRT                     FLASH_CR_STRT_Msk                           /*!< Start */
N
N#define FLASH_CR_LOCK_Pos                 (7U)
N#define FLASH_CR_LOCK_Msk                 (0x1UL << FLASH_CR_LOCK_Pos)                /*!< 0x00000080 */
N#define FLASH_CR_LOCK                     FLASH_CR_LOCK_Msk                           /*!< Lock */
N
N#define FLASH_CR_OPTWRE_Pos               (9U)
N#define FLASH_CR_OPTWRE_Msk               (0x1UL << FLASH_CR_OPTWRE_Pos)              /*!< 0x00000200 */
N#define FLASH_CR_OPTWRE                   FLASH_CR_OPTWRE_Msk                         /*!< Option Bytes Write Enable */
N
N#define FLASH_CR_ERRIE_Pos                (10U)
N#define FLASH_CR_ERRIE_Msk                (0x1UL << FLASH_CR_ERRIE_Pos)               /*!< 0x00000400 */
N#define FLASH_CR_ERRIE                    FLASH_CR_ERRIE_Msk                          /*!< Error Interrupt Enable */
N
N#define FLASH_CR_EOPIE_Pos                (12U)
N#define FLASH_CR_EOPIE_Msk                (0x1UL << FLASH_CR_EOPIE_Pos)               /*!< 0x00001000 */
N#define FLASH_CR_EOPIE                    FLASH_CR_EOPIE_Msk                          /*!< End of operation interrupt enable */
N
N#define FLASH_CR_OBL_LAUNCH_Pos           (13U)
N#define FLASH_CR_OBL_LAUNCH_Msk           (0x1UL << FLASH_CR_OBL_LAUNCH_Pos)          /*!< 0x00002000 */
N#define FLASH_CR_OBL_LAUNCH               FLASH_CR_OBL_LAUNCH_Msk                     /*!< Option Bytes Loader Launch */
N
N/*******************  Bit definition for FLASH_AR register  *******************/
N#define FLASH_AR_FAR_Pos                  (0U)
N#define FLASH_AR_FAR_Msk                  (0xFFFFFFFFUL << FLASH_AR_FAR_Pos)          /*!< 0xFFFFFFFF */
N#define FLASH_AR_FAR                      FLASH_AR_FAR_Msk                            /*!< Flash Address */
N
N/******************  Bit definition for FLASH_OBR register  *******************/
N#define FLASH_OBR_OPTERR_Pos              (0U)
N#define FLASH_OBR_OPTERR_Msk              (0x1UL << FLASH_OBR_OPTERR_Pos)             /*!< 0x00000001 */
N#define FLASH_OBR_OPTERR                  FLASH_OBR_OPTERR_Msk                        /*!< Option Byte Error */
N
N#define FLASH_OBR_RDPRT1_Pos              (1U)
N#define FLASH_OBR_RDPRT1_Msk              (0x1UL << FLASH_OBR_RDPRT1_Pos)             /*!< 0x00000002 */
N#define FLASH_OBR_RDPRT1                  FLASH_OBR_RDPRT1_Msk                        /*!< Read protection Level 1 */
N
N#define FLASH_OBR_RDPRT2_Pos              (2U)
N#define FLASH_OBR_RDPRT2_Msk              (0x1UL << FLASH_OBR_RDPRT2_Pos)             /*!< 0x00000004 */
N#define FLASH_OBR_RDPRT2                  FLASH_OBR_RDPRT2_Msk                        /*!< Read protection Level 2 */
N
N#define FLASH_OBR_USER_Pos                (8U)
N#define FLASH_OBR_USER_Msk                (0x77UL << FLASH_OBR_USER_Pos)              /*!< 0x00007700 */
N#define FLASH_OBR_USER                    FLASH_OBR_USER_Msk                          /*!< User Option Bytes */
N
N#define FLASH_OBR_IWDG_SW_Pos             (8U)
N#define FLASH_OBR_IWDG_SW_Msk             (0x1UL << FLASH_OBR_IWDG_SW_Pos)            /*!< 0x00000100 */
N#define FLASH_OBR_IWDG_SW                 FLASH_OBR_IWDG_SW_Msk                       /*!< IWDG SW */
N
N#define FLASH_OBR_nRST_STOP_Pos           (9U)
N#define FLASH_OBR_nRST_STOP_Msk           (0x1UL << FLASH_OBR_nRST_STOP_Pos)          /*!< 0x00000200 */
N#define FLASH_OBR_nRST_STOP               FLASH_OBR_nRST_STOP_Msk                     /*!< nRST_STOP */
N
N#define FLASH_OBR_nRST_STDBY_Pos          (10U)
N#define FLASH_OBR_nRST_STDBY_Msk          (0x1UL << FLASH_OBR_nRST_STDBY_Pos)         /*!< 0x00000400 */
N#define FLASH_OBR_nRST_STDBY              FLASH_OBR_nRST_STDBY_Msk                    /*!< nRST_STDBY */
N
N#define FLASH_OBR_nBOOT1_Pos              (12U)
N#define FLASH_OBR_nBOOT1_Msk              (0x1UL << FLASH_OBR_nBOOT1_Pos)             /*!< 0x00001000 */
N#define FLASH_OBR_nBOOT1                  FLASH_OBR_nBOOT1_Msk                        /*!< nBOOT1 */
N
N#define FLASH_OBR_VDDA_MONITOR_Pos        (13U)
N#define FLASH_OBR_VDDA_MONITOR_Msk        (0x1UL << FLASH_OBR_VDDA_MONITOR_Pos)       /*!< 0x00002000 */
N#define FLASH_OBR_VDDA_MONITOR            FLASH_OBR_VDDA_MONITOR_Msk                  /*!< VDDA power supply supervisor */
N
N#define FLASH_OBR_RAM_PARITY_CHECK_Pos    (14U)
N#define FLASH_OBR_RAM_PARITY_CHECK_Msk    (0x1UL << FLASH_OBR_RAM_PARITY_CHECK_Pos)   /*!< 0x00004000 */
N#define FLASH_OBR_RAM_PARITY_CHECK        FLASH_OBR_RAM_PARITY_CHECK_Msk              /*!< RAM parity check */
N
N#define FLASH_OBR_DATA0_Pos               (16U)
N#define FLASH_OBR_DATA0_Msk               (0xFFUL << FLASH_OBR_DATA0_Pos)             /*!< 0x00FF0000 */
N#define FLASH_OBR_DATA0                   FLASH_OBR_DATA0_Msk                         /*!< Data0 */
N
N#define FLASH_OBR_DATA1_Pos               (24U)
N#define FLASH_OBR_DATA1_Msk               (0xFFUL << FLASH_OBR_DATA1_Pos)             /*!< 0xFF000000 */
N#define FLASH_OBR_DATA1                   FLASH_OBR_DATA1_Msk                         /*!< Data1 */
N
N/******************  Bit definition for FLASH_WRPR register  ******************/
N#define FLASH_WRPR_WRP_Pos                (0U)
N#define FLASH_WRPR_WRP_Msk                (0xFFFFUL << FLASH_WRPR_WRP_Pos)            /*!< 0x0000FFFF */
N#define FLASH_WRPR_WRP                    FLASH_WRPR_WRP_Msk                          /*!< Write Protect */
N
N/*----------------------------------------------------------------------------*/
N/******************  Bit definition for OB_RDP register  **********************/
N#define OB_RDP_RDP_Pos                    (0U)
N#define OB_RDP_RDP_Msk                    (0xFFUL << OB_RDP_RDP_Pos)                  /*!< 0x000000FF */
N#define OB_RDP_RDP                        OB_RDP_RDP_Msk                              /*!< Read protection option byte */
N
N#define OB_RDP_nRDP_Pos                   (8U)
N#define OB_RDP_nRDP_Msk                   (0xFFUL << OB_RDP_nRDP_Pos)                 /*!< 0x0000FF00 */
N#define OB_RDP_nRDP                       OB_RDP_nRDP_Msk                             /*!< Read protection complemented option byte */
N
N/******************  Bit definition for OB_USER register  *********************/
N#define OB_USER_USER_Pos                  (16U)
N#define OB_USER_USER_Msk                  (0xFFUL << OB_USER_USER_Pos)                /*!< 0x00FF0000 */
N#define OB_USER_USER                      OB_USER_USER_Msk                            /*!< User option byte */
N
N#define OB_USER_nUSER_Pos                 (24U)
N#define OB_USER_nUSER_Msk                 (0xFFUL << OB_USER_nUSER_Pos)               /*!< 0xFF000000 */
N#define OB_USER_nUSER                     OB_USER_nUSER_Msk                           /*!< User complemented option byte */
N
N/******************  Bit definition for OB_WRP0 register  *********************/
N#define OB_WRP0_WRP0_Pos                  (0U)
N#define OB_WRP0_WRP0_Msk                  (0xFFUL << OB_WRP0_WRP0_Pos)                /*!< 0x000000FF */
N#define OB_WRP0_WRP0                      OB_WRP0_WRP0_Msk                            /*!< Flash memory write protection option bytes */
N
N#define OB_WRP0_nWRP0_Pos                 (8U)
N#define OB_WRP0_nWRP0_Msk                 (0xFFUL << OB_WRP0_nWRP0_Pos)               /*!< 0x0000FF00 */
N#define OB_WRP0_nWRP0                     OB_WRP0_nWRP0_Msk                           /*!< Flash memory write protection complemented option bytes */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                       General Purpose IOs (GPIO)                           */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for GPIO_MODER register  *****************/
N#define GPIO_MODER_MODER0_Pos           (0U)
N#define GPIO_MODER_MODER0_Msk           (0x3UL << GPIO_MODER_MODER0_Pos)        /*!< 0x00000003 */
N#define GPIO_MODER_MODER0               GPIO_MODER_MODER0_Msk
N#define GPIO_MODER_MODER0_0             (0x1UL << GPIO_MODER_MODER0_Pos)        /*!< 0x00000001 */
N#define GPIO_MODER_MODER0_1             (0x2UL << GPIO_MODER_MODER0_Pos)        /*!< 0x00000002 */
N
N#define GPIO_MODER_MODER1_Pos           (2U)
N#define GPIO_MODER_MODER1_Msk           (0x3UL << GPIO_MODER_MODER1_Pos)        /*!< 0x0000000C */
N#define GPIO_MODER_MODER1               GPIO_MODER_MODER1_Msk
N#define GPIO_MODER_MODER1_0             (0x1UL << GPIO_MODER_MODER1_Pos)        /*!< 0x00000004 */
N#define GPIO_MODER_MODER1_1             (0x2UL << GPIO_MODER_MODER1_Pos)        /*!< 0x00000008 */
N
N#define GPIO_MODER_MODER2_Pos           (4U)
N#define GPIO_MODER_MODER2_Msk           (0x3UL << GPIO_MODER_MODER2_Pos)        /*!< 0x00000030 */
N#define GPIO_MODER_MODER2               GPIO_MODER_MODER2_Msk
N#define GPIO_MODER_MODER2_0             (0x1UL << GPIO_MODER_MODER2_Pos)        /*!< 0x00000010 */
N#define GPIO_MODER_MODER2_1             (0x2UL << GPIO_MODER_MODER2_Pos)        /*!< 0x00000020 */
N
N#define GPIO_MODER_MODER3_Pos           (6U)
N#define GPIO_MODER_MODER3_Msk           (0x3UL << GPIO_MODER_MODER3_Pos)        /*!< 0x000000C0 */
N#define GPIO_MODER_MODER3               GPIO_MODER_MODER3_Msk
N#define GPIO_MODER_MODER3_0             (0x1UL << GPIO_MODER_MODER3_Pos)        /*!< 0x00000040 */
N#define GPIO_MODER_MODER3_1             (0x2UL << GPIO_MODER_MODER3_Pos)        /*!< 0x00000080 */
N
N#define GPIO_MODER_MODER4_Pos           (8U)
N#define GPIO_MODER_MODER4_Msk           (0x3UL << GPIO_MODER_MODER4_Pos)        /*!< 0x00000300 */
N#define GPIO_MODER_MODER4               GPIO_MODER_MODER4_Msk
N#define GPIO_MODER_MODER4_0             (0x1UL << GPIO_MODER_MODER4_Pos)        /*!< 0x00000100 */
N#define GPIO_MODER_MODER4_1             (0x2UL << GPIO_MODER_MODER4_Pos)        /*!< 0x00000200 */
N
N#define GPIO_MODER_MODER5_Pos           (10U)
N#define GPIO_MODER_MODER5_Msk           (0x3UL << GPIO_MODER_MODER5_Pos)        /*!< 0x00000C00 */
N#define GPIO_MODER_MODER5               GPIO_MODER_MODER5_Msk
N#define GPIO_MODER_MODER5_0             (0x1UL << GPIO_MODER_MODER5_Pos)        /*!< 0x00000400 */
N#define GPIO_MODER_MODER5_1             (0x2UL << GPIO_MODER_MODER5_Pos)        /*!< 0x00000800 */
N
N#define GPIO_MODER_MODER6_Pos           (12U)
N#define GPIO_MODER_MODER6_Msk           (0x3UL << GPIO_MODER_MODER6_Pos)        /*!< 0x00003000 */
N#define GPIO_MODER_MODER6               GPIO_MODER_MODER6_Msk
N#define GPIO_MODER_MODER6_0             (0x1UL << GPIO_MODER_MODER6_Pos)        /*!< 0x00001000 */
N#define GPIO_MODER_MODER6_1             (0x2UL << GPIO_MODER_MODER6_Pos)        /*!< 0x00002000 */
N
N#define GPIO_MODER_MODER7_Pos           (14U)
N#define GPIO_MODER_MODER7_Msk           (0x3UL << GPIO_MODER_MODER7_Pos)        /*!< 0x0000C000 */
N#define GPIO_MODER_MODER7               GPIO_MODER_MODER7_Msk
N#define GPIO_MODER_MODER7_0             (0x1UL << GPIO_MODER_MODER7_Pos)        /*!< 0x00004000 */
N#define GPIO_MODER_MODER7_1             (0x2UL << GPIO_MODER_MODER7_Pos)        /*!< 0x00008000 */
N
N#define GPIO_MODER_MODER8_Pos           (16U)
N#define GPIO_MODER_MODER8_Msk           (0x3UL << GPIO_MODER_MODER8_Pos)        /*!< 0x00030000 */
N#define GPIO_MODER_MODER8               GPIO_MODER_MODER8_Msk
N#define GPIO_MODER_MODER8_0             (0x1UL << GPIO_MODER_MODER8_Pos)        /*!< 0x00010000 */
N#define GPIO_MODER_MODER8_1             (0x2UL << GPIO_MODER_MODER8_Pos)        /*!< 0x00020000 */
N
N#define GPIO_MODER_MODER9_Pos           (18U)
N#define GPIO_MODER_MODER9_Msk           (0x3UL << GPIO_MODER_MODER9_Pos)        /*!< 0x000C0000 */
N#define GPIO_MODER_MODER9               GPIO_MODER_MODER9_Msk
N#define GPIO_MODER_MODER9_0             (0x1UL << GPIO_MODER_MODER9_Pos)        /*!< 0x00040000 */
N#define GPIO_MODER_MODER9_1             (0x2UL << GPIO_MODER_MODER9_Pos)        /*!< 0x00080000 */
N
N#define GPIO_MODER_MODER10_Pos          (20U)
N#define GPIO_MODER_MODER10_Msk          (0x3UL << GPIO_MODER_MODER10_Pos)       /*!< 0x00300000 */
N#define GPIO_MODER_MODER10              GPIO_MODER_MODER10_Msk
N#define GPIO_MODER_MODER10_0            (0x1UL << GPIO_MODER_MODER10_Pos)       /*!< 0x00100000 */
N#define GPIO_MODER_MODER10_1            (0x2UL << GPIO_MODER_MODER10_Pos)       /*!< 0x00200000 */
N
N#define GPIO_MODER_MODER11_Pos          (22U)
N#define GPIO_MODER_MODER11_Msk          (0x3UL << GPIO_MODER_MODER11_Pos)       /*!< 0x00C00000 */
N#define GPIO_MODER_MODER11              GPIO_MODER_MODER11_Msk
N#define GPIO_MODER_MODER11_0            (0x1UL << GPIO_MODER_MODER11_Pos)       /*!< 0x00400000 */
N#define GPIO_MODER_MODER11_1            (0x2UL << GPIO_MODER_MODER11_Pos)       /*!< 0x00800000 */
N
N#define GPIO_MODER_MODER12_Pos          (24U)
N#define GPIO_MODER_MODER12_Msk          (0x3UL << GPIO_MODER_MODER12_Pos)       /*!< 0x03000000 */
N#define GPIO_MODER_MODER12              GPIO_MODER_MODER12_Msk
N#define GPIO_MODER_MODER12_0            (0x1UL << GPIO_MODER_MODER12_Pos)       /*!< 0x01000000 */
N#define GPIO_MODER_MODER12_1            (0x2UL << GPIO_MODER_MODER12_Pos)       /*!< 0x02000000 */
N
N#define GPIO_MODER_MODER13_Pos          (26U)
N#define GPIO_MODER_MODER13_Msk          (0x3UL << GPIO_MODER_MODER13_Pos)       /*!< 0x0C000000 */
N#define GPIO_MODER_MODER13              GPIO_MODER_MODER13_Msk
N#define GPIO_MODER_MODER13_0            (0x1UL << GPIO_MODER_MODER13_Pos)       /*!< 0x04000000 */
N#define GPIO_MODER_MODER13_1            (0x2UL << GPIO_MODER_MODER13_Pos)       /*!< 0x08000000 */
N
N#define GPIO_MODER_MODER14_Pos          (28U)
N#define GPIO_MODER_MODER14_Msk          (0x3UL << GPIO_MODER_MODER14_Pos)       /*!< 0x30000000 */
N#define GPIO_MODER_MODER14              GPIO_MODER_MODER14_Msk
N#define GPIO_MODER_MODER14_0            (0x1UL << GPIO_MODER_MODER14_Pos)       /*!< 0x10000000 */
N#define GPIO_MODER_MODER14_1            (0x2UL << GPIO_MODER_MODER14_Pos)       /*!< 0x20000000 */
N
N#define GPIO_MODER_MODER15_Pos          (30U)
N#define GPIO_MODER_MODER15_Msk          (0x3UL << GPIO_MODER_MODER15_Pos)       /*!< 0xC0000000 */
N#define GPIO_MODER_MODER15              GPIO_MODER_MODER15_Msk
N#define GPIO_MODER_MODER15_0            (0x1UL << GPIO_MODER_MODER15_Pos)       /*!< 0x40000000 */
N#define GPIO_MODER_MODER15_1            (0x2UL << GPIO_MODER_MODER15_Pos)       /*!< 0x80000000 */
N
N/******************  Bit definition for GPIO_OTYPER register  *****************/
N#define GPIO_OTYPER_OT_0                (0x00000001U)
N#define GPIO_OTYPER_OT_1                (0x00000002U)
N#define GPIO_OTYPER_OT_2                (0x00000004U)
N#define GPIO_OTYPER_OT_3                (0x00000008U)
N#define GPIO_OTYPER_OT_4                (0x00000010U)
N#define GPIO_OTYPER_OT_5                (0x00000020U)
N#define GPIO_OTYPER_OT_6                (0x00000040U)
N#define GPIO_OTYPER_OT_7                (0x00000080U)
N#define GPIO_OTYPER_OT_8                (0x00000100U)
N#define GPIO_OTYPER_OT_9                (0x00000200U)
N#define GPIO_OTYPER_OT_10               (0x00000400U)
N#define GPIO_OTYPER_OT_11               (0x00000800U)
N#define GPIO_OTYPER_OT_12               (0x00001000U)
N#define GPIO_OTYPER_OT_13               (0x00002000U)
N#define GPIO_OTYPER_OT_14               (0x00004000U)
N#define GPIO_OTYPER_OT_15               (0x00008000U)
N
N/****************  Bit definition for GPIO_OSPEEDR register  ******************/
N#define GPIO_OSPEEDR_OSPEEDR0_Pos       (0U)
N#define GPIO_OSPEEDR_OSPEEDR0_Msk       (0x3UL << GPIO_OSPEEDR_OSPEEDR0_Pos)    /*!< 0x00000003 */
N#define GPIO_OSPEEDR_OSPEEDR0           GPIO_OSPEEDR_OSPEEDR0_Msk
N#define GPIO_OSPEEDR_OSPEEDR0_0         (0x1UL << GPIO_OSPEEDR_OSPEEDR0_Pos)    /*!< 0x00000001 */
N#define GPIO_OSPEEDR_OSPEEDR0_1         (0x2UL << GPIO_OSPEEDR_OSPEEDR0_Pos)    /*!< 0x00000002 */
N
N#define GPIO_OSPEEDR_OSPEEDR1_Pos       (2U)
N#define GPIO_OSPEEDR_OSPEEDR1_Msk       (0x3UL << GPIO_OSPEEDR_OSPEEDR1_Pos)    /*!< 0x0000000C */
N#define GPIO_OSPEEDR_OSPEEDR1           GPIO_OSPEEDR_OSPEEDR1_Msk
N#define GPIO_OSPEEDR_OSPEEDR1_0         (0x1UL << GPIO_OSPEEDR_OSPEEDR1_Pos)    /*!< 0x00000004 */
N#define GPIO_OSPEEDR_OSPEEDR1_1         (0x2UL << GPIO_OSPEEDR_OSPEEDR1_Pos)    /*!< 0x00000008 */
N
N#define GPIO_OSPEEDR_OSPEEDR2_Pos       (4U)
N#define GPIO_OSPEEDR_OSPEEDR2_Msk       (0x3UL << GPIO_OSPEEDR_OSPEEDR2_Pos)    /*!< 0x00000030 */
N#define GPIO_OSPEEDR_OSPEEDR2           GPIO_OSPEEDR_OSPEEDR2_Msk
N#define GPIO_OSPEEDR_OSPEEDR2_0         (0x1UL << GPIO_OSPEEDR_OSPEEDR2_Pos)    /*!< 0x00000010 */
N#define GPIO_OSPEEDR_OSPEEDR2_1         (0x2UL << GPIO_OSPEEDR_OSPEEDR2_Pos)    /*!< 0x00000020 */
N
N#define GPIO_OSPEEDR_OSPEEDR3_Pos       (6U)
N#define GPIO_OSPEEDR_OSPEEDR3_Msk       (0x3UL << GPIO_OSPEEDR_OSPEEDR3_Pos)    /*!< 0x000000C0 */
N#define GPIO_OSPEEDR_OSPEEDR3           GPIO_OSPEEDR_OSPEEDR3_Msk
N#define GPIO_OSPEEDR_OSPEEDR3_0         (0x1UL << GPIO_OSPEEDR_OSPEEDR3_Pos)    /*!< 0x00000040 */
N#define GPIO_OSPEEDR_OSPEEDR3_1         (0x2UL << GPIO_OSPEEDR_OSPEEDR3_Pos)    /*!< 0x00000080 */
N
N#define GPIO_OSPEEDR_OSPEEDR4_Pos       (8U)
N#define GPIO_OSPEEDR_OSPEEDR4_Msk       (0x3UL << GPIO_OSPEEDR_OSPEEDR4_Pos)    /*!< 0x00000300 */
N#define GPIO_OSPEEDR_OSPEEDR4           GPIO_OSPEEDR_OSPEEDR4_Msk
N#define GPIO_OSPEEDR_OSPEEDR4_0         (0x1UL << GPIO_OSPEEDR_OSPEEDR4_Pos)    /*!< 0x00000100 */
N#define GPIO_OSPEEDR_OSPEEDR4_1         (0x2UL << GPIO_OSPEEDR_OSPEEDR4_Pos)    /*!< 0x00000200 */
N
N#define GPIO_OSPEEDR_OSPEEDR5_Pos       (10U)
N#define GPIO_OSPEEDR_OSPEEDR5_Msk       (0x3UL << GPIO_OSPEEDR_OSPEEDR5_Pos)    /*!< 0x00000C00 */
N#define GPIO_OSPEEDR_OSPEEDR5           GPIO_OSPEEDR_OSPEEDR5_Msk
N#define GPIO_OSPEEDR_OSPEEDR5_0         (0x1UL << GPIO_OSPEEDR_OSPEEDR5_Pos)    /*!< 0x00000400 */
N#define GPIO_OSPEEDR_OSPEEDR5_1         (0x2UL << GPIO_OSPEEDR_OSPEEDR5_Pos)    /*!< 0x00000800 */
N
N#define GPIO_OSPEEDR_OSPEEDR6_Pos       (12U)
N#define GPIO_OSPEEDR_OSPEEDR6_Msk       (0x3UL << GPIO_OSPEEDR_OSPEEDR6_Pos)    /*!< 0x00003000 */
N#define GPIO_OSPEEDR_OSPEEDR6           GPIO_OSPEEDR_OSPEEDR6_Msk
N#define GPIO_OSPEEDR_OSPEEDR6_0         (0x1UL << GPIO_OSPEEDR_OSPEEDR6_Pos)    /*!< 0x00001000 */
N#define GPIO_OSPEEDR_OSPEEDR6_1         (0x2UL << GPIO_OSPEEDR_OSPEEDR6_Pos)    /*!< 0x00002000 */
N
N#define GPIO_OSPEEDR_OSPEEDR7_Pos       (14U)
N#define GPIO_OSPEEDR_OSPEEDR7_Msk       (0x3UL << GPIO_OSPEEDR_OSPEEDR7_Pos)    /*!< 0x0000C000 */
N#define GPIO_OSPEEDR_OSPEEDR7           GPIO_OSPEEDR_OSPEEDR7_Msk
N#define GPIO_OSPEEDR_OSPEEDR7_0         (0x1UL << GPIO_OSPEEDR_OSPEEDR7_Pos)    /*!< 0x00004000 */
N#define GPIO_OSPEEDR_OSPEEDR7_1         (0x2UL << GPIO_OSPEEDR_OSPEEDR7_Pos)    /*!< 0x00008000 */
N
N#define GPIO_OSPEEDR_OSPEEDR8_Pos       (16U)
N#define GPIO_OSPEEDR_OSPEEDR8_Msk       (0x3UL << GPIO_OSPEEDR_OSPEEDR8_Pos)    /*!< 0x00030000 */
N#define GPIO_OSPEEDR_OSPEEDR8           GPIO_OSPEEDR_OSPEEDR8_Msk
N#define GPIO_OSPEEDR_OSPEEDR8_0         (0x1UL << GPIO_OSPEEDR_OSPEEDR8_Pos)    /*!< 0x00010000 */
N#define GPIO_OSPEEDR_OSPEEDR8_1         (0x2UL << GPIO_OSPEEDR_OSPEEDR8_Pos)    /*!< 0x00020000 */
N
N#define GPIO_OSPEEDR_OSPEEDR9_Pos       (18U)
N#define GPIO_OSPEEDR_OSPEEDR9_Msk       (0x3UL << GPIO_OSPEEDR_OSPEEDR9_Pos)    /*!< 0x000C0000 */
N#define GPIO_OSPEEDR_OSPEEDR9           GPIO_OSPEEDR_OSPEEDR9_Msk
N#define GPIO_OSPEEDR_OSPEEDR9_0         (0x1UL << GPIO_OSPEEDR_OSPEEDR9_Pos)    /*!< 0x00040000 */
N#define GPIO_OSPEEDR_OSPEEDR9_1         (0x2UL << GPIO_OSPEEDR_OSPEEDR9_Pos)    /*!< 0x00080000 */
N
N#define GPIO_OSPEEDR_OSPEEDR10_Pos      (20U)
N#define GPIO_OSPEEDR_OSPEEDR10_Msk      (0x3UL << GPIO_OSPEEDR_OSPEEDR10_Pos)   /*!< 0x00300000 */
N#define GPIO_OSPEEDR_OSPEEDR10          GPIO_OSPEEDR_OSPEEDR10_Msk
N#define GPIO_OSPEEDR_OSPEEDR10_0        (0x1UL << GPIO_OSPEEDR_OSPEEDR10_Pos)   /*!< 0x00100000 */
N#define GPIO_OSPEEDR_OSPEEDR10_1        (0x2UL << GPIO_OSPEEDR_OSPEEDR10_Pos)   /*!< 0x00200000 */
N
N#define GPIO_OSPEEDR_OSPEEDR11_Pos      (22U)
N#define GPIO_OSPEEDR_OSPEEDR11_Msk      (0x3UL << GPIO_OSPEEDR_OSPEEDR11_Pos)   /*!< 0x00C00000 */
N#define GPIO_OSPEEDR_OSPEEDR11          GPIO_OSPEEDR_OSPEEDR11_Msk
N#define GPIO_OSPEEDR_OSPEEDR11_0        (0x1UL << GPIO_OSPEEDR_OSPEEDR11_Pos)   /*!< 0x00400000 */
N#define GPIO_OSPEEDR_OSPEEDR11_1        (0x2UL << GPIO_OSPEEDR_OSPEEDR11_Pos)   /*!< 0x00800000 */
N
N#define GPIO_OSPEEDR_OSPEEDR12_Pos      (24U)
N#define GPIO_OSPEEDR_OSPEEDR12_Msk      (0x3UL << GPIO_OSPEEDR_OSPEEDR12_Pos)   /*!< 0x03000000 */
N#define GPIO_OSPEEDR_OSPEEDR12          GPIO_OSPEEDR_OSPEEDR12_Msk
N#define GPIO_OSPEEDR_OSPEEDR12_0        (0x1UL << GPIO_OSPEEDR_OSPEEDR12_Pos)   /*!< 0x01000000 */
N#define GPIO_OSPEEDR_OSPEEDR12_1        (0x2UL << GPIO_OSPEEDR_OSPEEDR12_Pos)   /*!< 0x02000000 */
N
N#define GPIO_OSPEEDR_OSPEEDR13_Pos      (26U)
N#define GPIO_OSPEEDR_OSPEEDR13_Msk      (0x3UL << GPIO_OSPEEDR_OSPEEDR13_Pos)   /*!< 0x0C000000 */
N#define GPIO_OSPEEDR_OSPEEDR13          GPIO_OSPEEDR_OSPEEDR13_Msk
N#define GPIO_OSPEEDR_OSPEEDR13_0        (0x1UL << GPIO_OSPEEDR_OSPEEDR13_Pos)   /*!< 0x04000000 */
N#define GPIO_OSPEEDR_OSPEEDR13_1        (0x2UL << GPIO_OSPEEDR_OSPEEDR13_Pos)   /*!< 0x08000000 */
N
N#define GPIO_OSPEEDR_OSPEEDR14_Pos      (28U)
N#define GPIO_OSPEEDR_OSPEEDR14_Msk      (0x3UL << GPIO_OSPEEDR_OSPEEDR14_Pos)   /*!< 0x30000000 */
N#define GPIO_OSPEEDR_OSPEEDR14          GPIO_OSPEEDR_OSPEEDR14_Msk
N#define GPIO_OSPEEDR_OSPEEDR14_0        (0x1UL << GPIO_OSPEEDR_OSPEEDR14_Pos)   /*!< 0x10000000 */
N#define GPIO_OSPEEDR_OSPEEDR14_1        (0x2UL << GPIO_OSPEEDR_OSPEEDR14_Pos)   /*!< 0x20000000 */
N
N#define GPIO_OSPEEDR_OSPEEDR15_Pos      (30U)
N#define GPIO_OSPEEDR_OSPEEDR15_Msk      (0x3UL << GPIO_OSPEEDR_OSPEEDR15_Pos)   /*!< 0xC0000000 */
N#define GPIO_OSPEEDR_OSPEEDR15          GPIO_OSPEEDR_OSPEEDR15_Msk
N#define GPIO_OSPEEDR_OSPEEDR15_0        (0x1UL << GPIO_OSPEEDR_OSPEEDR15_Pos)   /*!< 0x40000000 */
N#define GPIO_OSPEEDR_OSPEEDR15_1        (0x2UL << GPIO_OSPEEDR_OSPEEDR15_Pos)   /*!< 0x80000000 */
N
N/*******************  Bit definition for GPIO_PUPDR register ******************/
N#define GPIO_PUPDR_PUPDR0_Pos           (0U)
N#define GPIO_PUPDR_PUPDR0_Msk           (0x3UL << GPIO_PUPDR_PUPDR0_Pos)        /*!< 0x00000003 */
N#define GPIO_PUPDR_PUPDR0               GPIO_PUPDR_PUPDR0_Msk
N#define GPIO_PUPDR_PUPDR0_0             (0x1UL << GPIO_PUPDR_PUPDR0_Pos)        /*!< 0x00000001 */
N#define GPIO_PUPDR_PUPDR0_1             (0x2UL << GPIO_PUPDR_PUPDR0_Pos)        /*!< 0x00000002 */
N
N#define GPIO_PUPDR_PUPDR1_Pos           (2U)
N#define GPIO_PUPDR_PUPDR1_Msk           (0x3UL << GPIO_PUPDR_PUPDR1_Pos)        /*!< 0x0000000C */
N#define GPIO_PUPDR_PUPDR1               GPIO_PUPDR_PUPDR1_Msk
N#define GPIO_PUPDR_PUPDR1_0             (0x1UL << GPIO_PUPDR_PUPDR1_Pos)        /*!< 0x00000004 */
N#define GPIO_PUPDR_PUPDR1_1             (0x2UL << GPIO_PUPDR_PUPDR1_Pos)        /*!< 0x00000008 */
N
N#define GPIO_PUPDR_PUPDR2_Pos           (4U)
N#define GPIO_PUPDR_PUPDR2_Msk           (0x3UL << GPIO_PUPDR_PUPDR2_Pos)        /*!< 0x00000030 */
N#define GPIO_PUPDR_PUPDR2               GPIO_PUPDR_PUPDR2_Msk
N#define GPIO_PUPDR_PUPDR2_0             (0x1UL << GPIO_PUPDR_PUPDR2_Pos)        /*!< 0x00000010 */
N#define GPIO_PUPDR_PUPDR2_1             (0x2UL << GPIO_PUPDR_PUPDR2_Pos)        /*!< 0x00000020 */
N
N#define GPIO_PUPDR_PUPDR3_Pos           (6U)
N#define GPIO_PUPDR_PUPDR3_Msk           (0x3UL << GPIO_PUPDR_PUPDR3_Pos)        /*!< 0x000000C0 */
N#define GPIO_PUPDR_PUPDR3               GPIO_PUPDR_PUPDR3_Msk
N#define GPIO_PUPDR_PUPDR3_0             (0x1UL << GPIO_PUPDR_PUPDR3_Pos)        /*!< 0x00000040 */
N#define GPIO_PUPDR_PUPDR3_1             (0x2UL << GPIO_PUPDR_PUPDR3_Pos)        /*!< 0x00000080 */
N
N#define GPIO_PUPDR_PUPDR4_Pos           (8U)
N#define GPIO_PUPDR_PUPDR4_Msk           (0x3UL << GPIO_PUPDR_PUPDR4_Pos)        /*!< 0x00000300 */
N#define GPIO_PUPDR_PUPDR4               GPIO_PUPDR_PUPDR4_Msk
N#define GPIO_PUPDR_PUPDR4_0             (0x1UL << GPIO_PUPDR_PUPDR4_Pos)        /*!< 0x00000100 */
N#define GPIO_PUPDR_PUPDR4_1             (0x2UL << GPIO_PUPDR_PUPDR4_Pos)        /*!< 0x00000200 */
N
N#define GPIO_PUPDR_PUPDR5_Pos           (10U)
N#define GPIO_PUPDR_PUPDR5_Msk           (0x3UL << GPIO_PUPDR_PUPDR5_Pos)        /*!< 0x00000C00 */
N#define GPIO_PUPDR_PUPDR5               GPIO_PUPDR_PUPDR5_Msk
N#define GPIO_PUPDR_PUPDR5_0             (0x1UL << GPIO_PUPDR_PUPDR5_Pos)        /*!< 0x00000400 */
N#define GPIO_PUPDR_PUPDR5_1             (0x2UL << GPIO_PUPDR_PUPDR5_Pos)        /*!< 0x00000800 */
N
N#define GPIO_PUPDR_PUPDR6_Pos           (12U)
N#define GPIO_PUPDR_PUPDR6_Msk           (0x3UL << GPIO_PUPDR_PUPDR6_Pos)        /*!< 0x00003000 */
N#define GPIO_PUPDR_PUPDR6               GPIO_PUPDR_PUPDR6_Msk
N#define GPIO_PUPDR_PUPDR6_0             (0x1UL << GPIO_PUPDR_PUPDR6_Pos)        /*!< 0x00001000 */
N#define GPIO_PUPDR_PUPDR6_1             (0x2UL << GPIO_PUPDR_PUPDR6_Pos)        /*!< 0x00002000 */
N
N#define GPIO_PUPDR_PUPDR7_Pos           (14U)
N#define GPIO_PUPDR_PUPDR7_Msk           (0x3UL << GPIO_PUPDR_PUPDR7_Pos)        /*!< 0x0000C000 */
N#define GPIO_PUPDR_PUPDR7               GPIO_PUPDR_PUPDR7_Msk
N#define GPIO_PUPDR_PUPDR7_0             (0x1UL << GPIO_PUPDR_PUPDR7_Pos)        /*!< 0x00004000 */
N#define GPIO_PUPDR_PUPDR7_1             (0x2UL << GPIO_PUPDR_PUPDR7_Pos)        /*!< 0x00008000 */
N
N#define GPIO_PUPDR_PUPDR8_Pos           (16U)
N#define GPIO_PUPDR_PUPDR8_Msk           (0x3UL << GPIO_PUPDR_PUPDR8_Pos)        /*!< 0x00030000 */
N#define GPIO_PUPDR_PUPDR8               GPIO_PUPDR_PUPDR8_Msk
N#define GPIO_PUPDR_PUPDR8_0             (0x1UL << GPIO_PUPDR_PUPDR8_Pos)        /*!< 0x00010000 */
N#define GPIO_PUPDR_PUPDR8_1             (0x2UL << GPIO_PUPDR_PUPDR8_Pos)        /*!< 0x00020000 */
N
N#define GPIO_PUPDR_PUPDR9_Pos           (18U)
N#define GPIO_PUPDR_PUPDR9_Msk           (0x3UL << GPIO_PUPDR_PUPDR9_Pos)        /*!< 0x000C0000 */
N#define GPIO_PUPDR_PUPDR9               GPIO_PUPDR_PUPDR9_Msk
N#define GPIO_PUPDR_PUPDR9_0             (0x1UL << GPIO_PUPDR_PUPDR9_Pos)        /*!< 0x00040000 */
N#define GPIO_PUPDR_PUPDR9_1             (0x2UL << GPIO_PUPDR_PUPDR9_Pos)        /*!< 0x00080000 */
N
N#define GPIO_PUPDR_PUPDR10_Pos          (20U)
N#define GPIO_PUPDR_PUPDR10_Msk          (0x3UL << GPIO_PUPDR_PUPDR10_Pos)       /*!< 0x00300000 */
N#define GPIO_PUPDR_PUPDR10              GPIO_PUPDR_PUPDR10_Msk
N#define GPIO_PUPDR_PUPDR10_0            (0x1UL << GPIO_PUPDR_PUPDR10_Pos)       /*!< 0x00100000 */
N#define GPIO_PUPDR_PUPDR10_1            (0x2UL << GPIO_PUPDR_PUPDR10_Pos)       /*!< 0x00200000 */
N
N#define GPIO_PUPDR_PUPDR11_Pos          (22U)
N#define GPIO_PUPDR_PUPDR11_Msk          (0x3UL << GPIO_PUPDR_PUPDR11_Pos)       /*!< 0x00C00000 */
N#define GPIO_PUPDR_PUPDR11              GPIO_PUPDR_PUPDR11_Msk
N#define GPIO_PUPDR_PUPDR11_0            (0x1UL << GPIO_PUPDR_PUPDR11_Pos)       /*!< 0x00400000 */
N#define GPIO_PUPDR_PUPDR11_1            (0x2UL << GPIO_PUPDR_PUPDR11_Pos)       /*!< 0x00800000 */
N
N#define GPIO_PUPDR_PUPDR12_Pos          (24U)
N#define GPIO_PUPDR_PUPDR12_Msk          (0x3UL << GPIO_PUPDR_PUPDR12_Pos)       /*!< 0x03000000 */
N#define GPIO_PUPDR_PUPDR12              GPIO_PUPDR_PUPDR12_Msk
N#define GPIO_PUPDR_PUPDR12_0            (0x1UL << GPIO_PUPDR_PUPDR12_Pos)       /*!< 0x01000000 */
N#define GPIO_PUPDR_PUPDR12_1            (0x2UL << GPIO_PUPDR_PUPDR12_Pos)       /*!< 0x02000000 */
N
N#define GPIO_PUPDR_PUPDR13_Pos          (26U)
N#define GPIO_PUPDR_PUPDR13_Msk          (0x3UL << GPIO_PUPDR_PUPDR13_Pos)       /*!< 0x0C000000 */
N#define GPIO_PUPDR_PUPDR13              GPIO_PUPDR_PUPDR13_Msk
N#define GPIO_PUPDR_PUPDR13_0            (0x1UL << GPIO_PUPDR_PUPDR13_Pos)       /*!< 0x04000000 */
N#define GPIO_PUPDR_PUPDR13_1            (0x2UL << GPIO_PUPDR_PUPDR13_Pos)       /*!< 0x08000000 */
N
N#define GPIO_PUPDR_PUPDR14_Pos          (28U)
N#define GPIO_PUPDR_PUPDR14_Msk          (0x3UL << GPIO_PUPDR_PUPDR14_Pos)       /*!< 0x30000000 */
N#define GPIO_PUPDR_PUPDR14              GPIO_PUPDR_PUPDR14_Msk
N#define GPIO_PUPDR_PUPDR14_0            (0x1UL << GPIO_PUPDR_PUPDR14_Pos)       /*!< 0x10000000 */
N#define GPIO_PUPDR_PUPDR14_1            (0x2UL << GPIO_PUPDR_PUPDR14_Pos)       /*!< 0x20000000 */
N
N#define GPIO_PUPDR_PUPDR15_Pos          (30U)
N#define GPIO_PUPDR_PUPDR15_Msk          (0x3UL << GPIO_PUPDR_PUPDR15_Pos)       /*!< 0xC0000000 */
N#define GPIO_PUPDR_PUPDR15              GPIO_PUPDR_PUPDR15_Msk
N#define GPIO_PUPDR_PUPDR15_0            (0x1UL << GPIO_PUPDR_PUPDR15_Pos)       /*!< 0x40000000 */
N#define GPIO_PUPDR_PUPDR15_1            (0x2UL << GPIO_PUPDR_PUPDR15_Pos)       /*!< 0x80000000 */
N
N/*******************  Bit definition for GPIO_IDR register  *******************/
N#define GPIO_IDR_0                      (0x00000001U)
N#define GPIO_IDR_1                      (0x00000002U)
N#define GPIO_IDR_2                      (0x00000004U)
N#define GPIO_IDR_3                      (0x00000008U)
N#define GPIO_IDR_4                      (0x00000010U)
N#define GPIO_IDR_5                      (0x00000020U)
N#define GPIO_IDR_6                      (0x00000040U)
N#define GPIO_IDR_7                      (0x00000080U)
N#define GPIO_IDR_8                      (0x00000100U)
N#define GPIO_IDR_9                      (0x00000200U)
N#define GPIO_IDR_10                     (0x00000400U)
N#define GPIO_IDR_11                     (0x00000800U)
N#define GPIO_IDR_12                     (0x00001000U)
N#define GPIO_IDR_13                     (0x00002000U)
N#define GPIO_IDR_14                     (0x00004000U)
N#define GPIO_IDR_15                     (0x00008000U)
N
N/******************  Bit definition for GPIO_ODR register  ********************/
N#define GPIO_ODR_0                      (0x00000001U)
N#define GPIO_ODR_1                      (0x00000002U)
N#define GPIO_ODR_2                      (0x00000004U)
N#define GPIO_ODR_3                      (0x00000008U)
N#define GPIO_ODR_4                      (0x00000010U)
N#define GPIO_ODR_5                      (0x00000020U)
N#define GPIO_ODR_6                      (0x00000040U)
N#define GPIO_ODR_7                      (0x00000080U)
N#define GPIO_ODR_8                      (0x00000100U)
N#define GPIO_ODR_9                      (0x00000200U)
N#define GPIO_ODR_10                     (0x00000400U)
N#define GPIO_ODR_11                     (0x00000800U)
N#define GPIO_ODR_12                     (0x00001000U)
N#define GPIO_ODR_13                     (0x00002000U)
N#define GPIO_ODR_14                     (0x00004000U)
N#define GPIO_ODR_15                     (0x00008000U)
N
N/****************** Bit definition for GPIO_BSRR register  ********************/
N#define GPIO_BSRR_BS_0                  (0x00000001U)
N#define GPIO_BSRR_BS_1                  (0x00000002U)
N#define GPIO_BSRR_BS_2                  (0x00000004U)
N#define GPIO_BSRR_BS_3                  (0x00000008U)
N#define GPIO_BSRR_BS_4                  (0x00000010U)
N#define GPIO_BSRR_BS_5                  (0x00000020U)
N#define GPIO_BSRR_BS_6                  (0x00000040U)
N#define GPIO_BSRR_BS_7                  (0x00000080U)
N#define GPIO_BSRR_BS_8                  (0x00000100U)
N#define GPIO_BSRR_BS_9                  (0x00000200U)
N#define GPIO_BSRR_BS_10                 (0x00000400U)
N#define GPIO_BSRR_BS_11                 (0x00000800U)
N#define GPIO_BSRR_BS_12                 (0x00001000U)
N#define GPIO_BSRR_BS_13                 (0x00002000U)
N#define GPIO_BSRR_BS_14                 (0x00004000U)
N#define GPIO_BSRR_BS_15                 (0x00008000U)
N#define GPIO_BSRR_BR_0                  (0x00010000U)
N#define GPIO_BSRR_BR_1                  (0x00020000U)
N#define GPIO_BSRR_BR_2                  (0x00040000U)
N#define GPIO_BSRR_BR_3                  (0x00080000U)
N#define GPIO_BSRR_BR_4                  (0x00100000U)
N#define GPIO_BSRR_BR_5                  (0x00200000U)
N#define GPIO_BSRR_BR_6                  (0x00400000U)
N#define GPIO_BSRR_BR_7                  (0x00800000U)
N#define GPIO_BSRR_BR_8                  (0x01000000U)
N#define GPIO_BSRR_BR_9                  (0x02000000U)
N#define GPIO_BSRR_BR_10                 (0x04000000U)
N#define GPIO_BSRR_BR_11                 (0x08000000U)
N#define GPIO_BSRR_BR_12                 (0x10000000U)
N#define GPIO_BSRR_BR_13                 (0x20000000U)
N#define GPIO_BSRR_BR_14                 (0x40000000U)
N#define GPIO_BSRR_BR_15                 (0x80000000U)
N
N/****************** Bit definition for GPIO_LCKR register  ********************/
N#define GPIO_LCKR_LCK0_Pos              (0U)
N#define GPIO_LCKR_LCK0_Msk              (0x1UL << GPIO_LCKR_LCK0_Pos)           /*!< 0x00000001 */
N#define GPIO_LCKR_LCK0                  GPIO_LCKR_LCK0_Msk
N
N#define GPIO_LCKR_LCK1_Pos              (1U)
N#define GPIO_LCKR_LCK1_Msk              (0x1UL << GPIO_LCKR_LCK1_Pos)           /*!< 0x00000002 */
N#define GPIO_LCKR_LCK1                  GPIO_LCKR_LCK1_Msk
N
N#define GPIO_LCKR_LCK2_Pos              (2U)
N#define GPIO_LCKR_LCK2_Msk              (0x1UL << GPIO_LCKR_LCK2_Pos)           /*!< 0x00000004 */
N#define GPIO_LCKR_LCK2                  GPIO_LCKR_LCK2_Msk
N
N#define GPIO_LCKR_LCK3_Pos              (3U)
N#define GPIO_LCKR_LCK3_Msk              (0x1UL << GPIO_LCKR_LCK3_Pos)           /*!< 0x00000008 */
N#define GPIO_LCKR_LCK3                  GPIO_LCKR_LCK3_Msk
N
N#define GPIO_LCKR_LCK4_Pos              (4U)
N#define GPIO_LCKR_LCK4_Msk              (0x1UL << GPIO_LCKR_LCK4_Pos)           /*!< 0x00000010 */
N#define GPIO_LCKR_LCK4                  GPIO_LCKR_LCK4_Msk
N
N#define GPIO_LCKR_LCK5_Pos              (5U)
N#define GPIO_LCKR_LCK5_Msk              (0x1UL << GPIO_LCKR_LCK5_Pos)           /*!< 0x00000020 */
N#define GPIO_LCKR_LCK5                  GPIO_LCKR_LCK5_Msk
N
N#define GPIO_LCKR_LCK6_Pos              (6U)
N#define GPIO_LCKR_LCK6_Msk              (0x1UL << GPIO_LCKR_LCK6_Pos)           /*!< 0x00000040 */
N#define GPIO_LCKR_LCK6                  GPIO_LCKR_LCK6_Msk
N
N#define GPIO_LCKR_LCK7_Pos              (7U)
N#define GPIO_LCKR_LCK7_Msk              (0x1UL << GPIO_LCKR_LCK7_Pos)           /*!< 0x00000080 */
N#define GPIO_LCKR_LCK7                  GPIO_LCKR_LCK7_Msk
N
N#define GPIO_LCKR_LCK8_Pos              (8U)
N#define GPIO_LCKR_LCK8_Msk              (0x1UL << GPIO_LCKR_LCK8_Pos)           /*!< 0x00000100 */
N#define GPIO_LCKR_LCK8                  GPIO_LCKR_LCK8_Msk
N
N#define GPIO_LCKR_LCK9_Pos              (9U)
N#define GPIO_LCKR_LCK9_Msk              (0x1UL << GPIO_LCKR_LCK9_Pos)           /*!< 0x00000200 */
N#define GPIO_LCKR_LCK9                  GPIO_LCKR_LCK9_Msk
N
N#define GPIO_LCKR_LCK10_Pos             (10U)
N#define GPIO_LCKR_LCK10_Msk             (0x1UL << GPIO_LCKR_LCK10_Pos)          /*!< 0x00000400 */
N#define GPIO_LCKR_LCK10                 GPIO_LCKR_LCK10_Msk
N
N#define GPIO_LCKR_LCK11_Pos             (11U)
N#define GPIO_LCKR_LCK11_Msk             (0x1UL << GPIO_LCKR_LCK11_Pos)          /*!< 0x00000800 */
N#define GPIO_LCKR_LCK11                 GPIO_LCKR_LCK11_Msk
N
N#define GPIO_LCKR_LCK12_Pos             (12U)
N#define GPIO_LCKR_LCK12_Msk             (0x1UL << GPIO_LCKR_LCK12_Pos)          /*!< 0x00001000 */
N#define GPIO_LCKR_LCK12                 GPIO_LCKR_LCK12_Msk
N
N#define GPIO_LCKR_LCK13_Pos             (13U)
N#define GPIO_LCKR_LCK13_Msk             (0x1UL << GPIO_LCKR_LCK13_Pos)          /*!< 0x00002000 */
N#define GPIO_LCKR_LCK13                 GPIO_LCKR_LCK13_Msk
N
N#define GPIO_LCKR_LCK14_Pos             (14U)
N#define GPIO_LCKR_LCK14_Msk             (0x1UL << GPIO_LCKR_LCK14_Pos)          /*!< 0x00004000 */
N#define GPIO_LCKR_LCK14                 GPIO_LCKR_LCK14_Msk
N
N#define GPIO_LCKR_LCK15_Pos             (15U)
N#define GPIO_LCKR_LCK15_Msk             (0x1UL << GPIO_LCKR_LCK15_Pos)          /*!< 0x00008000 */
N#define GPIO_LCKR_LCK15                 GPIO_LCKR_LCK15_Msk
N
N#define GPIO_LCKR_LCKK_Pos              (16U)
N#define GPIO_LCKR_LCKK_Msk              (0x1UL << GPIO_LCKR_LCKK_Pos)           /*!< 0x00010000 */
N#define GPIO_LCKR_LCKK                  GPIO_LCKR_LCKK_Msk
N
N/****************** Bit definition for GPIO_AFRL register  ********************/
N#define GPIO_AFRL_AFSEL0_Pos            (0U)
N#define GPIO_AFRL_AFSEL0_Msk            (0xFUL << GPIO_AFRL_AFSEL0_Pos)         /*!< 0x0000000F */
N#define GPIO_AFRL_AFSEL0                GPIO_AFRL_AFSEL0_Msk
N
N#define GPIO_AFRL_AFSEL1_Pos            (4U)
N#define GPIO_AFRL_AFSEL1_Msk            (0xFUL << GPIO_AFRL_AFSEL1_Pos)         /*!< 0x000000F0 */
N#define GPIO_AFRL_AFSEL1                GPIO_AFRL_AFSEL1_Msk
N
N#define GPIO_AFRL_AFSEL2_Pos            (8U)
N#define GPIO_AFRL_AFSEL2_Msk            (0xFUL << GPIO_AFRL_AFSEL2_Pos)         /*!< 0x00000F00 */
N#define GPIO_AFRL_AFSEL2                GPIO_AFRL_AFSEL2_Msk
N
N#define GPIO_AFRL_AFSEL3_Pos            (12U)
N#define GPIO_AFRL_AFSEL3_Msk            (0xFUL << GPIO_AFRL_AFSEL3_Pos)         /*!< 0x0000F000 */
N#define GPIO_AFRL_AFSEL3                GPIO_AFRL_AFSEL3_Msk
N
N#define GPIO_AFRL_AFSEL4_Pos            (16U)
N#define GPIO_AFRL_AFSEL4_Msk            (0xFUL << GPIO_AFRL_AFSEL4_Pos)         /*!< 0x000F0000 */
N#define GPIO_AFRL_AFSEL4                GPIO_AFRL_AFSEL4_Msk
N
N#define GPIO_AFRL_AFSEL5_Pos            (20U)
N#define GPIO_AFRL_AFSEL5_Msk            (0xFUL << GPIO_AFRL_AFSEL5_Pos)         /*!< 0x00F00000 */
N#define GPIO_AFRL_AFSEL5                GPIO_AFRL_AFSEL5_Msk
N
N#define GPIO_AFRL_AFSEL6_Pos            (24U)
N#define GPIO_AFRL_AFSEL6_Msk            (0xFUL << GPIO_AFRL_AFSEL6_Pos)         /*!< 0x0F000000 */
N#define GPIO_AFRL_AFSEL6                GPIO_AFRL_AFSEL6_Msk
N
N#define GPIO_AFRL_AFSEL7_Pos            (28U)
N#define GPIO_AFRL_AFSEL7_Msk            (0xFUL << GPIO_AFRL_AFSEL7_Pos)         /*!< 0xF0000000 */
N#define GPIO_AFRL_AFSEL7                GPIO_AFRL_AFSEL7_Msk
N
N/****************** Bit definition for GPIO_AFRH register  ********************/
N#define GPIO_AFRH_AFSEL8_Pos            (0U)
N#define GPIO_AFRH_AFSEL8_Msk            (0xFUL << GPIO_AFRH_AFSEL8_Pos)         /*!< 0x0000000F */
N#define GPIO_AFRH_AFSEL8                GPIO_AFRH_AFSEL8_Msk
N
N#define GPIO_AFRH_AFSEL9_Pos            (4U)
N#define GPIO_AFRH_AFSEL9_Msk            (0xFUL << GPIO_AFRH_AFSEL9_Pos)         /*!< 0x000000F0 */
N#define GPIO_AFRH_AFSEL9                GPIO_AFRH_AFSEL9_Msk
N
N#define GPIO_AFRH_AFSEL10_Pos           (8U)
N#define GPIO_AFRH_AFSEL10_Msk           (0xFUL << GPIO_AFRH_AFSEL10_Pos)        /*!< 0x00000F00 */
N#define GPIO_AFRH_AFSEL10               GPIO_AFRH_AFSEL10_Msk
N
N#define GPIO_AFRH_AFSEL11_Pos           (12U)
N#define GPIO_AFRH_AFSEL11_Msk           (0xFUL << GPIO_AFRH_AFSEL11_Pos)        /*!< 0x0000F000 */
N#define GPIO_AFRH_AFSEL11               GPIO_AFRH_AFSEL11_Msk
N
N#define GPIO_AFRH_AFSEL12_Pos           (16U)
N#define GPIO_AFRH_AFSEL12_Msk           (0xFUL << GPIO_AFRH_AFSEL12_Pos)        /*!< 0x000F0000 */
N#define GPIO_AFRH_AFSEL12               GPIO_AFRH_AFSEL12_Msk
N
N#define GPIO_AFRH_AFSEL13_Pos           (20U)
N#define GPIO_AFRH_AFSEL13_Msk           (0xFUL << GPIO_AFRH_AFSEL13_Pos)        /*!< 0x00F00000 */
N#define GPIO_AFRH_AFSEL13               GPIO_AFRH_AFSEL13_Msk
N
N#define GPIO_AFRH_AFSEL14_Pos           (24U)
N#define GPIO_AFRH_AFSEL14_Msk           (0xFUL << GPIO_AFRH_AFSEL14_Pos)        /*!< 0x0F000000 */
N#define GPIO_AFRH_AFSEL14               GPIO_AFRH_AFSEL14_Msk
N
N#define GPIO_AFRH_AFSEL15_Pos           (28U)
N#define GPIO_AFRH_AFSEL15_Msk           (0xFUL << GPIO_AFRH_AFSEL15_Pos)        /*!< 0xF0000000 */
N#define GPIO_AFRH_AFSEL15               GPIO_AFRH_AFSEL15_Msk
N
N/****************** Bit definition for GPIO_BRR register  *********************/
N#define GPIO_BRR_BR_0                   (0x00000001U)
N#define GPIO_BRR_BR_1                   (0x00000002U)
N#define GPIO_BRR_BR_2                   (0x00000004U)
N#define GPIO_BRR_BR_3                   (0x00000008U)
N#define GPIO_BRR_BR_4                   (0x00000010U)
N#define GPIO_BRR_BR_5                   (0x00000020U)
N#define GPIO_BRR_BR_6                   (0x00000040U)
N#define GPIO_BRR_BR_7                   (0x00000080U)
N#define GPIO_BRR_BR_8                   (0x00000100U)
N#define GPIO_BRR_BR_9                   (0x00000200U)
N#define GPIO_BRR_BR_10                  (0x00000400U)
N#define GPIO_BRR_BR_11                  (0x00000800U)
N#define GPIO_BRR_BR_12                  (0x00001000U)
N#define GPIO_BRR_BR_13                  (0x00002000U)
N#define GPIO_BRR_BR_14                  (0x00004000U)
N#define GPIO_BRR_BR_15                  (0x00008000U)
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                   Inter-integrated Circuit Interface (I2C)                 */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for I2C_CR1 register  *******************/
N#define I2C_CR1_PE_Pos               (0U)
N#define I2C_CR1_PE_Msk               (0x1UL << I2C_CR1_PE_Pos)                  /*!< 0x00000001 */
N#define I2C_CR1_PE                   I2C_CR1_PE_Msk                             /*!< Peripheral enable */
N
N#define I2C_CR1_TXIE_Pos             (1U)
N#define I2C_CR1_TXIE_Msk             (0x1UL << I2C_CR1_TXIE_Pos)                /*!< 0x00000002 */
N#define I2C_CR1_TXIE                 I2C_CR1_TXIE_Msk                           /*!< TX interrupt enable */
N
N#define I2C_CR1_RXIE_Pos             (2U)
N#define I2C_CR1_RXIE_Msk             (0x1UL << I2C_CR1_RXIE_Pos)                /*!< 0x00000004 */
N#define I2C_CR1_RXIE                 I2C_CR1_RXIE_Msk                           /*!< RX interrupt enable */
N
N#define I2C_CR1_ADDRIE_Pos           (3U)
N#define I2C_CR1_ADDRIE_Msk           (0x1UL << I2C_CR1_ADDRIE_Pos)              /*!< 0x00000008 */
N#define I2C_CR1_ADDRIE               I2C_CR1_ADDRIE_Msk                         /*!< Address match interrupt enable */
N
N#define I2C_CR1_NACKIE_Pos           (4U)
N#define I2C_CR1_NACKIE_Msk           (0x1UL << I2C_CR1_NACKIE_Pos)              /*!< 0x00000010 */
N#define I2C_CR1_NACKIE               I2C_CR1_NACKIE_Msk                         /*!< NACK received interrupt enable */
N
N#define I2C_CR1_STOPIE_Pos           (5U)
N#define I2C_CR1_STOPIE_Msk           (0x1UL << I2C_CR1_STOPIE_Pos)              /*!< 0x00000020 */
N#define I2C_CR1_STOPIE               I2C_CR1_STOPIE_Msk                         /*!< STOP detection interrupt enable */
N
N#define I2C_CR1_TCIE_Pos             (6U)
N#define I2C_CR1_TCIE_Msk             (0x1UL << I2C_CR1_TCIE_Pos)                /*!< 0x00000040 */
N#define I2C_CR1_TCIE                 I2C_CR1_TCIE_Msk                           /*!< Transfer complete interrupt enable */
N
N#define I2C_CR1_ERRIE_Pos            (7U)
N#define I2C_CR1_ERRIE_Msk            (0x1UL << I2C_CR1_ERRIE_Pos)               /*!< 0x00000080 */
N#define I2C_CR1_ERRIE                I2C_CR1_ERRIE_Msk                          /*!< Errors interrupt enable */
N
N#define I2C_CR1_DNF_Pos              (8U)
N#define I2C_CR1_DNF_Msk              (0xFUL << I2C_CR1_DNF_Pos)                 /*!< 0x00000F00 */
N#define I2C_CR1_DNF                  I2C_CR1_DNF_Msk                            /*!< Digital noise filter */
N
N#define I2C_CR1_ANFOFF_Pos           (12U)
N#define I2C_CR1_ANFOFF_Msk           (0x1UL << I2C_CR1_ANFOFF_Pos)              /*!< 0x00001000 */
N#define I2C_CR1_ANFOFF               I2C_CR1_ANFOFF_Msk                         /*!< Analog noise filter OFF */
N
N#define I2C_CR1_SWRST_Pos            (13U)
N#define I2C_CR1_SWRST_Msk            (0x1UL << I2C_CR1_SWRST_Pos)               /*!< 0x00002000 */
N#define I2C_CR1_SWRST                I2C_CR1_SWRST_Msk                          /*!< Software reset */
N
N#define I2C_CR1_TXDMAEN_Pos          (14U)
N#define I2C_CR1_TXDMAEN_Msk          (0x1UL << I2C_CR1_TXDMAEN_Pos)             /*!< 0x00004000 */
N#define I2C_CR1_TXDMAEN              I2C_CR1_TXDMAEN_Msk                        /*!< DMA transmission requests enable */
N
N#define I2C_CR1_RXDMAEN_Pos          (15U)
N#define I2C_CR1_RXDMAEN_Msk          (0x1UL << I2C_CR1_RXDMAEN_Pos)             /*!< 0x00008000 */
N#define I2C_CR1_RXDMAEN              I2C_CR1_RXDMAEN_Msk                        /*!< DMA reception requests enable */
N
N#define I2C_CR1_SBC_Pos              (16U)
N#define I2C_CR1_SBC_Msk              (0x1UL << I2C_CR1_SBC_Pos)                 /*!< 0x00010000 */
N#define I2C_CR1_SBC                  I2C_CR1_SBC_Msk                            /*!< Slave byte control */
N
N#define I2C_CR1_NOSTRETCH_Pos        (17U)
N#define I2C_CR1_NOSTRETCH_Msk        (0x1UL << I2C_CR1_NOSTRETCH_Pos)           /*!< 0x00020000 */
N#define I2C_CR1_NOSTRETCH            I2C_CR1_NOSTRETCH_Msk                      /*!< Clock stretching disable */
N
N#define I2C_CR1_WUPEN_Pos            (18U)
N#define I2C_CR1_WUPEN_Msk            (0x1UL << I2C_CR1_WUPEN_Pos)               /*!< 0x00040000 */
N#define I2C_CR1_WUPEN                I2C_CR1_WUPEN_Msk                          /*!< Wakeup from STOP enable */
N
N#define I2C_CR1_GCEN_Pos             (19U)
N#define I2C_CR1_GCEN_Msk             (0x1UL << I2C_CR1_GCEN_Pos)                /*!< 0x00080000 */
N#define I2C_CR1_GCEN                 I2C_CR1_GCEN_Msk                           /*!< General call enable */
N
N#define I2C_CR1_SMBHEN_Pos           (20U)
N#define I2C_CR1_SMBHEN_Msk           (0x1UL << I2C_CR1_SMBHEN_Pos)              /*!< 0x00100000 */
N#define I2C_CR1_SMBHEN               I2C_CR1_SMBHEN_Msk                         /*!< SMBus host address enable */
N
N#define I2C_CR1_SMBDEN_Pos           (21U)
N#define I2C_CR1_SMBDEN_Msk           (0x1UL << I2C_CR1_SMBDEN_Pos)              /*!< 0x00200000 */
N#define I2C_CR1_SMBDEN               I2C_CR1_SMBDEN_Msk                         /*!< SMBus device default address enable */
N
N#define I2C_CR1_ALERTEN_Pos          (22U)
N#define I2C_CR1_ALERTEN_Msk          (0x1UL << I2C_CR1_ALERTEN_Pos)             /*!< 0x00400000 */
N#define I2C_CR1_ALERTEN              I2C_CR1_ALERTEN_Msk                        /*!< SMBus alert enable */
N
N#define I2C_CR1_PECEN_Pos            (23U)
N#define I2C_CR1_PECEN_Msk            (0x1UL << I2C_CR1_PECEN_Pos)               /*!< 0x00800000 */
N#define I2C_CR1_PECEN                I2C_CR1_PECEN_Msk                          /*!< PEC enable */
N
N/******************  Bit definition for I2C_CR2 register  ********************/
N#define I2C_CR2_SADD_Pos             (0U)
N#define I2C_CR2_SADD_Msk             (0x3FFUL << I2C_CR2_SADD_Pos)              /*!< 0x000003FF */
N#define I2C_CR2_SADD                 I2C_CR2_SADD_Msk                           /*!< Slave address (master mode) */
N
N#define I2C_CR2_RD_WRN_Pos           (10U)
N#define I2C_CR2_RD_WRN_Msk           (0x1UL << I2C_CR2_RD_WRN_Pos)              /*!< 0x00000400 */
N#define I2C_CR2_RD_WRN               I2C_CR2_RD_WRN_Msk                         /*!< Transfer direction (master mode) */
N
N#define I2C_CR2_ADD10_Pos            (11U)
N#define I2C_CR2_ADD10_Msk            (0x1UL << I2C_CR2_ADD10_Pos)               /*!< 0x00000800 */
N#define I2C_CR2_ADD10                I2C_CR2_ADD10_Msk                          /*!< 10-bit addressing mode (master mode) */
N
N#define I2C_CR2_HEAD10R_Pos          (12U)
N#define I2C_CR2_HEAD10R_Msk          (0x1UL << I2C_CR2_HEAD10R_Pos)             /*!< 0x00001000 */
N#define I2C_CR2_HEAD10R              I2C_CR2_HEAD10R_Msk                        /*!< 10-bit address header only read direction (master mode) */
N
N#define I2C_CR2_START_Pos            (13U)
N#define I2C_CR2_START_Msk            (0x1UL << I2C_CR2_START_Pos)               /*!< 0x00002000 */
N#define I2C_CR2_START                I2C_CR2_START_Msk                          /*!< START generation */
N
N#define I2C_CR2_STOP_Pos             (14U)
N#define I2C_CR2_STOP_Msk             (0x1UL << I2C_CR2_STOP_Pos)                /*!< 0x00004000 */
N#define I2C_CR2_STOP                 I2C_CR2_STOP_Msk                           /*!< STOP generation (master mode) */
N
N#define I2C_CR2_NACK_Pos             (15U)
N#define I2C_CR2_NACK_Msk             (0x1UL << I2C_CR2_NACK_Pos)                /*!< 0x00008000 */
N#define I2C_CR2_NACK                 I2C_CR2_NACK_Msk                           /*!< NACK generation (slave mode) */
N
N#define I2C_CR2_NBYTES_Pos           (16U)
N#define I2C_CR2_NBYTES_Msk           (0xFFUL << I2C_CR2_NBYTES_Pos)             /*!< 0x00FF0000 */
N#define I2C_CR2_NBYTES               I2C_CR2_NBYTES_Msk                         /*!< Number of bytes */
N
N#define I2C_CR2_RELOAD_Pos           (24U)
N#define I2C_CR2_RELOAD_Msk           (0x1UL << I2C_CR2_RELOAD_Pos)              /*!< 0x01000000 */
N#define I2C_CR2_RELOAD               I2C_CR2_RELOAD_Msk                         /*!< NBYTES reload mode */
N
N#define I2C_CR2_AUTOEND_Pos          (25U)
N#define I2C_CR2_AUTOEND_Msk          (0x1UL << I2C_CR2_AUTOEND_Pos)             /*!< 0x02000000 */
N#define I2C_CR2_AUTOEND              I2C_CR2_AUTOEND_Msk                        /*!< Automatic end mode (master mode) */
N
N#define I2C_CR2_PECBYTE_Pos          (26U)
N#define I2C_CR2_PECBYTE_Msk          (0x1UL << I2C_CR2_PECBYTE_Pos)             /*!< 0x04000000 */
N#define I2C_CR2_PECBYTE              I2C_CR2_PECBYTE_Msk                        /*!< Packet error checking byte */
N
N/*******************  Bit definition for I2C_OAR1 register  ******************/
N#define I2C_OAR1_OA1_Pos             (0U)
N#define I2C_OAR1_OA1_Msk             (0x3FFUL << I2C_OAR1_OA1_Pos)              /*!< 0x000003FF */
N#define I2C_OAR1_OA1                 I2C_OAR1_OA1_Msk                           /*!< Interface own address 1 */
N
N#define I2C_OAR1_OA1MODE_Pos         (10U)
N#define I2C_OAR1_OA1MODE_Msk         (0x1UL << I2C_OAR1_OA1MODE_Pos)            /*!< 0x00000400 */
N#define I2C_OAR1_OA1MODE             I2C_OAR1_OA1MODE_Msk                       /*!< Own address 1 10-bit mode */
N
N#define I2C_OAR1_OA1EN_Pos           (15U)
N#define I2C_OAR1_OA1EN_Msk           (0x1UL << I2C_OAR1_OA1EN_Pos)              /*!< 0x00008000 */
N#define I2C_OAR1_OA1EN               I2C_OAR1_OA1EN_Msk                         /*!< Own address 1 enable */
N
N/*******************  Bit definition for I2C_OAR2 register  ******************/
N#define I2C_OAR2_OA2_Pos             (1U)
N#define I2C_OAR2_OA2_Msk             (0x7FUL << I2C_OAR2_OA2_Pos)               /*!< 0x000000FE */
N#define I2C_OAR2_OA2                 I2C_OAR2_OA2_Msk                           /*!< Interface own address 2 */
N
N#define I2C_OAR2_OA2MSK_Pos          (8U)
N#define I2C_OAR2_OA2MSK_Msk          (0x7UL << I2C_OAR2_OA2MSK_Pos)             /*!< 0x00000700 */
N#define I2C_OAR2_OA2MSK              I2C_OAR2_OA2MSK_Msk                        /*!< Own address 2 masks */
N
N#define I2C_OAR2_OA2NOMASK           (0x00000000U)                              /*!< No mask                                        */
N#define I2C_OAR2_OA2MASK01_Pos       (8U)
N#define I2C_OAR2_OA2MASK01_Msk       (0x1UL << I2C_OAR2_OA2MASK01_Pos)          /*!< 0x00000100 */
N#define I2C_OAR2_OA2MASK01           I2C_OAR2_OA2MASK01_Msk                     /*!< OA2[1] is masked, Only OA2[7:2] are compared   */
N
N#define I2C_OAR2_OA2MASK02_Pos       (9U)
N#define I2C_OAR2_OA2MASK02_Msk       (0x1UL << I2C_OAR2_OA2MASK02_Pos)          /*!< 0x00000200 */
N#define I2C_OAR2_OA2MASK02           I2C_OAR2_OA2MASK02_Msk                     /*!< OA2[2:1] is masked, Only OA2[7:3] are compared */
N
N#define I2C_OAR2_OA2MASK03_Pos       (8U)
N#define I2C_OAR2_OA2MASK03_Msk       (0x3UL << I2C_OAR2_OA2MASK03_Pos)          /*!< 0x00000300 */
N#define I2C_OAR2_OA2MASK03           I2C_OAR2_OA2MASK03_Msk                     /*!< OA2[3:1] is masked, Only OA2[7:4] are compared */
N
N#define I2C_OAR2_OA2MASK04_Pos       (10U)
N#define I2C_OAR2_OA2MASK04_Msk       (0x1UL << I2C_OAR2_OA2MASK04_Pos)          /*!< 0x00000400 */
N#define I2C_OAR2_OA2MASK04           I2C_OAR2_OA2MASK04_Msk                     /*!< OA2[4:1] is masked, Only OA2[7:5] are compared */
N
N#define I2C_OAR2_OA2MASK05_Pos       (8U)
N#define I2C_OAR2_OA2MASK05_Msk       (0x5UL << I2C_OAR2_OA2MASK05_Pos)          /*!< 0x00000500 */
N#define I2C_OAR2_OA2MASK05           I2C_OAR2_OA2MASK05_Msk                     /*!< OA2[5:1] is masked, Only OA2[7:6] are compared */
N
N#define I2C_OAR2_OA2MASK06_Pos       (9U)
N#define I2C_OAR2_OA2MASK06_Msk       (0x3UL << I2C_OAR2_OA2MASK06_Pos)          /*!< 0x00000600 */
N#define I2C_OAR2_OA2MASK06           I2C_OAR2_OA2MASK06_Msk                     /*!< OA2[6:1] is masked, Only OA2[7] are compared   */
N
N#define I2C_OAR2_OA2MASK07_Pos       (8U)
N#define I2C_OAR2_OA2MASK07_Msk       (0x7UL << I2C_OAR2_OA2MASK07_Pos)          /*!< 0x00000700 */
N#define I2C_OAR2_OA2MASK07           I2C_OAR2_OA2MASK07_Msk                     /*!< OA2[7:1] is masked, No comparison is done      */
N
N#define I2C_OAR2_OA2EN_Pos           (15U)
N#define I2C_OAR2_OA2EN_Msk           (0x1UL << I2C_OAR2_OA2EN_Pos)              /*!< 0x00008000 */
N#define I2C_OAR2_OA2EN               I2C_OAR2_OA2EN_Msk                         /*!< Own address 2 enable */
N
N/*******************  Bit definition for I2C_TIMINGR register ****************/
N#define I2C_TIMINGR_SCLL_Pos         (0U)
N#define I2C_TIMINGR_SCLL_Msk         (0xFFUL << I2C_TIMINGR_SCLL_Pos)           /*!< 0x000000FF */
N#define I2C_TIMINGR_SCLL             I2C_TIMINGR_SCLL_Msk                       /*!< SCL low period (master mode) */
N
N#define I2C_TIMINGR_SCLH_Pos         (8U)
N#define I2C_TIMINGR_SCLH_Msk         (0xFFUL << I2C_TIMINGR_SCLH_Pos)           /*!< 0x0000FF00 */
N#define I2C_TIMINGR_SCLH             I2C_TIMINGR_SCLH_Msk                       /*!< SCL high period (master mode) */
N
N#define I2C_TIMINGR_SDADEL_Pos       (16U)
N#define I2C_TIMINGR_SDADEL_Msk       (0xFUL << I2C_TIMINGR_SDADEL_Pos)          /*!< 0x000F0000 */
N#define I2C_TIMINGR_SDADEL           I2C_TIMINGR_SDADEL_Msk                     /*!< Data hold time */
N
N#define I2C_TIMINGR_SCLDEL_Pos       (20U)
N#define I2C_TIMINGR_SCLDEL_Msk       (0xFUL << I2C_TIMINGR_SCLDEL_Pos)          /*!< 0x00F00000 */
N#define I2C_TIMINGR_SCLDEL           I2C_TIMINGR_SCLDEL_Msk                     /*!< Data setup time */
N
N#define I2C_TIMINGR_PRESC_Pos        (28U)
N#define I2C_TIMINGR_PRESC_Msk        (0xFUL << I2C_TIMINGR_PRESC_Pos)           /*!< 0xF0000000 */
N#define I2C_TIMINGR_PRESC            I2C_TIMINGR_PRESC_Msk                      /*!< Timings prescaler */
N
N/******************* Bit definition for I2C_TIMEOUTR register ****************/
N#define I2C_TIMEOUTR_TIMEOUTA_Pos    (0U)
N#define I2C_TIMEOUTR_TIMEOUTA_Msk    (0xFFFUL << I2C_TIMEOUTR_TIMEOUTA_Pos)     /*!< 0x00000FFF */
N#define I2C_TIMEOUTR_TIMEOUTA        I2C_TIMEOUTR_TIMEOUTA_Msk                  /*!< Bus timeout A */
N
N#define I2C_TIMEOUTR_TIDLE_Pos       (12U)
N#define I2C_TIMEOUTR_TIDLE_Msk       (0x1UL << I2C_TIMEOUTR_TIDLE_Pos)          /*!< 0x00001000 */
N#define I2C_TIMEOUTR_TIDLE           I2C_TIMEOUTR_TIDLE_Msk                     /*!< Idle clock timeout detection */
N
N#define I2C_TIMEOUTR_TIMOUTEN_Pos    (15U)
N#define I2C_TIMEOUTR_TIMOUTEN_Msk    (0x1UL << I2C_TIMEOUTR_TIMOUTEN_Pos)       /*!< 0x00008000 */
N#define I2C_TIMEOUTR_TIMOUTEN        I2C_TIMEOUTR_TIMOUTEN_Msk                  /*!< Clock timeout enable */
N
N#define I2C_TIMEOUTR_TIMEOUTB_Pos    (16U)
N#define I2C_TIMEOUTR_TIMEOUTB_Msk    (0xFFFUL << I2C_TIMEOUTR_TIMEOUTB_Pos)     /*!< 0x0FFF0000 */
N#define I2C_TIMEOUTR_TIMEOUTB        I2C_TIMEOUTR_TIMEOUTB_Msk                  /*!< Bus timeout B*/
N
N#define I2C_TIMEOUTR_TEXTEN_Pos      (31U)
N#define I2C_TIMEOUTR_TEXTEN_Msk      (0x1UL << I2C_TIMEOUTR_TEXTEN_Pos)         /*!< 0x80000000 */
N#define I2C_TIMEOUTR_TEXTEN          I2C_TIMEOUTR_TEXTEN_Msk                    /*!< Extended clock timeout enable */
N
N/******************  Bit definition for I2C_ISR register  ********************/
N#define I2C_ISR_TXE_Pos              (0U)
N#define I2C_ISR_TXE_Msk              (0x1UL << I2C_ISR_TXE_Pos)                 /*!< 0x00000001 */
N#define I2C_ISR_TXE                  I2C_ISR_TXE_Msk                            /*!< Transmit data register empty */
N
N#define I2C_ISR_TXIS_Pos             (1U)
N#define I2C_ISR_TXIS_Msk             (0x1UL << I2C_ISR_TXIS_Pos)                /*!< 0x00000002 */
N#define I2C_ISR_TXIS                 I2C_ISR_TXIS_Msk                           /*!< Transmit interrupt status */
N
N#define I2C_ISR_RXNE_Pos             (2U)
N#define I2C_ISR_RXNE_Msk             (0x1UL << I2C_ISR_RXNE_Pos)                /*!< 0x00000004 */
N#define I2C_ISR_RXNE                 I2C_ISR_RXNE_Msk                           /*!< Receive data register not empty */
N
N#define I2C_ISR_ADDR_Pos             (3U)
N#define I2C_ISR_ADDR_Msk             (0x1UL << I2C_ISR_ADDR_Pos)                /*!< 0x00000008 */
N#define I2C_ISR_ADDR                 I2C_ISR_ADDR_Msk                           /*!< Address matched (slave mode)*/
N
N#define I2C_ISR_NACKF_Pos            (4U)
N#define I2C_ISR_NACKF_Msk            (0x1UL << I2C_ISR_NACKF_Pos)               /*!< 0x00000010 */
N#define I2C_ISR_NACKF                I2C_ISR_NACKF_Msk                          /*!< NACK received flag */
N
N#define I2C_ISR_STOPF_Pos            (5U)
N#define I2C_ISR_STOPF_Msk            (0x1UL << I2C_ISR_STOPF_Pos)               /*!< 0x00000020 */
N#define I2C_ISR_STOPF                I2C_ISR_STOPF_Msk                          /*!< STOP detection flag */
N
N#define I2C_ISR_TC_Pos               (6U)
N#define I2C_ISR_TC_Msk               (0x1UL << I2C_ISR_TC_Pos)                  /*!< 0x00000040 */
N#define I2C_ISR_TC                   I2C_ISR_TC_Msk                             /*!< Transfer complete (master mode) */
N
N#define I2C_ISR_TCR_Pos              (7U)
N#define I2C_ISR_TCR_Msk              (0x1UL << I2C_ISR_TCR_Pos)                 /*!< 0x00000080 */
N#define I2C_ISR_TCR                  I2C_ISR_TCR_Msk                            /*!< Transfer complete reload */
N
N#define I2C_ISR_BERR_Pos             (8U)
N#define I2C_ISR_BERR_Msk             (0x1UL << I2C_ISR_BERR_Pos)                /*!< 0x00000100 */
N#define I2C_ISR_BERR                 I2C_ISR_BERR_Msk                           /*!< Bus error */
N
N#define I2C_ISR_ARLO_Pos             (9U)
N#define I2C_ISR_ARLO_Msk             (0x1UL << I2C_ISR_ARLO_Pos)                /*!< 0x00000200 */
N#define I2C_ISR_ARLO                 I2C_ISR_ARLO_Msk                           /*!< Arbitration lost */
N
N#define I2C_ISR_OVR_Pos              (10U)
N#define I2C_ISR_OVR_Msk              (0x1UL << I2C_ISR_OVR_Pos)                 /*!< 0x00000400 */
N#define I2C_ISR_OVR                  I2C_ISR_OVR_Msk                            /*!< Overrun/Underrun */
N
N#define I2C_ISR_PECERR_Pos           (11U)
N#define I2C_ISR_PECERR_Msk           (0x1UL << I2C_ISR_PECERR_Pos)              /*!< 0x00000800 */
N#define I2C_ISR_PECERR               I2C_ISR_PECERR_Msk                         /*!< PEC error in reception */
N
N#define I2C_ISR_TIMEOUT_Pos          (12U)
N#define I2C_ISR_TIMEOUT_Msk          (0x1UL << I2C_ISR_TIMEOUT_Pos)             /*!< 0x00001000 */
N#define I2C_ISR_TIMEOUT              I2C_ISR_TIMEOUT_Msk                        /*!< Timeout or Tlow detection flag */
N
N#define I2C_ISR_ALERT_Pos            (13U)
N#define I2C_ISR_ALERT_Msk            (0x1UL << I2C_ISR_ALERT_Pos)               /*!< 0x00002000 */
N#define I2C_ISR_ALERT                I2C_ISR_ALERT_Msk                          /*!< SMBus alert */
N
N#define I2C_ISR_BUSY_Pos             (15U)
N#define I2C_ISR_BUSY_Msk             (0x1UL << I2C_ISR_BUSY_Pos)                /*!< 0x00008000 */
N#define I2C_ISR_BUSY                 I2C_ISR_BUSY_Msk                           /*!< Bus busy */
N
N#define I2C_ISR_DIR_Pos              (16U)
N#define I2C_ISR_DIR_Msk              (0x1UL << I2C_ISR_DIR_Pos)                 /*!< 0x00010000 */
N#define I2C_ISR_DIR                  I2C_ISR_DIR_Msk                            /*!< Transfer direction (slave mode) */
N
N#define I2C_ISR_ADDCODE_Pos          (17U)
N#define I2C_ISR_ADDCODE_Msk          (0x7FUL << I2C_ISR_ADDCODE_Pos)            /*!< 0x00FE0000 */
N#define I2C_ISR_ADDCODE              I2C_ISR_ADDCODE_Msk                        /*!< Address match code (slave mode) */
N
N/******************  Bit definition for I2C_ICR register  ********************/
N#define I2C_ICR_ADDRCF_Pos           (3U)
N#define I2C_ICR_ADDRCF_Msk           (0x1UL << I2C_ICR_ADDRCF_Pos)              /*!< 0x00000008 */
N#define I2C_ICR_ADDRCF               I2C_ICR_ADDRCF_Msk                         /*!< Address matched clear flag */
N
N#define I2C_ICR_NACKCF_Pos           (4U)
N#define I2C_ICR_NACKCF_Msk           (0x1UL << I2C_ICR_NACKCF_Pos)              /*!< 0x00000010 */
N#define I2C_ICR_NACKCF               I2C_ICR_NACKCF_Msk                         /*!< NACK clear flag */
N
N#define I2C_ICR_STOPCF_Pos           (5U)
N#define I2C_ICR_STOPCF_Msk           (0x1UL << I2C_ICR_STOPCF_Pos)              /*!< 0x00000020 */
N#define I2C_ICR_STOPCF               I2C_ICR_STOPCF_Msk                         /*!< STOP detection clear flag */
N
N#define I2C_ICR_BERRCF_Pos           (8U)
N#define I2C_ICR_BERRCF_Msk           (0x1UL << I2C_ICR_BERRCF_Pos)              /*!< 0x00000100 */
N#define I2C_ICR_BERRCF               I2C_ICR_BERRCF_Msk                         /*!< Bus error clear flag */
N
N#define I2C_ICR_ARLOCF_Pos           (9U)
N#define I2C_ICR_ARLOCF_Msk           (0x1UL << I2C_ICR_ARLOCF_Pos)              /*!< 0x00000200 */
N#define I2C_ICR_ARLOCF               I2C_ICR_ARLOCF_Msk                         /*!< Arbitration lost clear flag */
N
N#define I2C_ICR_OVRCF_Pos            (10U)
N#define I2C_ICR_OVRCF_Msk            (0x1UL << I2C_ICR_OVRCF_Pos)               /*!< 0x00000400 */
N#define I2C_ICR_OVRCF                I2C_ICR_OVRCF_Msk                          /*!< Overrun/Underrun clear flag */
N
N#define I2C_ICR_PECCF_Pos            (11U)
N#define I2C_ICR_PECCF_Msk            (0x1UL << I2C_ICR_PECCF_Pos)               /*!< 0x00000800 */
N#define I2C_ICR_PECCF                I2C_ICR_PECCF_Msk                          /*!< PAC error clear flag */
N
N#define I2C_ICR_TIMOUTCF_Pos         (12U)
N#define I2C_ICR_TIMOUTCF_Msk         (0x1UL << I2C_ICR_TIMOUTCF_Pos)            /*!< 0x00001000 */
N#define I2C_ICR_TIMOUTCF             I2C_ICR_TIMOUTCF_Msk                       /*!< Timeout clear flag */
N
N#define I2C_ICR_ALERTCF_Pos          (13U)
N#define I2C_ICR_ALERTCF_Msk          (0x1UL << I2C_ICR_ALERTCF_Pos)             /*!< 0x00002000 */
N#define I2C_ICR_ALERTCF              I2C_ICR_ALERTCF_Msk                        /*!< Alert clear flag */
N
N/******************  Bit definition for I2C_PECR register  *******************/
N#define I2C_PECR_PEC_Pos             (0U)
N#define I2C_PECR_PEC_Msk             (0xFFUL << I2C_PECR_PEC_Pos)               /*!< 0x000000FF */
N#define I2C_PECR_PEC                 I2C_PECR_PEC_Msk                           /*!< PEC register */
N
N/******************  Bit definition for I2C_RXDR register  *********************/
N#define I2C_RXDR_RXDATA_Pos          (0U)
N#define I2C_RXDR_RXDATA_Msk          (0xFFUL << I2C_RXDR_RXDATA_Pos)            /*!< 0x000000FF */
N#define I2C_RXDR_RXDATA              I2C_RXDR_RXDATA_Msk                        /*!< 8-bit receive data */
N
N/******************  Bit definition for I2C_TXDR register  *******************/
N#define I2C_TXDR_TXDATA_Pos          (0U)
N#define I2C_TXDR_TXDATA_Msk          (0xFFUL << I2C_TXDR_TXDATA_Pos)            /*!< 0x000000FF */
N#define I2C_TXDR_TXDATA              I2C_TXDR_TXDATA_Msk                        /*!< 8-bit transmit data */
N
N
N/*****************************************************************************/
N/*                                                                           */
N/*                        Independent WATCHDOG (IWDG)                        */
N/*                                                                           */
N/*****************************************************************************/
N/*******************  Bit definition for IWDG_KR register  *******************/
N#define IWDG_KR_KEY_Pos      (0U)
N#define IWDG_KR_KEY_Msk      (0xFFFFUL << IWDG_KR_KEY_Pos)                      /*!< 0x0000FFFF */
N#define IWDG_KR_KEY          IWDG_KR_KEY_Msk                                    /*!< Key value (write only, read 0000h) */
N
N/*******************  Bit definition for IWDG_PR register  *******************/
N#define IWDG_PR_PR_Pos       (0U)
N#define IWDG_PR_PR_Msk       (0x7UL << IWDG_PR_PR_Pos)                          /*!< 0x00000007 */
N#define IWDG_PR_PR           IWDG_PR_PR_Msk                                     /*!< PR[2:0] (Prescaler divider) */
N#define IWDG_PR_PR_0         (0x1UL << IWDG_PR_PR_Pos)                          /*!< 0x01 */
N#define IWDG_PR_PR_1         (0x2UL << IWDG_PR_PR_Pos)                          /*!< 0x02 */
N#define IWDG_PR_PR_2         (0x4UL << IWDG_PR_PR_Pos)                          /*!< 0x04 */
N
N/*******************  Bit definition for IWDG_RLR register  ******************/
N#define IWDG_RLR_RL_Pos      (0U)
N#define IWDG_RLR_RL_Msk      (0xFFFUL << IWDG_RLR_RL_Pos)                       /*!< 0x00000FFF */
N#define IWDG_RLR_RL          IWDG_RLR_RL_Msk                                    /*!< Watchdog counter reload value */
N
N/*******************  Bit definition for IWDG_SR register  *******************/
N#define IWDG_SR_PVU_Pos      (0U)
N#define IWDG_SR_PVU_Msk      (0x1UL << IWDG_SR_PVU_Pos)                         /*!< 0x00000001 */
N#define IWDG_SR_PVU          IWDG_SR_PVU_Msk                                    /*!< Watchdog prescaler value update */
N#define IWDG_SR_RVU_Pos      (1U)
N#define IWDG_SR_RVU_Msk      (0x1UL << IWDG_SR_RVU_Pos)                         /*!< 0x00000002 */
N#define IWDG_SR_RVU          IWDG_SR_RVU_Msk                                    /*!< Watchdog counter reload value update */
N#define IWDG_SR_WVU_Pos      (2U)
N#define IWDG_SR_WVU_Msk      (0x1UL << IWDG_SR_WVU_Pos)                         /*!< 0x00000004 */
N#define IWDG_SR_WVU          IWDG_SR_WVU_Msk                                    /*!< Watchdog counter window value update */
N
N/*******************  Bit definition for IWDG_KR register  *******************/
N#define IWDG_WINR_WIN_Pos    (0U)
N#define IWDG_WINR_WIN_Msk    (0xFFFUL << IWDG_WINR_WIN_Pos)                     /*!< 0x00000FFF */
N#define IWDG_WINR_WIN        IWDG_WINR_WIN_Msk                                  /*!< Watchdog counter window value */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                       Operational Amplifier  (OPAMP)                       */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for OPAMP_OPCR register  ******************/
N#define OPAMP_OPCR_OPAMP1EN_Pos     (0U)
N#define OPAMP_OPCR_OPAMP1EN_Msk     (0x1UL << OPAMP_OPCR_OPAMP1EN_Pos)          /*!< 0x00000001 */
N#define OPAMP_OPCR_OPAMP1EN         OPAMP_OPCR_OPAMP1EN_Msk
N
N#define OPAMP_OPCR_OPAMP1NSEL_Pos   (1U)
N#define OPAMP_OPCR_OPAMP1NSEL_Msk   (0x3UL << OPAMP_OPCR_OPAMP1NSEL_Pos)        /*!< 0x00000006 */
N#define OPAMP_OPCR_OPAMP1NSEL       OPAMP_OPCR_OPAMP1NSEL_Msk
N#define OPAMP_OPCR_OPAMP1NSEL_0     (0x1UL << OPAMP_OPCR_OPAMP1NSEL_Pos)
N#define OPAMP_OPCR_OPAMP1NSEL_1     (0x2UL << OPAMP_OPCR_OPAMP1NSEL_Pos)
N
N#define OPAMP_OPCR_OPAMP1GAIN_Pos   (4U)
N#define OPAMP_OPCR_OPAMP1GAIN_Msk   (0x3UL << OPAMP_OPCR_OPAMP1GAIN_Pos)        /*!< 0x00000030 */
N#define OPAMP_OPCR_OPAMP1GAIN       OPAMP_OPCR_OPAMP1GAIN_Msk
N#define OPAMP_OPCR_OPAMP1GAIN_0     (0x1UL << OPAMP_OPCR_OPAMP1GAIN_Pos)
N#define OPAMP_OPCR_OPAMP1GAIN_1     (0x2UL << OPAMP_OPCR_OPAMP1GAIN_Pos)
N
N#define OPAMP_OPCR_OPAMP1OUTEN_Pos  (7U)
N#define OPAMP_OPCR_OPAMP1OUTEN_Msk  (0x1UL << OPAMP_OPCR_OPAMP1OUTEN_Pos)       /*!< 0x00000080 */
N#define OPAMP_OPCR_OPAMP1OUTEN      OPAMP_OPCR_OPAMP1OUTEN_Msk
N
N#define OPAMP_OPCR_OPAMP2EN_Pos     (8U)
N#define OPAMP_OPCR_OPAMP2EN_Msk     (0x1UL << OPAMP_OPCR_OPAMP2EN_Pos)          /*!< 0x00000100 */
N#define OPAMP_OPCR_OPAMP2EN         OPAMP_OPCR_OPAMP2EN_Msk
N
N#define OPAMP_OPCR_OPAMP2NSEL_Pos   (9U)
N#define OPAMP_OPCR_OPAMP2NSEL_Msk   (0x3UL << OPAMP_OPCR_OPAMP2NSEL_Pos)        /*!< 0x00000600 */
N#define OPAMP_OPCR_OPAMP2NSEL       OPAMP_OPCR_OPAMP2NSEL_Msk
N#define OPAMP_OPCR_OPAMP2NSEL_0     (0x1UL << OPAMP_OPCR_OPAMP2NSEL_Pos)
N#define OPAMP_OPCR_OPAMP2NSEL_1     (0x2UL << OPAMP_OPCR_OPAMP2NSEL_Pos)
N
N#define OPAMP_OPCR_OPAMP2GAIN_Pos   (12U)
N#define OPAMP_OPCR_OPAMP2GAIN_Msk   (0x3UL << OPAMP_OPCR_OPAMP2GAIN_Pos)        /*!< 0x00003000 */
N#define OPAMP_OPCR_OPAMP2GAIN       OPAMP_OPCR_OPAMP2GAIN_Msk
N#define OPAMP_OPCR_OPAMP2GAIN_0     (0x1UL << OPAMP_OPCR_OPAMP2GAIN_Pos)
N#define OPAMP_OPCR_OPAMP2GAIN_1     (0x2UL << OPAMP_OPCR_OPAMP2GAIN_Pos)
N
N#define OPAMP_OPCR_OPAMP2OUTEN_Pos  (15U)
N#define OPAMP_OPCR_OPAMP2OUTEN_Msk  (0x1UL << OPAMP_OPCR_OPAMP2OUTEN_Pos)       /*!< 0x00008000 */
N#define OPAMP_OPCR_OPAMP2OUTEN      OPAMP_OPCR_OPAMP2OUTEN_Msk
N
N#define OPAMP_OPCR_OPAMP3EN_Pos     (16U)
N#define OPAMP_OPCR_OPAMP3EN_Msk     (0x1UL << OPAMP_OPCR_OPAMP3EN_Pos)          /*!< 0x00010000 */
N#define OPAMP_OPCR_OPAMP3EN         OPAMP_OPCR_OPAMP3EN_Msk
N
N#define OPAMP_OPCR_OPAMP3NSEL_Pos   (17U)
N#define OPAMP_OPCR_OPAMP3NSEL_Msk   (0x3UL << OPAMP_OPCR_OPAMP3NSEL_Pos)        /*!< 0x00060000 */
N#define OPAMP_OPCR_OPAMP3NSEL       OPAMP_OPCR_OPAMP3NSEL_Msk
N#define OPAMP_OPCR_OPAMP3NSEL_0     (0x1UL << OPAMP_OPCR_OPAMP3NSEL_Pos)
N#define OPAMP_OPCR_OPAMP3NSEL_1     (0x2UL << OPAMP_OPCR_OPAMP3NSEL_Pos)
N
N#define OPAMP_OPCR_OPAMP3GAIN_Pos   (20U)
N#define OPAMP_OPCR_OPAMP3GAIN_Msk   (0x3UL << OPAMP_OPCR_OPAMP3GAIN_Pos)        /*!< 0x00300000 */
N#define OPAMP_OPCR_OPAMP3GAIN       OPAMP_OPCR_OPAMP3GAIN_Msk
N#define OPAMP_OPCR_OPAMP3GAIN_0     (0x1UL << OPAMP_OPCR_OPAMP3GAIN_Pos)
N#define OPAMP_OPCR_OPAMP3GAIN_1     (0x2UL << OPAMP_OPCR_OPAMP3GAIN_Pos)
N
N#define OPAMP_OPCR_OPAMP3OUTEN_Pos  (23U)
N#define OPAMP_OPCR_OPAMP3OUTEN_Msk  (0x1UL << OPAMP_OPCR_OPAMP3OUTEN_Pos)       /*!< 0x00800000 */
N#define OPAMP_OPCR_OPAMP3OUTEN      OPAMP_OPCR_OPAMP3OUTEN_Msk
N
N#define OPAMP_OPCR_OPAMPLCK_Pos     (31U)
N#define OPAMP_OPCR_OPAMPLCK_Msk     (0x1UL << OPAMP_OPCR_OPAMPLCK_Pos)          /*!< 0x80000000 */
N#define OPAMP_OPCR_OPAMPLCK         OPAMP_OPCR_OPAMPLCK_Msk
N
N/*****************  Bit definition for OPAMP_OPxCAL register  *****************/
N#define OPAMP_OPxCAL_OPxCALDATN_Pos (0U)
N#define OPAMP_OPxCAL_OPxCALDATN_Msk (0x1UL << OPAMP_OPxCAL_OPxCALDATN_Pos)      /*!< 0x0000003F */
N#define OPAMP_OPxCAL_OPxCALDATN     OPAMP_OPxCAL_OPxCALDATN_Msk
N#define OPAMP_OPxCAL_OPxCALDATN_0   (0x01UL << OPAMP_OPxCAL_OPxCALDATN_Pos)
N#define OPAMP_OPxCAL_OPxCALDATN_1   (0x02UL << OPAMP_OPxCAL_OPxCALDATN_Pos)
N#define OPAMP_OPxCAL_OPxCALDATN_2   (0x04UL << OPAMP_OPxCAL_OPxCALDATN_Pos)
N#define OPAMP_OPxCAL_OPxCALDATN_3   (0x08UL << OPAMP_OPxCAL_OPxCALDATN_Pos)
N#define OPAMP_OPxCAL_OPxCALDATN_4   (0x10UL << OPAMP_OPxCAL_OPxCALDATN_Pos)
N#define OPAMP_OPxCAL_OPxCALDATN_5   (0x20UL << OPAMP_OPxCAL_OPxCALDATN_Pos)
N
N#define OPAMP_OPxCAL_OPxCALDATP_Pos (8U)
N#define OPAMP_OPxCAL_OPxCALDATP_Msk (0x1UL << OPAMP_OPxCAL_OPxCALDATP_Pos)      /*!< 0x00003F00 */
N#define OPAMP_OPxCAL_OPxCALDATP     OPAMP_OPxCAL_OPxCALDATP_Msk
N#define OPAMP_OPxCAL_OPxCALDATP_0   (0x01UL << OPAMP_OPxCAL_OPxCALDATP_Pos)
N#define OPAMP_OPxCAL_OPxCALDATP_1   (0x02UL << OPAMP_OPxCAL_OPxCALDATP_Pos)
N#define OPAMP_OPxCAL_OPxCALDATP_2   (0x04UL << OPAMP_OPxCAL_OPxCALDATP_Pos)
N#define OPAMP_OPxCAL_OPxCALDATP_3   (0x08UL << OPAMP_OPxCAL_OPxCALDATP_Pos)
N#define OPAMP_OPxCAL_OPxCALDATP_4   (0x10UL << OPAMP_OPxCAL_OPxCALDATP_Pos)
N#define OPAMP_OPxCAL_OPxCALDATP_5   (0x20UL << OPAMP_OPxCAL_OPxCALDATP_Pos)
N
N#define OPAMP_OPxCAL_OPxSYNC_Pos    (30U)
N#define OPAMP_OPxCAL_OPxSYNC_Msk    (0x1UL << OPAMP_OPxCAL_OPxSYNC_Pos)         /*!< 0x40000000 */
N#define OPAMP_OPxCAL_OPxSYNC        OPAMP_OPxCAL_OPxSYNC_Msk
N
N#define OPAMP_OPxCAL_OPxCALEN_Pos   (31U)
N#define OPAMP_OPxCAL_OPxCALEN_Msk   (0x1UL << OPAMP_OPxCAL_OPxCALEN_Pos)        /*!< 0x80000000 */
N#define OPAMP_OPxCAL_OPxCALEN       OPAMP_OPxCAL_OPxCALEN_Msk
N
N
N/*****************************************************************************/
N/*                                                                           */
N/*                          Power Control (PWR)                              */
N/*                                                                           */
N/*****************************************************************************/
N#define PWR_PVD_SUPPORT            /*!< PWR feature available only on specific devices: Power Voltage Detection feature */
N
N/********************  Bit definition for PWR_CR register  *******************/
N#define PWR_CR_LPDS_Pos            (0U)
N#define PWR_CR_LPDS_Msk            (0x1UL << PWR_CR_LPDS_Pos)                   /*!< 0x00000001 */
N#define PWR_CR_LPDS                PWR_CR_LPDS_Msk                              /*!< Low-power Deepsleep */
N
N#define PWR_CR_PDDS_Pos            (1U)
N#define PWR_CR_PDDS_Msk            (0x1UL << PWR_CR_PDDS_Pos)                   /*!< 0x00000002 */
N#define PWR_CR_PDDS                PWR_CR_PDDS_Msk                              /*!< Power Down Deepsleep */
N
N#define PWR_CR_CWUF_Pos            (2U)
N#define PWR_CR_CWUF_Msk            (0x1UL << PWR_CR_CWUF_Pos)                   /*!< 0x00000004 */
N#define PWR_CR_CWUF                PWR_CR_CWUF_Msk                              /*!< Clear Wakeup Flag */
N
N#define PWR_CR_CSBF_Pos            (3U)
N#define PWR_CR_CSBF_Msk            (0x1UL << PWR_CR_CSBF_Pos)                   /*!< 0x00000008 */
N#define PWR_CR_CSBF                PWR_CR_CSBF_Msk                              /*!< Clear Standby Flag */
N
N#define PWR_CR_PVDE_Pos            (4U)
N#define PWR_CR_PVDE_Msk            (0x1UL << PWR_CR_PVDE_Pos)                   /*!< 0x00000010 */
N#define PWR_CR_PVDE                PWR_CR_PVDE_Msk                              /*!< Power Voltage Detector Enable */
N
N#define PWR_CR_PLS_Pos             (5U)
N#define PWR_CR_PLS_Msk             (0x7UL << PWR_CR_PLS_Pos)                    /*!< 0x000000E0 */
N#define PWR_CR_PLS                 PWR_CR_PLS_Msk                               /*!< PLS[2:0] bits (PVD Level Selection) */
N#define PWR_CR_PLS_0               (0x1UL << PWR_CR_PLS_Pos)                    /*!< 0x00000020 */
N#define PWR_CR_PLS_1               (0x2UL << PWR_CR_PLS_Pos)                    /*!< 0x00000040 */
N#define PWR_CR_PLS_2               (0x4UL << PWR_CR_PLS_Pos)                    /*!< 0x00000080 */
N
N/*!< PVD level configuration */
N#define PWR_CR_PLS_LEV0            (0x00000000U)                                /*!< PVD level 0 */
N#define PWR_CR_PLS_LEV1            (0x00000020U)                                /*!< PVD level 1 */
N#define PWR_CR_PLS_LEV2            (0x00000040U)                                /*!< PVD level 2 */
N#define PWR_CR_PLS_LEV3            (0x00000060U)                                /*!< PVD level 3 */
N#define PWR_CR_PLS_LEV4            (0x00000080U)                                /*!< PVD level 4 */
N#define PWR_CR_PLS_LEV5            (0x000000A0U)                                /*!< PVD level 5 */
N#define PWR_CR_PLS_LEV6            (0x000000C0U)                                /*!< PVD level 6 */
N#define PWR_CR_PLS_LEV7            (0x000000E0U)                                /*!< PVD level 7 */
N
N#define PWR_CR_DBP_Pos             (8U)
N#define PWR_CR_DBP_Msk             (0x1UL << PWR_CR_DBP_Pos)                    /*!< 0x00000100 */
N#define PWR_CR_DBP                 PWR_CR_DBP_Msk                               /*!< Disable Backup Domain write protection */
N
N/*******************  Bit definition for PWR_CSR register  *******************/
N#define PWR_CSR_WUF_Pos            (0U)
N#define PWR_CSR_WUF_Msk            (0x1UL << PWR_CSR_WUF_Pos)                   /*!< 0x00000001 */
N#define PWR_CSR_WUF                PWR_CSR_WUF_Msk                              /*!< Wakeup Flag */
N
N#define PWR_CSR_SBF_Pos            (1U)
N#define PWR_CSR_SBF_Msk            (0x1UL << PWR_CSR_SBF_Pos)                   /*!< 0x00000002 */
N#define PWR_CSR_SBF                PWR_CSR_SBF_Msk                              /*!< Standby Flag */
N
N#define PWR_CSR_PVDO_Pos           (2U)
N#define PWR_CSR_PVDO_Msk           (0x1UL << PWR_CSR_PVDO_Pos)                  /*!< 0x00000004 */
N#define PWR_CSR_PVDO               PWR_CSR_PVDO_Msk                             /*!< PVD Output */
N
N#define PWR_CSR_VREFINTRDYF_Pos    (3U)
N#define PWR_CSR_VREFINTRDYF_Msk    (0x1UL << PWR_CSR_VREFINTRDYF_Pos)           /*!< 0x00000008 */
N#define PWR_CSR_VREFINTRDYF        PWR_CSR_VREFINTRDYF_Msk                      /*!< Internal voltage reference (VREFINT) ready flag */
N
N#define PWR_CSR_EWUP1_Pos          (8U)
N#define PWR_CSR_EWUP1_Msk          (0x1UL << PWR_CSR_EWUP1_Pos)                 /*!< 0x00000100 */
N#define PWR_CSR_EWUP1              PWR_CSR_EWUP1_Msk                            /*!< Enable WKUP pin 1 */
N
N#define PWR_CSR_EWUP2_Pos          (9U)
N#define PWR_CSR_EWUP2_Msk          (0x1UL << PWR_CSR_EWUP2_Pos)                 /*!< 0x00000200 */
N#define PWR_CSR_EWUP2              PWR_CSR_EWUP2_Msk                            /*!< Enable WKUP pin 2 */
N
N
N/*****************************************************************************/
N/*                                                                           */
N/*                         Reset and Clock Control                           */
N/*                                                                           */
N/*****************************************************************************/
N/********************  Bit definition for RCC_CR register  *******************/
N#define RCC_CR_HSION_Pos                    (0U)
N#define RCC_CR_HSION_Msk                    (0x1UL << RCC_CR_HSION_Pos)             /*!< 0x00000001 */
N#define RCC_CR_HSION                        RCC_CR_HSION_Msk                        /*!< Internal High Speed clock enable */
N
N#define RCC_CR_HSIRDY_Pos                   (1U)
N#define RCC_CR_HSIRDY_Msk                   (0x1UL << RCC_CR_HSIRDY_Pos)            /*!< 0x00000002 */
N#define RCC_CR_HSIRDY                       RCC_CR_HSIRDY_Msk                       /*!< Internal High Speed clock ready flag */
N
N#define RCC_CR_HSITRIM_Pos                  (3U)
N#define RCC_CR_HSITRIM_Msk                  (0x1FUL << RCC_CR_HSITRIM_Pos)          /*!< 0x000000F8 */
N#define RCC_CR_HSITRIM                      RCC_CR_HSITRIM_Msk                      /*!< Internal High Speed clock trimming */
N#define RCC_CR_HSITRIM_0                    (0x01UL << RCC_CR_HSITRIM_Pos)          /*!< 0x00000008 */
N#define RCC_CR_HSITRIM_1                    (0x02UL << RCC_CR_HSITRIM_Pos)          /*!< 0x00000010 */
N#define RCC_CR_HSITRIM_2                    (0x04UL << RCC_CR_HSITRIM_Pos)          /*!< 0x00000020 */
N#define RCC_CR_HSITRIM_3                    (0x08UL << RCC_CR_HSITRIM_Pos)          /*!< 0x00000040 */
N#define RCC_CR_HSITRIM_4                    (0x10UL << RCC_CR_HSITRIM_Pos)          /*!< 0x00000080 */
N
N#define RCC_CR_HSICAL_Pos                   (8U)
N#define RCC_CR_HSICAL_Msk                   (0xFFUL << RCC_CR_HSICAL_Pos)           /*!< 0x0000FF00 */
N#define RCC_CR_HSICAL                       RCC_CR_HSICAL_Msk                       /*!< Internal High Speed clock Calibration */
N#define RCC_CR_HSICAL_0                     (0x01UL << RCC_CR_HSICAL_Pos)           /*!< 0x00000100 */
N#define RCC_CR_HSICAL_1                     (0x02UL << RCC_CR_HSICAL_Pos)           /*!< 0x00000200 */
N#define RCC_CR_HSICAL_2                     (0x04UL << RCC_CR_HSICAL_Pos)           /*!< 0x00000400 */
N#define RCC_CR_HSICAL_3                     (0x08UL << RCC_CR_HSICAL_Pos)           /*!< 0x00000800 */
N#define RCC_CR_HSICAL_4                     (0x10UL << RCC_CR_HSICAL_Pos)           /*!< 0x00001000 */
N#define RCC_CR_HSICAL_5                     (0x20UL << RCC_CR_HSICAL_Pos)           /*!< 0x00002000 */
N#define RCC_CR_HSICAL_6                     (0x40UL << RCC_CR_HSICAL_Pos)           /*!< 0x00004000 */
N#define RCC_CR_HSICAL_7                     (0x80UL << RCC_CR_HSICAL_Pos)           /*!< 0x00008000 */
N
N#define RCC_CR_HSEON_Pos                    (16U)
N#define RCC_CR_HSEON_Msk                    (0x1UL << RCC_CR_HSEON_Pos)             /*!< 0x00010000 */
N#define RCC_CR_HSEON                        RCC_CR_HSEON_Msk                        /*!< External High Speed clock enable */
N
N#define RCC_CR_HSERDY_Pos                   (17U)
N#define RCC_CR_HSERDY_Msk                   (0x1UL << RCC_CR_HSERDY_Pos)            /*!< 0x00020000 */
N#define RCC_CR_HSERDY                       RCC_CR_HSERDY_Msk                       /*!< External High Speed clock ready flag */
N
N#define RCC_CR_HSEBYP_Pos                   (18U)
N#define RCC_CR_HSEBYP_Msk                   (0x1UL << RCC_CR_HSEBYP_Pos)            /*!< 0x00040000 */
N#define RCC_CR_HSEBYP                       RCC_CR_HSEBYP_Msk                       /*!< External High Speed clock Bypass */
N
N#define RCC_CR_CSSON_Pos                    (19U)
N#define RCC_CR_CSSON_Msk                    (0x1UL << RCC_CR_CSSON_Pos)             /*!< 0x00080000 */
N#define RCC_CR_CSSON                        RCC_CR_CSSON_Msk                        /*!< Clock Security System enable */
N
N#define RCC_CR_PLLON_Pos                    (24U)
N#define RCC_CR_PLLON_Msk                    (0x1UL << RCC_CR_PLLON_Pos)             /*!< 0x01000000 */
N#define RCC_CR_PLLON                        RCC_CR_PLLON_Msk                        /*!< PLL enable */
N
N#define RCC_CR_PLLRDY_Pos                   (25U)
N#define RCC_CR_PLLRDY_Msk                   (0x1UL << RCC_CR_PLLRDY_Pos)            /*!< 0x02000000 */
N#define RCC_CR_PLLRDY                       RCC_CR_PLLRDY_Msk                       /*!< PLL clock ready flag */
N
N/********************  Bit definition for RCC_CFGR register  *****************/
N/*!< SW configuration */
N#define RCC_CFGR_SW_Pos                     (0U)
N#define RCC_CFGR_SW_Msk                     (0x3UL << RCC_CFGR_SW_Pos)              /*!< 0x00000003 */
N#define RCC_CFGR_SW                         RCC_CFGR_SW_Msk                         /*!< SW[1:0] bits (System clock Switch) */
N#define RCC_CFGR_SW_0                       (0x1UL << RCC_CFGR_SW_Pos)              /*!< 0x00000001 */
N#define RCC_CFGR_SW_1                       (0x2UL << RCC_CFGR_SW_Pos)              /*!< 0x00000002 */
N#define RCC_CFGR_SW_HSI                     (0x00000000U)                           /*!< HSI selected as system clock */
N#define RCC_CFGR_SW_HSE                     (0x00000001U)                           /*!< HSE selected as system clock */
N#define RCC_CFGR_SW_PLL                     (0x00000002U)                           /*!< PLL selected as system clock */
N
N/*!< SWS configuration */
N#define RCC_CFGR_SWS_Pos                    (2U)
N#define RCC_CFGR_SWS_Msk                    (0x3UL << RCC_CFGR_SWS_Pos)             /*!< 0x0000000C */
N#define RCC_CFGR_SWS                        RCC_CFGR_SWS_Msk                        /*!< SWS[1:0] bits (System Clock Switch Status) */
N#define RCC_CFGR_SWS_0                      (0x1UL << RCC_CFGR_SWS_Pos)             /*!< 0x00000004 */
N#define RCC_CFGR_SWS_1                      (0x2UL << RCC_CFGR_SWS_Pos)             /*!< 0x00000008 */
N#define RCC_CFGR_SWS_HSI                    (0x00000000U)                           /*!< HSI oscillator used as system clock */
N#define RCC_CFGR_SWS_HSE                    (0x00000004U)                           /*!< HSE oscillator used as system clock */
N#define RCC_CFGR_SWS_PLL                    (0x00000008U)                           /*!< PLL used as system clock */
N
N/*!< HPRE configuration */
N#define RCC_CFGR_HPRE_Pos                   (4U)
N#define RCC_CFGR_HPRE_Msk                   (0xFUL << RCC_CFGR_HPRE_Pos)            /*!< 0x000000F0 */
N#define RCC_CFGR_HPRE                       RCC_CFGR_HPRE_Msk                       /*!< HPRE[3:0] bits (AHB prescaler) */
N#define RCC_CFGR_HPRE_0                     (0x1UL << RCC_CFGR_HPRE_Pos)            /*!< 0x00000010 */
N#define RCC_CFGR_HPRE_1                     (0x2UL << RCC_CFGR_HPRE_Pos)            /*!< 0x00000020 */
N#define RCC_CFGR_HPRE_2                     (0x4UL << RCC_CFGR_HPRE_Pos)            /*!< 0x00000040 */
N#define RCC_CFGR_HPRE_3                     (0x8UL << RCC_CFGR_HPRE_Pos)            /*!< 0x00000080 */
N#define RCC_CFGR_HPRE_DIV1                  (0x00000000U)                           /*!< SYSCLK not divided */
N#define RCC_CFGR_HPRE_DIV2                  (0x00000080U)                           /*!< SYSCLK divided by 2 */
N#define RCC_CFGR_HPRE_DIV4                  (0x00000090U)                           /*!< SYSCLK divided by 4 */
N#define RCC_CFGR_HPRE_DIV8                  (0x000000A0U)                           /*!< SYSCLK divided by 8 */
N#define RCC_CFGR_HPRE_DIV16                 (0x000000B0U)                           /*!< SYSCLK divided by 16 */
N#define RCC_CFGR_HPRE_DIV64                 (0x000000C0U)                           /*!< SYSCLK divided by 64 */
N#define RCC_CFGR_HPRE_DIV128                (0x000000D0U)                           /*!< SYSCLK divided by 128 */
N#define RCC_CFGR_HPRE_DIV256                (0x000000E0U)                           /*!< SYSCLK divided by 256 */
N#define RCC_CFGR_HPRE_DIV512                (0x000000F0U)                           /*!< SYSCLK divided by 512 */
N
N/*!< PPRE configuration */
N#define RCC_CFGR_PPRE_Pos                   (8U)
N#define RCC_CFGR_PPRE_Msk                   (0x7UL << RCC_CFGR_PPRE_Pos)            /*!< 0x00000700 */
N#define RCC_CFGR_PPRE                       RCC_CFGR_PPRE_Msk                       /*!< PRE[2:0] bits (APB prescaler) */
N#define RCC_CFGR_PPRE_0                     (0x1UL << RCC_CFGR_PPRE_Pos)            /*!< 0x00000100 */
N#define RCC_CFGR_PPRE_1                     (0x2UL << RCC_CFGR_PPRE_Pos)            /*!< 0x00000200 */
N#define RCC_CFGR_PPRE_2                     (0x4UL << RCC_CFGR_PPRE_Pos)            /*!< 0x00000400 */
N#define RCC_CFGR_PPRE_DIV1                  (0x00000000U)                           /*!< HCLK not divided */
N#define RCC_CFGR_PPRE_DIV2_Pos              (10U)
N#define RCC_CFGR_PPRE_DIV2_Msk              (0x1UL << RCC_CFGR_PPRE_DIV2_Pos)       /*!< 0x00000400 */
N#define RCC_CFGR_PPRE_DIV2                  RCC_CFGR_PPRE_DIV2_Msk                  /*!< HCLK divided by 2 */
N#define RCC_CFGR_PPRE_DIV4_Pos              (8U)
N#define RCC_CFGR_PPRE_DIV4_Msk              (0x5UL << RCC_CFGR_PPRE_DIV4_Pos)       /*!< 0x00000500 */
N#define RCC_CFGR_PPRE_DIV4                  RCC_CFGR_PPRE_DIV4_Msk                  /*!< HCLK divided by 4 */
N#define RCC_CFGR_PPRE_DIV8_Pos              (9U)
N#define RCC_CFGR_PPRE_DIV8_Msk              (0x3UL << RCC_CFGR_PPRE_DIV8_Pos)       /*!< 0x00000600 */
N#define RCC_CFGR_PPRE_DIV8                  RCC_CFGR_PPRE_DIV8_Msk                  /*!< HCLK divided by 8 */
N#define RCC_CFGR_PPRE_DIV16_Pos             (8U)
N#define RCC_CFGR_PPRE_DIV16_Msk             (0x7UL << RCC_CFGR_PPRE_DIV16_Pos)      /*!< 0x00000700 */
N#define RCC_CFGR_PPRE_DIV16                 RCC_CFGR_PPRE_DIV16_Msk                 /*!< HCLK divided by 16 */
N
N/*!< ADCPPRE configuration */
N#define RCC_CFGR_ADCPRE_Pos                 (14U)
N#define RCC_CFGR_ADCPRE_Msk                 (0x1UL << RCC_CFGR_ADCPRE_Pos)          /*!< 0x00004000 */
N#define RCC_CFGR_ADCPRE                     RCC_CFGR_ADCPRE_Msk                     /*!< ADCPRE bit (ADC prescaler) */
N#define RCC_CFGR_ADCPRE_DIV2                (0x00000000U)                           /*!< PCLK divided by 2 */
N#define RCC_CFGR_ADCPRE_DIV4                (0x00004000U)                           /*!< PCLK divided by 4 */
N
N#define RCC_CFGR_PLLSRC_Pos                 (16U)
N#define RCC_CFGR_PLLSRC_Msk                 (0x1UL << RCC_CFGR_PLLSRC_Pos)          /*!< 0x00010000 */
N#define RCC_CFGR_PLLSRC                     RCC_CFGR_PLLSRC_Msk                     /*!< PLL entry clock source */
N#define RCC_CFGR_PLLSRC_HSI_DIV2            (0x00000000U)                           /*!< HSI clock divided by 2 selected as PLL entry clock source */
N#define RCC_CFGR_PLLSRC_HSE_PREDIV          (0x00010000U)                           /*!< HSE/PREDIV clock selected as PLL entry clock source */
N
N#define RCC_CFGR_PLLXTPRE_Pos               (17U)
N#define RCC_CFGR_PLLXTPRE_Msk               (0x1UL << RCC_CFGR_PLLXTPRE_Pos)        /*!< 0x00020000 */
N#define RCC_CFGR_PLLXTPRE                   RCC_CFGR_PLLXTPRE_Msk                   /*!< HSE divider for PLL entry */
N#define RCC_CFGR_PLLXTPRE_HSE_PREDIV_DIV1   (0x00000000U)                           /*!< HSE/PREDIV clock not divided for PLL entry */
N#define RCC_CFGR_PLLXTPRE_HSE_PREDIV_DIV2   (0x00020000U)                           /*!< HSE/PREDIV clock divided by 2 for PLL entry */
N
N/*!< PLLMUL configuration */
N#define RCC_CFGR_PLLMUL_Pos                 (18U)
N#define RCC_CFGR_PLLMUL_Msk                 (0xFUL << RCC_CFGR_PLLMUL_Pos)          /*!< 0x003C0000 */
N#define RCC_CFGR_PLLMUL                     RCC_CFGR_PLLMUL_Msk                     /*!< PLLMUL[3:0] bits (PLL multiplication factor) */
N#define RCC_CFGR_PLLMUL_0                   (0x1UL << RCC_CFGR_PLLMUL_Pos)          /*!< 0x00040000 */
N#define RCC_CFGR_PLLMUL_1                   (0x2UL << RCC_CFGR_PLLMUL_Pos)          /*!< 0x00080000 */
N#define RCC_CFGR_PLLMUL_2                   (0x4UL << RCC_CFGR_PLLMUL_Pos)          /*!< 0x00100000 */
N#define RCC_CFGR_PLLMUL_3                   (0x8UL << RCC_CFGR_PLLMUL_Pos)          /*!< 0x00200000 */
N#define RCC_CFGR_PLLMUL2                    (0x00000000U)                           /*!< PLL input clock*2 */
N#define RCC_CFGR_PLLMUL3                    (0x00040000U)                           /*!< PLL input clock*3 */
N#define RCC_CFGR_PLLMUL4                    (0x00080000U)                           /*!< PLL input clock*4 */
N#define RCC_CFGR_PLLMUL5                    (0x000C0000U)                           /*!< PLL input clock*5 */
N#define RCC_CFGR_PLLMUL6                    (0x00100000U)                           /*!< PLL input clock*6 */
N#define RCC_CFGR_PLLMUL7                    (0x00140000U)                           /*!< PLL input clock*7 */
N#define RCC_CFGR_PLLMUL8                    (0x00180000U)                           /*!< PLL input clock*8 */
N#define RCC_CFGR_PLLMUL9                    (0x001C0000U)                           /*!< PLL input clock*9 */
N#define RCC_CFGR_PLLMUL10                   (0x00200000U)                           /*!< PLL input clock10 */
N#define RCC_CFGR_PLLMUL11                   (0x00240000U)                           /*!< PLL input clock*11 */
N#define RCC_CFGR_PLLMUL12                   (0x00280000U)                           /*!< PLL input clock*12 */
N#define RCC_CFGR_PLLMUL13                   (0x002C0000U)                           /*!< PLL input clock*13 */
N#define RCC_CFGR_PLLMUL14                   (0x00300000U)                           /*!< PLL input clock*14 */
N#define RCC_CFGR_PLLMUL15                   (0x00340000U)                           /*!< PLL input clock*15 */
N#define RCC_CFGR_PLLMUL16                   (0x00380000U)                           /*!< PLL input clock*16 */
N
N/*!< MCO configuration */
N#define RCC_CFGR_MCO_Pos                    (24U)
N#define RCC_CFGR_MCO_Msk                    (0xFUL << RCC_CFGR_MCO_Pos)             /*!< 0x0F000000 */
N#define RCC_CFGR_MCO                        RCC_CFGR_MCO_Msk                        /*!< MCO[3:0] bits (Microcontroller Clock Output) */
N#define RCC_CFGR_MCO_0                      (0x1UL << RCC_CFGR_MCO_Pos)             /*!< 0x01000000 */
N#define RCC_CFGR_MCO_1                      (0x2UL << RCC_CFGR_MCO_Pos)             /*!< 0x02000000 */
N#define RCC_CFGR_MCO_2                      (0x4UL << RCC_CFGR_MCO_Pos)             /*!< 0x04000000 */
N#define RCC_CFGR_MCO_NOCLOCK                (0x00000000U)                           /*!< No clock */
N#define RCC_CFGR_MCO_HSI16                  (0x01000000U)                           /*!< HSI14 clock selected as MCO source */
N#define RCC_CFGR_MCO_LSI                    (0x02000000U)                           /*!< LSI clock selected as MCO source */
N#define RCC_CFGR_MCO_LSE                    (0x03000000U)                           /*!< LSE clock selected as MCO source */
N#define RCC_CFGR_MCO_SYSCLK                 (0x04000000U)                           /*!< System clock selected as MCO source */
N#define RCC_CFGR_MCO_HSI                    (0x05000000U)                           /*!< HSI clock selected as MCO source */
N#define RCC_CFGR_MCO_HSE                    (0x06000000U)                           /*!< HSE clock selected as MCO source  */
N#define RCC_CFGR_MCO_PLL                    (0x07000000U)                           /*!< PLL clock divided by 2 selected as MCO source */
N
N#define RCC_CFGR_MCOPRE_Pos                 (28U)
N#define RCC_CFGR_MCOPRE_Msk                 (0x7UL << RCC_CFGR_MCOPRE_Pos)          /*!< 0x70000000 */
N#define RCC_CFGR_MCOPRE                     RCC_CFGR_MCOPRE_Msk                     /*!< MCO prescaler  */
N#define RCC_CFGR_MCOPRE_DIV1                (0x00000000U)                           /*!< MCO is divided by 1  */
N#define RCC_CFGR_MCOPRE_DIV2                (0x10000000U)                           /*!< MCO is divided by 2  */
N#define RCC_CFGR_MCOPRE_DIV4                (0x20000000U)                           /*!< MCO is divided by 4  */
N#define RCC_CFGR_MCOPRE_DIV8                (0x30000000U)                           /*!< MCO is divided by 8  */
N#define RCC_CFGR_MCOPRE_DIV16               (0x40000000U)                           /*!< MCO is divided by 16  */
N#define RCC_CFGR_MCOPRE_DIV32               (0x50000000U)                           /*!< MCO is divided by 32  */
N#define RCC_CFGR_MCOPRE_DIV64               (0x60000000U)                           /*!< MCO is divided by 64  */
N#define RCC_CFGR_MCOPRE_DIV128              (0x70000000U)                           /*!< MCO is divided by 128  */
N
N#define RCC_CFGR_PLLNODIV_Pos               (31U)
N#define RCC_CFGR_PLLNODIV_Msk               (0x1UL << RCC_CFGR_PLLNODIV_Pos)        /*!< 0x80000000 */
N#define RCC_CFGR_PLLNODIV                   RCC_CFGR_PLLNODIV_Msk                   /*!< PLL is not divided to MCO  */
N
N/*!<******************  Bit definition for RCC_CIR register  *****************/
N#define RCC_CIR_LSIRDYF_Pos                 (0U)
N#define RCC_CIR_LSIRDYF_Msk                 (0x1UL << RCC_CIR_LSIRDYF_Pos)          /*!< 0x00000001 */
N#define RCC_CIR_LSIRDYF                     RCC_CIR_LSIRDYF_Msk                     /*!< LSI Ready Interrupt flag */
N
N#define RCC_CIR_LSERDYF_Pos                 (1U)
N#define RCC_CIR_LSERDYF_Msk                 (0x1UL << RCC_CIR_LSERDYF_Pos)          /*!< 0x00000002 */
N#define RCC_CIR_LSERDYF                     RCC_CIR_LSERDYF_Msk                     /*!< LSE Ready Interrupt flag */
N
N#define RCC_CIR_HSIRDYF_Pos                 (2U)
N#define RCC_CIR_HSIRDYF_Msk                 (0x1UL << RCC_CIR_HSIRDYF_Pos)          /*!< 0x00000004 */
N#define RCC_CIR_HSIRDYF                     RCC_CIR_HSIRDYF_Msk                     /*!< HSI Ready Interrupt flag */
N
N#define RCC_CIR_HSERDYF_Pos                 (3U)
N#define RCC_CIR_HSERDYF_Msk                 (0x1UL << RCC_CIR_HSERDYF_Pos)          /*!< 0x00000008 */
N#define RCC_CIR_HSERDYF                     RCC_CIR_HSERDYF_Msk                     /*!< HSE Ready Interrupt flag */
N
N#define RCC_CIR_PLLRDYF_Pos                 (4U)
N#define RCC_CIR_PLLRDYF_Msk                 (0x1UL << RCC_CIR_PLLRDYF_Pos)          /*!< 0x00000010 */
N#define RCC_CIR_PLLRDYF                     RCC_CIR_PLLRDYF_Msk                     /*!< PLL Ready Interrupt flag */
N
N#define RCC_CIR_HSI16RDYF_Pos               (5U)
N#define RCC_CIR_HSI16RDYF_Msk               (0x1UL << RCC_CIR_HSI16RDYF_Pos)        /*!< 0x00000020 */
N#define RCC_CIR_HSI16RDYF                   RCC_CIR_HSI16RDYF_Msk                   /*!< HSI16 Ready Interrupt flag */
N
N#define RCC_CIR_CSSF_Pos                    (7U)
N#define RCC_CIR_CSSF_Msk                    (0x1UL << RCC_CIR_CSSF_Pos)             /*!< 0x00000080 */
N#define RCC_CIR_CSSF                        RCC_CIR_CSSF_Msk                        /*!< Clock Security System Interrupt flag */
N
N#define RCC_CIR_LSIRDYIE_Pos                (8U)
N#define RCC_CIR_LSIRDYIE_Msk                (0x1UL << RCC_CIR_LSIRDYIE_Pos)         /*!< 0x00000100 */
N#define RCC_CIR_LSIRDYIE                    RCC_CIR_LSIRDYIE_Msk                    /*!< LSI Ready Interrupt Enable */
N
N#define RCC_CIR_LSERDYIE_Pos                (9U)
N#define RCC_CIR_LSERDYIE_Msk                (0x1UL << RCC_CIR_LSERDYIE_Pos)         /*!< 0x00000200 */
N#define RCC_CIR_LSERDYIE                    RCC_CIR_LSERDYIE_Msk                    /*!< LSE Ready Interrupt Enable */
N
N#define RCC_CIR_HSIRDYIE_Pos                (10U)
N#define RCC_CIR_HSIRDYIE_Msk                (0x1UL << RCC_CIR_HSIRDYIE_Pos)         /*!< 0x00000400 */
N#define RCC_CIR_HSIRDYIE                    RCC_CIR_HSIRDYIE_Msk                    /*!< HSI Ready Interrupt Enable */
N
N#define RCC_CIR_HSERDYIE_Pos                (11U)
N#define RCC_CIR_HSERDYIE_Msk                (0x1UL << RCC_CIR_HSERDYIE_Pos)         /*!< 0x00000800 */
N#define RCC_CIR_HSERDYIE                    RCC_CIR_HSERDYIE_Msk                    /*!< HSE Ready Interrupt Enable */
N
N#define RCC_CIR_PLLRDYIE_Pos                (12U)
N#define RCC_CIR_PLLRDYIE_Msk                (0x1UL << RCC_CIR_PLLRDYIE_Pos)         /*!< 0x00001000 */
N#define RCC_CIR_PLLRDYIE                    RCC_CIR_PLLRDYIE_Msk                    /*!< PLL Ready Interrupt Enable */
N
N#define RCC_CIR_HSI16RDYIE_Pos              (13U)
N#define RCC_CIR_HSI16RDYIE_Msk              (0x1UL << RCC_CIR_HSI16RDYIE_Pos)       /*!< 0x00002000 */
N#define RCC_CIR_HSI16RDYIE                  RCC_CIR_HSI16RDYIE_Msk                  /*!< HSI16 Ready Interrupt Enable */
N
N#define RCC_CIR_LSIRDYC_Pos                 (16U)
N#define RCC_CIR_LSIRDYC_Msk                 (0x1UL << RCC_CIR_LSIRDYC_Pos)          /*!< 0x00010000 */
N#define RCC_CIR_LSIRDYC                     RCC_CIR_LSIRDYC_Msk                     /*!< LSI Ready Interrupt Clear */
N
N#define RCC_CIR_LSERDYC_Pos                 (17U)
N#define RCC_CIR_LSERDYC_Msk                 (0x1UL << RCC_CIR_LSERDYC_Pos)          /*!< 0x00020000 */
N#define RCC_CIR_LSERDYC                     RCC_CIR_LSERDYC_Msk                     /*!< LSE Ready Interrupt Clear */
N
N#define RCC_CIR_HSIRDYC_Pos                 (18U)
N#define RCC_CIR_HSIRDYC_Msk                 (0x1UL << RCC_CIR_HSIRDYC_Pos)          /*!< 0x00040000 */
N#define RCC_CIR_HSIRDYC                     RCC_CIR_HSIRDYC_Msk                     /*!< HSI Ready Interrupt Clear */
N
N#define RCC_CIR_HSERDYC_Pos                 (19U)
N#define RCC_CIR_HSERDYC_Msk                 (0x1UL << RCC_CIR_HSERDYC_Pos)          /*!< 0x00080000 */
N#define RCC_CIR_HSERDYC                     RCC_CIR_HSERDYC_Msk                     /*!< HSE Ready Interrupt Clear */
N
N#define RCC_CIR_PLLRDYC_Pos                 (20U)
N#define RCC_CIR_PLLRDYC_Msk                 (0x1UL << RCC_CIR_PLLRDYC_Pos)          /*!< 0x00100000 */
N#define RCC_CIR_PLLRDYC                     RCC_CIR_PLLRDYC_Msk                     /*!< PLL Ready Interrupt Clear */
N
N#define RCC_CIR_HSI14RDYC_Pos               (21U)
N#define RCC_CIR_HSI14RDYC_Msk               (0x1UL << RCC_CIR_HSI14RDYC_Pos)        /*!< 0x00200000 */
N#define RCC_CIR_HSI14RDYC                   RCC_CIR_HSI14RDYC_Msk                   /*!< HSI14 Ready Interrupt Clear */
N
N#define RCC_CIR_CSSC_Pos                    (23U)
N#define RCC_CIR_CSSC_Msk                    (0x1UL << RCC_CIR_CSSC_Pos)             /*!< 0x00800000 */
N#define RCC_CIR_CSSC                        RCC_CIR_CSSC_Msk                        /*!< Clock Security System Interrupt Clear */
N
N/*****************  Bit definition for RCC_APB2RSTR register  ****************/
N#define RCC_APB2RSTR_SYSCFGRST_Pos          (0U)
N#define RCC_APB2RSTR_SYSCFGRST_Msk          (0x1UL << RCC_APB2RSTR_SYSCFGRST_Pos)   /*!< 0x00000001 */
N#define RCC_APB2RSTR_SYSCFGRST              RCC_APB2RSTR_SYSCFGRST_Msk              /*!< SYSCFG reset */
N
N#define RCC_APB2RSTR_ADCRST_Pos             (9U)
N#define RCC_APB2RSTR_ADCRST_Msk             (0x1UL << RCC_APB2RSTR_ADCRST_Pos)      /*!< 0x00000200 */
N#define RCC_APB2RSTR_ADCRST                 RCC_APB2RSTR_ADCRST_Msk                 /*!< ADC reset */
N
N#define RCC_APB2RSTR_TIM1RST_Pos            (11U)
N#define RCC_APB2RSTR_TIM1RST_Msk            (0x1UL << RCC_APB2RSTR_TIM1RST_Pos)     /*!< 0x00000800 */
N#define RCC_APB2RSTR_TIM1RST                RCC_APB2RSTR_TIM1RST_Msk                /*!< TIM1 reset */
N
N#define RCC_APB2RSTR_SPI1RST_Pos            (12U)
N#define RCC_APB2RSTR_SPI1RST_Msk            (0x1UL << RCC_APB2RSTR_SPI1RST_Pos)     /*!< 0x00001000 */
N#define RCC_APB2RSTR_SPI1RST                RCC_APB2RSTR_SPI1RST_Msk                /*!< SPI1 reset */
N
N#define RCC_APB2RSTR_USART1RST_Pos          (14U)
N#define RCC_APB2RSTR_USART1RST_Msk          (0x1UL << RCC_APB2RSTR_USART1RST_Pos)   /*!< 0x00004000 */
N#define RCC_APB2RSTR_USART1RST              RCC_APB2RSTR_USART1RST_Msk              /*!< USART1 reset */
N
N#define RCC_APB2RSTR_TIM16RST_Pos           (17U)
N#define RCC_APB2RSTR_TIM16RST_Msk           (0x1UL << RCC_APB2RSTR_TIM16RST_Pos)    /*!< 0x00020000 */
N#define RCC_APB2RSTR_TIM16RST               RCC_APB2RSTR_TIM16RST_Msk               /*!< TIM16 reset */
N
N#define RCC_APB2RSTR_TIM17RST_Pos           (18U)
N#define RCC_APB2RSTR_TIM17RST_Msk           (0x1UL << RCC_APB2RSTR_TIM17RST_Pos)    /*!< 0x00040000 */
N#define RCC_APB2RSTR_TIM17RST               RCC_APB2RSTR_TIM17RST_Msk               /*!< TIM17 reset */
N
N#define RCC_APB2RSTR_DBGMCURST_Pos          (22U)
N#define RCC_APB2RSTR_DBGMCURST_Msk          (0x1UL << RCC_APB2RSTR_DBGMCURST_Pos)   /*!< 0x00400000 */
N#define RCC_APB2RSTR_DBGMCURST              RCC_APB2RSTR_DBGMCURST_Msk              /*!< DBGMCU reset */
N
N/*****************  Bit definition for RCC_APB1RSTR register  ****************/
N#define RCC_APB1RSTR_TIM2RST_Pos            (0U)
N#define RCC_APB1RSTR_TIM2RST_Msk            (0x1UL << RCC_APB1RSTR_TIM2RST_Pos)     /*!< 0x00000001 */
N#define RCC_APB1RSTR_TIM2RST                RCC_APB1RSTR_TIM2RST_Msk                /*!< Timer 2 reset */
N
N#define RCC_APB1RSTR_TIM3RST_Pos            (1U)
N#define RCC_APB1RSTR_TIM3RST_Msk            (0x1UL << RCC_APB1RSTR_TIM3RST_Pos)     /*!< 0x00000002 */
N#define RCC_APB1RSTR_TIM3RST                RCC_APB1RSTR_TIM3RST_Msk                /*!< Timer 3 reset */
N
N#define RCC_APB1RSTR_TIM14RST_Pos           (8U)
N#define RCC_APB1RSTR_TIM14RST_Msk           (0x1UL << RCC_APB1RSTR_TIM14RST_Pos)    /*!< 0x00000100 */
N#define RCC_APB1RSTR_TIM14RST               RCC_APB1RSTR_TIM14RST_Msk               /*!< Timer 14 reset */
N
N#define RCC_APB1RSTR_WWDGRST_Pos            (11U)
N#define RCC_APB1RSTR_WWDGRST_Msk            (0x1UL << RCC_APB1RSTR_WWDGRST_Pos)     /*!< 0x00000800 */
N#define RCC_APB1RSTR_WWDGRST                RCC_APB1RSTR_WWDGRST_Msk                /*!< Window Watchdog reset */
N
N#define RCC_APB1RSTR_I2C1RST_Pos            (21U)
N#define RCC_APB1RSTR_I2C1RST_Msk            (0x1UL << RCC_APB1RSTR_I2C1RST_Pos)     /*!< 0x00200000 */
N#define RCC_APB1RSTR_I2C1RST                RCC_APB1RSTR_I2C1RST_Msk                /*!< I2C1 reset */
N
N#define RCC_APB1RSTR_PWRRST_Pos             (28U)
N#define RCC_APB1RSTR_PWRRST_Msk             (0x1UL << RCC_APB1RSTR_PWRRST_Pos)      /*!< 0x10000000 */
N#define RCC_APB1RSTR_PWRRST                 RCC_APB1RSTR_PWRRST_Msk                 /*!< PWR reset */
N
N/******************  Bit definition for RCC_AHBENR register  *****************/
N#define RCC_AHBENR_DMAEN_Pos                (0U)
N#define RCC_AHBENR_DMAEN_Msk                (0x1UL << RCC_AHBENR_DMAEN_Pos)         /*!< 0x00000001 */
N#define RCC_AHBENR_DMAEN                    RCC_AHBENR_DMAEN_Msk                    /*!< DMA1 clock enable */
N
N#define RCC_AHBENR_SRAMEN_Pos               (2U)
N#define RCC_AHBENR_SRAMEN_Msk               (0x1UL << RCC_AHBENR_SRAMEN_Pos)        /*!< 0x00000004 */
N#define RCC_AHBENR_SRAMEN                   RCC_AHBENR_SRAMEN_Msk                   /*!< SRAM interface clock enable */
N
N#define RCC_AHBENR_FLITFEN_Pos              (4U)
N#define RCC_AHBENR_FLITFEN_Msk              (0x1UL << RCC_AHBENR_FLITFEN_Pos)       /*!< 0x00000010 */
N#define RCC_AHBENR_FLITFEN                  RCC_AHBENR_FLITFEN_Msk                  /*!< FLITF clock enable */
N
N#define RCC_AHBENR_CRCEN_Pos                (6U)
N#define RCC_AHBENR_CRCEN_Msk                (0x1UL << RCC_AHBENR_CRCEN_Pos)         /*!< 0x00000040 */
N#define RCC_AHBENR_CRCEN                    RCC_AHBENR_CRCEN_Msk                    /*!< CRC clock enable */
N
N#define RCC_AHBENR_GPIOAEN_Pos              (17U)
N#define RCC_AHBENR_GPIOAEN_Msk              (0x1UL << RCC_AHBENR_GPIOAEN_Pos)       /*!< 0x00020000 */
N#define RCC_AHBENR_GPIOAEN                  RCC_AHBENR_GPIOAEN_Msk                  /*!< GPIOA clock enable */
N
N#define RCC_AHBENR_GPIOBEN_Pos              (18U)
N#define RCC_AHBENR_GPIOBEN_Msk              (0x1UL << RCC_AHBENR_GPIOBEN_Pos)       /*!< 0x00040000 */
N#define RCC_AHBENR_GPIOBEN                  RCC_AHBENR_GPIOBEN_Msk                  /*!< GPIOB clock enable */
N
N#define RCC_AHBENR_GPIOCEN_Pos              (19U)
N#define RCC_AHBENR_GPIOCEN_Msk              (0x1UL << RCC_AHBENR_GPIOCEN_Pos)       /*!< 0x00080000 */
N#define RCC_AHBENR_GPIOCEN                  RCC_AHBENR_GPIOCEN_Msk                  /*!< GPIOC clock enable */
N
N#define RCC_AHBENR_GPIOFEN_Pos              (22U)
N#define RCC_AHBENR_GPIOFEN_Msk              (0x1UL << RCC_AHBENR_GPIOFEN_Pos)       /*!< 0x00400000 */
N#define RCC_AHBENR_GPIOFEN                  RCC_AHBENR_GPIOFEN_Msk                  /*!< GPIOF clock enable */
N
N/*****************  Bit definition for RCC_APB2ENR register  *****************/
N#define RCC_APB2ENR_SYSCFGCOMPEN_Pos        (0U)
N#define RCC_APB2ENR_SYSCFGCOMPEN_Msk        (0x1UL << RCC_APB2ENR_SYSCFGCOMPEN_Pos) /*!< 0x00000001 */
N#define RCC_APB2ENR_SYSCFGCOMPEN            RCC_APB2ENR_SYSCFGCOMPEN_Msk            /*!< SYSCFG and comparator clock enable */
N
N#define RCC_APB2ENR_ADCEN_Pos               (9U)
N#define RCC_APB2ENR_ADCEN_Msk               (0x1UL << RCC_APB2ENR_ADCEN_Pos)        /*!< 0x00000200 */
N#define RCC_APB2ENR_ADCEN                   RCC_APB2ENR_ADCEN_Msk                   /*!< ADC1 clock enable */
N
N#define RCC_APB2ENR_TIM1EN_Pos              (11U)
N#define RCC_APB2ENR_TIM1EN_Msk              (0x1UL << RCC_APB2ENR_TIM1EN_Pos)       /*!< 0x00000800 */
N#define RCC_APB2ENR_TIM1EN                  RCC_APB2ENR_TIM1EN_Msk                  /*!< TIM1 clock enable */
N
N#define RCC_APB2ENR_SPI1EN_Pos              (12U)
N#define RCC_APB2ENR_SPI1EN_Msk              (0x1UL << RCC_APB2ENR_SPI1EN_Pos)       /*!< 0x00001000 */
N#define RCC_APB2ENR_SPI1EN                  RCC_APB2ENR_SPI1EN_Msk                  /*!< SPI1 clock enable */
N
N#define RCC_APB2ENR_USART1EN_Pos            (14U)
N#define RCC_APB2ENR_USART1EN_Msk            (0x1UL << RCC_APB2ENR_USART1EN_Pos)     /*!< 0x00004000 */
N#define RCC_APB2ENR_USART1EN                RCC_APB2ENR_USART1EN_Msk                /*!< USART1 clock enable */
N
N#define RCC_APB2ENR_TIM16EN_Pos             (17U)
N#define RCC_APB2ENR_TIM16EN_Msk             (0x1UL << RCC_APB2ENR_TIM16EN_Pos)      /*!< 0x00020000 */
N#define RCC_APB2ENR_TIM16EN                 RCC_APB2ENR_TIM16EN_Msk                 /*!< TIM16 clock enable */
N
N#define RCC_APB2ENR_TIM17EN_Pos             (18U)
N#define RCC_APB2ENR_TIM17EN_Msk             (0x1UL << RCC_APB2ENR_TIM17EN_Pos)      /*!< 0x00040000 */
N#define RCC_APB2ENR_TIM17EN                 RCC_APB2ENR_TIM17EN_Msk                 /*!< TIM17 clock enable */
N
N#define RCC_APB2ENR_DBGMCUEN_Pos            (22U)
N#define RCC_APB2ENR_DBGMCUEN_Msk            (0x1UL << RCC_APB2ENR_DBGMCUEN_Pos)     /*!< 0x00400000 */
N#define RCC_APB2ENR_DBGMCUEN                RCC_APB2ENR_DBGMCUEN_Msk                /*!< DBGMCU clock enable */
N
N/*****************  Bit definition for RCC_APB1ENR register  *****************/
N#define RCC_APB1ENR_TIM2EN_Pos              (0U)
N#define RCC_APB1ENR_TIM2EN_Msk              (0x1UL << RCC_APB1ENR_TIM2EN_Pos)       /*!< 0x00000001 */
N#define RCC_APB1ENR_TIM2EN                  RCC_APB1ENR_TIM2EN_Msk                  /*!< Timer 2 clock enable */
N
N#define RCC_APB1ENR_TIM3EN_Pos              (1U)
N#define RCC_APB1ENR_TIM3EN_Msk              (0x1UL << RCC_APB1ENR_TIM3EN_Pos)       /*!< 0x00000002 */
N#define RCC_APB1ENR_TIM3EN                  RCC_APB1ENR_TIM3EN_Msk                  /*!< Timer 3 clock enable */
N
N#define RCC_APB1ENR_TIM14EN_Pos             (8U)
N#define RCC_APB1ENR_TIM14EN_Msk             (0x1UL << RCC_APB1ENR_TIM14EN_Pos)      /*!< 0x00000100 */
N#define RCC_APB1ENR_TIM14EN                 RCC_APB1ENR_TIM14EN_Msk                 /*!< Timer 14 clock enable */
N
N#define RCC_APB1ENR_WWDGEN_Pos              (11U)
N#define RCC_APB1ENR_WWDGEN_Msk              (0x1UL << RCC_APB1ENR_WWDGEN_Pos)       /*!< 0x00000800 */
N#define RCC_APB1ENR_WWDGEN                  RCC_APB1ENR_WWDGEN_Msk                  /*!< Window Watchdog clock enable */
N
N#define RCC_APB1ENR_I2C1EN_Pos              (21U)
N#define RCC_APB1ENR_I2C1EN_Msk              (0x1UL << RCC_APB1ENR_I2C1EN_Pos)       /*!< 0x00200000 */
N#define RCC_APB1ENR_I2C1EN                  RCC_APB1ENR_I2C1EN_Msk                  /*!< I2C1 clock enable */
N
N#define RCC_APB1ENR_PWREN_Pos               (28U)
N#define RCC_APB1ENR_PWREN_Msk               (0x1UL << RCC_APB1ENR_PWREN_Pos)        /*!< 0x10000000 */
N#define RCC_APB1ENR_PWREN                   RCC_APB1ENR_PWREN_Msk                   /*!< PWR clock enable */
N
N/*******************  Bit definition for RCC_BDCR register  ******************/
N#define RCC_BDCR_LSEON_Pos                  (0U)
N#define RCC_BDCR_LSEON_Msk                  (0x1UL << RCC_BDCR_LSEON_Pos)           /*!< 0x00000001 */
N#define RCC_BDCR_LSEON                      RCC_BDCR_LSEON_Msk                      /*!< External Low Speed oscillator enable */
N
N#define RCC_BDCR_LSERDY_Pos                 (1U)
N#define RCC_BDCR_LSERDY_Msk                 (0x1UL << RCC_BDCR_LSERDY_Pos)          /*!< 0x00000002 */
N#define RCC_BDCR_LSERDY                     RCC_BDCR_LSERDY_Msk                     /*!< External Low Speed oscillator Ready */
N
N#define RCC_BDCR_LSEBYP_Pos                 (2U)
N#define RCC_BDCR_LSEBYP_Msk                 (0x1UL << RCC_BDCR_LSEBYP_Pos)          /*!< 0x00000004 */
N#define RCC_BDCR_LSEBYP                     RCC_BDCR_LSEBYP_Msk                     /*!< External Low Speed oscillator Bypass */
N
N#define RCC_BDCR_LSEDRV_Pos                 (3U)
N#define RCC_BDCR_LSEDRV_Msk                 (0x3UL << RCC_BDCR_LSEDRV_Pos)          /*!< 0x00000018 */
N#define RCC_BDCR_LSEDRV                     RCC_BDCR_LSEDRV_Msk                     /*!< LSEDRV[1:0] bits (LSE Osc. drive capability) */
N#define RCC_BDCR_LSEDRV_0                   (0x1UL << RCC_BDCR_LSEDRV_Pos)          /*!< 0x00000008 */
N#define RCC_BDCR_LSEDRV_1                   (0x2UL << RCC_BDCR_LSEDRV_Pos)          /*!< 0x00000010 */
N
N#define RCC_BDCR_RTCSEL_Pos                 (8U)
N#define RCC_BDCR_RTCSEL_Msk                 (0x3UL << RCC_BDCR_RTCSEL_Pos)          /*!< 0x00000300 */
N#define RCC_BDCR_RTCSEL                     RCC_BDCR_RTCSEL_Msk                     /*!< RTCSEL[1:0] bits (RTC clock source selection) */
N#define RCC_BDCR_RTCSEL_0                   (0x1UL << RCC_BDCR_RTCSEL_Pos)          /*!< 0x00000100 */
N#define RCC_BDCR_RTCSEL_1                   (0x2UL << RCC_BDCR_RTCSEL_Pos)          /*!< 0x00000200 */
N
N/*!< RTC configuration */
N#define RCC_BDCR_RTCSEL_NOCLOCK             (0x00000000U)                           /*!< No clock */
N#define RCC_BDCR_RTCSEL_LSE                 (0x00000100U)                           /*!< LSE oscillator clock used as RTC clock */
N#define RCC_BDCR_RTCSEL_LSI                 (0x00000200U)                           /*!< LSI oscillator clock used as RTC clock */
N#define RCC_BDCR_RTCSEL_HSE                 (0x00000300U)                           /*!< HSE oscillator clock divided by 128 used as RTC clock */
N
N#define RCC_BDCR_RTCEN_Pos                  (15U)
N#define RCC_BDCR_RTCEN_Msk                  (0x1UL << RCC_BDCR_RTCEN_Pos)           /*!< 0x00008000 */
N#define RCC_BDCR_RTCEN                      RCC_BDCR_RTCEN_Msk                      /*!< RTC clock enable */
N
N#define RCC_BDCR_BDRST_Pos                  (16U)
N#define RCC_BDCR_BDRST_Msk                  (0x1UL << RCC_BDCR_BDRST_Pos)           /*!< 0x00010000 */
N#define RCC_BDCR_BDRST                      RCC_BDCR_BDRST_Msk                      /*!< Backup domain software reset  */
N
N/*******************  Bit definition for RCC_CSR register  *******************/
N#define RCC_CSR_LSION_Pos                   (0U)
N#define RCC_CSR_LSION_Msk                   (0x1UL << RCC_CSR_LSION_Pos)            /*!< 0x00000001 */
N#define RCC_CSR_LSION                       RCC_CSR_LSION_Msk                       /*!< Internal Low Speed oscillator enable */
N
N#define RCC_CSR_LSIRDY_Pos                  (1U)
N#define RCC_CSR_LSIRDY_Msk                  (0x1UL << RCC_CSR_LSIRDY_Pos)           /*!< 0x00000002 */
N#define RCC_CSR_LSIRDY                      RCC_CSR_LSIRDY_Msk                      /*!< Internal Low Speed oscillator Ready */
N
N#define RCC_CSR_V15PWRRSTF_Pos              (23U)
N#define RCC_CSR_V15PWRRSTF_Msk              (0x1UL << RCC_CSR_V15PWRRSTF_Pos)       /*!< 0x00800000 */
N#define RCC_CSR_V15PWRRSTF                  RCC_CSR_V15PWRRSTF_Msk                  /*!< V1.5 power domain reset flag */
N
N#define RCC_CSR_RMVF_Pos                    (24U)
N#define RCC_CSR_RMVF_Msk                    (0x1UL << RCC_CSR_RMVF_Pos)             /*!< 0x01000000 */
N#define RCC_CSR_RMVF                        RCC_CSR_RMVF_Msk                        /*!< Remove reset flag */
N
N#define RCC_CSR_OBLRSTF_Pos                 (25U)
N#define RCC_CSR_OBLRSTF_Msk                 (0x1UL << RCC_CSR_OBLRSTF_Pos)          /*!< 0x02000000 */
N#define RCC_CSR_OBLRSTF                     RCC_CSR_OBLRSTF_Msk                     /*!< OBL reset flag */
N
N#define RCC_CSR_PINRSTF_Pos                 (26U)
N#define RCC_CSR_PINRSTF_Msk                 (0x1UL << RCC_CSR_PINRSTF_Pos)          /*!< 0x04000000 */
N#define RCC_CSR_PINRSTF                     RCC_CSR_PINRSTF_Msk                     /*!< PIN reset flag */
N
N#define RCC_CSR_PORRSTF_Pos                 (27U)
N#define RCC_CSR_PORRSTF_Msk                 (0x1UL << RCC_CSR_PORRSTF_Pos)          /*!< 0x08000000 */
N#define RCC_CSR_PORRSTF                     RCC_CSR_PORRSTF_Msk                     /*!< POR/PDR reset flag */
N
N#define RCC_CSR_SFTRSTF_Pos                 (28U)
N#define RCC_CSR_SFTRSTF_Msk                 (0x1UL << RCC_CSR_SFTRSTF_Pos)          /*!< 0x10000000 */
N#define RCC_CSR_SFTRSTF                     RCC_CSR_SFTRSTF_Msk                     /*!< Software Reset flag */
N
N#define RCC_CSR_IWDGRSTF_Pos                (29U)
N#define RCC_CSR_IWDGRSTF_Msk                (0x1UL << RCC_CSR_IWDGRSTF_Pos)         /*!< 0x20000000 */
N#define RCC_CSR_IWDGRSTF                    RCC_CSR_IWDGRSTF_Msk                    /*!< Independent Watchdog reset flag */
N
N#define RCC_CSR_WWDGRSTF_Pos                (30U)
N#define RCC_CSR_WWDGRSTF_Msk                (0x1UL << RCC_CSR_WWDGRSTF_Pos)         /*!< 0x40000000 */
N#define RCC_CSR_WWDGRSTF                    RCC_CSR_WWDGRSTF_Msk                    /*!< Window watchdog reset flag */
N
N#define RCC_CSR_LPWRRSTF_Pos                (31U)
N#define RCC_CSR_LPWRRSTF_Msk                (0x1UL << RCC_CSR_LPWRRSTF_Pos)         /*!< 0x80000000 */
N#define RCC_CSR_LPWRRSTF                    RCC_CSR_LPWRRSTF_Msk                    /*!< Low-Power reset flag */
N
N/*******************  Bit definition for RCC_AHBRSTR register  ***************/
N#define RCC_AHBRSTR_GPIOARST_Pos            (17U)
N#define RCC_AHBRSTR_GPIOARST_Msk            (0x1UL << RCC_AHBRSTR_GPIOARST_Pos)     /*!< 0x00020000 */
N#define RCC_AHBRSTR_GPIOARST                RCC_AHBRSTR_GPIOARST_Msk                /*!< GPIOA reset */
N
N#define RCC_AHBRSTR_GPIOBRST_Pos            (18U)
N#define RCC_AHBRSTR_GPIOBRST_Msk            (0x1UL << RCC_AHBRSTR_GPIOBRST_Pos)     /*!< 0x00040000 */
N#define RCC_AHBRSTR_GPIOBRST                RCC_AHBRSTR_GPIOBRST_Msk                /*!< GPIOB reset */
N
N#define RCC_AHBRSTR_GPIOCRST_Pos            (19U)
N#define RCC_AHBRSTR_GPIOCRST_Msk            (0x1UL << RCC_AHBRSTR_GPIOCRST_Pos)     /*!< 0x00080000 */
N#define RCC_AHBRSTR_GPIOCRST                RCC_AHBRSTR_GPIOCRST_Msk                /*!< GPIOC reset */
N
N#define RCC_AHBRSTR_GPIOFRST_Pos            (22U)
N#define RCC_AHBRSTR_GPIOFRST_Msk            (0x1UL << RCC_AHBRSTR_GPIOFRST_Pos)     /*!< 0x00400000 */
N#define RCC_AHBRSTR_GPIOFRST                RCC_AHBRSTR_GPIOFRST_Msk                /*!< GPIOF reset */
N
N/*******************  Bit definition for RCC_CFGR2 register  *****************/
N/*!< PREDIV configuration */
N#define RCC_CFGR2_PREDIV_Pos                (0U)
N#define RCC_CFGR2_PREDIV_Msk                (0xFUL << RCC_CFGR2_PREDIV_Pos)         /*!< 0x0000000F */
N#define RCC_CFGR2_PREDIV                    RCC_CFGR2_PREDIV_Msk                    /*!< PREDIV[3:0] bits */
N#define RCC_CFGR2_PREDIV_0                  (0x1UL << RCC_CFGR2_PREDIV_Pos)         /*!< 0x00000001 */
N#define RCC_CFGR2_PREDIV_1                  (0x2UL << RCC_CFGR2_PREDIV_Pos)         /*!< 0x00000002 */
N#define RCC_CFGR2_PREDIV_2                  (0x4UL << RCC_CFGR2_PREDIV_Pos)         /*!< 0x00000004 */
N#define RCC_CFGR2_PREDIV_3                  (0x8UL << RCC_CFGR2_PREDIV_Pos)         /*!< 0x00000008 */
N#define RCC_CFGR2_PREDIV_DIV1               (0x00000000U)                           /*!< PREDIV input clock not divided */
N#define RCC_CFGR2_PREDIV_DIV2               (0x00000001U)                           /*!< PREDIV input clock divided by 2 */
N#define RCC_CFGR2_PREDIV_DIV3               (0x00000002U)                           /*!< PREDIV input clock divided by 3 */
N#define RCC_CFGR2_PREDIV_DIV4               (0x00000003U)                           /*!< PREDIV input clock divided by 4 */
N#define RCC_CFGR2_PREDIV_DIV5               (0x00000004U)                           /*!< PREDIV input clock divided by 5 */
N#define RCC_CFGR2_PREDIV_DIV6               (0x00000005U)                           /*!< PREDIV input clock divided by 6 */
N#define RCC_CFGR2_PREDIV_DIV7               (0x00000006U)                           /*!< PREDIV input clock divided by 7 */
N#define RCC_CFGR2_PREDIV_DIV8               (0x00000007U)                           /*!< PREDIV input clock divided by 8 */
N#define RCC_CFGR2_PREDIV_DIV9               (0x00000008U)                           /*!< PREDIV input clock divided by 9 */
N#define RCC_CFGR2_PREDIV_DIV10              (0x00000009U)                           /*!< PREDIV input clock divided by 10 */
N#define RCC_CFGR2_PREDIV_DIV11              (0x0000000AU)                           /*!< PREDIV input clock divided by 11 */
N#define RCC_CFGR2_PREDIV_DIV12              (0x0000000BU)                           /*!< PREDIV input clock divided by 12 */
N#define RCC_CFGR2_PREDIV_DIV13              (0x0000000CU)                           /*!< PREDIV input clock divided by 13 */
N#define RCC_CFGR2_PREDIV_DIV14              (0x0000000DU)                           /*!< PREDIV input clock divided by 14 */
N#define RCC_CFGR2_PREDIV_DIV15              (0x0000000EU)                           /*!< PREDIV input clock divided by 15 */
N#define RCC_CFGR2_PREDIV_DIV16              (0x0000000FU)                           /*!< PREDIV input clock divided by 16 */
N
N/*******************  Bit definition for RCC_CFGR3 register  *****************/
N/*!< USART1 Clock source selection */
N#define RCC_CFGR3_USART1SW_Pos              (0U)
N#define RCC_CFGR3_USART1SW_Msk              (0x3UL << RCC_CFGR3_USART1SW_Pos)       /*!< 0x00000003 */
N#define RCC_CFGR3_USART1SW                  RCC_CFGR3_USART1SW_Msk                  /*!< USART1SW[1:0] bits */
N#define RCC_CFGR3_USART1SW_0                (0x1UL << RCC_CFGR3_USART1SW_Pos)       /*!< 0x00000001 */
N#define RCC_CFGR3_USART1SW_1                (0x2UL << RCC_CFGR3_USART1SW_Pos)       /*!< 0x00000002 */
N#define RCC_CFGR3_USART1SW_PCLK             (0x00000000U)                           /*!< PCLK clock used as USART1 clock source */
N#define RCC_CFGR3_USART1SW_SYSCLK           (0x00000001U)                           /*!< System clock selected as USART1 clock source */
N#define RCC_CFGR3_USART1SW_LSE              (0x00000002U)                           /*!< LSE oscillator clock used as USART1 clock source */
N#define RCC_CFGR3_USART1SW_HSI              (0x00000003U)                           /*!< HSI oscillator clock used as USART1 clock source */
N
N/*!< I2C1 Clock source selection */
N#define RCC_CFGR3_I2C1SW_Pos                (4U)
N#define RCC_CFGR3_I2C1SW_Msk                (0x1UL << RCC_CFGR3_I2C1SW_Pos)         /*!< 0x00000010 */
N#define RCC_CFGR3_I2C1SW                    RCC_CFGR3_I2C1SW_Msk                    /*!< I2C1SW bits */
N#define RCC_CFGR3_I2C1SW_HSI                (0x00000000U)                           /*!< HSI oscillator clock used as I2C1 clock source */
N#define RCC_CFGR3_I2C1SW_SYSCLK_Pos         (4U)
N#define RCC_CFGR3_I2C1SW_SYSCLK_Msk         (0x1UL << RCC_CFGR3_I2C1SW_SYSCLK_Pos)  /*!< 0x00000010 */
N#define RCC_CFGR3_I2C1SW_SYSCLK             RCC_CFGR3_I2C1SW_SYSCLK_Msk             /*!< System clock selected as I2C1 clock source */
N
N
N/*****************************************************************************/
N/*                                                                           */
N/*                           Real-Time Clock (RTC)                           */
N/*                                                                           */
N/*****************************************************************************/
N#define RTC_TAMPER1_SUPPORT  /*!< TAMPER 1 feature support */
N#define RTC_TAMPER2_SUPPORT  /*!< TAMPER 2 feature support */
N#define RTC_BACKUP_SUPPORT   /*!< BACKUP register feature support */
N
N/********************  Bits definition for RTC_TR register  ******************/
N#define RTC_TR_PM_Pos                (22U)
N#define RTC_TR_PM_Msk                (0x1UL << RTC_TR_PM_Pos)                   /*!< 0x00400000 */
N#define RTC_TR_PM                    RTC_TR_PM_Msk
N
N#define RTC_TR_HT_Pos                (20U)
N#define RTC_TR_HT_Msk                (0x3UL << RTC_TR_HT_Pos)                   /*!< 0x00300000 */
N#define RTC_TR_HT                    RTC_TR_HT_Msk
N#define RTC_TR_HT_0                  (0x1UL << RTC_TR_HT_Pos)                   /*!< 0x00100000 */
N#define RTC_TR_HT_1                  (0x2UL << RTC_TR_HT_Pos)                   /*!< 0x00200000 */
N
N#define RTC_TR_HU_Pos                (16U)
N#define RTC_TR_HU_Msk                (0xFUL << RTC_TR_HU_Pos)                   /*!< 0x000F0000 */
N#define RTC_TR_HU                    RTC_TR_HU_Msk
N#define RTC_TR_HU_0                  (0x1UL << RTC_TR_HU_Pos)                   /*!< 0x00010000 */
N#define RTC_TR_HU_1                  (0x2UL << RTC_TR_HU_Pos)                   /*!< 0x00020000 */
N#define RTC_TR_HU_2                  (0x4UL << RTC_TR_HU_Pos)                   /*!< 0x00040000 */
N#define RTC_TR_HU_3                  (0x8UL << RTC_TR_HU_Pos)                   /*!< 0x00080000 */
N
N#define RTC_TR_MNT_Pos               (12U)
N#define RTC_TR_MNT_Msk               (0x7UL << RTC_TR_MNT_Pos)                  /*!< 0x00007000 */
N#define RTC_TR_MNT                   RTC_TR_MNT_Msk
N#define RTC_TR_MNT_0                 (0x1UL << RTC_TR_MNT_Pos)                  /*!< 0x00001000 */
N#define RTC_TR_MNT_1                 (0x2UL << RTC_TR_MNT_Pos)                  /*!< 0x00002000 */
N#define RTC_TR_MNT_2                 (0x4UL << RTC_TR_MNT_Pos)                  /*!< 0x00004000 */
N
N#define RTC_TR_MNU_Pos               (8U)
N#define RTC_TR_MNU_Msk               (0xFUL << RTC_TR_MNU_Pos)                  /*!< 0x00000F00 */
N#define RTC_TR_MNU                   RTC_TR_MNU_Msk
N#define RTC_TR_MNU_0                 (0x1UL << RTC_TR_MNU_Pos)                  /*!< 0x00000100 */
N#define RTC_TR_MNU_1                 (0x2UL << RTC_TR_MNU_Pos)                  /*!< 0x00000200 */
N#define RTC_TR_MNU_2                 (0x4UL << RTC_TR_MNU_Pos)                  /*!< 0x00000400 */
N#define RTC_TR_MNU_3                 (0x8UL << RTC_TR_MNU_Pos)                  /*!< 0x00000800 */
N
N#define RTC_TR_ST_Pos                (4U)
N#define RTC_TR_ST_Msk                (0x7UL << RTC_TR_ST_Pos)                   /*!< 0x00000070 */
N#define RTC_TR_ST                    RTC_TR_ST_Msk
N#define RTC_TR_ST_0                  (0x1UL << RTC_TR_ST_Pos)                   /*!< 0x00000010 */
N#define RTC_TR_ST_1                  (0x2UL << RTC_TR_ST_Pos)                   /*!< 0x00000020 */
N#define RTC_TR_ST_2                  (0x4UL << RTC_TR_ST_Pos)                   /*!< 0x00000040 */
N
N#define RTC_TR_SU_Pos                (0U)
N#define RTC_TR_SU_Msk                (0xFUL << RTC_TR_SU_Pos)                   /*!< 0x0000000F */
N#define RTC_TR_SU                    RTC_TR_SU_Msk
N#define RTC_TR_SU_0                  (0x1UL << RTC_TR_SU_Pos)                   /*!< 0x00000001 */
N#define RTC_TR_SU_1                  (0x2UL << RTC_TR_SU_Pos)                   /*!< 0x00000002 */
N#define RTC_TR_SU_2                  (0x4UL << RTC_TR_SU_Pos)                   /*!< 0x00000004 */
N#define RTC_TR_SU_3                  (0x8UL << RTC_TR_SU_Pos)                   /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_DR register  ******************/
N#define RTC_DR_YT_Pos                (20U)
N#define RTC_DR_YT_Msk                (0xFUL << RTC_DR_YT_Pos)                   /*!< 0x00F00000 */
N#define RTC_DR_YT                    RTC_DR_YT_Msk
N#define RTC_DR_YT_0                  (0x1UL << RTC_DR_YT_Pos)                   /*!< 0x00100000 */
N#define RTC_DR_YT_1                  (0x2UL << RTC_DR_YT_Pos)                   /*!< 0x00200000 */
N#define RTC_DR_YT_2                  (0x4UL << RTC_DR_YT_Pos)                   /*!< 0x00400000 */
N#define RTC_DR_YT_3                  (0x8UL << RTC_DR_YT_Pos)                   /*!< 0x00800000 */
N
N#define RTC_DR_YU_Pos                (16U)
N#define RTC_DR_YU_Msk                (0xFUL << RTC_DR_YU_Pos)                   /*!< 0x000F0000 */
N#define RTC_DR_YU                    RTC_DR_YU_Msk
N#define RTC_DR_YU_0                  (0x1UL << RTC_DR_YU_Pos)                   /*!< 0x00010000 */
N#define RTC_DR_YU_1                  (0x2UL << RTC_DR_YU_Pos)                   /*!< 0x00020000 */
N#define RTC_DR_YU_2                  (0x4UL << RTC_DR_YU_Pos)                   /*!< 0x00040000 */
N#define RTC_DR_YU_3                  (0x8UL << RTC_DR_YU_Pos)                   /*!< 0x00080000 */
N
N#define RTC_DR_WDU_Pos               (13U)
N#define RTC_DR_WDU_Msk               (0x7UL << RTC_DR_WDU_Pos)                  /*!< 0x0000E000 */
N#define RTC_DR_WDU                   RTC_DR_WDU_Msk
N#define RTC_DR_WDU_0                 (0x1UL << RTC_DR_WDU_Pos)                  /*!< 0x00002000 */
N#define RTC_DR_WDU_1                 (0x2UL << RTC_DR_WDU_Pos)                  /*!< 0x00004000 */
N#define RTC_DR_WDU_2                 (0x4UL << RTC_DR_WDU_Pos)                  /*!< 0x00008000 */
N
N#define RTC_DR_MT_Pos                (12U)
N#define RTC_DR_MT_Msk                (0x1UL << RTC_DR_MT_Pos)                   /*!< 0x00001000 */
N#define RTC_DR_MT                    RTC_DR_MT_Msk
N#define RTC_DR_MU_Pos                (8U)
N#define RTC_DR_MU_Msk                (0xFUL << RTC_DR_MU_Pos)                   /*!< 0x00000F00 */
N#define RTC_DR_MU                    RTC_DR_MU_Msk
N#define RTC_DR_MU_0                  (0x1UL << RTC_DR_MU_Pos)                   /*!< 0x00000100 */
N#define RTC_DR_MU_1                  (0x2UL << RTC_DR_MU_Pos)                   /*!< 0x00000200 */
N#define RTC_DR_MU_2                  (0x4UL << RTC_DR_MU_Pos)                   /*!< 0x00000400 */
N#define RTC_DR_MU_3                  (0x8UL << RTC_DR_MU_Pos)                   /*!< 0x00000800 */
N
N#define RTC_DR_DT_Pos                (4U)
N#define RTC_DR_DT_Msk                (0x3UL << RTC_DR_DT_Pos)                   /*!< 0x00000030 */
N#define RTC_DR_DT                    RTC_DR_DT_Msk
N#define RTC_DR_DT_0                  (0x1UL << RTC_DR_DT_Pos)                   /*!< 0x00000010 */
N#define RTC_DR_DT_1                  (0x2UL << RTC_DR_DT_Pos)                   /*!< 0x00000020 */
N
N#define RTC_DR_DU_Pos                (0U)
N#define RTC_DR_DU_Msk                (0xFUL << RTC_DR_DU_Pos)                   /*!< 0x0000000F */
N#define RTC_DR_DU                    RTC_DR_DU_Msk
N#define RTC_DR_DU_0                  (0x1UL << RTC_DR_DU_Pos)                   /*!< 0x00000001 */
N#define RTC_DR_DU_1                  (0x2UL << RTC_DR_DU_Pos)                   /*!< 0x00000002 */
N#define RTC_DR_DU_2                  (0x4UL << RTC_DR_DU_Pos)                   /*!< 0x00000004 */
N#define RTC_DR_DU_3                  (0x8UL << RTC_DR_DU_Pos)                   /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_CR register  ******************/
N#define RTC_CR_COE_Pos               (23U)
N#define RTC_CR_COE_Msk               (0x1UL << RTC_CR_COE_Pos)                  /*!< 0x00800000 */
N#define RTC_CR_COE                   RTC_CR_COE_Msk
N
N#define RTC_CR_OSEL_Pos              (21U)
N#define RTC_CR_OSEL_Msk              (0x3UL << RTC_CR_OSEL_Pos)                 /*!< 0x00600000 */
N#define RTC_CR_OSEL                  RTC_CR_OSEL_Msk
N#define RTC_CR_OSEL_0                (0x1UL << RTC_CR_OSEL_Pos)                 /*!< 0x00200000 */
N#define RTC_CR_OSEL_1                (0x2UL << RTC_CR_OSEL_Pos)                 /*!< 0x00400000 */
N
N#define RTC_CR_POL_Pos               (20U)
N#define RTC_CR_POL_Msk               (0x1UL << RTC_CR_POL_Pos)                  /*!< 0x00100000 */
N#define RTC_CR_POL                   RTC_CR_POL_Msk
N
N#define RTC_CR_COSEL_Pos             (19U)
N#define RTC_CR_COSEL_Msk             (0x1UL << RTC_CR_COSEL_Pos)                /*!< 0x00080000 */
N#define RTC_CR_COSEL                 RTC_CR_COSEL_Msk
N
N#define RTC_CR_BKP_Pos               (18U)
N#define RTC_CR_BKP_Msk               (0x1UL << RTC_CR_BKP_Pos)                  /*!< 0x00040000 */
N#define RTC_CR_BKP                   RTC_CR_BKP_Msk
N
N#define RTC_CR_SUB1H_Pos             (17U)
N#define RTC_CR_SUB1H_Msk             (0x1UL << RTC_CR_SUB1H_Pos)                /*!< 0x00020000 */
N#define RTC_CR_SUB1H                 RTC_CR_SUB1H_Msk
N
N#define RTC_CR_ADD1H_Pos             (16U)
N#define RTC_CR_ADD1H_Msk             (0x1UL << RTC_CR_ADD1H_Pos)                /*!< 0x00010000 */
N#define RTC_CR_ADD1H                 RTC_CR_ADD1H_Msk
N
N#define RTC_CR_TSIE_Pos              (15U)
N#define RTC_CR_TSIE_Msk              (0x1UL << RTC_CR_TSIE_Pos)                 /*!< 0x00008000 */
N#define RTC_CR_TSIE                  RTC_CR_TSIE_Msk
N
N#define RTC_CR_ALRAIE_Pos            (12U)
N#define RTC_CR_ALRAIE_Msk            (0x1UL << RTC_CR_ALRAIE_Pos)               /*!< 0x00001000 */
N#define RTC_CR_ALRAIE                RTC_CR_ALRAIE_Msk
N
N#define RTC_CR_TSE_Pos               (11U)
N#define RTC_CR_TSE_Msk               (0x1UL << RTC_CR_TSE_Pos)                  /*!< 0x00000800 */
N#define RTC_CR_TSE                   RTC_CR_TSE_Msk
N
N#define RTC_CR_ALRAE_Pos             (8U)
N#define RTC_CR_ALRAE_Msk             (0x1UL << RTC_CR_ALRAE_Pos)                /*!< 0x00000100 */
N#define RTC_CR_ALRAE                 RTC_CR_ALRAE_Msk
N
N#define RTC_CR_FMT_Pos               (6U)
N#define RTC_CR_FMT_Msk               (0x1UL << RTC_CR_FMT_Pos)                  /*!< 0x00000040 */
N#define RTC_CR_FMT                   RTC_CR_FMT_Msk
N
N#define RTC_CR_BYPSHAD_Pos           (5U)
N#define RTC_CR_BYPSHAD_Msk           (0x1UL << RTC_CR_BYPSHAD_Pos)              /*!< 0x00000020 */
N#define RTC_CR_BYPSHAD               RTC_CR_BYPSHAD_Msk
N
N#define RTC_CR_REFCKON_Pos           (4U)
N#define RTC_CR_REFCKON_Msk           (0x1UL << RTC_CR_REFCKON_Pos)              /*!< 0x00000010 */
N#define RTC_CR_REFCKON               RTC_CR_REFCKON_Msk
N
N#define RTC_CR_TSEDGE_Pos            (3U)
N#define RTC_CR_TSEDGE_Msk            (0x1UL << RTC_CR_TSEDGE_Pos)               /*!< 0x00000008 */
N#define RTC_CR_TSEDGE                RTC_CR_TSEDGE_Msk
N
N/********************  Bits definition for RTC_ISR register  *****************/
N#define RTC_ISR_RECALPF_Pos          (16U)
N#define RTC_ISR_RECALPF_Msk          (0x1UL << RTC_ISR_RECALPF_Pos)             /*!< 0x00010000 */
N#define RTC_ISR_RECALPF              RTC_ISR_RECALPF_Msk
N
N#define RTC_ISR_TAMP2F_Pos           (14U)
N#define RTC_ISR_TAMP2F_Msk           (0x1UL << RTC_ISR_TAMP2F_Pos)              /*!< 0x00004000 */
N#define RTC_ISR_TAMP2F               RTC_ISR_TAMP2F_Msk
N
N#define RTC_ISR_TAMP1F_Pos           (13U)
N#define RTC_ISR_TAMP1F_Msk           (0x1UL << RTC_ISR_TAMP1F_Pos)              /*!< 0x00002000 */
N#define RTC_ISR_TAMP1F               RTC_ISR_TAMP1F_Msk
N
N#define RTC_ISR_TSOVF_Pos            (12U)
N#define RTC_ISR_TSOVF_Msk            (0x1UL << RTC_ISR_TSOVF_Pos)               /*!< 0x00001000 */
N#define RTC_ISR_TSOVF                RTC_ISR_TSOVF_Msk
N
N#define RTC_ISR_TSF_Pos              (11U)
N#define RTC_ISR_TSF_Msk              (0x1UL << RTC_ISR_TSF_Pos)                 /*!< 0x00000800 */
N#define RTC_ISR_TSF                  RTC_ISR_TSF_Msk
N
N#define RTC_ISR_ALRAF_Pos            (8U)
N#define RTC_ISR_ALRAF_Msk            (0x1UL << RTC_ISR_ALRAF_Pos)               /*!< 0x00000100 */
N#define RTC_ISR_ALRAF                RTC_ISR_ALRAF_Msk
N
N#define RTC_ISR_INIT_Pos             (7U)
N#define RTC_ISR_INIT_Msk             (0x1UL << RTC_ISR_INIT_Pos)                /*!< 0x00000080 */
N#define RTC_ISR_INIT                 RTC_ISR_INIT_Msk
N
N#define RTC_ISR_INITF_Pos            (6U)
N#define RTC_ISR_INITF_Msk            (0x1UL << RTC_ISR_INITF_Pos)               /*!< 0x00000040 */
N#define RTC_ISR_INITF                RTC_ISR_INITF_Msk
N
N#define RTC_ISR_RSF_Pos              (5U)
N#define RTC_ISR_RSF_Msk              (0x1UL << RTC_ISR_RSF_Pos)                 /*!< 0x00000020 */
N#define RTC_ISR_RSF                  RTC_ISR_RSF_Msk
N
N#define RTC_ISR_INITS_Pos            (4U)
N#define RTC_ISR_INITS_Msk            (0x1UL << RTC_ISR_INITS_Pos)               /*!< 0x00000010 */
N#define RTC_ISR_INITS                RTC_ISR_INITS_Msk
N
N#define RTC_ISR_SHPF_Pos             (3U)
N#define RTC_ISR_SHPF_Msk             (0x1UL << RTC_ISR_SHPF_Pos)                /*!< 0x00000008 */
N#define RTC_ISR_SHPF                 RTC_ISR_SHPF_Msk
N
N#define RTC_ISR_ALRAWF_Pos           (0U)
N#define RTC_ISR_ALRAWF_Msk           (0x1UL << RTC_ISR_ALRAWF_Pos)              /*!< 0x00000001 */
N#define RTC_ISR_ALRAWF               RTC_ISR_ALRAWF_Msk
N
N/********************  Bits definition for RTC_PRER register  ****************/
N#define RTC_PRER_PREDIV_A_Pos        (16U)
N#define RTC_PRER_PREDIV_A_Msk        (0x7FUL << RTC_PRER_PREDIV_A_Pos)          /*!< 0x007F0000 */
N#define RTC_PRER_PREDIV_A            RTC_PRER_PREDIV_A_Msk
N
N#define RTC_PRER_PREDIV_S_Pos        (0U)
N#define RTC_PRER_PREDIV_S_Msk        (0x7FFFUL << RTC_PRER_PREDIV_S_Pos)        /*!< 0x00007FFF */
N#define RTC_PRER_PREDIV_S            RTC_PRER_PREDIV_S_Msk
N
N/********************  Bits definition for RTC_ALRMAR register  **************/
N#define RTC_ALRMAR_MSK4_Pos          (31U)
N#define RTC_ALRMAR_MSK4_Msk          (0x1UL << RTC_ALRMAR_MSK4_Pos)             /*!< 0x80000000 */
N#define RTC_ALRMAR_MSK4              RTC_ALRMAR_MSK4_Msk
N
N#define RTC_ALRMAR_WDSEL_Pos         (30U)
N#define RTC_ALRMAR_WDSEL_Msk         (0x1UL << RTC_ALRMAR_WDSEL_Pos)            /*!< 0x40000000 */
N#define RTC_ALRMAR_WDSEL             RTC_ALRMAR_WDSEL_Msk
N
N#define RTC_ALRMAR_DT_Pos            (28U)
N#define RTC_ALRMAR_DT_Msk            (0x3UL << RTC_ALRMAR_DT_Pos)               /*!< 0x30000000 */
N#define RTC_ALRMAR_DT                RTC_ALRMAR_DT_Msk
N#define RTC_ALRMAR_DT_0              (0x1UL << RTC_ALRMAR_DT_Pos)               /*!< 0x10000000 */
N#define RTC_ALRMAR_DT_1              (0x2UL << RTC_ALRMAR_DT_Pos)               /*!< 0x20000000 */
N
N#define RTC_ALRMAR_DU_Pos            (24U)
N#define RTC_ALRMAR_DU_Msk            (0xFUL << RTC_ALRMAR_DU_Pos)               /*!< 0x0F000000 */
N#define RTC_ALRMAR_DU                RTC_ALRMAR_DU_Msk
N#define RTC_ALRMAR_DU_0              (0x1UL << RTC_ALRMAR_DU_Pos)               /*!< 0x01000000 */
N#define RTC_ALRMAR_DU_1              (0x2UL << RTC_ALRMAR_DU_Pos)               /*!< 0x02000000 */
N#define RTC_ALRMAR_DU_2              (0x4UL << RTC_ALRMAR_DU_Pos)               /*!< 0x04000000 */
N#define RTC_ALRMAR_DU_3              (0x8UL << RTC_ALRMAR_DU_Pos)               /*!< 0x08000000 */
N
N#define RTC_ALRMAR_MSK3_Pos          (23U)
N#define RTC_ALRMAR_MSK3_Msk          (0x1UL << RTC_ALRMAR_MSK3_Pos)             /*!< 0x00800000 */
N#define RTC_ALRMAR_MSK3              RTC_ALRMAR_MSK3_Msk
N
N#define RTC_ALRMAR_PM_Pos            (22U)
N#define RTC_ALRMAR_PM_Msk            (0x1UL << RTC_ALRMAR_PM_Pos)               /*!< 0x00400000 */
N#define RTC_ALRMAR_PM                RTC_ALRMAR_PM_Msk
N
N#define RTC_ALRMAR_HT_Pos            (20U)
N#define RTC_ALRMAR_HT_Msk            (0x3UL << RTC_ALRMAR_HT_Pos)               /*!< 0x00300000 */
N#define RTC_ALRMAR_HT                RTC_ALRMAR_HT_Msk
N#define RTC_ALRMAR_HT_0              (0x1UL << RTC_ALRMAR_HT_Pos)               /*!< 0x00100000 */
N#define RTC_ALRMAR_HT_1              (0x2UL << RTC_ALRMAR_HT_Pos)               /*!< 0x00200000 */
N
N#define RTC_ALRMAR_HU_Pos            (16U)
N#define RTC_ALRMAR_HU_Msk            (0xFUL << RTC_ALRMAR_HU_Pos)               /*!< 0x000F0000 */
N#define RTC_ALRMAR_HU                RTC_ALRMAR_HU_Msk
N#define RTC_ALRMAR_HU_0              (0x1UL << RTC_ALRMAR_HU_Pos)               /*!< 0x00010000 */
N#define RTC_ALRMAR_HU_1              (0x2UL << RTC_ALRMAR_HU_Pos)               /*!< 0x00020000 */
N#define RTC_ALRMAR_HU_2              (0x4UL << RTC_ALRMAR_HU_Pos)               /*!< 0x00040000 */
N#define RTC_ALRMAR_HU_3              (0x8UL << RTC_ALRMAR_HU_Pos)               /*!< 0x00080000 */
N
N#define RTC_ALRMAR_MSK2_Pos          (15U)
N#define RTC_ALRMAR_MSK2_Msk          (0x1UL << RTC_ALRMAR_MSK2_Pos)             /*!< 0x00008000 */
N#define RTC_ALRMAR_MSK2              RTC_ALRMAR_MSK2_Msk
N
N#define RTC_ALRMAR_MNT_Pos           (12U)
N#define RTC_ALRMAR_MNT_Msk           (0x7UL << RTC_ALRMAR_MNT_Pos)              /*!< 0x00007000 */
N#define RTC_ALRMAR_MNT               RTC_ALRMAR_MNT_Msk
N#define RTC_ALRMAR_MNT_0             (0x1UL << RTC_ALRMAR_MNT_Pos)              /*!< 0x00001000 */
N#define RTC_ALRMAR_MNT_1             (0x2UL << RTC_ALRMAR_MNT_Pos)              /*!< 0x00002000 */
N#define RTC_ALRMAR_MNT_2             (0x4UL << RTC_ALRMAR_MNT_Pos)              /*!< 0x00004000 */
N
N#define RTC_ALRMAR_MNU_Pos           (8U)
N#define RTC_ALRMAR_MNU_Msk           (0xFUL << RTC_ALRMAR_MNU_Pos)              /*!< 0x00000F00 */
N#define RTC_ALRMAR_MNU               RTC_ALRMAR_MNU_Msk
N#define RTC_ALRMAR_MNU_0             (0x1UL << RTC_ALRMAR_MNU_Pos)              /*!< 0x00000100 */
N#define RTC_ALRMAR_MNU_1             (0x2UL << RTC_ALRMAR_MNU_Pos)              /*!< 0x00000200 */
N#define RTC_ALRMAR_MNU_2             (0x4UL << RTC_ALRMAR_MNU_Pos)              /*!< 0x00000400 */
N#define RTC_ALRMAR_MNU_3             (0x8UL << RTC_ALRMAR_MNU_Pos)              /*!< 0x00000800 */
N
N#define RTC_ALRMAR_MSK1_Pos          (7U)
N#define RTC_ALRMAR_MSK1_Msk          (0x1UL << RTC_ALRMAR_MSK1_Pos)             /*!< 0x00000080 */
N#define RTC_ALRMAR_MSK1              RTC_ALRMAR_MSK1_Msk
N
N#define RTC_ALRMAR_ST_Pos            (4U)
N#define RTC_ALRMAR_ST_Msk            (0x7UL << RTC_ALRMAR_ST_Pos)               /*!< 0x00000070 */
N#define RTC_ALRMAR_ST                RTC_ALRMAR_ST_Msk
N#define RTC_ALRMAR_ST_0              (0x1UL << RTC_ALRMAR_ST_Pos)               /*!< 0x00000010 */
N#define RTC_ALRMAR_ST_1              (0x2UL << RTC_ALRMAR_ST_Pos)               /*!< 0x00000020 */
N#define RTC_ALRMAR_ST_2              (0x4UL << RTC_ALRMAR_ST_Pos)               /*!< 0x00000040 */
N
N#define RTC_ALRMAR_SU_Pos            (0U)
N#define RTC_ALRMAR_SU_Msk            (0xFUL << RTC_ALRMAR_SU_Pos)               /*!< 0x0000000F */
N#define RTC_ALRMAR_SU                RTC_ALRMAR_SU_Msk
N#define RTC_ALRMAR_SU_0              (0x1UL << RTC_ALRMAR_SU_Pos)               /*!< 0x00000001 */
N#define RTC_ALRMAR_SU_1              (0x2UL << RTC_ALRMAR_SU_Pos)               /*!< 0x00000002 */
N#define RTC_ALRMAR_SU_2              (0x4UL << RTC_ALRMAR_SU_Pos)               /*!< 0x00000004 */
N#define RTC_ALRMAR_SU_3              (0x8UL << RTC_ALRMAR_SU_Pos)               /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_WPR register  *****************/
N#define RTC_WPR_KEY_Pos              (0U)
N#define RTC_WPR_KEY_Msk              (0xFFUL << RTC_WPR_KEY_Pos)                /*!< 0x000000FF */
N#define RTC_WPR_KEY                  RTC_WPR_KEY_Msk
N
N/********************  Bits definition for RTC_SSR register  *****************/
N#define RTC_SSR_SS_Pos               (0U)
N#define RTC_SSR_SS_Msk               (0xFFFFUL << RTC_SSR_SS_Pos)               /*!< 0x0000FFFF */
N#define RTC_SSR_SS                   RTC_SSR_SS_Msk
N
N/********************  Bits definition for RTC_SHIFTR register  **************/
N#define RTC_SHIFTR_SUBFS_Pos         (0U)
N#define RTC_SHIFTR_SUBFS_Msk         (0x7FFFUL << RTC_SHIFTR_SUBFS_Pos)         /*!< 0x00007FFF */
N#define RTC_SHIFTR_SUBFS             RTC_SHIFTR_SUBFS_Msk
N#define RTC_SHIFTR_ADD1S_Pos         (31U)
N#define RTC_SHIFTR_ADD1S_Msk         (0x1UL << RTC_SHIFTR_ADD1S_Pos)            /*!< 0x80000000 */
N#define RTC_SHIFTR_ADD1S             RTC_SHIFTR_ADD1S_Msk
N
N/********************  Bits definition for RTC_TSTR register  ****************/
N#define RTC_TSTR_PM_Pos              (22U)
N#define RTC_TSTR_PM_Msk              (0x1UL << RTC_TSTR_PM_Pos)                 /*!< 0x00400000 */
N#define RTC_TSTR_PM                  RTC_TSTR_PM_Msk
N
N#define RTC_TSTR_HT_Pos              (20U)
N#define RTC_TSTR_HT_Msk              (0x3UL << RTC_TSTR_HT_Pos)                 /*!< 0x00300000 */
N#define RTC_TSTR_HT                  RTC_TSTR_HT_Msk
N#define RTC_TSTR_HT_0                (0x1UL << RTC_TSTR_HT_Pos)                 /*!< 0x00100000 */
N#define RTC_TSTR_HT_1                (0x2UL << RTC_TSTR_HT_Pos)                 /*!< 0x00200000 */
N
N#define RTC_TSTR_HU_Pos              (16U)
N#define RTC_TSTR_HU_Msk              (0xFUL << RTC_TSTR_HU_Pos)                 /*!< 0x000F0000 */
N#define RTC_TSTR_HU                  RTC_TSTR_HU_Msk
N#define RTC_TSTR_HU_0                (0x1UL << RTC_TSTR_HU_Pos)                 /*!< 0x00010000 */
N#define RTC_TSTR_HU_1                (0x2UL << RTC_TSTR_HU_Pos)                 /*!< 0x00020000 */
N#define RTC_TSTR_HU_2                (0x4UL << RTC_TSTR_HU_Pos)                 /*!< 0x00040000 */
N#define RTC_TSTR_HU_3                (0x8UL << RTC_TSTR_HU_Pos)                 /*!< 0x00080000 */
N
N#define RTC_TSTR_MNT_Pos             (12U)
N#define RTC_TSTR_MNT_Msk             (0x7UL << RTC_TSTR_MNT_Pos)                /*!< 0x00007000 */
N#define RTC_TSTR_MNT                 RTC_TSTR_MNT_Msk
N#define RTC_TSTR_MNT_0               (0x1UL << RTC_TSTR_MNT_Pos)                /*!< 0x00001000 */
N#define RTC_TSTR_MNT_1               (0x2UL << RTC_TSTR_MNT_Pos)                /*!< 0x00002000 */
N#define RTC_TSTR_MNT_2               (0x4UL << RTC_TSTR_MNT_Pos)                /*!< 0x00004000 */
N
N#define RTC_TSTR_MNU_Pos             (8U)
N#define RTC_TSTR_MNU_Msk             (0xFUL << RTC_TSTR_MNU_Pos)                /*!< 0x00000F00 */
N#define RTC_TSTR_MNU                 RTC_TSTR_MNU_Msk
N#define RTC_TSTR_MNU_0               (0x1UL << RTC_TSTR_MNU_Pos)                /*!< 0x00000100 */
N#define RTC_TSTR_MNU_1               (0x2UL << RTC_TSTR_MNU_Pos)                /*!< 0x00000200 */
N#define RTC_TSTR_MNU_2               (0x4UL << RTC_TSTR_MNU_Pos)                /*!< 0x00000400 */
N#define RTC_TSTR_MNU_3               (0x8UL << RTC_TSTR_MNU_Pos)                /*!< 0x00000800 */
N
N#define RTC_TSTR_ST_Pos              (4U)
N#define RTC_TSTR_ST_Msk              (0x7UL << RTC_TSTR_ST_Pos)                 /*!< 0x00000070 */
N#define RTC_TSTR_ST                  RTC_TSTR_ST_Msk
N#define RTC_TSTR_ST_0                (0x1UL << RTC_TSTR_ST_Pos)                 /*!< 0x00000010 */
N#define RTC_TSTR_ST_1                (0x2UL << RTC_TSTR_ST_Pos)                 /*!< 0x00000020 */
N#define RTC_TSTR_ST_2                (0x4UL << RTC_TSTR_ST_Pos)                 /*!< 0x00000040 */
N
N#define RTC_TSTR_SU_Pos              (0U)
N#define RTC_TSTR_SU_Msk              (0xFUL << RTC_TSTR_SU_Pos)                 /*!< 0x0000000F */
N#define RTC_TSTR_SU                  RTC_TSTR_SU_Msk
N#define RTC_TSTR_SU_0                (0x1UL << RTC_TSTR_SU_Pos)                 /*!< 0x00000001 */
N#define RTC_TSTR_SU_1                (0x2UL << RTC_TSTR_SU_Pos)                 /*!< 0x00000002 */
N#define RTC_TSTR_SU_2                (0x4UL << RTC_TSTR_SU_Pos)                 /*!< 0x00000004 */
N#define RTC_TSTR_SU_3                (0x8UL << RTC_TSTR_SU_Pos)                 /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_TSDR register  ****************/
N#define RTC_TSDR_WDU_Pos             (13U)
N#define RTC_TSDR_WDU_Msk             (0x7UL << RTC_TSDR_WDU_Pos)                /*!< 0x0000E000 */
N#define RTC_TSDR_WDU                 RTC_TSDR_WDU_Msk
N#define RTC_TSDR_WDU_0               (0x1UL << RTC_TSDR_WDU_Pos)                /*!< 0x00002000 */
N#define RTC_TSDR_WDU_1               (0x2UL << RTC_TSDR_WDU_Pos)                /*!< 0x00004000 */
N#define RTC_TSDR_WDU_2               (0x4UL << RTC_TSDR_WDU_Pos)                /*!< 0x00008000 */
N
N#define RTC_TSDR_MT_Pos              (12U)
N#define RTC_TSDR_MT_Msk              (0x1UL << RTC_TSDR_MT_Pos)                 /*!< 0x00001000 */
N#define RTC_TSDR_MT                  RTC_TSDR_MT_Msk
N
N#define RTC_TSDR_MU_Pos              (8U)
N#define RTC_TSDR_MU_Msk              (0xFUL << RTC_TSDR_MU_Pos)                 /*!< 0x00000F00 */
N#define RTC_TSDR_MU                  RTC_TSDR_MU_Msk
N#define RTC_TSDR_MU_0                (0x1UL << RTC_TSDR_MU_Pos)                 /*!< 0x00000100 */
N#define RTC_TSDR_MU_1                (0x2UL << RTC_TSDR_MU_Pos)                 /*!< 0x00000200 */
N#define RTC_TSDR_MU_2                (0x4UL << RTC_TSDR_MU_Pos)                 /*!< 0x00000400 */
N#define RTC_TSDR_MU_3                (0x8UL << RTC_TSDR_MU_Pos)                 /*!< 0x00000800 */
N
N#define RTC_TSDR_DT_Pos              (4U)
N#define RTC_TSDR_DT_Msk              (0x3UL << RTC_TSDR_DT_Pos)                 /*!< 0x00000030 */
N#define RTC_TSDR_DT                  RTC_TSDR_DT_Msk
N#define RTC_TSDR_DT_0                (0x1UL << RTC_TSDR_DT_Pos)                 /*!< 0x00000010 */
N#define RTC_TSDR_DT_1                (0x2UL << RTC_TSDR_DT_Pos)                 /*!< 0x00000020 */
N
N#define RTC_TSDR_DU_Pos              (0U)
N#define RTC_TSDR_DU_Msk              (0xFUL << RTC_TSDR_DU_Pos)                 /*!< 0x0000000F */
N#define RTC_TSDR_DU                  RTC_TSDR_DU_Msk
N#define RTC_TSDR_DU_0                (0x1UL << RTC_TSDR_DU_Pos)                 /*!< 0x00000001 */
N#define RTC_TSDR_DU_1                (0x2UL << RTC_TSDR_DU_Pos)                 /*!< 0x00000002 */
N#define RTC_TSDR_DU_2                (0x4UL << RTC_TSDR_DU_Pos)                 /*!< 0x00000004 */
N#define RTC_TSDR_DU_3                (0x8UL << RTC_TSDR_DU_Pos)                 /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_TSSSR register  ***************/
N#define RTC_TSSSR_SS_Pos             (0U)
N#define RTC_TSSSR_SS_Msk             (0xFFFFUL << RTC_TSSSR_SS_Pos)             /*!< 0x0000FFFF */
N#define RTC_TSSSR_SS                 RTC_TSSSR_SS_Msk
N
N/********************  Bits definition for RTC_CALR register  ****************/
N#define RTC_CALR_CALP_Pos            (15U)
N#define RTC_CALR_CALP_Msk            (0x1UL << RTC_CALR_CALP_Pos)               /*!< 0x00008000 */
N#define RTC_CALR_CALP                RTC_CALR_CALP_Msk
N
N#define RTC_CALR_CALW8_Pos           (14U)
N#define RTC_CALR_CALW8_Msk           (0x1UL << RTC_CALR_CALW8_Pos)              /*!< 0x00004000 */
N#define RTC_CALR_CALW8               RTC_CALR_CALW8_Msk
N
N#define RTC_CALR_CALW16_Pos          (13U)
N#define RTC_CALR_CALW16_Msk          (0x1UL << RTC_CALR_CALW16_Pos)             /*!< 0x00002000 */
N#define RTC_CALR_CALW16              RTC_CALR_CALW16_Msk
N
N#define RTC_CALR_CALM_Pos            (0U)
N#define RTC_CALR_CALM_Msk            (0x1FFUL << RTC_CALR_CALM_Pos)             /*!< 0x000001FF */
N#define RTC_CALR_CALM                RTC_CALR_CALM_Msk
N#define RTC_CALR_CALM_0              (0x001UL << RTC_CALR_CALM_Pos)             /*!< 0x00000001 */
N#define RTC_CALR_CALM_1              (0x002UL << RTC_CALR_CALM_Pos)             /*!< 0x00000002 */
N#define RTC_CALR_CALM_2              (0x004UL << RTC_CALR_CALM_Pos)             /*!< 0x00000004 */
N#define RTC_CALR_CALM_3              (0x008UL << RTC_CALR_CALM_Pos)             /*!< 0x00000008 */
N#define RTC_CALR_CALM_4              (0x010UL << RTC_CALR_CALM_Pos)             /*!< 0x00000010 */
N#define RTC_CALR_CALM_5              (0x020UL << RTC_CALR_CALM_Pos)             /*!< 0x00000020 */
N#define RTC_CALR_CALM_6              (0x040UL << RTC_CALR_CALM_Pos)             /*!< 0x00000040 */
N#define RTC_CALR_CALM_7              (0x080UL << RTC_CALR_CALM_Pos)             /*!< 0x00000080 */
N#define RTC_CALR_CALM_8              (0x100UL << RTC_CALR_CALM_Pos)             /*!< 0x00000100 */
N
N/********************  Bits definition for RTC_TAFCR register  ***************/
N#define RTC_TAFCR_PC15MODE_Pos       (23U)
N#define RTC_TAFCR_PC15MODE_Msk       (0x1UL << RTC_TAFCR_PC15MODE_Pos)          /*!< 0x00800000 */
N#define RTC_TAFCR_PC15MODE           RTC_TAFCR_PC15MODE_Msk
N
N#define RTC_TAFCR_PC15VALUE_Pos      (22U)
N#define RTC_TAFCR_PC15VALUE_Msk      (0x1UL << RTC_TAFCR_PC15VALUE_Pos)         /*!< 0x00400000 */
N#define RTC_TAFCR_PC15VALUE          RTC_TAFCR_PC15VALUE_Msk
N
N#define RTC_TAFCR_PC14MODE_Pos       (21U)
N#define RTC_TAFCR_PC14MODE_Msk       (0x1UL << RTC_TAFCR_PC14MODE_Pos)          /*!< 0x00200000 */
N#define RTC_TAFCR_PC14MODE           RTC_TAFCR_PC14MODE_Msk
N
N#define RTC_TAFCR_PC14VALUE_Pos      (20U)
N#define RTC_TAFCR_PC14VALUE_Msk      (0x1UL << RTC_TAFCR_PC14VALUE_Pos)         /*!< 0x00100000 */
N#define RTC_TAFCR_PC14VALUE          RTC_TAFCR_PC14VALUE_Msk
N
N#define RTC_TAFCR_PC13MODE_Pos       (19U)
N#define RTC_TAFCR_PC13MODE_Msk       (0x1UL << RTC_TAFCR_PC13MODE_Pos)          /*!< 0x00080000 */
N#define RTC_TAFCR_PC13MODE           RTC_TAFCR_PC13MODE_Msk
N
N#define RTC_TAFCR_PC13VALUE_Pos      (18U)
N#define RTC_TAFCR_PC13VALUE_Msk      (0x1UL << RTC_TAFCR_PC13VALUE_Pos)         /*!< 0x00040000 */
N#define RTC_TAFCR_PC13VALUE          RTC_TAFCR_PC13VALUE_Msk
N
N#define RTC_TAFCR_TAMPPUDIS_Pos      (15U)
N#define RTC_TAFCR_TAMPPUDIS_Msk      (0x1UL << RTC_TAFCR_TAMPPUDIS_Pos)         /*!< 0x00008000 */
N#define RTC_TAFCR_TAMPPUDIS          RTC_TAFCR_TAMPPUDIS_Msk
N
N#define RTC_TAFCR_TAMPPRCH_Pos       (13U)
N#define RTC_TAFCR_TAMPPRCH_Msk       (0x3UL << RTC_TAFCR_TAMPPRCH_Pos)          /*!< 0x00006000 */
N#define RTC_TAFCR_TAMPPRCH           RTC_TAFCR_TAMPPRCH_Msk
N#define RTC_TAFCR_TAMPPRCH_0         (0x1UL << RTC_TAFCR_TAMPPRCH_Pos)          /*!< 0x00002000 */
N#define RTC_TAFCR_TAMPPRCH_1         (0x2UL << RTC_TAFCR_TAMPPRCH_Pos)          /*!< 0x00004000 */
N
N#define RTC_TAFCR_TAMPFLT_Pos        (11U)
N#define RTC_TAFCR_TAMPFLT_Msk        (0x3UL << RTC_TAFCR_TAMPFLT_Pos)           /*!< 0x00001800 */
N#define RTC_TAFCR_TAMPFLT            RTC_TAFCR_TAMPFLT_Msk
N#define RTC_TAFCR_TAMPFLT_0          (0x1UL << RTC_TAFCR_TAMPFLT_Pos)           /*!< 0x00000800 */
N#define RTC_TAFCR_TAMPFLT_1          (0x2UL << RTC_TAFCR_TAMPFLT_Pos)           /*!< 0x00001000 */
N
N#define RTC_TAFCR_TAMPFREQ_Pos       (8U)
N#define RTC_TAFCR_TAMPFREQ_Msk       (0x7UL << RTC_TAFCR_TAMPFREQ_Pos)          /*!< 0x00000700 */
N#define RTC_TAFCR_TAMPFREQ           RTC_TAFCR_TAMPFREQ_Msk
N#define RTC_TAFCR_TAMPFREQ_0         (0x1UL << RTC_TAFCR_TAMPFREQ_Pos)          /*!< 0x00000100 */
N#define RTC_TAFCR_TAMPFREQ_1         (0x2UL << RTC_TAFCR_TAMPFREQ_Pos)          /*!< 0x00000200 */
N#define RTC_TAFCR_TAMPFREQ_2         (0x4UL << RTC_TAFCR_TAMPFREQ_Pos)          /*!< 0x00000400 */
N
N#define RTC_TAFCR_TAMPTS_Pos         (7U)
N#define RTC_TAFCR_TAMPTS_Msk         (0x1UL << RTC_TAFCR_TAMPTS_Pos)            /*!< 0x00000080 */
N#define RTC_TAFCR_TAMPTS             RTC_TAFCR_TAMPTS_Msk
N
N#define RTC_TAFCR_TAMP2TRG_Pos       (4U)
N#define RTC_TAFCR_TAMP2TRG_Msk       (0x1UL << RTC_TAFCR_TAMP2TRG_Pos)          /*!< 0x00000010 */
N#define RTC_TAFCR_TAMP2TRG           RTC_TAFCR_TAMP2TRG_Msk
N
N#define RTC_TAFCR_TAMP2E_Pos         (3U)
N#define RTC_TAFCR_TAMP2E_Msk         (0x1UL << RTC_TAFCR_TAMP2E_Pos)            /*!< 0x00000008 */
N#define RTC_TAFCR_TAMP2E             RTC_TAFCR_TAMP2E_Msk
N
N#define RTC_TAFCR_TAMPIE_Pos         (2U)
N#define RTC_TAFCR_TAMPIE_Msk         (0x1UL << RTC_TAFCR_TAMPIE_Pos)            /*!< 0x00000004 */
N#define RTC_TAFCR_TAMPIE             RTC_TAFCR_TAMPIE_Msk
N
N#define RTC_TAFCR_TAMP1TRG_Pos       (1U)
N#define RTC_TAFCR_TAMP1TRG_Msk       (0x1UL << RTC_TAFCR_TAMP1TRG_Pos)          /*!< 0x00000002 */
N#define RTC_TAFCR_TAMP1TRG           RTC_TAFCR_TAMP1TRG_Msk
N
N#define RTC_TAFCR_TAMP1E_Pos         (0U)
N#define RTC_TAFCR_TAMP1E_Msk         (0x1UL << RTC_TAFCR_TAMP1E_Pos)            /*!< 0x00000001 */
N#define RTC_TAFCR_TAMP1E             RTC_TAFCR_TAMP1E_Msk
N
N/********************  Bits definition for RTC_ALRMASSR register  ************/
N#define RTC_ALRMASSR_MASKSS_Pos      (24U)
N#define RTC_ALRMASSR_MASKSS_Msk      (0xFUL << RTC_ALRMASSR_MASKSS_Pos)         /*!< 0x0F000000 */
N#define RTC_ALRMASSR_MASKSS          RTC_ALRMASSR_MASKSS_Msk
N#define RTC_ALRMASSR_MASKSS_0        (0x1UL << RTC_ALRMASSR_MASKSS_Pos)         /*!< 0x01000000 */
N#define RTC_ALRMASSR_MASKSS_1        (0x2UL << RTC_ALRMASSR_MASKSS_Pos)         /*!< 0x02000000 */
N#define RTC_ALRMASSR_MASKSS_2        (0x4UL << RTC_ALRMASSR_MASKSS_Pos)         /*!< 0x04000000 */
N#define RTC_ALRMASSR_MASKSS_3        (0x8UL << RTC_ALRMASSR_MASKSS_Pos)         /*!< 0x08000000 */
N
N#define RTC_ALRMASSR_SS_Pos          (0U)
N#define RTC_ALRMASSR_SS_Msk          (0x7FFFUL << RTC_ALRMASSR_SS_Pos)          /*!< 0x00007FFF */
N#define RTC_ALRMASSR_SS              RTC_ALRMASSR_SS_Msk
N
N/********************  Bits definition for RTC_BKP0R register  ***************/
N#define RTC_BKP0R_Pos                (0U)
N#define RTC_BKP0R_Msk                (0xFFFFFFFFUL << RTC_BKP0R_Pos)            /*!< 0xFFFFFFFF */
N#define RTC_BKP0R                    RTC_BKP0R_Msk
N
N/********************  Bits definition for RTC_BKP1R register  ***************/
N#define RTC_BKP1R_Pos                (0U)
N#define RTC_BKP1R_Msk                (0xFFFFFFFFUL << RTC_BKP1R_Pos)            /*!< 0xFFFFFFFF */
N#define RTC_BKP1R                    RTC_BKP1R_Msk
N
N/********************  Bits definition for RTC_BKP2R register  ***************/
N#define RTC_BKP2R_Pos                (0U)
N#define RTC_BKP2R_Msk                (0xFFFFFFFFUL << RTC_BKP2R_Pos)            /*!< 0xFFFFFFFF */
N#define RTC_BKP2R                    RTC_BKP2R_Msk
N
N/********************  Bits definition for RTC_BKP3R register  ***************/
N#define RTC_BKP3R_Pos                (0U)
N#define RTC_BKP3R_Msk                (0xFFFFFFFFUL << RTC_BKP3R_Pos)            /*!< 0xFFFFFFFF */
N#define RTC_BKP3R                    RTC_BKP3R_Msk
N
N/********************  Bits definition for RTC_BKP4R register  ***************/
N#define RTC_BKP4R_Pos                (0U)
N#define RTC_BKP4R_Msk                (0xFFFFFFFFUL << RTC_BKP4R_Pos)            /*!< 0xFFFFFFFF */
N#define RTC_BKP4R                    RTC_BKP4R_Msk
N
N/******************** Number of backup registers ******************************/
N#define RTC_BKP_NUMBER               (0x00000005U)
N
N
N/*****************************************************************************/
N/*                                                                           */
N/*                        Serial Peripheral Interface (SPI)                  */
N/*                                                                           */
N/*****************************************************************************/
N#define SPI_I2S_SUPPORT             /*!< I2S support */
N
N/*******************  Bit definition for SPI_CR1 register  *******************/
N#define SPI_CR1_CPHA_Pos            (0U)
N#define SPI_CR1_CPHA_Msk            (0x1UL << SPI_CR1_CPHA_Pos)                 /*!< 0x00000001 */
N#define SPI_CR1_CPHA                SPI_CR1_CPHA_Msk                            /*!< Clock Phase */
N
N#define SPI_CR1_CPOL_Pos            (1U)
N#define SPI_CR1_CPOL_Msk            (0x1UL << SPI_CR1_CPOL_Pos)                 /*!< 0x00000002 */
N#define SPI_CR1_CPOL                SPI_CR1_CPOL_Msk                            /*!< Clock Polarity */
N
N#define SPI_CR1_MSTR_Pos            (2U)
N#define SPI_CR1_MSTR_Msk            (0x1UL << SPI_CR1_MSTR_Pos)                 /*!< 0x00000004 */
N#define SPI_CR1_MSTR                SPI_CR1_MSTR_Msk                            /*!< Master Selection */
N
N#define SPI_CR1_BR_Pos              (3U)
N#define SPI_CR1_BR_Msk              (0x7UL << SPI_CR1_BR_Pos)                   /*!< 0x00000038 */
N#define SPI_CR1_BR                  SPI_CR1_BR_Msk                              /*!< BR[2:0] bits (Baud Rate Control) */
N#define SPI_CR1_BR_0                (0x1UL << SPI_CR1_BR_Pos)                   /*!< 0x00000008 */
N#define SPI_CR1_BR_1                (0x2UL << SPI_CR1_BR_Pos)                   /*!< 0x00000010 */
N#define SPI_CR1_BR_2                (0x4UL << SPI_CR1_BR_Pos)                   /*!< 0x00000020 */
N
N#define SPI_CR1_SPE_Pos             (6U)
N#define SPI_CR1_SPE_Msk             (0x1UL << SPI_CR1_SPE_Pos)                  /*!< 0x00000040 */
N#define SPI_CR1_SPE                 SPI_CR1_SPE_Msk                             /*!< SPI Enable */
N
N#define SPI_CR1_LSBFIRST_Pos        (7U)
N#define SPI_CR1_LSBFIRST_Msk        (0x1UL << SPI_CR1_LSBFIRST_Pos)             /*!< 0x00000080 */
N#define SPI_CR1_LSBFIRST            SPI_CR1_LSBFIRST_Msk                        /*!< Frame Format */
N
N#define SPI_CR1_SSI_Pos             (8U)
N#define SPI_CR1_SSI_Msk             (0x1UL << SPI_CR1_SSI_Pos)                  /*!< 0x00000100 */
N#define SPI_CR1_SSI                 SPI_CR1_SSI_Msk                             /*!< Internal slave select */
N
N#define SPI_CR1_SSM_Pos             (9U)
N#define SPI_CR1_SSM_Msk             (0x1UL << SPI_CR1_SSM_Pos)                  /*!< 0x00000200 */
N#define SPI_CR1_SSM                 SPI_CR1_SSM_Msk                             /*!< Software slave management */
N
N#define SPI_CR1_RXONLY_Pos          (10U)
N#define SPI_CR1_RXONLY_Msk          (0x1UL << SPI_CR1_RXONLY_Pos)               /*!< 0x00000400 */
N#define SPI_CR1_RXONLY              SPI_CR1_RXONLY_Msk                          /*!< Receive only */
N
N#define SPI_CR1_CRCL_Pos            (11U)
N#define SPI_CR1_CRCL_Msk            (0x1UL << SPI_CR1_CRCL_Pos)                 /*!< 0x00000800 */
N#define SPI_CR1_CRCL                SPI_CR1_CRCL_Msk                            /*!< CRC Length */
N
N#define SPI_CR1_CRCNEXT_Pos         (12U)
N#define SPI_CR1_CRCNEXT_Msk         (0x1UL << SPI_CR1_CRCNEXT_Pos)              /*!< 0x00001000 */
N#define SPI_CR1_CRCNEXT             SPI_CR1_CRCNEXT_Msk                         /*!< Transmit CRC next */
N
N#define SPI_CR1_CRCEN_Pos           (13U)
N#define SPI_CR1_CRCEN_Msk           (0x1UL << SPI_CR1_CRCEN_Pos)                /*!< 0x00002000 */
N#define SPI_CR1_CRCEN               SPI_CR1_CRCEN_Msk                           /*!< Hardware CRC calculation enable */
N
N#define SPI_CR1_BIDIOE_Pos          (14U)
N#define SPI_CR1_BIDIOE_Msk          (0x1UL << SPI_CR1_BIDIOE_Pos)               /*!< 0x00004000 */
N#define SPI_CR1_BIDIOE              SPI_CR1_BIDIOE_Msk                          /*!< Output enable in bidirectional mode */
N
N#define SPI_CR1_BIDIMODE_Pos        (15U)
N#define SPI_CR1_BIDIMODE_Msk        (0x1UL << SPI_CR1_BIDIMODE_Pos)             /*!< 0x00008000 */
N#define SPI_CR1_BIDIMODE            SPI_CR1_BIDIMODE_Msk                        /*!< Bidirectional data mode enable */
N
N/*******************  Bit definition for SPI_CR2 register  *******************/
N#define SPI_CR2_RXDMAEN_Pos         (0U)
N#define SPI_CR2_RXDMAEN_Msk         (0x1UL << SPI_CR2_RXDMAEN_Pos)              /*!< 0x00000001 */
N#define SPI_CR2_RXDMAEN             SPI_CR2_RXDMAEN_Msk                         /*!< Rx Buffer DMA Enable */
N
N#define SPI_CR2_TXDMAEN_Pos         (1U)
N#define SPI_CR2_TXDMAEN_Msk         (0x1UL << SPI_CR2_TXDMAEN_Pos)              /*!< 0x00000002 */
N#define SPI_CR2_TXDMAEN             SPI_CR2_TXDMAEN_Msk                         /*!< Tx Buffer DMA Enable */
N
N#define SPI_CR2_SSOE_Pos            (2U)
N#define SPI_CR2_SSOE_Msk            (0x1UL << SPI_CR2_SSOE_Pos)                 /*!< 0x00000004 */
N#define SPI_CR2_SSOE                SPI_CR2_SSOE_Msk                            /*!< SS Output Enable */
N
N#define SPI_CR2_NSSP_Pos            (3U)
N#define SPI_CR2_NSSP_Msk            (0x1UL << SPI_CR2_NSSP_Pos)                 /*!< 0x00000008 */
N#define SPI_CR2_NSSP                SPI_CR2_NSSP_Msk                            /*!< NSS pulse management Enable */
N
N#define SPI_CR2_FRF_Pos             (4U)
N#define SPI_CR2_FRF_Msk             (0x1UL << SPI_CR2_FRF_Pos)                  /*!< 0x00000010 */
N#define SPI_CR2_FRF                 SPI_CR2_FRF_Msk                             /*!< Frame Format Enable */
N
N#define SPI_CR2_ERRIE_Pos           (5U)
N#define SPI_CR2_ERRIE_Msk           (0x1UL << SPI_CR2_ERRIE_Pos)                /*!< 0x00000020 */
N#define SPI_CR2_ERRIE               SPI_CR2_ERRIE_Msk                           /*!< Error Interrupt Enable */
N
N#define SPI_CR2_RXNEIE_Pos          (6U)
N#define SPI_CR2_RXNEIE_Msk          (0x1UL << SPI_CR2_RXNEIE_Pos)               /*!< 0x00000040 */
N#define SPI_CR2_RXNEIE              SPI_CR2_RXNEIE_Msk                          /*!< RX buffer Not Empty Interrupt Enable */
N
N#define SPI_CR2_TXEIE_Pos           (7U)
N#define SPI_CR2_TXEIE_Msk           (0x1UL << SPI_CR2_TXEIE_Pos)                /*!< 0x00000080 */
N#define SPI_CR2_TXEIE               SPI_CR2_TXEIE_Msk                           /*!< Tx buffer Empty Interrupt Enable */
N
N#define SPI_CR2_DS_Pos              (8U)
N#define SPI_CR2_DS_Msk              (0xFUL << SPI_CR2_DS_Pos)                   /*!< 0x00000F00 */
N#define SPI_CR2_DS                  SPI_CR2_DS_Msk                              /*!< DS[3:0] Data Size */
N#define SPI_CR2_DS_0                (0x1UL << SPI_CR2_DS_Pos)                   /*!< 0x00000100 */
N#define SPI_CR2_DS_1                (0x2UL << SPI_CR2_DS_Pos)                   /*!< 0x00000200 */
N#define SPI_CR2_DS_2                (0x4UL << SPI_CR2_DS_Pos)                   /*!< 0x00000400 */
N#define SPI_CR2_DS_3                (0x8UL << SPI_CR2_DS_Pos)                   /*!< 0x00000800 */
N
N#define SPI_CR2_FRXTH_Pos           (12U)
N#define SPI_CR2_FRXTH_Msk           (0x1UL << SPI_CR2_FRXTH_Pos)                /*!< 0x00001000 */
N#define SPI_CR2_FRXTH               SPI_CR2_FRXTH_Msk                           /*!< FIFO reception Threshold */
N
N#define SPI_CR2_LDMARX_Pos          (13U)
N#define SPI_CR2_LDMARX_Msk          (0x1UL << SPI_CR2_LDMARX_Pos)               /*!< 0x00002000 */
N#define SPI_CR2_LDMARX              SPI_CR2_LDMARX_Msk                          /*!< Last DMA transfer for reception */
N
N#define SPI_CR2_LDMATX_Pos          (14U)
N#define SPI_CR2_LDMATX_Msk          (0x1UL << SPI_CR2_LDMATX_Pos)               /*!< 0x00004000 */
N#define SPI_CR2_LDMATX              SPI_CR2_LDMATX_Msk                          /*!< Last DMA transfer for transmission */
N
N/********************  Bit definition for SPI_SR register  *******************/
N#define SPI_SR_RXNE_Pos             (0U)
N#define SPI_SR_RXNE_Msk             (0x1UL << SPI_SR_RXNE_Pos)                  /*!< 0x00000001 */
N#define SPI_SR_RXNE                 SPI_SR_RXNE_Msk                             /*!< Receive buffer Not Empty */
N
N#define SPI_SR_TXE_Pos              (1U)
N#define SPI_SR_TXE_Msk              (0x1UL << SPI_SR_TXE_Pos)                   /*!< 0x00000002 */
N#define SPI_SR_TXE                  SPI_SR_TXE_Msk                              /*!< Transmit buffer Empty */
N
N#define SPI_SR_CHSIDE_Pos           (2U)
N#define SPI_SR_CHSIDE_Msk           (0x1UL << SPI_SR_CHSIDE_Pos)                /*!< 0x00000004 */
N#define SPI_SR_CHSIDE               SPI_SR_CHSIDE_Msk                           /*!< Channel side */
N
N#define SPI_SR_UDR_Pos              (3U)
N#define SPI_SR_UDR_Msk              (0x1UL << SPI_SR_UDR_Pos)                   /*!< 0x00000008 */
N#define SPI_SR_UDR                  SPI_SR_UDR_Msk                              /*!< Underrun flag */
N
N#define SPI_SR_CRCERR_Pos           (4U)
N#define SPI_SR_CRCERR_Msk           (0x1UL << SPI_SR_CRCERR_Pos)                /*!< 0x00000010 */
N#define SPI_SR_CRCERR               SPI_SR_CRCERR_Msk                           /*!< CRC Error flag */
N
N#define SPI_SR_MODF_Pos             (5U)
N#define SPI_SR_MODF_Msk             (0x1UL << SPI_SR_MODF_Pos)                  /*!< 0x00000020 */
N#define SPI_SR_MODF                 SPI_SR_MODF_Msk                             /*!< Mode fault */
N
N#define SPI_SR_OVR_Pos              (6U)
N#define SPI_SR_OVR_Msk              (0x1UL << SPI_SR_OVR_Pos)                   /*!< 0x00000040 */
N#define SPI_SR_OVR                  SPI_SR_OVR_Msk                              /*!< Overrun flag */
N
N#define SPI_SR_BSY_Pos              (7U)
N#define SPI_SR_BSY_Msk              (0x1UL << SPI_SR_BSY_Pos)                   /*!< 0x00000080 */
N#define SPI_SR_BSY                  SPI_SR_BSY_Msk                              /*!< Busy flag */
N
N#define SPI_SR_FRE_Pos              (8U)
N#define SPI_SR_FRE_Msk              (0x1UL << SPI_SR_FRE_Pos)                   /*!< 0x00000100 */
N#define SPI_SR_FRE                  SPI_SR_FRE_Msk                              /*!< TI frame format error */
N
N#define SPI_SR_FRLVL_Pos            (9U)
N#define SPI_SR_FRLVL_Msk            (0x3UL << SPI_SR_FRLVL_Pos)                 /*!< 0x00000600 */
N#define SPI_SR_FRLVL                SPI_SR_FRLVL_Msk                            /*!< FIFO Reception Level */
N#define SPI_SR_FRLVL_0              (0x1UL << SPI_SR_FRLVL_Pos)                 /*!< 0x00000200 */
N#define SPI_SR_FRLVL_1              (0x2UL << SPI_SR_FRLVL_Pos)                 /*!< 0x00000400 */
N
N#define SPI_SR_FTLVL_Pos            (11U)
N#define SPI_SR_FTLVL_Msk            (0x3UL << SPI_SR_FTLVL_Pos)                 /*!< 0x00001800 */
N#define SPI_SR_FTLVL                SPI_SR_FTLVL_Msk                            /*!< FIFO Transmission Level */
N#define SPI_SR_FTLVL_0              (0x1UL << SPI_SR_FTLVL_Pos)                 /*!< 0x00000800 */
N#define SPI_SR_FTLVL_1              (0x2UL << SPI_SR_FTLVL_Pos)                 /*!< 0x00001000 */
N
N/********************  Bit definition for SPI_DR register  *******************/
N#define SPI_DR_DR_Pos               (0U)
N#define SPI_DR_DR_Msk               (0xFFFFFFFFUL << SPI_DR_DR_Pos)             /*!< 0xFFFFFFFF */
N#define SPI_DR_DR                   SPI_DR_DR_Msk                               /*!< Data Register */
N
N/*******************  Bit definition for SPI_CRCPR register  *****************/
N#define SPI_CRCPR_CRCPOLY_Pos       (0U)
N#define SPI_CRCPR_CRCPOLY_Msk       (0xFFFFFFFFUL << SPI_CRCPR_CRCPOLY_Pos)     /*!< 0xFFFFFFFF */
N#define SPI_CRCPR_CRCPOLY           SPI_CRCPR_CRCPOLY_Msk                       /*!< CRC polynomial register */
N
N/******************  Bit definition for SPI_RXCRCR register  *****************/
N#define SPI_RXCRCR_RXCRC_Pos        (0U)
N#define SPI_RXCRCR_RXCRC_Msk        (0xFFFFFFFFUL << SPI_RXCRCR_RXCRC_Pos)      /*!< 0xFFFFFFFF */
N#define SPI_RXCRCR_RXCRC            SPI_RXCRCR_RXCRC_Msk                        /*!< Rx CRC Register */
N
N/******************  Bit definition for SPI_TXCRCR register  *****************/
N#define SPI_TXCRCR_TXCRC_Pos        (0U)
N#define SPI_TXCRCR_TXCRC_Msk        (0xFFFFFFFFUL << SPI_TXCRCR_TXCRC_Pos)      /*!< 0xFFFFFFFF */
N#define SPI_TXCRCR_TXCRC            SPI_TXCRCR_TXCRC_Msk                        /*!< Tx CRC Register */
N
N/******************  Bit definition for SPI_I2SCFGR register  ****************/
N#define SPI_I2SCFGR_CHLEN_Pos       (0U)
N#define SPI_I2SCFGR_CHLEN_Msk       (0x1UL << SPI_I2SCFGR_CHLEN_Pos)            /*!< 0x00000001 */
N#define SPI_I2SCFGR_CHLEN           SPI_I2SCFGR_CHLEN_Msk                       /*!<Channel length (number of bits per audio channel) */
N
N#define SPI_I2SCFGR_DATLEN_Pos      (1U)
N#define SPI_I2SCFGR_DATLEN_Msk      (0x3UL << SPI_I2SCFGR_DATLEN_Pos)           /*!< 0x00000006 */
N#define SPI_I2SCFGR_DATLEN          SPI_I2SCFGR_DATLEN_Msk                      /*!<DATLEN[1:0] bits (Data length to be transferred) */
N#define SPI_I2SCFGR_DATLEN_0        (0x1UL << SPI_I2SCFGR_DATLEN_Pos)           /*!< 0x00000002 */
N#define SPI_I2SCFGR_DATLEN_1        (0x2UL << SPI_I2SCFGR_DATLEN_Pos)           /*!< 0x00000004 */
N
N#define SPI_I2SCFGR_CKPOL_Pos       (3U)
N#define SPI_I2SCFGR_CKPOL_Msk       (0x1UL << SPI_I2SCFGR_CKPOL_Pos)            /*!< 0x00000008 */
N#define SPI_I2SCFGR_CKPOL           SPI_I2SCFGR_CKPOL_Msk                       /*!<steady state clock polarity */
N
N#define SPI_I2SCFGR_I2SSTD_Pos      (4U)
N#define SPI_I2SCFGR_I2SSTD_Msk      (0x3UL << SPI_I2SCFGR_I2SSTD_Pos)           /*!< 0x00000030 */
N#define SPI_I2SCFGR_I2SSTD          SPI_I2SCFGR_I2SSTD_Msk                      /*!<I2SSTD[1:0] bits (I2S standard selection) */
N#define SPI_I2SCFGR_I2SSTD_0        (0x1UL << SPI_I2SCFGR_I2SSTD_Pos)           /*!< 0x00000010 */
N#define SPI_I2SCFGR_I2SSTD_1        (0x2UL << SPI_I2SCFGR_I2SSTD_Pos)           /*!< 0x00000020 */
N
N#define SPI_I2SCFGR_PCMSYNC_Pos     (7U)
N#define SPI_I2SCFGR_PCMSYNC_Msk     (0x1UL << SPI_I2SCFGR_PCMSYNC_Pos)          /*!< 0x00000080 */
N#define SPI_I2SCFGR_PCMSYNC         SPI_I2SCFGR_PCMSYNC_Msk                     /*!<PCM frame synchronization */
N
N#define SPI_I2SCFGR_I2SCFG_Pos      (8U)
N#define SPI_I2SCFGR_I2SCFG_Msk      (0x3UL << SPI_I2SCFGR_I2SCFG_Pos)           /*!< 0x00000300 */
N#define SPI_I2SCFGR_I2SCFG          SPI_I2SCFGR_I2SCFG_Msk                      /*!<I2SCFG[1:0] bits (I2S configuration mode) */
N#define SPI_I2SCFGR_I2SCFG_0        (0x1UL << SPI_I2SCFGR_I2SCFG_Pos)           /*!< 0x00000100 */
N#define SPI_I2SCFGR_I2SCFG_1        (0x2UL << SPI_I2SCFGR_I2SCFG_Pos)           /*!< 0x00000200 */
N
N#define SPI_I2SCFGR_I2SE_Pos        (10U)
N#define SPI_I2SCFGR_I2SE_Msk        (0x1UL << SPI_I2SCFGR_I2SE_Pos)             /*!< 0x00000400 */
N#define SPI_I2SCFGR_I2SE            SPI_I2SCFGR_I2SE_Msk                        /*!<I2S Enable */
N
N#define SPI_I2SCFGR_I2SMOD_Pos      (11U)
N#define SPI_I2SCFGR_I2SMOD_Msk      (0x1UL << SPI_I2SCFGR_I2SMOD_Pos)           /*!< 0x00000800 */
N#define SPI_I2SCFGR_I2SMOD          SPI_I2SCFGR_I2SMOD_Msk                      /*!<I2S mode selection */
N
N/******************  Bit definition for SPI_I2SPR register  ******************/
N#define SPI_I2SPR_I2SDIV_Pos        (0U)
N#define SPI_I2SPR_I2SDIV_Msk        (0xFFUL << SPI_I2SPR_I2SDIV_Pos)            /*!< 0x000000FF */
N#define SPI_I2SPR_I2SDIV            SPI_I2SPR_I2SDIV_Msk                        /*!<I2S Linear prescaler */
N
N#define SPI_I2SPR_ODD_Pos           (8U)
N#define SPI_I2SPR_ODD_Msk           (0x1UL << SPI_I2SPR_ODD_Pos)                /*!< 0x00000100 */
N#define SPI_I2SPR_ODD               SPI_I2SPR_ODD_Msk                           /*!<Odd factor for the prescaler */
N
N#define SPI_I2SPR_MCKOE_Pos         (9U)
N#define SPI_I2SPR_MCKOE_Msk         (0x1UL << SPI_I2SPR_MCKOE_Pos)              /*!< 0x00000200 */
N#define SPI_I2SPR_MCKOE             SPI_I2SPR_MCKOE_Msk                         /*!<Master Clock Output Enable */
N
N
N/*****************************************************************************/
N/*                                                                           */
N/*                       System Configuration (SYSCFG)                       */
N/*                                                                           */
N/*****************************************************************************/
N/*****************  Bit definition for SYSCFG_CFGR1 register  ****************/
N#define SYSCFG_CFGR1_MEM_MODE_Pos            (0U)
N#define SYSCFG_CFGR1_MEM_MODE_Msk            (0x3UL << SYSCFG_CFGR1_MEM_MODE_Pos)         /*!< 0x00000003 */
N#define SYSCFG_CFGR1_MEM_MODE                SYSCFG_CFGR1_MEM_MODE_Msk                    /*!< SYSCFG_Memory Remap Config */
N#define SYSCFG_CFGR1_MEM_MODE_0              (0x1UL << SYSCFG_CFGR1_MEM_MODE_Pos)         /*!< 0x00000001 */
N#define SYSCFG_CFGR1_MEM_MODE_1              (0x2UL << SYSCFG_CFGR1_MEM_MODE_Pos)         /*!< 0x00000002 */
N
N#define SYSCFG_CFGR1_DMA_RMP_Pos             (8U)
N#define SYSCFG_CFGR1_DMA_RMP_Msk             (0x1FUL << SYSCFG_CFGR1_DMA_RMP_Pos)         /*!< 0x00001F00 */
N#define SYSCFG_CFGR1_DMA_RMP                 SYSCFG_CFGR1_DMA_RMP_Msk                     /*!< DMA remap mask */
N
N#define SYSCFG_CFGR1_ADC_DMA_RMP_Pos         (8U)
N#define SYSCFG_CFGR1_ADC_DMA_RMP_Msk         (0x1UL << SYSCFG_CFGR1_ADC_DMA_RMP_Pos)      /*!< 0x00000100 */
N#define SYSCFG_CFGR1_ADC_DMA_RMP             SYSCFG_CFGR1_ADC_DMA_RMP_Msk                 /*!< ADC DMA remap */
N
N#define SYSCFG_CFGR1_USART1TX_DMA_RMP_Pos    (9U)
N#define SYSCFG_CFGR1_USART1TX_DMA_RMP_Msk    (0x1UL << SYSCFG_CFGR1_USART1TX_DMA_RMP_Pos) /*!< 0x00000200 */
N#define SYSCFG_CFGR1_USART1TX_DMA_RMP        SYSCFG_CFGR1_USART1TX_DMA_RMP_Msk            /*!< USART1 TX DMA remap */
N
N#define SYSCFG_CFGR1_USART1RX_DMA_RMP_Pos    (10U)
N#define SYSCFG_CFGR1_USART1RX_DMA_RMP_Msk    (0x1UL << SYSCFG_CFGR1_USART1RX_DMA_RMP_Pos) /*!< 0x00000400 */
N#define SYSCFG_CFGR1_USART1RX_DMA_RMP        SYSCFG_CFGR1_USART1RX_DMA_RMP_Msk            /*!< USART1 RX DMA remap */
N
N#define SYSCFG_CFGR1_TIM16_DMA_RMP_Pos       (11U)
N#define SYSCFG_CFGR1_TIM16_DMA_RMP_Msk       (0x1UL << SYSCFG_CFGR1_TIM16_DMA_RMP_Pos)    /*!< 0x00000800 */
N#define SYSCFG_CFGR1_TIM16_DMA_RMP           SYSCFG_CFGR1_TIM16_DMA_RMP_Msk               /*!< Timer 16 DMA remap */
N
N#define SYSCFG_CFGR1_TIM17_DMA_RMP_Pos       (12U)
N#define SYSCFG_CFGR1_TIM17_DMA_RMP_Msk       (0x1UL << SYSCFG_CFGR1_TIM17_DMA_RMP_Pos)    /*!< 0x00001000 */
N#define SYSCFG_CFGR1_TIM17_DMA_RMP           SYSCFG_CFGR1_TIM17_DMA_RMP_Msk               /*!< Timer 17 DMA remap */
N
N#define SYSCFG_CFGR1_I2C_FMP_PB6_Pos         (16U)
N#define SYSCFG_CFGR1_I2C_FMP_PB6_Msk         (0x1UL << SYSCFG_CFGR1_I2C_FMP_PB6_Pos)      /*!< 0x00010000 */
N#define SYSCFG_CFGR1_I2C_FMP_PB6             SYSCFG_CFGR1_I2C_FMP_PB6_Msk                 /*!< I2C PB6 Fast mode plus */
N
N#define SYSCFG_CFGR1_I2C_FMP_PB7_Pos         (17U)
N#define SYSCFG_CFGR1_I2C_FMP_PB7_Msk         (0x1UL << SYSCFG_CFGR1_I2C_FMP_PB7_Pos)      /*!< 0x00020000 */
N#define SYSCFG_CFGR1_I2C_FMP_PB7             SYSCFG_CFGR1_I2C_FMP_PB7_Msk                 /*!< I2C PB7 Fast mode plus */
N
N#define SYSCFG_CFGR1_I2C_FMP_PB8_Pos         (18U)
N#define SYSCFG_CFGR1_I2C_FMP_PB8_Msk         (0x1UL << SYSCFG_CFGR1_I2C_FMP_PB8_Pos)      /*!< 0x00040000 */
N#define SYSCFG_CFGR1_I2C_FMP_PB8             SYSCFG_CFGR1_I2C_FMP_PB8_Msk                 /*!< I2C PB8 Fast mode plus */
N
N#define SYSCFG_CFGR1_I2C_FMP_PB9_Pos         (19U)
N#define SYSCFG_CFGR1_I2C_FMP_PB9_Msk         (0x1UL << SYSCFG_CFGR1_I2C_FMP_PB9_Pos)      /*!< 0x00080000 */
N#define SYSCFG_CFGR1_I2C_FMP_PB9             SYSCFG_CFGR1_I2C_FMP_PB9_Msk                 /*!< I2C PB9 Fast mode plus */
N
N#define SYSCFG_CFGR1_I2C_FMP_I2C1_Pos        (20U)
N#define SYSCFG_CFGR1_I2C_FMP_I2C1_Msk        (0x1UL << SYSCFG_CFGR1_I2C_FMP_I2C1_Pos)     /*!< 0x00100000 */
N#define SYSCFG_CFGR1_I2C_FMP_I2C1            SYSCFG_CFGR1_I2C_FMP_I2C1_Msk                /*!< Enable Fast Mode Plus on PB10, PB11, PF6 and PF7  */
N
N#define SYSCFG_CFGR1_I2C_FMP_PA9_Pos         (22U)
N#define SYSCFG_CFGR1_I2C_FMP_PA9_Msk         (0x1UL << SYSCFG_CFGR1_I2C_FMP_PA9_Pos)      /*!< 0x00400000 */
N#define SYSCFG_CFGR1_I2C_FMP_PA9             SYSCFG_CFGR1_I2C_FMP_PA9_Msk                 /*!< Enable Fast Mode Plus on PA9  */
N
N#define SYSCFG_CFGR1_I2C_FMP_PA10_Pos        (23U)
N#define SYSCFG_CFGR1_I2C_FMP_PA10_Msk        (0x1UL << SYSCFG_CFGR1_I2C_FMP_PA10_Pos)     /*!< 0x00800000 */
N#define SYSCFG_CFGR1_I2C_FMP_PA10            SYSCFG_CFGR1_I2C_FMP_PA10_Msk                /*!< Enable Fast Mode Plus on PA10 */
N
N/*****************  Bit definition for SYSCFG_EXTICR1 register  **************/
N#define SYSCFG_EXTICR1_EXTI0_Pos             (0U)
N#define SYSCFG_EXTICR1_EXTI0_Msk             (0xFUL << SYSCFG_EXTICR1_EXTI0_Pos)          /*!< 0x0000000F */
N#define SYSCFG_EXTICR1_EXTI0                 SYSCFG_EXTICR1_EXTI0_Msk                     /*!< EXTI 0 configuration */
N
N#define SYSCFG_EXTICR1_EXTI1_Pos             (4U)
N#define SYSCFG_EXTICR1_EXTI1_Msk             (0xFUL << SYSCFG_EXTICR1_EXTI1_Pos)          /*!< 0x000000F0 */
N#define SYSCFG_EXTICR1_EXTI1                 SYSCFG_EXTICR1_EXTI1_Msk                     /*!< EXTI 1 configuration */
N
N#define SYSCFG_EXTICR1_EXTI2_Pos             (8U)
N#define SYSCFG_EXTICR1_EXTI2_Msk             (0xFUL << SYSCFG_EXTICR1_EXTI2_Pos)          /*!< 0x00000F00 */
N#define SYSCFG_EXTICR1_EXTI2                 SYSCFG_EXTICR1_EXTI2_Msk                     /*!< EXTI 2 configuration */
N
N#define SYSCFG_EXTICR1_EXTI3_Pos             (12U)
N#define SYSCFG_EXTICR1_EXTI3_Msk             (0xFUL << SYSCFG_EXTICR1_EXTI3_Pos)          /*!< 0x0000F000 */
N#define SYSCFG_EXTICR1_EXTI3                 SYSCFG_EXTICR1_EXTI3_Msk                     /*!< EXTI 3 configuration */
N
N/**
N  * @brief  EXTI0 configuration
N  */
N#define SYSCFG_EXTICR1_EXTI0_PA              (0x00000000U)                                /*!< PA[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PB              (0x00000001U)                                /*!< PB[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PC              (0x00000002U)                                /*!< PC[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PD              (0x00000003U)                                /*!< PD[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PF              (0x00000005U)                                /*!< PF[0] pin */
N
N/**
N  * @brief  EXTI1 configuration
N  */
N#define SYSCFG_EXTICR1_EXTI1_PA              (0x00000000U)                                /*!< PA[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PB              (0x00000010U)                                /*!< PB[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PC              (0x00000020U)                                /*!< PC[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PD              (0x00000030U)                                /*!< PD[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PF              (0x00000050U)                                /*!< PF[1] pin */
N
N/**
N  * @brief  EXTI2 configuration
N  */
N#define SYSCFG_EXTICR1_EXTI2_PA              (0x00000000U)                                /*!< PA[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PB              (0x00000100U)                                /*!< PB[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PC              (0x00000200U)                                /*!< PC[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PD              (0x00000300U)                                /*!< PD[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PF              (0x00000500U)                                /*!< PF[2] pin */
N
N/**
N  * @brief  EXTI3 configuration
N  */
N#define SYSCFG_EXTICR1_EXTI3_PA              (0x00000000U)                                /*!< PA[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PB              (0x00001000U)                                /*!< PB[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PC              (0x00002000U)                                /*!< PC[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PD              (0x00003000U)                                /*!< PD[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PF              (0x00005000U)                                /*!< PF[3] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR2 register  **************/
N#define SYSCFG_EXTICR2_EXTI4_Pos             (0U)
N#define SYSCFG_EXTICR2_EXTI4_Msk             (0xFUL << SYSCFG_EXTICR2_EXTI4_Pos)          /*!< 0x0000000F */
N#define SYSCFG_EXTICR2_EXTI4                 SYSCFG_EXTICR2_EXTI4_Msk                     /*!< EXTI 4 configuration */
N
N#define SYSCFG_EXTICR2_EXTI5_Pos             (4U)
N#define SYSCFG_EXTICR2_EXTI5_Msk             (0xFUL << SYSCFG_EXTICR2_EXTI5_Pos)          /*!< 0x000000F0 */
N#define SYSCFG_EXTICR2_EXTI5                 SYSCFG_EXTICR2_EXTI5_Msk                     /*!< EXTI 5 configuration */
N
N#define SYSCFG_EXTICR2_EXTI6_Pos             (8U)
N#define SYSCFG_EXTICR2_EXTI6_Msk             (0xFUL << SYSCFG_EXTICR2_EXTI6_Pos)          /*!< 0x00000F00 */
N#define SYSCFG_EXTICR2_EXTI6                 SYSCFG_EXTICR2_EXTI6_Msk                     /*!< EXTI 6 configuration */
N
N#define SYSCFG_EXTICR2_EXTI7_Pos             (12U)
N#define SYSCFG_EXTICR2_EXTI7_Msk             (0xFUL << SYSCFG_EXTICR2_EXTI7_Pos)          /*!< 0x0000F000 */
N#define SYSCFG_EXTICR2_EXTI7                 SYSCFG_EXTICR2_EXTI7_Msk                     /*!< EXTI 7 configuration */
N
N/**
N  * @brief  EXTI4 configuration
N  */
N#define SYSCFG_EXTICR2_EXTI4_PA              (0x00000000U)                                /*!< PA[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PB              (0x00000001U)                                /*!< PB[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PC              (0x00000002U)                                /*!< PC[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PD              (0x00000003U)                                /*!< PD[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PF              (0x00000005U)                                /*!< PF[4] pin */
N
N/**
N  * @brief  EXTI5 configuration
N  */
N#define SYSCFG_EXTICR2_EXTI5_PA              (0x00000000U)                                /*!< PA[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PB              (0x00000010U)                                /*!< PB[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PC              (0x00000020U)                                /*!< PC[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PD              (0x00000030U)                                /*!< PD[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PF              (0x00000050U)                                /*!< PF[5] pin */
N
N/**
N  * @brief  EXTI6 configuration
N  */
N#define SYSCFG_EXTICR2_EXTI6_PA              (0x00000000U)                                /*!< PA[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PB              (0x00000100U)                                /*!< PB[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PC              (0x00000200U)                                /*!< PC[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PD              (0x00000300U)                                /*!< PD[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PF              (0x00000500U)                                /*!< PF[6] pin */
N
N/**
N  * @brief  EXTI7 configuration
N  */
N#define SYSCFG_EXTICR2_EXTI7_PA              (0x00000000U)                                /*!< PA[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PB              (0x00001000U)                                /*!< PB[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PC              (0x00002000U)                                /*!< PC[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PD              (0x00003000U)                                /*!< PD[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PF              (0x00005000U)                                /*!< PF[7] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR3 register  **************/
N#define SYSCFG_EXTICR3_EXTI8_Pos             (0U)
N#define SYSCFG_EXTICR3_EXTI8_Msk             (0xFUL << SYSCFG_EXTICR3_EXTI8_Pos)          /*!< 0x0000000F */
N#define SYSCFG_EXTICR3_EXTI8                 SYSCFG_EXTICR3_EXTI8_Msk                     /*!< EXTI 8 configuration */
N
N#define SYSCFG_EXTICR3_EXTI9_Pos             (4U)
N#define SYSCFG_EXTICR3_EXTI9_Msk             (0xFUL << SYSCFG_EXTICR3_EXTI9_Pos)          /*!< 0x000000F0 */
N#define SYSCFG_EXTICR3_EXTI9                 SYSCFG_EXTICR3_EXTI9_Msk                     /*!< EXTI 9 configuration */
N
N#define SYSCFG_EXTICR3_EXTI10_Pos            (8U)
N#define SYSCFG_EXTICR3_EXTI10_Msk            (0xFUL << SYSCFG_EXTICR3_EXTI10_Pos)         /*!< 0x00000F00 */
N#define SYSCFG_EXTICR3_EXTI10                SYSCFG_EXTICR3_EXTI10_Msk                    /*!< EXTI 10 configuration */
N
N#define SYSCFG_EXTICR3_EXTI11_Pos            (12U)
N#define SYSCFG_EXTICR3_EXTI11_Msk            (0xFUL << SYSCFG_EXTICR3_EXTI11_Pos)         /*!< 0x0000F000 */
N#define SYSCFG_EXTICR3_EXTI11                SYSCFG_EXTICR3_EXTI11_Msk                    /*!< EXTI 11 configuration */
N
N/**
N  * @brief  EXTI8 configuration
N  */
N#define SYSCFG_EXTICR3_EXTI8_PA              (0x00000000U)                                /*!< PA[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PB              (0x00000001U)                                /*!< PB[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PC              (0x00000002U)                                /*!< PC[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PD              (0x00000003U)                                /*!< PD[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PF              (0x00000005U)                                /*!< PF[8] pin */
N
N
N/**
N  * @brief  EXTI9 configuration
N  */
N#define SYSCFG_EXTICR3_EXTI9_PA              (0x00000000U)                                /*!< PA[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PB              (0x00000010U)                                /*!< PB[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PC              (0x00000020U)                                /*!< PC[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PD              (0x00000030U)                                /*!< PD[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PF              (0x00000050U)                                /*!< PF[9] pin */
N
N/**
N  * @brief  EXTI10 configuration
N  */
N#define SYSCFG_EXTICR3_EXTI10_PA             (0x00000000U)                                /*!< PA[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PB             (0x00000100U)                                /*!< PB[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PC             (0x00000200U)                                /*!< PC[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PD             (0x00000300U)                                /*!< PD[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PF             (0x00000500U)                                /*!< PF[10] pin */
N
N/**
N  * @brief  EXTI11 configuration
N  */
N#define SYSCFG_EXTICR3_EXTI11_PA             (0x00000000U)                                /*!< PA[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PB             (0x00001000U)                                /*!< PB[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PC             (0x00002000U)                                /*!< PC[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PD             (0x00003000U)                                /*!< PD[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PF             (0x00005000U)                                /*!< PF[11] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR4 register  **************/
N#define SYSCFG_EXTICR4_EXTI12_Pos            (0U)
N#define SYSCFG_EXTICR4_EXTI12_Msk            (0xFUL << SYSCFG_EXTICR4_EXTI12_Pos)         /*!< 0x0000000F */
N#define SYSCFG_EXTICR4_EXTI12                SYSCFG_EXTICR4_EXTI12_Msk                    /*!< EXTI 12 configuration */
N
N#define SYSCFG_EXTICR4_EXTI13_Pos            (4U)
N#define SYSCFG_EXTICR4_EXTI13_Msk            (0xFUL << SYSCFG_EXTICR4_EXTI13_Pos)         /*!< 0x000000F0 */
N#define SYSCFG_EXTICR4_EXTI13                SYSCFG_EXTICR4_EXTI13_Msk                    /*!< EXTI 13 configuration */
N
N#define SYSCFG_EXTICR4_EXTI14_Pos            (8U)
N#define SYSCFG_EXTICR4_EXTI14_Msk            (0xFUL << SYSCFG_EXTICR4_EXTI14_Pos)         /*!< 0x00000F00 */
N#define SYSCFG_EXTICR4_EXTI14                SYSCFG_EXTICR4_EXTI14_Msk                    /*!< EXTI 14 configuration */
N
N#define SYSCFG_EXTICR4_EXTI15_Pos            (12U)
N#define SYSCFG_EXTICR4_EXTI15_Msk            (0xFUL << SYSCFG_EXTICR4_EXTI15_Pos)         /*!< 0x0000F000 */
N#define SYSCFG_EXTICR4_EXTI15                SYSCFG_EXTICR4_EXTI15_Msk                    /*!< EXTI 15 configuration */
N
N/**
N  * @brief  EXTI12 configuration
N  */
N#define SYSCFG_EXTICR4_EXTI12_PA             (0x00000000U)                                /*!< PA[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PB             (0x00000001U)                                /*!< PB[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PC             (0x00000002U)                                /*!< PC[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PD             (0x00000003U)                                /*!< PD[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PF             (0x00000005U)                                /*!< PF[12] pin */
N
N/**
N  * @brief  EXTI13 configuration
N  */
N#define SYSCFG_EXTICR4_EXTI13_PA             (0x00000000U)                                /*!< PA[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PB             (0x00000010U)                                /*!< PB[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PC             (0x00000020U)                                /*!< PC[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PD             (0x00000030U)                                /*!< PD[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PF             (0x00000050U)                                /*!< PF[13] pin */
N
N/**
N  * @brief  EXTI14 configuration
N  */
N#define SYSCFG_EXTICR4_EXTI14_PA             (0x00000000U)                                /*!< PA[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PB             (0x00000100U)                                /*!< PB[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PC             (0x00000200U)                                /*!< PC[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PD             (0x00000300U)                                /*!< PD[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PF             (0x00000500U)                                /*!< PF[14] pin */
N
N/**
N  * @brief  EXTI15 configuration
N  */
N#define SYSCFG_EXTICR4_EXTI15_PA             (0x00000000U)                                /*!< PA[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PB             (0x00001000U)                                /*!< PB[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PC             (0x00002000U)                                /*!< PC[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PD             (0x00003000U)                                /*!< PD[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PF             (0x00005000U)                                /*!< PF[15] pin */
N
N/*****************  Bit definition for SYSCFG_CFGR2 register  ****************/
N#define SYSCFG_CFGR2_LOCKUP_LOCK_Pos         (0U)
N#define SYSCFG_CFGR2_LOCKUP_LOCK_Msk         (0x1UL << SYSCFG_CFGR2_LOCKUP_LOCK_Pos)      /*!< 0x00000001 */
N#define SYSCFG_CFGR2_LOCKUP_LOCK             SYSCFG_CFGR2_LOCKUP_LOCK_Msk                 /*!< Enables and locks the LOCKUP (Hardfault) output of CortexM0 with Break Input of TIMER1 */
N
N#define SYSCFG_CFGR2_SRAM_PARITY_LOCK_Pos    (1U)
N#define SYSCFG_CFGR2_SRAM_PARITY_LOCK_Msk    (0x1UL << SYSCFG_CFGR2_SRAM_PARITY_LOCK_Pos) /*!< 0x00000002 */
N#define SYSCFG_CFGR2_SRAM_PARITY_LOCK        SYSCFG_CFGR2_SRAM_PARITY_LOCK_Msk            /*!< Enables and locks the SRAM_PARITY error signal with Break Input of TIMER1 */
N
N#define SYSCFG_CFGR2_PVD_LOCK_Pos            (2U)
N#define SYSCFG_CFGR2_PVD_LOCK_Msk            (0x1UL << SYSCFG_CFGR2_PVD_LOCK_Pos)         /*!< 0x00000004 */
N#define SYSCFG_CFGR2_PVD_LOCK                SYSCFG_CFGR2_PVD_LOCK_Msk                    /*!< Enables and locks the PVD connection with Timer1 Break Input and also the PVD_EN and PVDSEL[2:0] bits of the Power Control Interface */
N
N#define SYSCFG_CFGR2_SRAM_PEF_Pos            (8U)
N#define SYSCFG_CFGR2_SRAM_PEF_Msk            (0x1UL << SYSCFG_CFGR2_SRAM_PEF_Pos)         /*!< 0x00000100 */
N#define SYSCFG_CFGR2_SRAM_PEF                SYSCFG_CFGR2_SRAM_PEF_Msk                    /*!< SRAM Parity error flag */
N#define SYSCFG_CFGR2_SRAM_PE                 SYSCFG_CFGR2_SRAM_PEF                        /*!< SRAM Parity error flag (define maintained for legacy purpose) */
N
N
N/*****************************************************************************/
N/*                                                                           */
N/*                               Timers (TIM)                                */
N/*                                                                           */
N/*****************************************************************************/
N/*******************  Bit definition for TIM_CR1 register  *******************/
N#define TIM_CR1_CEN_Pos           (0U)
N#define TIM_CR1_CEN_Msk           (0x1UL << TIM_CR1_CEN_Pos)                    /*!< 0x00000001 */
N#define TIM_CR1_CEN               TIM_CR1_CEN_Msk                               /*!<Counter enable */
N
N#define TIM_CR1_UDIS_Pos          (1U)
N#define TIM_CR1_UDIS_Msk          (0x1UL << TIM_CR1_UDIS_Pos)                   /*!< 0x00000002 */
N#define TIM_CR1_UDIS              TIM_CR1_UDIS_Msk                              /*!<Update disable */
N
N#define TIM_CR1_URS_Pos           (2U)
N#define TIM_CR1_URS_Msk           (0x1UL << TIM_CR1_URS_Pos)                    /*!< 0x00000004 */
N#define TIM_CR1_URS               TIM_CR1_URS_Msk                               /*!<Update request source */
N
N#define TIM_CR1_OPM_Pos           (3U)
N#define TIM_CR1_OPM_Msk           (0x1UL << TIM_CR1_OPM_Pos)                    /*!< 0x00000008 */
N#define TIM_CR1_OPM               TIM_CR1_OPM_Msk                               /*!<One pulse mode */
N
N#define TIM_CR1_DIR_Pos           (4U)
N#define TIM_CR1_DIR_Msk           (0x1UL << TIM_CR1_DIR_Pos)                    /*!< 0x00000010 */
N#define TIM_CR1_DIR               TIM_CR1_DIR_Msk                               /*!<Direction */
N
N#define TIM_CR1_CMS_Pos           (5U)
N#define TIM_CR1_CMS_Msk           (0x3UL << TIM_CR1_CMS_Pos)                    /*!< 0x00000060 */
N#define TIM_CR1_CMS               TIM_CR1_CMS_Msk                               /*!<CMS[1:0] bits (Center-aligned mode selection) */
N#define TIM_CR1_CMS_0             (0x1UL << TIM_CR1_CMS_Pos)                    /*!< 0x00000020 */
N#define TIM_CR1_CMS_1             (0x2UL << TIM_CR1_CMS_Pos)                    /*!< 0x00000040 */
N
N#define TIM_CR1_ARPE_Pos          (7U)
N#define TIM_CR1_ARPE_Msk          (0x1UL << TIM_CR1_ARPE_Pos)                   /*!< 0x00000080 */
N#define TIM_CR1_ARPE              TIM_CR1_ARPE_Msk                              /*!<Auto-reload preload enable */
N
N#define TIM_CR1_CKD_Pos           (8U)
N#define TIM_CR1_CKD_Msk           (0x3UL << TIM_CR1_CKD_Pos)                    /*!< 0x00000300 */
N#define TIM_CR1_CKD               TIM_CR1_CKD_Msk                               /*!<CKD[1:0] bits (clock division) */
N#define TIM_CR1_CKD_0             (0x1UL << TIM_CR1_CKD_Pos)                    /*!< 0x00000100 */
N#define TIM_CR1_CKD_1             (0x2UL << TIM_CR1_CKD_Pos)                    /*!< 0x00000200 */
N
N/*******************  Bit definition for TIM_CR2 register  *******************/
N#define TIM_CR2_CCPC_Pos          (0U)
N#define TIM_CR2_CCPC_Msk          (0x1UL << TIM_CR2_CCPC_Pos)                   /*!< 0x00000001 */
N#define TIM_CR2_CCPC              TIM_CR2_CCPC_Msk                              /*!<Capture/Compare Preloaded Control */
N
N#define TIM_CR2_CCUS_Pos          (2U)
N#define TIM_CR2_CCUS_Msk          (0x1UL << TIM_CR2_CCUS_Pos)                   /*!< 0x00000004 */
N#define TIM_CR2_CCUS              TIM_CR2_CCUS_Msk                              /*!<Capture/Compare Control Update Selection */
N
N#define TIM_CR2_CCDS_Pos          (3U)
N#define TIM_CR2_CCDS_Msk          (0x1UL << TIM_CR2_CCDS_Pos)                   /*!< 0x00000008 */
N#define TIM_CR2_CCDS              TIM_CR2_CCDS_Msk                              /*!<Capture/Compare DMA Selection */
N
N#define TIM_CR2_MMS_Pos           (4U)
N#define TIM_CR2_MMS_Msk           (0x7UL << TIM_CR2_MMS_Pos)                    /*!< 0x00000070 */
N#define TIM_CR2_MMS               TIM_CR2_MMS_Msk                               /*!<MMS[2:0] bits (Master Mode Selection) */
N#define TIM_CR2_MMS_0             (0x1UL << TIM_CR2_MMS_Pos)                    /*!< 0x00000010 */
N#define TIM_CR2_MMS_1             (0x2UL << TIM_CR2_MMS_Pos)                    /*!< 0x00000020 */
N#define TIM_CR2_MMS_2             (0x4UL << TIM_CR2_MMS_Pos)                    /*!< 0x00000040 */
N
N#define TIM_CR2_TI1S_Pos          (7U)
N#define TIM_CR2_TI1S_Msk          (0x1UL << TIM_CR2_TI1S_Pos)                   /*!< 0x00000080 */
N#define TIM_CR2_TI1S              TIM_CR2_TI1S_Msk                              /*!<TI1 Selection */
N
N#define TIM_CR2_OIS1_Pos          (8U)
N#define TIM_CR2_OIS1_Msk          (0x1UL << TIM_CR2_OIS1_Pos)                   /*!< 0x00000100 */
N#define TIM_CR2_OIS1              TIM_CR2_OIS1_Msk                              /*!<Output Idle state 1 (OC1 output) */
N
N#define TIM_CR2_OIS1N_Pos         (9U)
N#define TIM_CR2_OIS1N_Msk         (0x1UL << TIM_CR2_OIS1N_Pos)                  /*!< 0x00000200 */
N#define TIM_CR2_OIS1N             TIM_CR2_OIS1N_Msk                             /*!<Output Idle state 1 (OC1N output) */
N
N#define TIM_CR2_OIS2_Pos          (10U)
N#define TIM_CR2_OIS2_Msk          (0x1UL << TIM_CR2_OIS2_Pos)                   /*!< 0x00000400 */
N#define TIM_CR2_OIS2              TIM_CR2_OIS2_Msk                              /*!<Output Idle state 2 (OC2 output) */
N
N#define TIM_CR2_OIS2N_Pos         (11U)
N#define TIM_CR2_OIS2N_Msk         (0x1UL << TIM_CR2_OIS2N_Pos)                  /*!< 0x00000800 */
N#define TIM_CR2_OIS2N             TIM_CR2_OIS2N_Msk                             /*!<Output Idle state 2 (OC2N output) */
N
N#define TIM_CR2_OIS3_Pos          (12U)
N#define TIM_CR2_OIS3_Msk          (0x1UL << TIM_CR2_OIS3_Pos)                   /*!< 0x00001000 */
N#define TIM_CR2_OIS3              TIM_CR2_OIS3_Msk                              /*!<Output Idle state 3 (OC3 output) */
N
N#define TIM_CR2_OIS3N_Pos         (13U)
N#define TIM_CR2_OIS3N_Msk         (0x1UL << TIM_CR2_OIS3N_Pos)                  /*!< 0x00002000 */
N#define TIM_CR2_OIS3N             TIM_CR2_OIS3N_Msk                             /*!<Output Idle state 3 (OC3N output) */
N
N#define TIM_CR2_OIS4_Pos          (14U)
N#define TIM_CR2_OIS4_Msk          (0x1UL << TIM_CR2_OIS4_Pos)                   /*!< 0x00004000 */
N#define TIM_CR2_OIS4              TIM_CR2_OIS4_Msk                              /*!<Output Idle state 4 (OC4 output) */
N
N/*******************  Bit definition for TIM_SMCR register  ******************/
N#define TIM_SMCR_SMS_Pos          (0U)
N#define TIM_SMCR_SMS_Msk          (0x7UL << TIM_SMCR_SMS_Pos)                   /*!< 0x00000007 */
N#define TIM_SMCR_SMS              TIM_SMCR_SMS_Msk                              /*!<SMS[2:0] bits (Slave mode selection) */
N#define TIM_SMCR_SMS_0            (0x1UL << TIM_SMCR_SMS_Pos)                   /*!< 0x00000001 */
N#define TIM_SMCR_SMS_1            (0x2UL << TIM_SMCR_SMS_Pos)                   /*!< 0x00000002 */
N#define TIM_SMCR_SMS_2            (0x4UL << TIM_SMCR_SMS_Pos)                   /*!< 0x00000004 */
N
N#define TIM_SMCR_OCCS_Pos         (3U)
N#define TIM_SMCR_OCCS_Msk         (0x1UL << TIM_SMCR_OCCS_Pos)                  /*!< 0x00000008 */
N#define TIM_SMCR_OCCS             TIM_SMCR_OCCS_Msk                             /*!< OCREF clear selection */
N
N#define TIM_SMCR_TS_Pos           (4U)
N#define TIM_SMCR_TS_Msk           (0x7UL << TIM_SMCR_TS_Pos)                    /*!< 0x00000070 */
N#define TIM_SMCR_TS               TIM_SMCR_TS_Msk                               /*!<TS[2:0] bits (Trigger selection) */
N#define TIM_SMCR_TS_0             (0x1UL << TIM_SMCR_TS_Pos)                    /*!< 0x00000010 */
N#define TIM_SMCR_TS_1             (0x2UL << TIM_SMCR_TS_Pos)                    /*!< 0x00000020 */
N#define TIM_SMCR_TS_2             (0x4UL << TIM_SMCR_TS_Pos)                    /*!< 0x00000040 */
N
N#define TIM_SMCR_MSM_Pos          (7U)
N#define TIM_SMCR_MSM_Msk          (0x1UL << TIM_SMCR_MSM_Pos)                   /*!< 0x00000080 */
N#define TIM_SMCR_MSM              TIM_SMCR_MSM_Msk                              /*!<Master/slave mode */
N
N#define TIM_SMCR_ETF_Pos          (8U)
N#define TIM_SMCR_ETF_Msk          (0xFUL << TIM_SMCR_ETF_Pos)                   /*!< 0x00000F00 */
N#define TIM_SMCR_ETF              TIM_SMCR_ETF_Msk                              /*!<ETF[3:0] bits (External trigger filter) */
N#define TIM_SMCR_ETF_0            (0x1UL << TIM_SMCR_ETF_Pos)                   /*!< 0x00000100 */
N#define TIM_SMCR_ETF_1            (0x2UL << TIM_SMCR_ETF_Pos)                   /*!< 0x00000200 */
N#define TIM_SMCR_ETF_2            (0x4UL << TIM_SMCR_ETF_Pos)                   /*!< 0x00000400 */
N#define TIM_SMCR_ETF_3            (0x8UL << TIM_SMCR_ETF_Pos)                   /*!< 0x00000800 */
N
N#define TIM_SMCR_ETPS_Pos         (12U)
N#define TIM_SMCR_ETPS_Msk         (0x3UL << TIM_SMCR_ETPS_Pos)                  /*!< 0x00003000 */
N#define TIM_SMCR_ETPS             TIM_SMCR_ETPS_Msk                             /*!<ETPS[1:0] bits (External trigger prescaler) */
N#define TIM_SMCR_ETPS_0           (0x1UL << TIM_SMCR_ETPS_Pos)                  /*!< 0x00001000 */
N#define TIM_SMCR_ETPS_1           (0x2UL << TIM_SMCR_ETPS_Pos)                  /*!< 0x00002000 */
N
N#define TIM_SMCR_ECE_Pos          (14U)
N#define TIM_SMCR_ECE_Msk          (0x1UL << TIM_SMCR_ECE_Pos)                   /*!< 0x00004000 */
N#define TIM_SMCR_ECE              TIM_SMCR_ECE_Msk                              /*!<External clock enable */
N
N#define TIM_SMCR_ETP_Pos          (15U)
N#define TIM_SMCR_ETP_Msk          (0x1UL << TIM_SMCR_ETP_Pos)                   /*!< 0x00008000 */
N#define TIM_SMCR_ETP              TIM_SMCR_ETP_Msk                              /*!<External trigger polarity */
N
N/*******************  Bit definition for TIM_DIER register  ******************/
N#define TIM_DIER_UIE_Pos          (0U)
N#define TIM_DIER_UIE_Msk          (0x1UL << TIM_DIER_UIE_Pos)                   /*!< 0x00000001 */
N#define TIM_DIER_UIE              TIM_DIER_UIE_Msk                              /*!<Update interrupt enable */
N
N#define TIM_DIER_CC1IE_Pos        (1U)
N#define TIM_DIER_CC1IE_Msk        (0x1UL << TIM_DIER_CC1IE_Pos)                 /*!< 0x00000002 */
N#define TIM_DIER_CC1IE            TIM_DIER_CC1IE_Msk                            /*!<Capture/Compare 1 interrupt enable */
N
N#define TIM_DIER_CC2IE_Pos        (2U)
N#define TIM_DIER_CC2IE_Msk        (0x1UL << TIM_DIER_CC2IE_Pos)                 /*!< 0x00000004 */
N#define TIM_DIER_CC2IE            TIM_DIER_CC2IE_Msk                            /*!<Capture/Compare 2 interrupt enable */
N
N#define TIM_DIER_CC3IE_Pos        (3U)
N#define TIM_DIER_CC3IE_Msk        (0x1UL << TIM_DIER_CC3IE_Pos)                 /*!< 0x00000008 */
N#define TIM_DIER_CC3IE            TIM_DIER_CC3IE_Msk                            /*!<Capture/Compare 3 interrupt enable */
N
N#define TIM_DIER_CC4IE_Pos        (4U)
N#define TIM_DIER_CC4IE_Msk        (0x1UL << TIM_DIER_CC4IE_Pos)                 /*!< 0x00000010 */
N#define TIM_DIER_CC4IE            TIM_DIER_CC4IE_Msk                            /*!<Capture/Compare 4 interrupt enable */
N
N#define TIM_DIER_COMIE_Pos        (5U)
N#define TIM_DIER_COMIE_Msk        (0x1UL << TIM_DIER_COMIE_Pos)                 /*!< 0x00000020 */
N#define TIM_DIER_COMIE            TIM_DIER_COMIE_Msk                            /*!<COM interrupt enable */
N
N#define TIM_DIER_TIE_Pos          (6U)
N#define TIM_DIER_TIE_Msk          (0x1UL << TIM_DIER_TIE_Pos)                   /*!< 0x00000040 */
N#define TIM_DIER_TIE              TIM_DIER_TIE_Msk                              /*!<Trigger interrupt enable */
N
N#define TIM_DIER_BIE_Pos          (7U)
N#define TIM_DIER_BIE_Msk          (0x1UL << TIM_DIER_BIE_Pos)                   /*!< 0x00000080 */
N#define TIM_DIER_BIE              TIM_DIER_BIE_Msk                              /*!<Break interrupt enable */
N
N#define TIM_DIER_UDE_Pos          (8U)
N#define TIM_DIER_UDE_Msk          (0x1UL << TIM_DIER_UDE_Pos)                   /*!< 0x00000100 */
N#define TIM_DIER_UDE              TIM_DIER_UDE_Msk                              /*!<Update DMA request enable */
N
N#define TIM_DIER_CC1DE_Pos        (9U)
N#define TIM_DIER_CC1DE_Msk        (0x1UL << TIM_DIER_CC1DE_Pos)                 /*!< 0x00000200 */
N#define TIM_DIER_CC1DE            TIM_DIER_CC1DE_Msk                            /*!<Capture/Compare 1 DMA request enable */
N
N#define TIM_DIER_CC2DE_Pos        (10U)
N#define TIM_DIER_CC2DE_Msk        (0x1UL << TIM_DIER_CC2DE_Pos)                 /*!< 0x00000400 */
N#define TIM_DIER_CC2DE            TIM_DIER_CC2DE_Msk                            /*!<Capture/Compare 2 DMA request enable */
N
N#define TIM_DIER_CC3DE_Pos        (11U)
N#define TIM_DIER_CC3DE_Msk        (0x1UL << TIM_DIER_CC3DE_Pos)                 /*!< 0x00000800 */
N#define TIM_DIER_CC3DE            TIM_DIER_CC3DE_Msk                            /*!<Capture/Compare 3 DMA request enable */
N
N#define TIM_DIER_CC4DE_Pos        (12U)
N#define TIM_DIER_CC4DE_Msk        (0x1UL << TIM_DIER_CC4DE_Pos)                 /*!< 0x00001000 */
N#define TIM_DIER_CC4DE            TIM_DIER_CC4DE_Msk                            /*!<Capture/Compare 4 DMA request enable */
N
N#define TIM_DIER_COMDE_Pos        (13U)
N#define TIM_DIER_COMDE_Msk        (0x1UL << TIM_DIER_COMDE_Pos)                 /*!< 0x00002000 */
N#define TIM_DIER_COMDE            TIM_DIER_COMDE_Msk                            /*!<COM DMA request enable */
N
N#define TIM_DIER_TDE_Pos          (14U)
N#define TIM_DIER_TDE_Msk          (0x1UL << TIM_DIER_TDE_Pos)                   /*!< 0x00004000 */
N#define TIM_DIER_TDE              TIM_DIER_TDE_Msk                              /*!<Trigger DMA request enable */
N
N/********************  Bit definition for TIM_SR register  *******************/
N#define TIM_SR_UIF_Pos            (0U)
N#define TIM_SR_UIF_Msk            (0x1UL << TIM_SR_UIF_Pos)                     /*!< 0x00000001 */
N#define TIM_SR_UIF                TIM_SR_UIF_Msk                                /*!<Update interrupt Flag */
N
N#define TIM_SR_CC1IF_Pos          (1U)
N#define TIM_SR_CC1IF_Msk          (0x1UL << TIM_SR_CC1IF_Pos)                   /*!< 0x00000002 */
N#define TIM_SR_CC1IF              TIM_SR_CC1IF_Msk                              /*!<Capture/Compare 1 interrupt Flag */
N
N#define TIM_SR_CC2IF_Pos          (2U)
N#define TIM_SR_CC2IF_Msk          (0x1UL << TIM_SR_CC2IF_Pos)                   /*!< 0x00000004 */
N#define TIM_SR_CC2IF              TIM_SR_CC2IF_Msk                              /*!<Capture/Compare 2 interrupt Flag */
N
N#define TIM_SR_CC3IF_Pos          (3U)
N#define TIM_SR_CC3IF_Msk          (0x1UL << TIM_SR_CC3IF_Pos)                   /*!< 0x00000008 */
N#define TIM_SR_CC3IF              TIM_SR_CC3IF_Msk                              /*!<Capture/Compare 3 interrupt Flag */
N
N#define TIM_SR_CC4IF_Pos          (4U)
N#define TIM_SR_CC4IF_Msk          (0x1UL << TIM_SR_CC4IF_Pos)                   /*!< 0x00000010 */
N#define TIM_SR_CC4IF              TIM_SR_CC4IF_Msk                              /*!<Capture/Compare 4 interrupt Flag */
N
N#define TIM_SR_COMIF_Pos          (5U)
N#define TIM_SR_COMIF_Msk          (0x1UL << TIM_SR_COMIF_Pos)                   /*!< 0x00000020 */
N#define TIM_SR_COMIF              TIM_SR_COMIF_Msk                              /*!<COM interrupt Flag */
N
N#define TIM_SR_TIF_Pos            (6U)
N#define TIM_SR_TIF_Msk            (0x1UL << TIM_SR_TIF_Pos)                     /*!< 0x00000040 */
N#define TIM_SR_TIF                TIM_SR_TIF_Msk                                /*!<Trigger interrupt Flag */
N
N#define TIM_SR_BIF_Pos            (7U)
N#define TIM_SR_BIF_Msk            (0x1UL << TIM_SR_BIF_Pos)                     /*!< 0x00000080 */
N#define TIM_SR_BIF                TIM_SR_BIF_Msk                                /*!<Break interrupt Flag */
N
N#define TIM_SR_CC1OF_Pos          (9U)
N#define TIM_SR_CC1OF_Msk          (0x1UL << TIM_SR_CC1OF_Pos)                   /*!< 0x00000200 */
N#define TIM_SR_CC1OF              TIM_SR_CC1OF_Msk                              /*!<Capture/Compare 1 Overcapture Flag */
N
N#define TIM_SR_CC2OF_Pos          (10U)
N#define TIM_SR_CC2OF_Msk          (0x1UL << TIM_SR_CC2OF_Pos)                   /*!< 0x00000400 */
N#define TIM_SR_CC2OF              TIM_SR_CC2OF_Msk                              /*!<Capture/Compare 2 Overcapture Flag */
N
N#define TIM_SR_CC3OF_Pos          (11U)
N#define TIM_SR_CC3OF_Msk          (0x1UL << TIM_SR_CC3OF_Pos)                   /*!< 0x00000800 */
N#define TIM_SR_CC3OF              TIM_SR_CC3OF_Msk                              /*!<Capture/Compare 3 Overcapture Flag */
N
N#define TIM_SR_CC4OF_Pos          (12U)
N#define TIM_SR_CC4OF_Msk          (0x1UL << TIM_SR_CC4OF_Pos)                   /*!< 0x00001000 */
N#define TIM_SR_CC4OF              TIM_SR_CC4OF_Msk                              /*!<Capture/Compare 4 Overcapture Flag */
N
N/*******************  Bit definition for TIM_EGR register  *******************/
N#define TIM_EGR_UG_Pos            (0U)
N#define TIM_EGR_UG_Msk            (0x1UL << TIM_EGR_UG_Pos)                     /*!< 0x00000001 */
N#define TIM_EGR_UG                TIM_EGR_UG_Msk                                /*!<Update Generation */
N
N#define TIM_EGR_CC1G_Pos          (1U)
N#define TIM_EGR_CC1G_Msk          (0x1UL << TIM_EGR_CC1G_Pos)                   /*!< 0x00000002 */
N#define TIM_EGR_CC1G              TIM_EGR_CC1G_Msk                              /*!<Capture/Compare 1 Generation */
N
N#define TIM_EGR_CC2G_Pos          (2U)
N#define TIM_EGR_CC2G_Msk          (0x1UL << TIM_EGR_CC2G_Pos)                   /*!< 0x00000004 */
N#define TIM_EGR_CC2G              TIM_EGR_CC2G_Msk                              /*!<Capture/Compare 2 Generation */
N
N#define TIM_EGR_CC3G_Pos          (3U)
N#define TIM_EGR_CC3G_Msk          (0x1UL << TIM_EGR_CC3G_Pos)                   /*!< 0x00000008 */
N#define TIM_EGR_CC3G              TIM_EGR_CC3G_Msk                              /*!<Capture/Compare 3 Generation */
N
N#define TIM_EGR_CC4G_Pos          (4U)
N#define TIM_EGR_CC4G_Msk          (0x1UL << TIM_EGR_CC4G_Pos)                   /*!< 0x00000010 */
N#define TIM_EGR_CC4G              TIM_EGR_CC4G_Msk                              /*!<Capture/Compare 4 Generation */
N
N#define TIM_EGR_COMG_Pos          (5U)
N#define TIM_EGR_COMG_Msk          (0x1UL << TIM_EGR_COMG_Pos)                   /*!< 0x00000020 */
N#define TIM_EGR_COMG              TIM_EGR_COMG_Msk                              /*!<Capture/Compare Control Update Generation */
N
N#define TIM_EGR_TG_Pos            (6U)
N#define TIM_EGR_TG_Msk            (0x1UL << TIM_EGR_TG_Pos)                     /*!< 0x00000040 */
N#define TIM_EGR_TG                TIM_EGR_TG_Msk                                /*!<Trigger Generation */
N
N#define TIM_EGR_BG_Pos            (7U)
N#define TIM_EGR_BG_Msk            (0x1UL << TIM_EGR_BG_Pos)                     /*!< 0x00000080 */
N#define TIM_EGR_BG                TIM_EGR_BG_Msk                                /*!<Break Generation */
N
N/******************  Bit definition for TIM_CCMR1 register  ******************/
N#define TIM_CCMR1_CC1S_Pos        (0U)
N#define TIM_CCMR1_CC1S_Msk        (0x3UL << TIM_CCMR1_CC1S_Pos)                 /*!< 0x00000003 */
N#define TIM_CCMR1_CC1S            TIM_CCMR1_CC1S_Msk                            /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
N#define TIM_CCMR1_CC1S_0          (0x1UL << TIM_CCMR1_CC1S_Pos)                 /*!< 0x00000001 */
N#define TIM_CCMR1_CC1S_1          (0x2UL << TIM_CCMR1_CC1S_Pos)                 /*!< 0x00000002 */
N
N#define TIM_CCMR1_OC1FE_Pos       (2U)
N#define TIM_CCMR1_OC1FE_Msk       (0x1UL << TIM_CCMR1_OC1FE_Pos)                /*!< 0x00000004 */
N#define TIM_CCMR1_OC1FE           TIM_CCMR1_OC1FE_Msk                           /*!<Output Compare 1 Fast enable */
N
N#define TIM_CCMR1_OC1PE_Pos       (3U)
N#define TIM_CCMR1_OC1PE_Msk       (0x1UL << TIM_CCMR1_OC1PE_Pos)                /*!< 0x00000008 */
N#define TIM_CCMR1_OC1PE           TIM_CCMR1_OC1PE_Msk                           /*!<Output Compare 1 Preload enable */
N
N#define TIM_CCMR1_OC1M_Pos        (4U)
N#define TIM_CCMR1_OC1M_Msk        (0x7UL << TIM_CCMR1_OC1M_Pos)                 /*!< 0x00000070 */
N#define TIM_CCMR1_OC1M            TIM_CCMR1_OC1M_Msk                            /*!<OC1M[2:0] bits (Output Compare 1 Mode) */
N#define TIM_CCMR1_OC1M_0          (0x1UL << TIM_CCMR1_OC1M_Pos)                 /*!< 0x00000010 */
N#define TIM_CCMR1_OC1M_1          (0x2UL << TIM_CCMR1_OC1M_Pos)                 /*!< 0x00000020 */
N#define TIM_CCMR1_OC1M_2          (0x4UL << TIM_CCMR1_OC1M_Pos)                 /*!< 0x00000040 */
N
N#define TIM_CCMR1_OC1CE_Pos       (7U)
N#define TIM_CCMR1_OC1CE_Msk       (0x1UL << TIM_CCMR1_OC1CE_Pos)                /*!< 0x00000080 */
N#define TIM_CCMR1_OC1CE           TIM_CCMR1_OC1CE_Msk                           /*!<Output Compare 1Clear Enable */
N
N#define TIM_CCMR1_CC2S_Pos        (8U)
N#define TIM_CCMR1_CC2S_Msk        (0x3UL << TIM_CCMR1_CC2S_Pos)                 /*!< 0x00000300 */
N#define TIM_CCMR1_CC2S            TIM_CCMR1_CC2S_Msk                            /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
N#define TIM_CCMR1_CC2S_0          (0x1UL << TIM_CCMR1_CC2S_Pos)                 /*!< 0x00000100 */
N#define TIM_CCMR1_CC2S_1          (0x2UL << TIM_CCMR1_CC2S_Pos)                 /*!< 0x00000200 */
N
N#define TIM_CCMR1_OC2FE_Pos       (10U)
N#define TIM_CCMR1_OC2FE_Msk       (0x1UL << TIM_CCMR1_OC2FE_Pos)                /*!< 0x00000400 */
N#define TIM_CCMR1_OC2FE           TIM_CCMR1_OC2FE_Msk                           /*!<Output Compare 2 Fast enable */
N
N#define TIM_CCMR1_OC2PE_Pos       (11U)
N#define TIM_CCMR1_OC2PE_Msk       (0x1UL << TIM_CCMR1_OC2PE_Pos)                /*!< 0x00000800 */
N#define TIM_CCMR1_OC2PE           TIM_CCMR1_OC2PE_Msk                           /*!<Output Compare 2 Preload enable */
N
N#define TIM_CCMR1_OC2M_Pos        (12U)
N#define TIM_CCMR1_OC2M_Msk        (0x7UL << TIM_CCMR1_OC2M_Pos)                 /*!< 0x00007000 */
N#define TIM_CCMR1_OC2M            TIM_CCMR1_OC2M_Msk                            /*!<OC2M[2:0] bits (Output Compare 2 Mode) */
N#define TIM_CCMR1_OC2M_0          (0x1UL << TIM_CCMR1_OC2M_Pos)                 /*!< 0x00001000 */
N#define TIM_CCMR1_OC2M_1          (0x2UL << TIM_CCMR1_OC2M_Pos)                 /*!< 0x00002000 */
N#define TIM_CCMR1_OC2M_2          (0x4UL << TIM_CCMR1_OC2M_Pos)                 /*!< 0x00004000 */
N
N#define TIM_CCMR1_OC2CE_Pos       (15U)
N#define TIM_CCMR1_OC2CE_Msk       (0x1UL << TIM_CCMR1_OC2CE_Pos)                /*!< 0x00008000 */
N#define TIM_CCMR1_OC2CE           TIM_CCMR1_OC2CE_Msk                           /*!<Output Compare 2 Clear Enable */
N
N/*---------------------------------------------------------------------------*/
N
N#define TIM_CCMR1_IC1PSC_Pos      (2U)
N#define TIM_CCMR1_IC1PSC_Msk      (0x3UL << TIM_CCMR1_IC1PSC_Pos)               /*!< 0x0000000C */
N#define TIM_CCMR1_IC1PSC          TIM_CCMR1_IC1PSC_Msk                          /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
N#define TIM_CCMR1_IC1PSC_0        (0x1UL << TIM_CCMR1_IC1PSC_Pos)               /*!< 0x00000004 */
N#define TIM_CCMR1_IC1PSC_1        (0x2UL << TIM_CCMR1_IC1PSC_Pos)               /*!< 0x00000008 */
N
N#define TIM_CCMR1_IC1F_Pos        (4U)
N#define TIM_CCMR1_IC1F_Msk        (0xFUL << TIM_CCMR1_IC1F_Pos)                 /*!< 0x000000F0 */
N#define TIM_CCMR1_IC1F            TIM_CCMR1_IC1F_Msk                            /*!<IC1F[3:0] bits (Input Capture 1 Filter) */
N#define TIM_CCMR1_IC1F_0          (0x1UL << TIM_CCMR1_IC1F_Pos)                 /*!< 0x00000010 */
N#define TIM_CCMR1_IC1F_1          (0x2UL << TIM_CCMR1_IC1F_Pos)                 /*!< 0x00000020 */
N#define TIM_CCMR1_IC1F_2          (0x4UL << TIM_CCMR1_IC1F_Pos)                 /*!< 0x00000040 */
N#define TIM_CCMR1_IC1F_3          (0x8UL << TIM_CCMR1_IC1F_Pos)                 /*!< 0x00000080 */
N
N#define TIM_CCMR1_IC2PSC_Pos      (10U)
N#define TIM_CCMR1_IC2PSC_Msk      (0x3UL << TIM_CCMR1_IC2PSC_Pos)               /*!< 0x00000C00 */
N#define TIM_CCMR1_IC2PSC          TIM_CCMR1_IC2PSC_Msk                          /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
N#define TIM_CCMR1_IC2PSC_0        (0x1UL << TIM_CCMR1_IC2PSC_Pos)               /*!< 0x00000400 */
N#define TIM_CCMR1_IC2PSC_1        (0x2UL << TIM_CCMR1_IC2PSC_Pos)               /*!< 0x00000800 */
N
N#define TIM_CCMR1_IC2F_Pos        (12U)
N#define TIM_CCMR1_IC2F_Msk        (0xFUL << TIM_CCMR1_IC2F_Pos)                 /*!< 0x0000F000 */
N#define TIM_CCMR1_IC2F            TIM_CCMR1_IC2F_Msk                            /*!<IC2F[3:0] bits (Input Capture 2 Filter) */
N#define TIM_CCMR1_IC2F_0          (0x1UL << TIM_CCMR1_IC2F_Pos)                 /*!< 0x00001000 */
N#define TIM_CCMR1_IC2F_1          (0x2UL << TIM_CCMR1_IC2F_Pos)                 /*!< 0x00002000 */
N#define TIM_CCMR1_IC2F_2          (0x4UL << TIM_CCMR1_IC2F_Pos)                 /*!< 0x00004000 */
N#define TIM_CCMR1_IC2F_3          (0x8UL << TIM_CCMR1_IC2F_Pos)                 /*!< 0x00008000 */
N
N/******************  Bit definition for TIM_CCMR2 register  ******************/
N#define TIM_CCMR2_CC3S_Pos        (0U)
N#define TIM_CCMR2_CC3S_Msk        (0x3UL << TIM_CCMR2_CC3S_Pos)                 /*!< 0x00000003 */
N#define TIM_CCMR2_CC3S            TIM_CCMR2_CC3S_Msk                            /*!<CC3S[1:0] bits (Capture/Compare 3 Selection) */
N#define TIM_CCMR2_CC3S_0          (0x1UL << TIM_CCMR2_CC3S_Pos)                 /*!< 0x00000001 */
N#define TIM_CCMR2_CC3S_1          (0x2UL << TIM_CCMR2_CC3S_Pos)                 /*!< 0x00000002 */
N
N#define TIM_CCMR2_OC3FE_Pos       (2U)
N#define TIM_CCMR2_OC3FE_Msk       (0x1UL << TIM_CCMR2_OC3FE_Pos)                /*!< 0x00000004 */
N#define TIM_CCMR2_OC3FE           TIM_CCMR2_OC3FE_Msk                           /*!<Output Compare 3 Fast enable */
N#define TIM_CCMR2_OC3PE_Pos       (3U)
N#define TIM_CCMR2_OC3PE_Msk       (0x1UL << TIM_CCMR2_OC3PE_Pos)                /*!< 0x00000008 */
N#define TIM_CCMR2_OC3PE           TIM_CCMR2_OC3PE_Msk                           /*!<Output Compare 3 Preload enable */
N
N#define TIM_CCMR2_OC3M_Pos        (4U)
N#define TIM_CCMR2_OC3M_Msk        (0x7UL << TIM_CCMR2_OC3M_Pos)                 /*!< 0x00000070 */
N#define TIM_CCMR2_OC3M            TIM_CCMR2_OC3M_Msk                            /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
N#define TIM_CCMR2_OC3M_0          (0x1UL << TIM_CCMR2_OC3M_Pos)                 /*!< 0x00000010 */
N#define TIM_CCMR2_OC3M_1          (0x2UL << TIM_CCMR2_OC3M_Pos)                 /*!< 0x00000020 */
N#define TIM_CCMR2_OC3M_2          (0x4UL << TIM_CCMR2_OC3M_Pos)                 /*!< 0x00000040 */
N
N#define TIM_CCMR2_OC3CE_Pos       (7U)
N#define TIM_CCMR2_OC3CE_Msk       (0x1UL << TIM_CCMR2_OC3CE_Pos)                /*!< 0x00000080 */
N#define TIM_CCMR2_OC3CE           TIM_CCMR2_OC3CE_Msk                           /*!<Output Compare 3 Clear Enable */
N
N#define TIM_CCMR2_CC4S_Pos        (8U)
N#define TIM_CCMR2_CC4S_Msk        (0x3UL << TIM_CCMR2_CC4S_Pos)                 /*!< 0x00000300 */
N#define TIM_CCMR2_CC4S            TIM_CCMR2_CC4S_Msk                            /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
N#define TIM_CCMR2_CC4S_0          (0x1UL << TIM_CCMR2_CC4S_Pos)                 /*!< 0x00000100 */
N#define TIM_CCMR2_CC4S_1          (0x2UL << TIM_CCMR2_CC4S_Pos)                 /*!< 0x00000200 */
N
N#define TIM_CCMR2_OC4FE_Pos       (10U)
N#define TIM_CCMR2_OC4FE_Msk       (0x1UL << TIM_CCMR2_OC4FE_Pos)                /*!< 0x00000400 */
N#define TIM_CCMR2_OC4FE           TIM_CCMR2_OC4FE_Msk                           /*!<Output Compare 4 Fast enable */
N#define TIM_CCMR2_OC4PE_Pos       (11U)
N#define TIM_CCMR2_OC4PE_Msk       (0x1UL << TIM_CCMR2_OC4PE_Pos)                /*!< 0x00000800 */
N#define TIM_CCMR2_OC4PE           TIM_CCMR2_OC4PE_Msk                           /*!<Output Compare 4 Preload enable */
N
N#define TIM_CCMR2_OC4M_Pos        (12U)
N#define TIM_CCMR2_OC4M_Msk        (0x7UL << TIM_CCMR2_OC4M_Pos)                 /*!< 0x00007000 */
N#define TIM_CCMR2_OC4M            TIM_CCMR2_OC4M_Msk                            /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
N#define TIM_CCMR2_OC4M_0          (0x1UL << TIM_CCMR2_OC4M_Pos)                 /*!< 0x00001000 */
N#define TIM_CCMR2_OC4M_1          (0x2UL << TIM_CCMR2_OC4M_Pos)                 /*!< 0x00002000 */
N#define TIM_CCMR2_OC4M_2          (0x4UL << TIM_CCMR2_OC4M_Pos)                 /*!< 0x00004000 */
N
N#define TIM_CCMR2_OC4CE_Pos       (15U)
N#define TIM_CCMR2_OC4CE_Msk       (0x1UL << TIM_CCMR2_OC4CE_Pos)                /*!< 0x00008000 */
N#define TIM_CCMR2_OC4CE           TIM_CCMR2_OC4CE_Msk                           /*!<Output Compare 4 Clear Enable */
N
N/*---------------------------------------------------------------------------*/
N#define TIM_CCMR2_IC3PSC_Pos      (2U)
N#define TIM_CCMR2_IC3PSC_Msk      (0x3UL << TIM_CCMR2_IC3PSC_Pos)               /*!< 0x0000000C */
N#define TIM_CCMR2_IC3PSC          TIM_CCMR2_IC3PSC_Msk                          /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
N#define TIM_CCMR2_IC3PSC_0        (0x1UL << TIM_CCMR2_IC3PSC_Pos)               /*!< 0x00000004 */
N#define TIM_CCMR2_IC3PSC_1        (0x2UL << TIM_CCMR2_IC3PSC_Pos)               /*!< 0x00000008 */
N
N#define TIM_CCMR2_IC3F_Pos        (4U)
N#define TIM_CCMR2_IC3F_Msk        (0xFUL << TIM_CCMR2_IC3F_Pos)                 /*!< 0x000000F0 */
N#define TIM_CCMR2_IC3F            TIM_CCMR2_IC3F_Msk                            /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
N#define TIM_CCMR2_IC3F_0          (0x1UL << TIM_CCMR2_IC3F_Pos)                 /*!< 0x00000010 */
N#define TIM_CCMR2_IC3F_1          (0x2UL << TIM_CCMR2_IC3F_Pos)                 /*!< 0x00000020 */
N#define TIM_CCMR2_IC3F_2          (0x4UL << TIM_CCMR2_IC3F_Pos)                 /*!< 0x00000040 */
N#define TIM_CCMR2_IC3F_3          (0x8UL << TIM_CCMR2_IC3F_Pos)                 /*!< 0x00000080 */
N
N#define TIM_CCMR2_IC4PSC_Pos      (10U)
N#define TIM_CCMR2_IC4PSC_Msk      (0x3UL << TIM_CCMR2_IC4PSC_Pos)               /*!< 0x00000C00 */
N#define TIM_CCMR2_IC4PSC          TIM_CCMR2_IC4PSC_Msk                          /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
N#define TIM_CCMR2_IC4PSC_0        (0x1UL << TIM_CCMR2_IC4PSC_Pos)               /*!< 0x00000400 */
N#define TIM_CCMR2_IC4PSC_1        (0x2UL << TIM_CCMR2_IC4PSC_Pos)               /*!< 0x00000800 */
N
N#define TIM_CCMR2_IC4F_Pos        (12U)
N#define TIM_CCMR2_IC4F_Msk        (0xFUL << TIM_CCMR2_IC4F_Pos)                 /*!< 0x0000F000 */
N#define TIM_CCMR2_IC4F            TIM_CCMR2_IC4F_Msk                            /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
N#define TIM_CCMR2_IC4F_0          (0x1UL << TIM_CCMR2_IC4F_Pos)                 /*!< 0x00001000 */
N#define TIM_CCMR2_IC4F_1          (0x2UL << TIM_CCMR2_IC4F_Pos)                 /*!< 0x00002000 */
N#define TIM_CCMR2_IC4F_2          (0x4UL << TIM_CCMR2_IC4F_Pos)                 /*!< 0x00004000 */
N#define TIM_CCMR2_IC4F_3          (0x8UL << TIM_CCMR2_IC4F_Pos)                 /*!< 0x00008000 */
N
N/*******************  Bit definition for TIM_CCER register  ******************/
N#define TIM_CCER_CC1E_Pos         (0U)
N#define TIM_CCER_CC1E_Msk         (0x1UL << TIM_CCER_CC1E_Pos)                  /*!< 0x00000001 */
N#define TIM_CCER_CC1E             TIM_CCER_CC1E_Msk                             /*!<Capture/Compare 1 output enable */
N
N#define TIM_CCER_CC1P_Pos         (1U)
N#define TIM_CCER_CC1P_Msk         (0x1UL << TIM_CCER_CC1P_Pos)                  /*!< 0x00000002 */
N#define TIM_CCER_CC1P             TIM_CCER_CC1P_Msk                             /*!<Capture/Compare 1 output Polarity */
N
N#define TIM_CCER_CC1NE_Pos        (2U)
N#define TIM_CCER_CC1NE_Msk        (0x1UL << TIM_CCER_CC1NE_Pos)                 /*!< 0x00000004 */
N#define TIM_CCER_CC1NE            TIM_CCER_CC1NE_Msk                            /*!<Capture/Compare 1 Complementary output enable */
N
N#define TIM_CCER_CC1NP_Pos        (3U)
N#define TIM_CCER_CC1NP_Msk        (0x1UL << TIM_CCER_CC1NP_Pos)                 /*!< 0x00000008 */
N#define TIM_CCER_CC1NP            TIM_CCER_CC1NP_Msk                            /*!<Capture/Compare 1 Complementary output Polarity */
N
N#define TIM_CCER_CC2E_Pos         (4U)
N#define TIM_CCER_CC2E_Msk         (0x1UL << TIM_CCER_CC2E_Pos)                  /*!< 0x00000010 */
N#define TIM_CCER_CC2E             TIM_CCER_CC2E_Msk                             /*!<Capture/Compare 2 output enable */
N
N#define TIM_CCER_CC2P_Pos         (5U)
N#define TIM_CCER_CC2P_Msk         (0x1UL << TIM_CCER_CC2P_Pos)                  /*!< 0x00000020 */
N#define TIM_CCER_CC2P             TIM_CCER_CC2P_Msk                             /*!<Capture/Compare 2 output Polarity */
N
N#define TIM_CCER_CC2NE_Pos        (6U)
N#define TIM_CCER_CC2NE_Msk        (0x1UL << TIM_CCER_CC2NE_Pos)                 /*!< 0x00000040 */
N#define TIM_CCER_CC2NE            TIM_CCER_CC2NE_Msk                            /*!<Capture/Compare 2 Complementary output enable */
N
N#define TIM_CCER_CC2NP_Pos        (7U)
N#define TIM_CCER_CC2NP_Msk        (0x1UL << TIM_CCER_CC2NP_Pos)                 /*!< 0x00000080 */
N#define TIM_CCER_CC2NP            TIM_CCER_CC2NP_Msk                            /*!<Capture/Compare 2 Complementary output Polarity */
N
N#define TIM_CCER_CC3E_Pos         (8U)
N#define TIM_CCER_CC3E_Msk         (0x1UL << TIM_CCER_CC3E_Pos)                  /*!< 0x00000100 */
N#define TIM_CCER_CC3E             TIM_CCER_CC3E_Msk                             /*!<Capture/Compare 3 output enable */
N
N#define TIM_CCER_CC3P_Pos         (9U)
N#define TIM_CCER_CC3P_Msk         (0x1UL << TIM_CCER_CC3P_Pos)                  /*!< 0x00000200 */
N#define TIM_CCER_CC3P             TIM_CCER_CC3P_Msk                             /*!<Capture/Compare 3 output Polarity */
N
N#define TIM_CCER_CC3NE_Pos        (10U)
N#define TIM_CCER_CC3NE_Msk        (0x1UL << TIM_CCER_CC3NE_Pos)                 /*!< 0x00000400 */
N#define TIM_CCER_CC3NE            TIM_CCER_CC3NE_Msk                            /*!<Capture/Compare 3 Complementary output enable */
N
N#define TIM_CCER_CC3NP_Pos        (11U)
N#define TIM_CCER_CC3NP_Msk        (0x1UL << TIM_CCER_CC3NP_Pos)                 /*!< 0x00000800 */
N#define TIM_CCER_CC3NP            TIM_CCER_CC3NP_Msk                            /*!<Capture/Compare 3 Complementary output Polarity */
N
N#define TIM_CCER_CC4E_Pos         (12U)
N#define TIM_CCER_CC4E_Msk         (0x1UL << TIM_CCER_CC4E_Pos)                  /*!< 0x00001000 */
N#define TIM_CCER_CC4E             TIM_CCER_CC4E_Msk                             /*!<Capture/Compare 4 output enable */
N
N#define TIM_CCER_CC4P_Pos         (13U)
N#define TIM_CCER_CC4P_Msk         (0x1UL << TIM_CCER_CC4P_Pos)                  /*!< 0x00002000 */
N#define TIM_CCER_CC4P             TIM_CCER_CC4P_Msk                             /*!<Capture/Compare 4 output Polarity */
N
N#define TIM_CCER_CC4NP_Pos        (15U)
N#define TIM_CCER_CC4NP_Msk        (0x1UL << TIM_CCER_CC4NP_Pos)                 /*!< 0x00008000 */
N#define TIM_CCER_CC4NP            TIM_CCER_CC4NP_Msk                            /*!<Capture/Compare 4 Complementary output Polarity */
N
N/*******************  Bit definition for TIM_CNT register  *******************/
N#define TIM_CNT_CNT_Pos           (0U)
N#define TIM_CNT_CNT_Msk           (0xFFFFFFFFUL << TIM_CNT_CNT_Pos)             /*!< 0xFFFFFFFF */
N#define TIM_CNT_CNT               TIM_CNT_CNT_Msk                               /*!<Counter Value */
N
N/*******************  Bit definition for TIM_PSC register  *******************/
N#define TIM_PSC_PSC_Pos           (0U)
N#define TIM_PSC_PSC_Msk           (0xFFFFUL << TIM_PSC_PSC_Pos)                 /*!< 0x0000FFFF */
N#define TIM_PSC_PSC               TIM_PSC_PSC_Msk                               /*!<Prescaler Value */
N
N/*******************  Bit definition for TIM_ARR register  *******************/
N#define TIM_ARR_ARR_Pos           (0U)
N#define TIM_ARR_ARR_Msk           (0xFFFFFFFFUL << TIM_ARR_ARR_Pos)             /*!< 0xFFFFFFFF */
N#define TIM_ARR_ARR               TIM_ARR_ARR_Msk                               /*!<actual auto-reload Value */
N
N/*******************  Bit definition for TIM_RCR register  *******************/
N#define TIM_RCR_REP_Pos           (0U)
N#define TIM_RCR_REP_Msk           (0xFFUL << TIM_RCR_REP_Pos)                   /*!< 0x000000FF */
N#define TIM_RCR_REP               TIM_RCR_REP_Msk                               /*!<Repetition Counter Value */
N
N/*******************  Bit definition for TIM_CCR1 register  ******************/
N#define TIM_CCR1_CCR1_Pos         (0U)
N#define TIM_CCR1_CCR1_Msk         (0xFFFFUL << TIM_CCR1_CCR1_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR1_CCR1             TIM_CCR1_CCR1_Msk                             /*!<Capture/Compare 1 Value */
N
N/*******************  Bit definition for TIM_CCR2 register  ******************/
N#define TIM_CCR2_CCR2_Pos         (0U)
N#define TIM_CCR2_CCR2_Msk         (0xFFFFUL << TIM_CCR2_CCR2_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR2_CCR2             TIM_CCR2_CCR2_Msk                             /*!<Capture/Compare 2 Value */
N
N/*******************  Bit definition for TIM_CCR3 register  ******************/
N#define TIM_CCR3_CCR3_Pos         (0U)
N#define TIM_CCR3_CCR3_Msk         (0xFFFFUL << TIM_CCR3_CCR3_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR3_CCR3             TIM_CCR3_CCR3_Msk                             /*!<Capture/Compare 3 Value */
N
N/*******************  Bit definition for TIM_CCR4 register  ******************/
N#define TIM_CCR4_CCR4_Pos         (0U)
N#define TIM_CCR4_CCR4_Msk         (0xFFFFUL << TIM_CCR4_CCR4_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR4_CCR4             TIM_CCR4_CCR4_Msk                             /*!<Capture/Compare 4 Value */
N
N/*******************  Bit definition for TIM_BDTR register  ******************/
N#define TIM_BDTR_DTG_Pos          (0U)
N#define TIM_BDTR_DTG_Msk          (0xFFUL << TIM_BDTR_DTG_Pos)                  /*!< 0x000000FF */
N#define TIM_BDTR_DTG              TIM_BDTR_DTG_Msk                              /*!<DTG[0:7] bits (Dead-Time Generator set-up) */
N#define TIM_BDTR_DTG_0            (0x01UL << TIM_BDTR_DTG_Pos)                  /*!< 0x00000001 */
N#define TIM_BDTR_DTG_1            (0x02UL << TIM_BDTR_DTG_Pos)                  /*!< 0x00000002 */
N#define TIM_BDTR_DTG_2            (0x04UL << TIM_BDTR_DTG_Pos)                  /*!< 0x00000004 */
N#define TIM_BDTR_DTG_3            (0x08UL << TIM_BDTR_DTG_Pos)                  /*!< 0x00000008 */
N#define TIM_BDTR_DTG_4            (0x10UL << TIM_BDTR_DTG_Pos)                  /*!< 0x00000010 */
N#define TIM_BDTR_DTG_5            (0x20UL << TIM_BDTR_DTG_Pos)                  /*!< 0x00000020 */
N#define TIM_BDTR_DTG_6            (0x40UL << TIM_BDTR_DTG_Pos)                  /*!< 0x00000040 */
N#define TIM_BDTR_DTG_7            (0x80UL << TIM_BDTR_DTG_Pos)                  /*!< 0x00000080 */
N
N#define TIM_BDTR_LOCK_Pos         (8U)
N#define TIM_BDTR_LOCK_Msk         (0x3UL << TIM_BDTR_LOCK_Pos)                  /*!< 0x00000300 */
N#define TIM_BDTR_LOCK             TIM_BDTR_LOCK_Msk                             /*!<LOCK[1:0] bits (Lock Configuration) */
N#define TIM_BDTR_LOCK_0           (0x1UL << TIM_BDTR_LOCK_Pos)                  /*!< 0x00000100 */
N#define TIM_BDTR_LOCK_1           (0x2UL << TIM_BDTR_LOCK_Pos)                  /*!< 0x00000200 */
N
N#define TIM_BDTR_OSSI_Pos         (10U)
N#define TIM_BDTR_OSSI_Msk         (0x1UL << TIM_BDTR_OSSI_Pos)                  /*!< 0x00000400 */
N#define TIM_BDTR_OSSI             TIM_BDTR_OSSI_Msk                             /*!<Off-State Selection for Idle mode */
N
N#define TIM_BDTR_OSSR_Pos         (11U)
N#define TIM_BDTR_OSSR_Msk         (0x1UL << TIM_BDTR_OSSR_Pos)                  /*!< 0x00000800 */
N#define TIM_BDTR_OSSR             TIM_BDTR_OSSR_Msk                             /*!<Off-State Selection for Run mode */
N
N#define TIM_BDTR_BKE_Pos          (12U)
N#define TIM_BDTR_BKE_Msk          (0x1UL << TIM_BDTR_BKE_Pos)                   /*!< 0x00001000 */
N#define TIM_BDTR_BKE              TIM_BDTR_BKE_Msk                              /*!<Break enable */
N
N#define TIM_BDTR_BKP_Pos          (13U)
N#define TIM_BDTR_BKP_Msk          (0x1UL << TIM_BDTR_BKP_Pos)                   /*!< 0x00002000 */
N#define TIM_BDTR_BKP              TIM_BDTR_BKP_Msk                              /*!<Break Polarity */
N
N#define TIM_BDTR_AOE_Pos          (14U)
N#define TIM_BDTR_AOE_Msk          (0x1UL << TIM_BDTR_AOE_Pos)                   /*!< 0x00004000 */
N#define TIM_BDTR_AOE              TIM_BDTR_AOE_Msk                              /*!<Automatic Output enable */
N
N#define TIM_BDTR_MOE_Pos          (15U)
N#define TIM_BDTR_MOE_Msk          (0x1UL << TIM_BDTR_MOE_Pos)                   /*!< 0x00008000 */
N#define TIM_BDTR_MOE              TIM_BDTR_MOE_Msk                              /*!<Main Output enable */
N
N/*******************  Bit definition for TIM_DCR register  *******************/
N#define TIM_DCR_DBA_Pos           (0U)
N#define TIM_DCR_DBA_Msk           (0x1FUL << TIM_DCR_DBA_Pos)                   /*!< 0x0000001F */
N#define TIM_DCR_DBA               TIM_DCR_DBA_Msk                               /*!<DBA[4:0] bits (DMA Base Address) */
N#define TIM_DCR_DBA_0             (0x01UL << TIM_DCR_DBA_Pos)                   /*!< 0x00000001 */
N#define TIM_DCR_DBA_1             (0x02UL << TIM_DCR_DBA_Pos)                   /*!< 0x00000002 */
N#define TIM_DCR_DBA_2             (0x04UL << TIM_DCR_DBA_Pos)                   /*!< 0x00000004 */
N#define TIM_DCR_DBA_3             (0x08UL << TIM_DCR_DBA_Pos)                   /*!< 0x00000008 */
N#define TIM_DCR_DBA_4             (0x10UL << TIM_DCR_DBA_Pos)                   /*!< 0x00000010 */
N
N#define TIM_DCR_DBL_Pos           (8U)
N#define TIM_DCR_DBL_Msk           (0x1FUL << TIM_DCR_DBL_Pos)                   /*!< 0x00001F00 */
N#define TIM_DCR_DBL               TIM_DCR_DBL_Msk                               /*!<DBL[4:0] bits (DMA Burst Length) */
N#define TIM_DCR_DBL_0             (0x01UL << TIM_DCR_DBL_Pos)                   /*!< 0x00000100 */
N#define TIM_DCR_DBL_1             (0x02UL << TIM_DCR_DBL_Pos)                   /*!< 0x00000200 */
N#define TIM_DCR_DBL_2             (0x04UL << TIM_DCR_DBL_Pos)                   /*!< 0x00000400 */
N#define TIM_DCR_DBL_3             (0x08UL << TIM_DCR_DBL_Pos)                   /*!< 0x00000800 */
N#define TIM_DCR_DBL_4             (0x10UL << TIM_DCR_DBL_Pos)                   /*!< 0x00001000 */
N
N/*******************  Bit definition for TIM_DMAR register  ******************/
N#define TIM_DMAR_DMAB_Pos         (0U)
N#define TIM_DMAR_DMAB_Msk         (0xFFFFUL << TIM_DMAR_DMAB_Pos)               /*!< 0x0000FFFF */
N#define TIM_DMAR_DMAB             TIM_DMAR_DMAB_Msk                             /*!<DMA register for burst accesses */
N
N/*******************  Bit definition for TIM14_OR register  ********************/
N#define TIM14_OR_TI1_RMP_Pos      (0U)
N#define TIM14_OR_TI1_RMP_Msk      (0x3UL << TIM14_OR_TI1_RMP_Pos)               /*!< 0x00000003 */
N#define TIM14_OR_TI1_RMP          TIM14_OR_TI1_RMP_Msk                          /*!<TI1_RMP[1:0] bits (TIM14 Input 4 remap) */
N#define TIM14_OR_TI1_RMP_0        (0x1UL << TIM14_OR_TI1_RMP_Pos)               /*!< 0x00000001 */
N#define TIM14_OR_TI1_RMP_1        (0x2UL << TIM14_OR_TI1_RMP_Pos)               /*!< 0x00000002 */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*      Universal Synchronous Asynchronous Receiver Transmitter (USART)       */
N/*                                                                            */
N/******************************************************************************/
N/* Support of LIN feature */
N#define USART_LIN_SUPPORT
N
N/* Support of Smartcard feature */
N#define USART_SMARTCARD_SUPPORT
N
N/* Support of Irda feature */
N#define USART_IRDA_SUPPORT
N
N/* Support of Wake Up from Stop Mode feature */
N#define USART_WUSM_SUPPORT
N
N/******************  Bit definition for USART_CR1 register  *******************/
N#define USART_CR1_UE_Pos              (0U)
N#define USART_CR1_UE_Msk              (0x1UL << USART_CR1_UE_Pos)               /*!< 0x00000001 */
N#define USART_CR1_UE                  USART_CR1_UE_Msk                          /*!< USART Enable */
N
N#define USART_CR1_UESM_Pos            (1U)
N#define USART_CR1_UESM_Msk            (0x1UL << USART_CR1_UESM_Pos)             /*!< 0x00000002 */
N#define USART_CR1_UESM                USART_CR1_UESM_Msk                        /*!< USART Enable in STOP Mode */
N
N#define USART_CR1_RE_Pos              (2U)
N#define USART_CR1_RE_Msk              (0x1UL << USART_CR1_RE_Pos)               /*!< 0x00000004 */
N#define USART_CR1_RE                  USART_CR1_RE_Msk                          /*!< Receiver Enable */
N
N#define USART_CR1_TE_Pos              (3U)
N#define USART_CR1_TE_Msk              (0x1UL << USART_CR1_TE_Pos)               /*!< 0x00000008 */
N#define USART_CR1_TE                  USART_CR1_TE_Msk                          /*!< Transmitter Enable */
N
N#define USART_CR1_IDLEIE_Pos          (4U)
N#define USART_CR1_IDLEIE_Msk          (0x1UL << USART_CR1_IDLEIE_Pos)           /*!< 0x00000010 */
N#define USART_CR1_IDLEIE              USART_CR1_IDLEIE_Msk                      /*!< IDLE Interrupt Enable */
N
N#define USART_CR1_RXNEIE_Pos          (5U)
N#define USART_CR1_RXNEIE_Msk          (0x1UL << USART_CR1_RXNEIE_Pos)           /*!< 0x00000020 */
N#define USART_CR1_RXNEIE              USART_CR1_RXNEIE_Msk                      /*!< RXNE Interrupt Enable */
N
N#define USART_CR1_TCIE_Pos            (6U)
N#define USART_CR1_TCIE_Msk            (0x1UL << USART_CR1_TCIE_Pos)             /*!< 0x00000040 */
N#define USART_CR1_TCIE                USART_CR1_TCIE_Msk                        /*!< Transmission Complete Interrupt Enable */
N
N#define USART_CR1_TXEIE_Pos           (7U)
N#define USART_CR1_TXEIE_Msk           (0x1UL << USART_CR1_TXEIE_Pos)            /*!< 0x00000080 */
N#define USART_CR1_TXEIE               USART_CR1_TXEIE_Msk                       /*!< TXE Interrupt Enable */
N
N#define USART_CR1_PEIE_Pos            (8U)
N#define USART_CR1_PEIE_Msk            (0x1UL << USART_CR1_PEIE_Pos)             /*!< 0x00000100 */
N#define USART_CR1_PEIE                USART_CR1_PEIE_Msk                        /*!< PE Interrupt Enable */
N
N#define USART_CR1_PS_Pos              (9U)
N#define USART_CR1_PS_Msk              (0x1UL << USART_CR1_PS_Pos)               /*!< 0x00000200 */
N#define USART_CR1_PS                  USART_CR1_PS_Msk                          /*!< Parity Selection */
N
N#define USART_CR1_PCE_Pos             (10U)
N#define USART_CR1_PCE_Msk             (0x1UL << USART_CR1_PCE_Pos)              /*!< 0x00000400 */
N#define USART_CR1_PCE                 USART_CR1_PCE_Msk                         /*!< Parity Control Enable */
N
N#define USART_CR1_WAKE_Pos            (11U)
N#define USART_CR1_WAKE_Msk            (0x1UL << USART_CR1_WAKE_Pos)             /*!< 0x00000800 */
N#define USART_CR1_WAKE                USART_CR1_WAKE_Msk                        /*!< Receiver Wakeup method */
N
N#define USART_CR1_M_Pos               (12U)
N#define USART_CR1_M_Msk               (0x1UL << USART_CR1_M_Pos)                /*!< 0x00001000 */
N#define USART_CR1_M                   USART_CR1_M_Msk                           /*!< Word Length */
N
N#define USART_CR1_MME_Pos             (13U)
N#define USART_CR1_MME_Msk             (0x1UL << USART_CR1_MME_Pos)              /*!< 0x00002000 */
N#define USART_CR1_MME                 USART_CR1_MME_Msk                         /*!< Mute Mode Enable */
N
N#define USART_CR1_CMIE_Pos            (14U)
N#define USART_CR1_CMIE_Msk            (0x1UL << USART_CR1_CMIE_Pos)             /*!< 0x00004000 */
N#define USART_CR1_CMIE                USART_CR1_CMIE_Msk                        /*!< Character match interrupt enable */
N
N#define USART_CR1_OVER8_Pos           (15U)
N#define USART_CR1_OVER8_Msk           (0x1UL << USART_CR1_OVER8_Pos)            /*!< 0x00008000 */
N#define USART_CR1_OVER8               USART_CR1_OVER8_Msk                       /*!< Oversampling by 8-bit or 16-bit mode */
N
N#define USART_CR1_DEDT_Pos            (16U)
N#define USART_CR1_DEDT_Msk            (0x1FUL << USART_CR1_DEDT_Pos)            /*!< 0x001F0000 */
N#define USART_CR1_DEDT                USART_CR1_DEDT_Msk                        /*!< DEDT[4:0] bits (Driver Enable Deassertion Time) */
N#define USART_CR1_DEDT_0              (0x01UL << USART_CR1_DEDT_Pos)            /*!< 0x00010000 */
N#define USART_CR1_DEDT_1              (0x02UL << USART_CR1_DEDT_Pos)            /*!< 0x00020000 */
N#define USART_CR1_DEDT_2              (0x04UL << USART_CR1_DEDT_Pos)            /*!< 0x00040000 */
N#define USART_CR1_DEDT_3              (0x08UL << USART_CR1_DEDT_Pos)            /*!< 0x00080000 */
N#define USART_CR1_DEDT_4              (0x10UL << USART_CR1_DEDT_Pos)            /*!< 0x00100000 */
N
N#define USART_CR1_DEAT_Pos            (21U)
N#define USART_CR1_DEAT_Msk            (0x1FUL << USART_CR1_DEAT_Pos)            /*!< 0x03E00000 */
N#define USART_CR1_DEAT                USART_CR1_DEAT_Msk                        /*!< DEAT[4:0] bits (Driver Enable Assertion Time) */
N#define USART_CR1_DEAT_0              (0x01UL << USART_CR1_DEAT_Pos)            /*!< 0x00200000 */
N#define USART_CR1_DEAT_1              (0x02UL << USART_CR1_DEAT_Pos)            /*!< 0x00400000 */
N#define USART_CR1_DEAT_2              (0x04UL << USART_CR1_DEAT_Pos)            /*!< 0x00800000 */
N#define USART_CR1_DEAT_3              (0x08UL << USART_CR1_DEAT_Pos)            /*!< 0x01000000 */
N#define USART_CR1_DEAT_4              (0x10UL << USART_CR1_DEAT_Pos)            /*!< 0x02000000 */
N
N#define USART_CR1_RTOIE_Pos           (26U)
N#define USART_CR1_RTOIE_Msk           (0x1UL << USART_CR1_RTOIE_Pos)            /*!< 0x04000000 */
N#define USART_CR1_RTOIE               USART_CR1_RTOIE_Msk                       /*!< Receive Time Out interrupt enable */
N
N#define USART_CR1_EOBIE_Pos           (27U)
N#define USART_CR1_EOBIE_Msk           (0x1UL << USART_CR1_EOBIE_Pos)            /*!< 0x08000000 */
N#define USART_CR1_EOBIE               USART_CR1_EOBIE_Msk                       /*!< End of Block interrupt enable */
N
N/******************  Bit definition for USART_CR2 register  *******************/
N#define USART_CR2_ADDM7_Pos           (4U)
N#define USART_CR2_ADDM7_Msk           (0x1UL << USART_CR2_ADDM7_Pos)            /*!< 0x00000010 */
N#define USART_CR2_ADDM7               USART_CR2_ADDM7_Msk                       /*!< 7-bit or 4-bit Address Detection */
N
N#define USART_CR2_LBDL_Pos            (5U)
N#define USART_CR2_LBDL_Msk            (0x1UL << USART_CR2_LBDL_Pos)             /*!< 0x00000020 */
N#define USART_CR2_LBDL                USART_CR2_LBDL_Msk                        /*!< LIN Break Detection Length */
N
N#define USART_CR2_LBDIE_Pos           (6U)
N#define USART_CR2_LBDIE_Msk           (0x1UL << USART_CR2_LBDIE_Pos)            /*!< 0x00000040 */
N#define USART_CR2_LBDIE               USART_CR2_LBDIE_Msk                       /*!< LIN Break Detection Interrupt Enable */
N
N#define USART_CR2_LBCL_Pos            (8U)
N#define USART_CR2_LBCL_Msk            (0x1UL << USART_CR2_LBCL_Pos)             /*!< 0x00000100 */
N#define USART_CR2_LBCL                USART_CR2_LBCL_Msk                        /*!< Last Bit Clock pulse */
N
N#define USART_CR2_CPHA_Pos            (9U)
N#define USART_CR2_CPHA_Msk            (0x1UL << USART_CR2_CPHA_Pos)             /*!< 0x00000200 */
N#define USART_CR2_CPHA                USART_CR2_CPHA_Msk                        /*!< Clock Phase */
N
N#define USART_CR2_CPOL_Pos            (10U)
N#define USART_CR2_CPOL_Msk            (0x1UL << USART_CR2_CPOL_Pos)             /*!< 0x00000400 */
N#define USART_CR2_CPOL                USART_CR2_CPOL_Msk                        /*!< Clock Polarity */
N
N#define USART_CR2_CLKEN_Pos           (11U)
N#define USART_CR2_CLKEN_Msk           (0x1UL << USART_CR2_CLKEN_Pos)            /*!< 0x00000800 */
N#define USART_CR2_CLKEN               USART_CR2_CLKEN_Msk                       /*!< Clock Enable */
N
N#define USART_CR2_STOP_Pos            (12U)
N#define USART_CR2_STOP_Msk            (0x3UL << USART_CR2_STOP_Pos)             /*!< 0x00003000 */
N#define USART_CR2_STOP                USART_CR2_STOP_Msk                        /*!< STOP[1:0] bits (STOP bits) */
N#define USART_CR2_STOP_0              (0x1UL << USART_CR2_STOP_Pos)             /*!< 0x00001000 */
N#define USART_CR2_STOP_1              (0x2UL << USART_CR2_STOP_Pos)             /*!< 0x00002000 */
N
N#define USART_CR2_LINEN_Pos           (14U)
N#define USART_CR2_LINEN_Msk           (0x1UL << USART_CR2_LINEN_Pos)            /*!< 0x00004000 */
N#define USART_CR2_LINEN               USART_CR2_LINEN_Msk                       /*!< LIN mode enable */
N
N#define USART_CR2_SWAP_Pos            (15U)
N#define USART_CR2_SWAP_Msk            (0x1UL << USART_CR2_SWAP_Pos)             /*!< 0x00008000 */
N#define USART_CR2_SWAP                USART_CR2_SWAP_Msk                        /*!< SWAP TX/RX pins */
N
N#define USART_CR2_RXINV_Pos           (16U)
N#define USART_CR2_RXINV_Msk           (0x1UL << USART_CR2_RXINV_Pos)            /*!< 0x00010000 */
N#define USART_CR2_RXINV               USART_CR2_RXINV_Msk                       /*!< RX pin active level inversion */
N
N#define USART_CR2_TXINV_Pos           (17U)
N#define USART_CR2_TXINV_Msk           (0x1UL << USART_CR2_TXINV_Pos)            /*!< 0x00020000 */
N#define USART_CR2_TXINV               USART_CR2_TXINV_Msk                       /*!< TX pin active level inversion */
N
N#define USART_CR2_DATAINV_Pos         (18U)
N#define USART_CR2_DATAINV_Msk         (0x1UL << USART_CR2_DATAINV_Pos)          /*!< 0x00040000 */
N#define USART_CR2_DATAINV             USART_CR2_DATAINV_Msk                     /*!< Binary data inversion */
N
N#define USART_CR2_MSBFIRST_Pos        (19U)
N#define USART_CR2_MSBFIRST_Msk        (0x1UL << USART_CR2_MSBFIRST_Pos)         /*!< 0x00080000 */
N#define USART_CR2_MSBFIRST            USART_CR2_MSBFIRST_Msk                    /*!< Most Significant Bit First */
N
N#define USART_CR2_ABREN_Pos           (20U)
N#define USART_CR2_ABREN_Msk           (0x1UL << USART_CR2_ABREN_Pos)            /*!< 0x00100000 */
N#define USART_CR2_ABREN               USART_CR2_ABREN_Msk                       /*!< Auto Baud-Rate Enable*/
N
N#define USART_CR2_ABRMODE_Pos         (21U)
N#define USART_CR2_ABRMODE_Msk         (0x3UL << USART_CR2_ABRMODE_Pos)          /*!< 0x00600000 */
N#define USART_CR2_ABRMODE             USART_CR2_ABRMODE_Msk                     /*!< ABRMOD[1:0] bits (Auto Baud-Rate Mode) */
N#define USART_CR2_ABRMODE_0           (0x1UL << USART_CR2_ABRMODE_Pos)          /*!< 0x00200000 */
N#define USART_CR2_ABRMODE_1           (0x2UL << USART_CR2_ABRMODE_Pos)          /*!< 0x00400000 */
N
N#define USART_CR2_RTOEN_Pos           (23U)
N#define USART_CR2_RTOEN_Msk           (0x1UL << USART_CR2_RTOEN_Pos)            /*!< 0x00800000 */
N#define USART_CR2_RTOEN               USART_CR2_RTOEN_Msk                       /*!< Receiver Time-Out enable */
N
N#define USART_CR2_ADD_Pos             (24U)
N#define USART_CR2_ADD_Msk             (0xFFUL << USART_CR2_ADD_Pos)             /*!< 0xFF000000 */
N#define USART_CR2_ADD                 USART_CR2_ADD_Msk                         /*!< Address of the USART node */
N
N/******************  Bit definition for USART_CR3 register  *******************/
N#define USART_CR3_EIE_Pos             (0U)
N#define USART_CR3_EIE_Msk             (0x1UL << USART_CR3_EIE_Pos)              /*!< 0x00000001 */
N#define USART_CR3_EIE                 USART_CR3_EIE_Msk                         /*!< Error Interrupt Enable */
N
N#define USART_CR3_IREN_Pos            (1U)
N#define USART_CR3_IREN_Msk            (0x1UL << USART_CR3_IREN_Pos)             /*!< 0x00000002 */
N#define USART_CR3_IREN                USART_CR3_IREN_Msk                        /*!< IrDA mode Enable */
N
N#define USART_CR3_IRLP_Pos            (2U)
N#define USART_CR3_IRLP_Msk            (0x1UL << USART_CR3_IRLP_Pos)             /*!< 0x00000004 */
N#define USART_CR3_IRLP                USART_CR3_IRLP_Msk                        /*!< IrDA Low-Power */
N
N#define USART_CR3_HDSEL_Pos           (3U)
N#define USART_CR3_HDSEL_Msk           (0x1UL << USART_CR3_HDSEL_Pos)            /*!< 0x00000008 */
N#define USART_CR3_HDSEL               USART_CR3_HDSEL_Msk                       /*!< Half-Duplex Selection */
N
N#define USART_CR3_NACK_Pos            (4U)
N#define USART_CR3_NACK_Msk            (0x1UL << USART_CR3_NACK_Pos)             /*!< 0x00000010 */
N#define USART_CR3_NACK                USART_CR3_NACK_Msk                        /*!< SmartCard NACK enable */
N
N#define USART_CR3_SCEN_Pos            (5U)
N#define USART_CR3_SCEN_Msk            (0x1UL << USART_CR3_SCEN_Pos)             /*!< 0x00000020 */
N#define USART_CR3_SCEN                USART_CR3_SCEN_Msk                        /*!< SmartCard mode enable */
N
N#define USART_CR3_DMAR_Pos            (6U)
N#define USART_CR3_DMAR_Msk            (0x1UL << USART_CR3_DMAR_Pos)             /*!< 0x00000040 */
N#define USART_CR3_DMAR                USART_CR3_DMAR_Msk                        /*!< DMA Enable Receiver */
N
N#define USART_CR3_DMAT_Pos            (7U)
N#define USART_CR3_DMAT_Msk            (0x1UL << USART_CR3_DMAT_Pos)             /*!< 0x00000080 */
N#define USART_CR3_DMAT                USART_CR3_DMAT_Msk                        /*!< DMA Enable Transmitter */
N
N#define USART_CR3_RTSE_Pos            (8U)
N#define USART_CR3_RTSE_Msk            (0x1UL << USART_CR3_RTSE_Pos)             /*!< 0x00000100 */
N#define USART_CR3_RTSE                USART_CR3_RTSE_Msk                        /*!< RTS Enable */
N
N#define USART_CR3_CTSE_Pos            (9U)
N#define USART_CR3_CTSE_Msk            (0x1UL << USART_CR3_CTSE_Pos)             /*!< 0x00000200 */
N#define USART_CR3_CTSE                USART_CR3_CTSE_Msk                        /*!< CTS Enable */
N
N#define USART_CR3_CTSIE_Pos           (10U)
N#define USART_CR3_CTSIE_Msk           (0x1UL << USART_CR3_CTSIE_Pos)            /*!< 0x00000400 */
N#define USART_CR3_CTSIE               USART_CR3_CTSIE_Msk                       /*!< CTS Interrupt Enable */
N
N#define USART_CR3_ONEBIT_Pos          (11U)
N#define USART_CR3_ONEBIT_Msk          (0x1UL << USART_CR3_ONEBIT_Pos)           /*!< 0x00000800 */
N#define USART_CR3_ONEBIT              USART_CR3_ONEBIT_Msk                      /*!< One sample bit method enable */
N
N#define USART_CR3_OVRDIS_Pos          (12U)
N#define USART_CR3_OVRDIS_Msk          (0x1UL << USART_CR3_OVRDIS_Pos)           /*!< 0x00001000 */
N#define USART_CR3_OVRDIS              USART_CR3_OVRDIS_Msk                      /*!< Overrun Disable */
N
N#define USART_CR3_DDRE_Pos            (13U)
N#define USART_CR3_DDRE_Msk            (0x1UL << USART_CR3_DDRE_Pos)             /*!< 0x00002000 */
N#define USART_CR3_DDRE                USART_CR3_DDRE_Msk                        /*!< DMA Disable on Reception Error */
N
N#define USART_CR3_DEM_Pos             (14U)
N#define USART_CR3_DEM_Msk             (0x1UL << USART_CR3_DEM_Pos)              /*!< 0x00004000 */
N#define USART_CR3_DEM                 USART_CR3_DEM_Msk                         /*!< Driver Enable Mode */
N
N#define USART_CR3_DEP_Pos             (15U)
N#define USART_CR3_DEP_Msk             (0x1UL << USART_CR3_DEP_Pos)              /*!< 0x00008000 */
N#define USART_CR3_DEP                 USART_CR3_DEP_Msk                         /*!< Driver Enable Polarity Selection */
N
N#define USART_CR3_SCARCNT_Pos         (17U)
N#define USART_CR3_SCARCNT_Msk         (0x7UL << USART_CR3_SCARCNT_Pos)          /*!< 0x000E0000 */
N#define USART_CR3_SCARCNT             USART_CR3_SCARCNT_Msk                     /*!< SCARCNT[2:0] bits (SmartCard Auto-Retry Count) */
N#define USART_CR3_SCARCNT_0           (0x1UL << USART_CR3_SCARCNT_Pos)          /*!< 0x00020000 */
N#define USART_CR3_SCARCNT_1           (0x2UL << USART_CR3_SCARCNT_Pos)          /*!< 0x00040000 */
N#define USART_CR3_SCARCNT_2           (0x4UL << USART_CR3_SCARCNT_Pos)          /*!< 0x00080000 */
N
N#define USART_CR3_WUS_Pos             (20U)
N#define USART_CR3_WUS_Msk             (0x3UL << USART_CR3_WUS_Pos)              /*!< 0x00300000 */
N#define USART_CR3_WUS                 USART_CR3_WUS_Msk                         /*!< WUS[1:0] bits (Wake UP Interrupt Flag Selection) */
N#define USART_CR3_WUS_0               (0x1UL << USART_CR3_WUS_Pos)              /*!< 0x00100000 */
N#define USART_CR3_WUS_1               (0x2UL << USART_CR3_WUS_Pos)              /*!< 0x00200000 */
N
N#define USART_CR3_WUFIE_Pos           (22U)
N#define USART_CR3_WUFIE_Msk           (0x1UL << USART_CR3_WUFIE_Pos)            /*!< 0x00400000 */
N#define USART_CR3_WUFIE               USART_CR3_WUFIE_Msk                       /*!< Wake Up Interrupt Enable */
N
N/******************  Bit definition for USART_BRR register  *******************/
N#define USART_BRR_DIV_FRACTION_Pos    (0U)
N#define USART_BRR_DIV_FRACTION_Msk    (0xFUL << USART_BRR_DIV_FRACTION_Pos)     /*!< 0x0000000F */
N#define USART_BRR_DIV_FRACTION        USART_BRR_DIV_FRACTION_Msk                /*!< Fraction of USARTDIV */
N
N#define USART_BRR_DIV_MANTISSA_Pos    (4U)
N#define USART_BRR_DIV_MANTISSA_Msk    (0xFFFUL << USART_BRR_DIV_MANTISSA_Pos)   /*!< 0x0000FFF0 */
N#define USART_BRR_DIV_MANTISSA        USART_BRR_DIV_MANTISSA_Msk                /*!< Mantissa of USARTDIV */
N
N/******************  Bit definition for USART_GTPR register  ******************/
N#define USART_GTPR_PSC_Pos            (0U)
N#define USART_GTPR_PSC_Msk            (0xFFUL << USART_GTPR_PSC_Pos)            /*!< 0x000000FF */
N#define USART_GTPR_PSC                USART_GTPR_PSC_Msk                        /*!< PSC[7:0] bits (Prescaler value) */
N#define USART_GTPR_GT_Pos             (8U)
N#define USART_GTPR_GT_Msk             (0xFFUL << USART_GTPR_GT_Pos)             /*!< 0x0000FF00 */
N#define USART_GTPR_GT                 USART_GTPR_GT_Msk                         /*!< GT[7:0] bits (Guard time value) */
N
N/*******************  Bit definition for USART_RTOR register  *****************/
N#define USART_RTOR_RTO_Pos            (0U)
N#define USART_RTOR_RTO_Msk            (0xFFFFFFUL << USART_RTOR_RTO_Pos)        /*!< 0x00FFFFFF */
N#define USART_RTOR_RTO                USART_RTOR_RTO_Msk                        /*!< Receiver Time Out Value */
N
N#define USART_RTOR_BLEN_Pos           (24U)
N#define USART_RTOR_BLEN_Msk           (0xFFUL << USART_RTOR_BLEN_Pos)           /*!< 0xFF000000 */
N#define USART_RTOR_BLEN               USART_RTOR_BLEN_Msk                       /*!< Block Length */
N
N/*******************  Bit definition for USART_RQR register  ******************/
N#define USART_RQR_ABRRQ_Pos           (0U)
N#define USART_RQR_ABRRQ_Msk           (0x1UL << USART_RQR_ABRRQ_Pos)            /*!< 0x00000001 */
N#define USART_RQR_ABRRQ               USART_RQR_ABRRQ_Msk                       /*!< Auto-Baud Rate Request */
N
N#define USART_RQR_SBKRQ_Pos           (1U)
N#define USART_RQR_SBKRQ_Msk           (0x1UL << USART_RQR_SBKRQ_Pos)            /*!< 0x00000002 */
N#define USART_RQR_SBKRQ               USART_RQR_SBKRQ_Msk                       /*!< Send Break Request */
N
N#define USART_RQR_MMRQ_Pos            (2U)
N#define USART_RQR_MMRQ_Msk            (0x1UL << USART_RQR_MMRQ_Pos)             /*!< 0x00000004 */
N#define USART_RQR_MMRQ                USART_RQR_MMRQ_Msk                        /*!< Mute Mode Request */
N
N#define USART_RQR_RXFRQ_Pos           (3U)
N#define USART_RQR_RXFRQ_Msk           (0x1UL << USART_RQR_RXFRQ_Pos)            /*!< 0x00000008 */
N#define USART_RQR_RXFRQ               USART_RQR_RXFRQ_Msk                       /*!< Receive Data flush Request */
N
N#define USART_RQR_TXFRQ_Pos           (4U)
N#define USART_RQR_TXFRQ_Msk           (0x1UL << USART_RQR_TXFRQ_Pos)            /*!< 0x00000010 */
N#define USART_RQR_TXFRQ               USART_RQR_TXFRQ_Msk                       /*!< Transmit data flush Request */
N
N/*******************  Bit definition for USART_ISR register  ******************/
N#define USART_ISR_PE_Pos              (0U)
N#define USART_ISR_PE_Msk              (0x1UL << USART_ISR_PE_Pos)               /*!< 0x00000001 */
N#define USART_ISR_PE                  USART_ISR_PE_Msk                          /*!< Parity Error */
N
N#define USART_ISR_FE_Pos              (1U)
N#define USART_ISR_FE_Msk              (0x1UL << USART_ISR_FE_Pos)               /*!< 0x00000002 */
N#define USART_ISR_FE                  USART_ISR_FE_Msk                          /*!< Framing Error */
N
N#define USART_ISR_NE_Pos              (2U)
N#define USART_ISR_NE_Msk              (0x1UL << USART_ISR_NE_Pos)               /*!< 0x00000004 */
N#define USART_ISR_NE                  USART_ISR_NE_Msk                          /*!< Noise detected Flag */
N
N#define USART_ISR_ORE_Pos             (3U)
N#define USART_ISR_ORE_Msk             (0x1UL << USART_ISR_ORE_Pos)              /*!< 0x00000008 */
N#define USART_ISR_ORE                 USART_ISR_ORE_Msk                         /*!< OverRun Error */
N
N#define USART_ISR_IDLE_Pos            (4U)
N#define USART_ISR_IDLE_Msk            (0x1UL << USART_ISR_IDLE_Pos)             /*!< 0x00000010 */
N#define USART_ISR_IDLE                USART_ISR_IDLE_Msk                        /*!< IDLE line detected */
N
N#define USART_ISR_RXNE_Pos            (5U)
N#define USART_ISR_RXNE_Msk            (0x1UL << USART_ISR_RXNE_Pos)             /*!< 0x00000020 */
N#define USART_ISR_RXNE                USART_ISR_RXNE_Msk                        /*!< Read Data Register Not Empty */
N
N#define USART_ISR_TC_Pos              (6U)
N#define USART_ISR_TC_Msk              (0x1UL << USART_ISR_TC_Pos)               /*!< 0x00000040 */
N#define USART_ISR_TC                  USART_ISR_TC_Msk                          /*!< Transmission Complete */
N
N#define USART_ISR_TXE_Pos             (7U)
N#define USART_ISR_TXE_Msk             (0x1UL << USART_ISR_TXE_Pos)              /*!< 0x00000080 */
N#define USART_ISR_TXE                 USART_ISR_TXE_Msk                         /*!< Transmit Data Register Empty */
N
N#define USART_ISR_LBDF_Pos            (8U)
N#define USART_ISR_LBDF_Msk            (0x1UL << USART_ISR_LBDF_Pos)             /*!< 0x00000100 */
N#define USART_ISR_LBDF                USART_ISR_LBDF_Msk                        /*!< LIN Break Detection Flag */
N
N#define USART_ISR_CTSIF_Pos           (9U)
N#define USART_ISR_CTSIF_Msk           (0x1UL << USART_ISR_CTSIF_Pos)            /*!< 0x00000200 */
N#define USART_ISR_CTSIF               USART_ISR_CTSIF_Msk                       /*!< CTS interrupt flag */
N
N#define USART_ISR_CTS_Pos             (10U)
N#define USART_ISR_CTS_Msk             (0x1UL << USART_ISR_CTS_Pos)              /*!< 0x00000400 */
N#define USART_ISR_CTS                 USART_ISR_CTS_Msk                         /*!< CTS flag */
N
N#define USART_ISR_RTOF_Pos            (11U)
N#define USART_ISR_RTOF_Msk            (0x1UL << USART_ISR_RTOF_Pos)             /*!< 0x00000800 */
N#define USART_ISR_RTOF                USART_ISR_RTOF_Msk                        /*!< Receiver Time Out */
N
N#define USART_ISR_EOBF_Pos            (12U)
N#define USART_ISR_EOBF_Msk            (0x1UL << USART_ISR_EOBF_Pos)             /*!< 0x00001000 */
N#define USART_ISR_EOBF                USART_ISR_EOBF_Msk                        /*!< End Of Block Flag */
N
N#define USART_ISR_ABRE_Pos            (14U)
N#define USART_ISR_ABRE_Msk            (0x1UL << USART_ISR_ABRE_Pos)             /*!< 0x00004000 */
N#define USART_ISR_ABRE                USART_ISR_ABRE_Msk                        /*!< Auto-Baud Rate Error */
N
N#define USART_ISR_ABRF_Pos            (15U)
N#define USART_ISR_ABRF_Msk            (0x1UL << USART_ISR_ABRF_Pos)             /*!< 0x00008000 */
N#define USART_ISR_ABRF                USART_ISR_ABRF_Msk                        /*!< Auto-Baud Rate Flag */
N
N#define USART_ISR_BUSY_Pos            (16U)
N#define USART_ISR_BUSY_Msk            (0x1UL << USART_ISR_BUSY_Pos)             /*!< 0x00010000 */
N#define USART_ISR_BUSY                USART_ISR_BUSY_Msk                        /*!< Busy Flag */
N
N#define USART_ISR_CMF_Pos             (17U)
N#define USART_ISR_CMF_Msk             (0x1UL << USART_ISR_CMF_Pos)              /*!< 0x00020000 */
N#define USART_ISR_CMF                 USART_ISR_CMF_Msk                         /*!< Character Match Flag */
N
N#define USART_ISR_SBKF_Pos            (18U)
N#define USART_ISR_SBKF_Msk            (0x1UL << USART_ISR_SBKF_Pos)             /*!< 0x00040000 */
N#define USART_ISR_SBKF                USART_ISR_SBKF_Msk                        /*!< Send Break Flag */
N
N#define USART_ISR_RWU_Pos             (19U)
N#define USART_ISR_RWU_Msk             (0x1UL << USART_ISR_RWU_Pos)              /*!< 0x00080000 */
N#define USART_ISR_RWU                 USART_ISR_RWU_Msk                         /*!< Receive Wake Up from mute mode Flag */
N
N#define USART_ISR_WUF_Pos             (20U)
N#define USART_ISR_WUF_Msk             (0x1UL << USART_ISR_WUF_Pos)              /*!< 0x00100000 */
N#define USART_ISR_WUF                 USART_ISR_WUF_Msk                         /*!< Wake Up from stop mode Flag */
N
N#define USART_ISR_TEACK_Pos           (21U)
N#define USART_ISR_TEACK_Msk           (0x1UL << USART_ISR_TEACK_Pos)            /*!< 0x00200000 */
N#define USART_ISR_TEACK               USART_ISR_TEACK_Msk                       /*!< Transmit Enable Acknowledge Flag */
N
N#define USART_ISR_REACK_Pos           (22U)
N#define USART_ISR_REACK_Msk           (0x1UL << USART_ISR_REACK_Pos)            /*!< 0x00400000 */
N#define USART_ISR_REACK               USART_ISR_REACK_Msk                       /*!< Receive Enable Acknowledge Flag */
N
N/*******************  Bit definition for USART_ICR register  ******************/
N#define USART_ICR_PECF_Pos            (0U)
N#define USART_ICR_PECF_Msk            (0x1UL << USART_ICR_PECF_Pos)             /*!< 0x00000001 */
N#define USART_ICR_PECF                USART_ICR_PECF_Msk                        /*!< Parity Error Clear Flag */
N
N#define USART_ICR_FECF_Pos            (1U)
N#define USART_ICR_FECF_Msk            (0x1UL << USART_ICR_FECF_Pos)             /*!< 0x00000002 */
N#define USART_ICR_FECF                USART_ICR_FECF_Msk                        /*!< Framing Error Clear Flag */
N
N#define USART_ICR_NCF_Pos             (2U)
N#define USART_ICR_NCF_Msk             (0x1UL << USART_ICR_NCF_Pos)              /*!< 0x00000004 */
N#define USART_ICR_NCF                 USART_ICR_NCF_Msk                         /*!< Noise detected Clear Flag */
N
N#define USART_ICR_ORECF_Pos           (3U)
N#define USART_ICR_ORECF_Msk           (0x1UL << USART_ICR_ORECF_Pos)            /*!< 0x00000008 */
N#define USART_ICR_ORECF               USART_ICR_ORECF_Msk                       /*!< OverRun Error Clear Flag */
N
N#define USART_ICR_IDLECF_Pos          (4U)
N#define USART_ICR_IDLECF_Msk          (0x1UL << USART_ICR_IDLECF_Pos)           /*!< 0x00000010 */
N#define USART_ICR_IDLECF              USART_ICR_IDLECF_Msk                      /*!< IDLE line detected Clear Flag */
N
N#define USART_ICR_TCCF_Pos            (6U)
N#define USART_ICR_TCCF_Msk            (0x1UL << USART_ICR_TCCF_Pos)             /*!< 0x00000040 */
N#define USART_ICR_TCCF                USART_ICR_TCCF_Msk                        /*!< Transmission Complete Clear Flag */
N
N#define USART_ICR_LBDCF_Pos           (8U)
N#define USART_ICR_LBDCF_Msk           (0x1UL << USART_ICR_LBDCF_Pos)            /*!< 0x00000100 */
N#define USART_ICR_LBDCF               USART_ICR_LBDCF_Msk                       /*!< LIN Break Detection Clear Flag */
N
N#define USART_ICR_CTSCF_Pos           (9U)
N#define USART_ICR_CTSCF_Msk           (0x1UL << USART_ICR_CTSCF_Pos)            /*!< 0x00000200 */
N#define USART_ICR_CTSCF               USART_ICR_CTSCF_Msk                       /*!< CTS Interrupt Clear Flag */
N
N#define USART_ICR_RTOCF_Pos           (11U)
N#define USART_ICR_RTOCF_Msk           (0x1UL << USART_ICR_RTOCF_Pos)            /*!< 0x00000800 */
N#define USART_ICR_RTOCF               USART_ICR_RTOCF_Msk                       /*!< Receiver Time Out Clear Flag */
N
N#define USART_ICR_EOBCF_Pos           (12U)
N#define USART_ICR_EOBCF_Msk           (0x1UL << USART_ICR_EOBCF_Pos)            /*!< 0x00001000 */
N#define USART_ICR_EOBCF               USART_ICR_EOBCF_Msk                       /*!< End Of Block Clear Flag */
N
N#define USART_ICR_CMCF_Pos            (17U)
N#define USART_ICR_CMCF_Msk            (0x1UL << USART_ICR_CMCF_Pos)             /*!< 0x00020000 */
N#define USART_ICR_CMCF                USART_ICR_CMCF_Msk                        /*!< Character Match Clear Flag */
N
N#define USART_ICR_WUCF_Pos            (20U)
N#define USART_ICR_WUCF_Msk            (0x1UL << USART_ICR_WUCF_Pos)             /*!< 0x00100000 */
N#define USART_ICR_WUCF                USART_ICR_WUCF_Msk                        /*!< Wake Up from stop mode Clear Flag */
N
N/*******************  Bit definition for USART_RDR register  ******************/
N#define USART_RDR_RDR                 ((uint16_t)0x01FFU)                       /*!< RDR[8:0] bits (Receive Data value) */
N
N/*******************  Bit definition for USART_TDR register  ******************/
N#define USART_TDR_TDR                 ((uint16_t)0x01FFU)                       /*!< TDR[8:0] bits (Transmit Data value) */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Window WATCHDOG (WWDG)                             */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for WWDG_CR register  ********************/
N#define WWDG_CR_T_Pos           (0U)
N#define WWDG_CR_T_Msk           (0x7FUL << WWDG_CR_T_Pos)                       /*!< 0x0000007F */
N#define WWDG_CR_T               WWDG_CR_T_Msk                                   /*!< T[6:0] bits (7-Bit counter (MSB to LSB)) */
N#define WWDG_CR_T_0             (0x01UL << WWDG_CR_T_Pos)                       /*!< 0x00000001 */
N#define WWDG_CR_T_1             (0x02UL << WWDG_CR_T_Pos)                       /*!< 0x00000002 */
N#define WWDG_CR_T_2             (0x04UL << WWDG_CR_T_Pos)                       /*!< 0x00000004 */
N#define WWDG_CR_T_3             (0x08UL << WWDG_CR_T_Pos)                       /*!< 0x00000008 */
N#define WWDG_CR_T_4             (0x10UL << WWDG_CR_T_Pos)                       /*!< 0x00000010 */
N#define WWDG_CR_T_5             (0x20UL << WWDG_CR_T_Pos)                       /*!< 0x00000020 */
N#define WWDG_CR_T_6             (0x40UL << WWDG_CR_T_Pos)                       /*!< 0x00000040 */
N
N#define WWDG_CR_WDGA_Pos        (7U)
N#define WWDG_CR_WDGA_Msk        (0x1UL << WWDG_CR_WDGA_Pos)                     /*!< 0x00000080 */
N#define WWDG_CR_WDGA            WWDG_CR_WDGA_Msk                                /*!< Activation bit */
N
N/*******************  Bit definition for WWDG_CFR register  *******************/
N#define WWDG_CFR_W_Pos          (0U)
N#define WWDG_CFR_W_Msk          (0x7FUL << WWDG_CFR_W_Pos)                      /*!< 0x0000007F */
N#define WWDG_CFR_W              WWDG_CFR_W_Msk                                  /*!< W[6:0] bits (7-bit window value) */
N#define WWDG_CFR_W_0            (0x01UL << WWDG_CFR_W_Pos)                      /*!< 0x00000001 */
N#define WWDG_CFR_W_1            (0x02UL << WWDG_CFR_W_Pos)                      /*!< 0x00000002 */
N#define WWDG_CFR_W_2            (0x04UL << WWDG_CFR_W_Pos)                      /*!< 0x00000004 */
N#define WWDG_CFR_W_3            (0x08UL << WWDG_CFR_W_Pos)                      /*!< 0x00000008 */
N#define WWDG_CFR_W_4            (0x10UL << WWDG_CFR_W_Pos)                      /*!< 0x00000010 */
N#define WWDG_CFR_W_5            (0x20UL << WWDG_CFR_W_Pos)                      /*!< 0x00000020 */
N#define WWDG_CFR_W_6            (0x40UL << WWDG_CFR_W_Pos)                      /*!< 0x00000040 */
N
N#define WWDG_CFR_WDGTB_Pos      (7U)
N#define WWDG_CFR_WDGTB_Msk      (0x3UL << WWDG_CFR_WDGTB_Pos)                   /*!< 0x00000180 */
N#define WWDG_CFR_WDGTB          WWDG_CFR_WDGTB_Msk                              /*!< WDGTB[1:0] bits (Timer Base) */
N#define WWDG_CFR_WDGTB_0        (0x1UL << WWDG_CFR_WDGTB_Pos)                   /*!< 0x00000080 */
N#define WWDG_CFR_WDGTB_1        (0x2UL << WWDG_CFR_WDGTB_Pos)                   /*!< 0x00000100 */
N
N#define WWDG_CFR_EWI_Pos        (9U)
N#define WWDG_CFR_EWI_Msk        (0x1UL << WWDG_CFR_EWI_Pos)                     /*!< 0x00000200 */
N#define WWDG_CFR_EWI            WWDG_CFR_EWI_Msk                                /*!< Early Wakeup Interrupt */
N
N/*******************  Bit definition for WWDG_SR register  ********************/
N#define WWDG_SR_EWIF_Pos        (0U)
N#define WWDG_SR_EWIF_Msk        (0x1UL << WWDG_SR_EWIF_Pos)                     /*!< 0x00000001 */
N#define WWDG_SR_EWIF            WWDG_SR_EWIF_Msk                                /*!< Early Wakeup Interrupt Flag */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @addtogroup Exported_macro
N  * @{
N  */
N
N/****************************** ADC Instances *********************************/
N#define IS_ADC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == ADC1)
N
N#define IS_ADC_COMMON_INSTANCE(INSTANCE) ((INSTANCE) == ADC)
N
N/****************************** CRC Instances *********************************/
N#define IS_CRC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == CRC)
N
N/******************************* DMA Instances ********************************/
N#define IS_DMA_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DMA1_Channel1) || \
N                                       ((INSTANCE) == DMA1_Channel2) || \
N                                       ((INSTANCE) == DMA1_Channel3) || \
N                                       ((INSTANCE) == DMA1_Channel4) || \
N                                       ((INSTANCE) == DMA1_Channel5))
X#define IS_DMA_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DMA1_Channel1) ||                                        ((INSTANCE) == DMA1_Channel2) ||                                        ((INSTANCE) == DMA1_Channel3) ||                                        ((INSTANCE) == DMA1_Channel4) ||                                        ((INSTANCE) == DMA1_Channel5))
N
N/****************************** GPIO Instances ********************************/
N#define IS_GPIO_ALL_INSTANCE(INSTANCE)  (((INSTANCE) == GPIOA) || \
N                                         ((INSTANCE) == GPIOB) || \
N                                         ((INSTANCE) == GPIOC) || \
N                                         ((INSTANCE) == GPIOF))
X#define IS_GPIO_ALL_INSTANCE(INSTANCE)  (((INSTANCE) == GPIOA) ||                                          ((INSTANCE) == GPIOB) ||                                          ((INSTANCE) == GPIOC) ||                                          ((INSTANCE) == GPIOF))
N
N/**************************** GPIO Alternate Function Instances ***************/
N#define IS_GPIO_AF_INSTANCE(INSTANCE)   (((INSTANCE) == GPIOA) || \
N                                         ((INSTANCE) == GPIOB) || \
N                                         ((INSTANCE) == GPIOC) || \
N                                         ((INSTANCE) == GPIOF))
X#define IS_GPIO_AF_INSTANCE(INSTANCE)   (((INSTANCE) == GPIOA) ||                                          ((INSTANCE) == GPIOB) ||                                          ((INSTANCE) == GPIOC) ||                                          ((INSTANCE) == GPIOF))
N
N/****************************** GPIO Lock Instances ***************************/
N#define IS_GPIO_LOCK_INSTANCE(INSTANCE) (((INSTANCE) == GPIOA) || \
N                                         ((INSTANCE) == GPIOB) || \
N                                         ((INSTANCE) == GPIOC) || \
N                                         ((INSTANCE) == GPIOF)
X#define IS_GPIO_LOCK_INSTANCE(INSTANCE) (((INSTANCE) == GPIOA) ||                                          ((INSTANCE) == GPIOB) ||                                          ((INSTANCE) == GPIOC) ||                                          ((INSTANCE) == GPIOF)
N
N/****************************** I2C Instances *********************************/
N#define IS_I2C_ALL_INSTANCE(INSTANCE) ((INSTANCE) == I2C1)
N
N/****************** I2C Instances : wakeup capability from stop modes *********/
N#define IS_I2C_WAKEUP_FROMSTOP_INSTANCE(INSTANCE) ((INSTANCE) == I2C1)
N
N/****************************** I2S Instances *********************************/
N#define IS_I2S_ALL_INSTANCE(INSTANCE) ((INSTANCE) == SPI1)
N
N/****************************** IWDG Instances ********************************/
N#define IS_IWDG_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == IWDG)
N
N/****************************** RTC Instances *********************************/
N#define IS_RTC_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == RTC)
N
N/****************************** SMBUS Instances *********************************/
N#define IS_SMBUS_ALL_INSTANCE(INSTANCE) ((INSTANCE) == I2C1)
N
N/****************************** SPI Instances *********************************/
N#define IS_SPI_ALL_INSTANCE(INSTANCE) ((INSTANCE) == SPI1)
N
N/****************************** TIM Instances *********************************/
N#define IS_TIM_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM14)   || \
N   ((INSTANCE) == TIM16)   || \
N   ((INSTANCE) == TIM17))
X#define IS_TIM_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM14)   ||    ((INSTANCE) == TIM16)   ||    ((INSTANCE) == TIM17))
N
N#define IS_TIM_CC1_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM14)   || \
N   ((INSTANCE) == TIM16)   || \
N   ((INSTANCE) == TIM17))
X#define IS_TIM_CC1_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM14)   ||    ((INSTANCE) == TIM16)   ||    ((INSTANCE) == TIM17))
N
N#define IS_TIM_CC2_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_CC2_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_CC3_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_CC3_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_CC4_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_CC4_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N
N#define IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_CLOCKSOURCE_TIX_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_CLOCKSOURCE_TIX_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_OCXREF_CLEAR_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_OCXREF_CLEAR_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_ENCODER_INTERFACE_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_ENCODER_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_HALL_INTERFACE_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1))
X#define IS_TIM_HALL_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1))
N
N#define IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1))
X#define IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1))
N
N#define IS_TIM_XOR_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_XOR_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_MASTER_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_MASTER_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_SLAVE_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_SLAVE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_32B_COUNTER_INSTANCE(INSTANCE)\
N    ((INSTANCE) == TIM2)
X#define IS_TIM_32B_COUNTER_INSTANCE(INSTANCE)    ((INSTANCE) == TIM2)
N
N#define IS_TIM_DMABURST_INSTANCE(INSTANCE)\
N    (((INSTANCE) == TIM1)    || \
N     ((INSTANCE) == TIM2)    || \
N     ((INSTANCE) == TIM3)    || \
N     ((INSTANCE) == TIM16)   || \
N     ((INSTANCE) == TIM17))
X#define IS_TIM_DMABURST_INSTANCE(INSTANCE)    (((INSTANCE) == TIM1)    ||      ((INSTANCE) == TIM2)    ||      ((INSTANCE) == TIM3)    ||      ((INSTANCE) == TIM16)   ||      ((INSTANCE) == TIM17))
N
N#define IS_TIM_BREAK_INSTANCE(INSTANCE)\
N      (((INSTANCE) == TIM1)    || \
N       ((INSTANCE) == TIM16)   || \
N       ((INSTANCE) == TIM17))
X#define IS_TIM_BREAK_INSTANCE(INSTANCE)      (((INSTANCE) == TIM1)    ||        ((INSTANCE) == TIM16)   ||        ((INSTANCE) == TIM17))
N
N#define IS_TIM_CCX_INSTANCE(INSTANCE, CHANNEL) \
N    ((((INSTANCE) == TIM1) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM2) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM3) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM14) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1)))           \
N    ||                                         \
N    (((INSTANCE) == TIM16) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1)))           \
N    ||                                         \
N    (((INSTANCE) == TIM17) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1))))
X#define IS_TIM_CCX_INSTANCE(INSTANCE, CHANNEL)     ((((INSTANCE) == TIM1) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM2) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM3) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM14) &&                       (((CHANNEL) == TIM_CHANNEL_1)))               ||                                             (((INSTANCE) == TIM16) &&                       (((CHANNEL) == TIM_CHANNEL_1)))               ||                                             (((INSTANCE) == TIM17) &&                       (((CHANNEL) == TIM_CHANNEL_1))))
N
N#define IS_TIM_CCXN_INSTANCE(INSTANCE, CHANNEL) \
N   ((((INSTANCE) == TIM1) &&                    \
N     (((CHANNEL) == TIM_CHANNEL_1) ||           \
N      ((CHANNEL) == TIM_CHANNEL_2) ||           \
N      ((CHANNEL) == TIM_CHANNEL_3)))            \
N    ||                                          \
N    (((INSTANCE) == TIM16) &&                   \
N     ((CHANNEL) == TIM_CHANNEL_1))              \
N    ||                                          \
N    (((INSTANCE) == TIM17) &&                   \
N     ((CHANNEL) == TIM_CHANNEL_1)))
X#define IS_TIM_CCXN_INSTANCE(INSTANCE, CHANNEL)    ((((INSTANCE) == TIM1) &&                         (((CHANNEL) == TIM_CHANNEL_1) ||                 ((CHANNEL) == TIM_CHANNEL_2) ||                 ((CHANNEL) == TIM_CHANNEL_3)))                ||                                              (((INSTANCE) == TIM16) &&                        ((CHANNEL) == TIM_CHANNEL_1))                  ||                                              (((INSTANCE) == TIM17) &&                        ((CHANNEL) == TIM_CHANNEL_1)))
N
N#define IS_TIM_COUNTER_MODE_SELECT_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_COUNTER_MODE_SELECT_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_REPETITION_COUNTER_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM16)   || \
N   ((INSTANCE) == TIM17))
X#define IS_TIM_REPETITION_COUNTER_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM16)   ||    ((INSTANCE) == TIM17))
N
N#define IS_TIM_CLOCK_DIVISION_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM14)   || \
N   ((INSTANCE) == TIM16)   || \
N   ((INSTANCE) == TIM17))
X#define IS_TIM_CLOCK_DIVISION_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM14)   ||    ((INSTANCE) == TIM16)   ||    ((INSTANCE) == TIM17))
N
N#define IS_TIM_DMA_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM16)   || \
N   ((INSTANCE) == TIM17))
X#define IS_TIM_DMA_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM16)   ||    ((INSTANCE) == TIM17))
N
N#define IS_TIM_OPM_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM16)   || \
N   ((INSTANCE) == TIM17))
X#define IS_TIM_OPM_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM16)   ||    ((INSTANCE) == TIM17))
N
N#define IS_TIM_DMA_CC_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM16)   || \
N   ((INSTANCE) == TIM17))
X#define IS_TIM_DMA_CC_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM16)   ||    ((INSTANCE) == TIM17))
N
N#define IS_TIM_COMMUTATION_EVENT_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM16)   || \
N   ((INSTANCE) == TIM17))
X#define IS_TIM_COMMUTATION_EVENT_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM16)   ||    ((INSTANCE) == TIM17))
N
N#define IS_TIM_REMAP_INSTANCE(INSTANCE)\
N  ((INSTANCE) == TIM14)
X#define IS_TIM_REMAP_INSTANCE(INSTANCE)  ((INSTANCE) == TIM14)
N
N#define IS_TIM_ADVANCED_INSTANCE(INSTANCE)\
N  ((INSTANCE) == TIM1)
X#define IS_TIM_ADVANCED_INSTANCE(INSTANCE)  ((INSTANCE) == TIM1)
N
N/*********************** UART Instances : IRDA mode ***************************/
N#define IS_IRDA_INSTANCE(INSTANCE) ((INSTANCE) == USART1)
N
N/********************* UART Instances : Smard card mode ***********************/
N#define IS_SMARTCARD_INSTANCE(INSTANCE) ((INSTANCE) == USART1)
N
N/******************** USART Instances : Synchronous mode **********************/
N#define IS_USART_INSTANCE(INSTANCE) ((INSTANCE) == USART1)
N
N/******************** USART Instances : auto Baud rate detection **************/
N#define IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(INSTANCE) ((INSTANCE) == USART1)
N
N/******************** UART Instances : Asynchronous mode **********************/
N#define IS_UART_INSTANCE(INSTANCE)   ((INSTANCE) == USART1)
N
N/******************** UART Instances : Half-Duplex mode **********************/
N#define IS_UART_HALFDUPLEX_INSTANCE(INSTANCE)   ((INSTANCE) == USART1)
N
N/****************** UART Instances : Hardware Flow control ********************/
N#define IS_UART_HWFLOW_INSTANCE(INSTANCE) ((INSTANCE) == USART1)
N
N/****************** UART Instances : LIN mode ********************/
N#define IS_UART_LIN_INSTANCE(INSTANCE) ((INSTANCE) == USART1)
N
N/****************** UART Instances : wakeup from stop mode ********************/
N#define IS_UART_WAKEUP_FROMSTOP_INSTANCE(INSTANCE) ((INSTANCE) == USART1)
N/* Old macro definition maintained for legacy purpose */
N#define IS_UART_WAKEUP_INSTANCE         IS_UART_WAKEUP_FROMSTOP_INSTANCE
N
N/****************** UART Instances : Driver enable detection ********************/
N#define IS_UART_DRIVER_ENABLE_INSTANCE(INSTANCE) ((INSTANCE) == USART1)
N
N/****************************** WWDG Instances ********************************/
N#define IS_WWDG_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == WWDG)
N
N
N/* Exported functions ------------------------------------------------------- */
N
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __MS32F031_H */
N
N/******************************** END OF FILE *********************************/
L 13 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N#else
S #error "Please select first the target MS32F0XX device used in your application (in ms32f0xx.h file)"
N#endif
N
N
N/* Exported types ------------------------------------------------------------*/
Ntypedef enum {
N  RESET = 0U,
N  SET   = !RESET
N} LevelStatus, FlagStatus, ITStatus;
N
Ntypedef enum {
N  DISABLE = 0U,
N  ENABLE  = !DISABLE
N} FunctionalState;
N
Ntypedef enum {
N  SUCCESS = 0U,
N  ERROR   = !SUCCESS
N} ErrorStatus;
N
N
N/* Exported constants --------------------------------------------------------*/
N/**
N  * @brief CMSIS Device version number V1.0.0
N  */
N#define __MC60F_DEVICE_VERSION_MAIN   (0x01) /*!< [31:24] main version */
N#define __MC60F_DEVICE_VERSION_SUB1   (0x00) /*!< [23:16] sub1 version */
N#define __MC60F_DEVICE_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
N#define __MC60F_DEVICE_VERSION_RC     (0x00) /*!< [7:0]  release candidate */
N#define __MC60F_DEVICE_VERSION        ((__MC60F_DEVICE_VERSION_MAIN << 24) \
N                                      |(__MC60F_DEVICE_VERSION_SUB1 << 16) \
N                                      |(__MC60F_DEVICE_VERSION_SUB2 << 8 ) \
N                                      |(__MC60F_DEVICE_VERSION_RC))
X#define __MC60F_DEVICE_VERSION        ((__MC60F_DEVICE_VERSION_MAIN << 24)                                       |(__MC60F_DEVICE_VERSION_SUB1 << 16)                                       |(__MC60F_DEVICE_VERSION_SUB2 << 8 )                                       |(__MC60F_DEVICE_VERSION_RC))
N
N
N/* Exported macro ------------------------------------------------------------*/
N#define IS_FUNCTIONAL_STATE(STATE)           (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
N#define SET_BIT(REG, BIT)                    ((REG) |= (BIT))
N#define CLEAR_BIT(REG, BIT)                  ((REG) &= ~(BIT))
N#define READ_BIT(REG, BIT)                   ((REG) & (BIT))
N#define CLEAR_REG(REG)                       ((REG) = (0x0))
N#define WRITE_REG(REG, VAL)                  ((REG) = (VAL))
N#define READ_REG(REG)                        ((REG))
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N
N/* Exported library ----------------------------------------------------------*/
N#if defined (MS32F031)
X#if 1L
N  #include "ms32f0xx_adc.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_adc.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_ADC_H
N#define __MS32F0XX_ADC_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
L 1 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_H
S#define __MS32F0XX_H
S
S#ifdef __cplusplus
S extern "C" {
S#endif /* __cplusplus */
S
S
S/* Includes ------------------------------------------------------------------*/
S#if defined (MS32F031)
S  #include "ms32f031.h"
S#else
S #error "Please select first the target MS32F0XX device used in your application (in ms32f0xx.h file)"
S#endif
S
S
S/* Exported types ------------------------------------------------------------*/
Stypedef enum {
S  RESET = 0U,
S  SET   = !RESET
S} LevelStatus, FlagStatus, ITStatus;
S
Stypedef enum {
S  DISABLE = 0U,
S  ENABLE  = !DISABLE
S} FunctionalState;
S
Stypedef enum {
S  SUCCESS = 0U,
S  ERROR   = !SUCCESS
S} ErrorStatus;
S
S
S/* Exported constants --------------------------------------------------------*/
S/**
S  * @brief CMSIS Device version number V1.0.0
S  */
S#define __MC60F_DEVICE_VERSION_MAIN   (0x01) /*!< [31:24] main version */
S#define __MC60F_DEVICE_VERSION_SUB1   (0x00) /*!< [23:16] sub1 version */
S#define __MC60F_DEVICE_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
S#define __MC60F_DEVICE_VERSION_RC     (0x00) /*!< [7:0]  release candidate */
S#define __MC60F_DEVICE_VERSION        ((__MC60F_DEVICE_VERSION_MAIN << 24) \
S                                      |(__MC60F_DEVICE_VERSION_SUB1 << 16) \
S                                      |(__MC60F_DEVICE_VERSION_SUB2 << 8 ) \
S                                      |(__MC60F_DEVICE_VERSION_RC))
X#define __MC60F_DEVICE_VERSION        ((__MC60F_DEVICE_VERSION_MAIN << 24)                                       |(__MC60F_DEVICE_VERSION_SUB1 << 16)                                       |(__MC60F_DEVICE_VERSION_SUB2 << 8 )                                       |(__MC60F_DEVICE_VERSION_RC))
S
S
S/* Exported macro ------------------------------------------------------------*/
S#define IS_FUNCTIONAL_STATE(STATE)           (((STATE) == DISABLE) || ((STATE) == ENABLE))
S
S#define SET_BIT(REG, BIT)                    ((REG) |= (BIT))
S#define CLEAR_BIT(REG, BIT)                  ((REG) &= ~(BIT))
S#define READ_BIT(REG, BIT)                   ((REG) & (BIT))
S#define CLEAR_REG(REG)                       ((REG) = (0x0))
S#define WRITE_REG(REG, VAL)                  ((REG) = (VAL))
S#define READ_REG(REG)                        ((REG))
S#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
S
S
S/* Exported library ----------------------------------------------------------*/
S#if defined (MS32F031)
S  #include "ms32f0xx_adc.h"
S  #include "ms32f0xx_bus.h"
S  #include "ms32f0xx_comp.h"
S  #include "ms32f0xx_cortex.h"
S  #include "ms32f0xx_crc.h"
S  #include "ms32f0xx_dma.h"
S  #include "ms32f0xx_exti.h"
S  #include "ms32f0xx_flash.h"
S  #include "ms32f0xx_gpio.h"
S  #include "ms32f0xx_i2c.h"
S  #include "ms32f0xx_iwdg.h"
S  #include "ms32f0xx_opamp.h"
S  #include "ms32f0xx_pwr.h"
S  #include "ms32f0xx_rcc.h"
S  #include "ms32f0xx_rtc.h"
S  #include "ms32f0xx_spi.h"
S  #include "ms32f0xx_system.h"
S  #include "ms32f0xx_tim.h"
S  #include "ms32f0xx_usart.h"
S  #include "ms32f0xx_utils.h"
S  #include "ms32f0xx_wwdg.h"
S#endif
S
S/* Exported functions ------------------------------------------------------- */
S
S
S#ifdef __cplusplus
S}
S#endif /* __cplusplus */
S
N#endif /* __MS32F0XX_H */
N
N/******************************** END OF FILE *********************************/
L 11 "..\..\library\ms32f0xx\include\ms32f0xx_adc.h" 2
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup ADC_MS32_Private_Constants ADC Private Constants
N  * @{
N  */
N
N/* Internal mask for ADC group regular trigger:                               */
N/* To select into literal MS32_ADC_REG_TRIG_x the relevant bits for:          */
N/* - regular trigger source                                                   */
N/* - regular trigger edge                                                     */
N#define ADC_REG_TRIG_EXT_EDGE_DEFAULT       (ADC_CFGR1_EXTEN_0) /* Trigger edge set to rising edge (default setting for compatibility with some ADC on other MS32 families having this setting set by HW default value) */
N
N/* Mask containing trigger source masks for each of possible                  */
N/* trigger edge selection duplicated with shifts [0; 4; 8; 12]                */
N/* corresponding to {SW start; ext trigger; ext trigger; ext trigger}.        */
N#define ADC_REG_TRIG_SOURCE_MASK            (((MS32_ADC_REG_TRIG_SOFTWARE & ADC_CFGR1_EXTSEL) << (4U * 0U)) | \
N                                             ((ADC_CFGR1_EXTSEL)                              << (4U * 1U)) | \
N                                             ((ADC_CFGR1_EXTSEL)                              << (4U * 2U)) | \
N                                             ((ADC_CFGR1_EXTSEL)                              << (4U * 3U))  )
X#define ADC_REG_TRIG_SOURCE_MASK            (((MS32_ADC_REG_TRIG_SOFTWARE & ADC_CFGR1_EXTSEL) << (4U * 0U)) |                                              ((ADC_CFGR1_EXTSEL)                              << (4U * 1U)) |                                              ((ADC_CFGR1_EXTSEL)                              << (4U * 2U)) |                                              ((ADC_CFGR1_EXTSEL)                              << (4U * 3U))  )
N
N/* Mask containing trigger edge masks for each of possible                    */
N/* trigger edge selection duplicated with shifts [0; 4; 8; 12]                */
N/* corresponding to {SW start; ext trigger; ext trigger; ext trigger}.        */
N#define ADC_REG_TRIG_EDGE_MASK              (((MS32_ADC_REG_TRIG_SOFTWARE & ADC_CFGR1_EXTEN) << (4U * 0U)) | \
N                                             ((ADC_REG_TRIG_EXT_EDGE_DEFAULT)                << (4U * 1U)) | \
N                                             ((ADC_REG_TRIG_EXT_EDGE_DEFAULT)                << (4U * 2U)) | \
N                                             ((ADC_REG_TRIG_EXT_EDGE_DEFAULT)                << (4U * 3U))  )
X#define ADC_REG_TRIG_EDGE_MASK              (((MS32_ADC_REG_TRIG_SOFTWARE & ADC_CFGR1_EXTEN) << (4U * 0U)) |                                              ((ADC_REG_TRIG_EXT_EDGE_DEFAULT)                << (4U * 1U)) |                                              ((ADC_REG_TRIG_EXT_EDGE_DEFAULT)                << (4U * 2U)) |                                              ((ADC_REG_TRIG_EXT_EDGE_DEFAULT)                << (4U * 3U))  )
N
N/* Definition of ADC group regular trigger bits information.                  */
N#define ADC_REG_TRIG_EXTSEL_BITOFFSET_POS  ( 6U) /* Value equivalent to POSITION_VAL(ADC_CFGR1_EXTSEL) */
N#define ADC_REG_TRIG_EXTEN_BITOFFSET_POS   (10U) /* Value equivalent to POSITION_VAL(ADC_CFGR1_EXTEN) */
N
N
N/* Internal mask for ADC channel:                                             */
N/* To select into literal MS32_ADC_CHANNEL_x the relevant bits for:           */
N/* - channel identifier defined by number                                     */
N/* - channel identifier defined by bitfield                                   */
N/* - channel differentiation between external channels (connected to          */
N/*   GPIO pins) and internal channels (connected to internal paths)           */
N#define ADC_CHANNEL_ID_NUMBER_MASK          (ADC_CFGR1_AWDCH)
N#define ADC_CHANNEL_ID_BITFIELD_MASK        (ADC_CHSELR_CHSEL)
N#define ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS (26U) /* Value equivalent to POSITION_VAL(ADC_CHANNEL_ID_NUMBER_MASK) */
N#define ADC_CHANNEL_ID_MASK                 (ADC_CHANNEL_ID_NUMBER_MASK | ADC_CHANNEL_ID_BITFIELD_MASK | ADC_CHANNEL_ID_INTERNAL_CH_MASK)
N
N/* Equivalent mask of ADC_CHANNEL_NUMBER_MASK aligned on register LSB (bit 0) */
N#define ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 (0x0000001FU) /* Equivalent to shift: (ADC_CHANNEL_NUMBER_MASK >> POSITION_VAL(ADC_CHANNEL_NUMBER_MASK)) */
N
N/* Channel differentiation between external and internal channels */
N#define ADC_CHANNEL_ID_INTERNAL_CH         (0x80000000U) /* Marker of internal channel */
N#define ADC_CHANNEL_ID_INTERNAL_CH_MASK    (ADC_CHANNEL_ID_INTERNAL_CH)
N
N
N/* Definition of channels ID number information to be inserted into           */
N/* channels literals definition.                                              */
N#define ADC_CHANNEL_0_NUMBER               (0x00000000U)
N#define ADC_CHANNEL_1_NUMBER               (                                                                                ADC_CFGR1_AWDCH_0)
N#define ADC_CHANNEL_2_NUMBER               (                                                            ADC_CFGR1_AWDCH_1                    )
N#define ADC_CHANNEL_3_NUMBER               (                                                            ADC_CFGR1_AWDCH_1 | ADC_CFGR1_AWDCH_0)
N#define ADC_CHANNEL_4_NUMBER               (                                        ADC_CFGR1_AWDCH_2                                        )
N#define ADC_CHANNEL_5_NUMBER               (                                        ADC_CFGR1_AWDCH_2                     | ADC_CFGR1_AWDCH_0)
N#define ADC_CHANNEL_6_NUMBER               (                                        ADC_CFGR1_AWDCH_2 | ADC_CFGR1_AWDCH_1                    )
N#define ADC_CHANNEL_7_NUMBER               (                                        ADC_CFGR1_AWDCH_2 | ADC_CFGR1_AWDCH_1 | ADC_CFGR1_AWDCH_0)
N#define ADC_CHANNEL_8_NUMBER               (                    ADC_CFGR1_AWDCH_3                                                            )
N#define ADC_CHANNEL_9_NUMBER               (                    ADC_CFGR1_AWDCH_3                                         | ADC_CFGR1_AWDCH_0)
N#define ADC_CHANNEL_10_NUMBER              (                    ADC_CFGR1_AWDCH_3                     | ADC_CFGR1_AWDCH_1                    )
N#define ADC_CHANNEL_11_NUMBER              (                    ADC_CFGR1_AWDCH_3                     | ADC_CFGR1_AWDCH_1 | ADC_CFGR1_AWDCH_0)
N#define ADC_CHANNEL_12_NUMBER              (                    ADC_CFGR1_AWDCH_3 | ADC_CFGR1_AWDCH_2                                        )
N#define ADC_CHANNEL_13_NUMBER              (                    ADC_CFGR1_AWDCH_3 | ADC_CFGR1_AWDCH_2                     | ADC_CFGR1_AWDCH_0)
N#define ADC_CHANNEL_14_NUMBER              (                    ADC_CFGR1_AWDCH_3 | ADC_CFGR1_AWDCH_2 | ADC_CFGR1_AWDCH_1                    )
N#define ADC_CHANNEL_15_NUMBER              (                    ADC_CFGR1_AWDCH_3 | ADC_CFGR1_AWDCH_2 | ADC_CFGR1_AWDCH_1 | ADC_CFGR1_AWDCH_0)
N#define ADC_CHANNEL_16_NUMBER              (ADC_CFGR1_AWDCH_4                                                                                )
N#define ADC_CHANNEL_17_NUMBER              (ADC_CFGR1_AWDCH_4                                                             | ADC_CFGR1_AWDCH_0)
N#define ADC_CHANNEL_18_NUMBER              (ADC_CFGR1_AWDCH_4                                         | ADC_CFGR1_AWDCH_1                    )
N#define ADC_CHANNEL_19_NUMBER              (ADC_CFGR1_AWDCH_4                                         | ADC_CFGR1_AWDCH_1 | ADC_CFGR1_AWDCH_0)
N#define ADC_CHANNEL_20_NUMBER              (ADC_CFGR1_AWDCH_4                     | ADC_CFGR1_AWDCH_2                                        )
N#define ADC_CHANNEL_21_NUMBER              (ADC_CFGR1_AWDCH_4                     | ADC_CFGR1_AWDCH_2                     | ADC_CFGR1_AWDCH_0)
N
N/* Definition of channels ID bitfield information to be inserted into         */
N/* channels literals definition.                                              */
N#define ADC_CHANNEL_0_BITFIELD             (ADC_CHSELR_CHSEL0)
N#define ADC_CHANNEL_1_BITFIELD             (ADC_CHSELR_CHSEL1)
N#define ADC_CHANNEL_2_BITFIELD             (ADC_CHSELR_CHSEL2)
N#define ADC_CHANNEL_3_BITFIELD             (ADC_CHSELR_CHSEL3)
N#define ADC_CHANNEL_4_BITFIELD             (ADC_CHSELR_CHSEL4)
N#define ADC_CHANNEL_5_BITFIELD             (ADC_CHSELR_CHSEL5)
N#define ADC_CHANNEL_6_BITFIELD             (ADC_CHSELR_CHSEL6)
N#define ADC_CHANNEL_7_BITFIELD             (ADC_CHSELR_CHSEL7)
N#define ADC_CHANNEL_8_BITFIELD             (ADC_CHSELR_CHSEL8)
N#define ADC_CHANNEL_9_BITFIELD             (ADC_CHSELR_CHSEL9)
N#define ADC_CHANNEL_10_BITFIELD            (ADC_CHSELR_CHSEL10)
N#define ADC_CHANNEL_11_BITFIELD            (ADC_CHSELR_CHSEL11)
N#define ADC_CHANNEL_12_BITFIELD            (ADC_CHSELR_CHSEL12)
N#define ADC_CHANNEL_13_BITFIELD            (ADC_CHSELR_CHSEL13)
N#define ADC_CHANNEL_14_BITFIELD            (ADC_CHSELR_CHSEL14)
N#define ADC_CHANNEL_15_BITFIELD            (ADC_CHSELR_CHSEL15)
N#define ADC_CHANNEL_16_BITFIELD            (ADC_CHSELR_CHSEL16)
N#define ADC_CHANNEL_17_BITFIELD            (ADC_CHSELR_CHSEL17)
N#define ADC_CHANNEL_18_BITFIELD            (ADC_CHSELR_CHSEL18)
N#define ADC_CHANNEL_19_BITFIELD            (ADC_CHSELR_CHSEL19)
N#define ADC_CHANNEL_20_BITFIELD            (ADC_CHSELR_CHSEL20)
N#define ADC_CHANNEL_21_BITFIELD            (ADC_CHSELR_CHSEL21)
N
N
N/* Internal mask for ADC analog watchdog:                                     */
N/* To select into literals MS32_ADC_AWD_CHANNELx_xxx the relevant bits for:     */
N/* (concatenation of multiple bits used in different analog watchdogs,        */
N/* (feature of several watchdogs not available on all MS32 families)).       */
N/* - analog watchdog 1: monitored channel defined by number,                  */
N/*   selection of ADC group (ADC group regular).                              */
N
N/* Internal register offset for ADC analog watchdog channel configuration */
N#define ADC_AWD_CR1_REGOFFSET              (0x00000000U)
N
N#define ADC_AWD_CRX_REGOFFSET_MASK         (ADC_AWD_CR1_REGOFFSET)
N
N#define ADC_AWD_CR1_CHANNEL_MASK           (ADC_CFGR1_AWDCH | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)
N#define ADC_AWD_CR_ALL_CHANNEL_MASK        (ADC_AWD_CR1_CHANNEL_MASK)
N
N/* Internal register offset for ADC analog watchdog threshold configuration */
N#define ADC_AWD_TR1_REGOFFSET              (ADC_AWD_CR1_REGOFFSET)
N#define ADC_AWD_TRX_REGOFFSET_MASK         (ADC_AWD_TR1_REGOFFSET)
N
N
N/* ADC registers bits positions */
N#define ADC_CFGR1_RES_BITOFFSET_POS        ( 3U) /* Value equivalent to POSITION_VAL(ADC_CFGR1_RES) */
N#define ADC_CFGR1_AWDSGL_BITOFFSET_POS     (22U) /* Value equivalent to POSITION_VAL(ADC_CFGR1_AWDSGL) */
N#define ADC_TR_HT_BITOFFSET_POS            (16U) /* Value equivalent to POSITION_VAL(ADC_TR_HT) */
N#define ADC_CHSELR_CHSEL0_BITOFFSET_POS    ( 0U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL0) */
N#define ADC_CHSELR_CHSEL1_BITOFFSET_POS    ( 1U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL1) */
N#define ADC_CHSELR_CHSEL2_BITOFFSET_POS    ( 2U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL2) */
N#define ADC_CHSELR_CHSEL3_BITOFFSET_POS    ( 3U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL3) */
N#define ADC_CHSELR_CHSEL4_BITOFFSET_POS    ( 4U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL4) */
N#define ADC_CHSELR_CHSEL5_BITOFFSET_POS    ( 5U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL5) */
N#define ADC_CHSELR_CHSEL6_BITOFFSET_POS    ( 6U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL6) */
N#define ADC_CHSELR_CHSEL7_BITOFFSET_POS    ( 7U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL7) */
N#define ADC_CHSELR_CHSEL8_BITOFFSET_POS    ( 8U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL8) */
N#define ADC_CHSELR_CHSEL9_BITOFFSET_POS    ( 9U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL9) */
N#define ADC_CHSELR_CHSEL10_BITOFFSET_POS   (10U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL10) */
N#define ADC_CHSELR_CHSEL11_BITOFFSET_POS   (11U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL11) */
N#define ADC_CHSELR_CHSEL12_BITOFFSET_POS   (12U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL12) */
N#define ADC_CHSELR_CHSEL13_BITOFFSET_POS   (13U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL13) */
N#define ADC_CHSELR_CHSEL14_BITOFFSET_POS   (14U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL14) */
N#define ADC_CHSELR_CHSEL15_BITOFFSET_POS   (15U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL15) */
N#define ADC_CHSELR_CHSEL16_BITOFFSET_POS   (16U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL16) */
N#define ADC_CHSELR_CHSEL17_BITOFFSET_POS   (17U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL17) */
N#define ADC_CHSELR_CHSEL18_BITOFFSET_POS   (18U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL18) */
N#define ADC_CHSELR_CHSEL19_BITOFFSET_POS   (19U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL19) */
N#define ADC_CHSELR_CHSEL20_BITOFFSET_POS   (20U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL20) */
N#define ADC_CHSELR_CHSEL21_BITOFFSET_POS   (21U) /* Value equivalent to POSITION_VAL(ADC_CHSELR_CHSEL21) */
N
N
N/* ADC registers bits groups */
N#define ADC_CR_BITS_PROPERTY_RS            (ADC_CR_ADCAL | ADC_CR_ADSTP | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN) /* ADC register CR bits with HW property "rs": Software can read as well as set this bit. Writing '0' has no effect on the bit value. */
N
N
N/* ADC internal channels related definitions */
N/* Internal voltage reference VrefInt */
N#define VREFINT_CAL_ADDR                   ((uint16_t*) (0x1FFFF7BAU)) /* Internal voltage reference, address of parameter VREFINT_CAL: VrefInt ADC raw data acquired at temperature 30 DegC (tolerance: +-5 DegC), Vref+ = 3.3 V (tolerance: +-10 mV). */
N#define VREFINT_CAL_VREF                   ( 3300U)                    /* Analog voltage reference (Vref+) value with which temperature sensor has been calibrated in production (tolerance: +-10 mV) (unit: mV). */
N
N/* Temperature sensor */
N#define TEMPSENSOR_CAL1_ADDR               ((uint16_t*) (0x1FFFF7B8U)) /* Internal temperature sensor, address of parameter TS_CAL1: On MS32F0, temperature sensor ADC raw data acquired at temperature  30 DegC (tolerance: +-5 DegC), Vref+ = 3.3 V (tolerance: +-10 mV). */
N#define TEMPSENSOR_CAL2_ADDR               ((uint16_t*) (0x1FFFF7C2U)) /* Internal temperature sensor, address of parameter TS_CAL2: On MS32F0, temperature sensor ADC raw data acquired at temperature 110 DegC (tolerance: +-5 DegC), Vref+ = 3.3 V (tolerance: +-10 mV). */
N#define TEMPSENSOR_CAL1_TEMP               (( int32_t)   30)           /* Internal temperature sensor, temperature at which temperature sensor has been calibrated in production for data into TEMPSENSOR_CAL1_ADDR (tolerance: +-5 DegC) (unit: DegC). */
N#define TEMPSENSOR_CAL2_TEMP               (( int32_t)  110)           /* Internal temperature sensor, temperature at which temperature sensor has been calibrated in production for data into TEMPSENSOR_CAL2_ADDR (tolerance: +-5 DegC) (unit: DegC). */
N#define TEMPSENSOR_CAL_VREFANALOG          ( 3300U)                    /* Analog voltage reference (Vref+) voltage with which temperature sensor has been calibrated in production (+-10 mV) (unit: mV). */
N
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup ADC_ES_INIT ADC Exported Init structure
N  * @{
N  */
N
N/**
N  * @brief  Structure definition of some features of ADC instance.
N  * @note   These parameters have an impact on ADC scope: ADC instance.
N  *         Refer to corresponding unitary functions into
N  *         @ref ADC_EF_Configuration_ADC_Instance .
N  * @note   The setting of these parameters by function @ref MS32_ADC_Init()
N  *         is conditioned to ADC state:
N  *         ADC instance must be disabled.
N  *         This condition is applied to all ADC features, for efficiency
N  *         and compatibility over all MS32 families. However, the different
N  *         features can be set under different ADC state conditions
N  *         (setting possible with ADC enabled without conversion on going,
N  *         ADC enabled with conversion on going, ...)
N  *         Each feature can be updated afterwards with a unitary function
N  *         and potentially with ADC in a different state than disabled,
N  *         refer to description of each function for setting
N  *         conditioned to ADC state.
N  */
Ntypedef struct {
N  uint32_t Clock;                       /*!< Set ADC instance clock source and prescaler.
N                                             This parameter can be a value of @ref ADC_EC_CLOCK_SOURCE
N                                             @note On this MS32 serie, this parameter has some clock ratio constraints:
N                                                   ADC clock synchronous (from PCLK) with prescaler 1 must be enabled only if PCLK has a 50% duty clock cycle
N                                                   (APB prescaler configured inside the RCC must be bypassed and the system clock must by 50% duty cycle).
N                                             This feature can be modified afterwards using unitary function @ref MS32_ADC_SetClock().
N                                             For more details, refer to description of this function. */
N  uint32_t Resolution;                  /*!< Set ADC resolution.
N                                             This parameter can be a value of @ref ADC_EC_RESOLUTION
N                                             This feature can be modified afterwards using unitary function @ref MS32_ADC_SetResolution(). */
N  uint32_t DataAlignment;               /*!< Set ADC conversion data alignment.
N                                             This parameter can be a value of @ref ADC_EC_DATA_ALIGN
N                                             This feature can be modified afterwards using unitary function @ref MS32_ADC_SetDataAlignment(). */
N  uint32_t LowPowerMode;                /*!< Set ADC low power mode.
N                                             This parameter can be a value of @ref ADC_EC_LP_MODE
N                                             This feature can be modified afterwards using unitary function @ref MS32_ADC_SetLowPowerMode(). */
N} MS32_ADC_InitTypeDef;
N
N/**
N  * @brief  Structure definition of some features of ADC group regular.
N  * @note   These parameters have an impact on ADC scope: ADC group regular.
N  *         Refer to corresponding unitary functions into
N  *         @ref ADC_EF_Configuration_ADC_Group_Regular
N  *         (functions with prefix "REG").
N  * @note   The setting of these parameters by function @ref MS32_ADC_REG_Init()
N  *         is conditioned to ADC state:
N  *         ADC instance must be disabled.
N  *         This condition is applied to all ADC features, for efficiency
N  *         and compatibility over all MS32 families. However, the different
N  *         features can be set under different ADC state conditions
N  *         (setting possible with ADC enabled without conversion on going,
N  *         ADC enabled with conversion on going, ...)
N  *         Each feature can be updated afterwards with a unitary function
N  *         and potentially with ADC in a different state than disabled,
N  *         refer to description of each function for setting
N  *         conditioned to ADC state.
N  */
Ntypedef struct {
N  uint32_t TriggerSource;               /*!< Set ADC group regular conversion trigger source: internal (SW start) or from external IP (timer event, external interrupt line).
N                                             This parameter can be a value of @ref ADC_EC_REG_TRIGGER_SOURCE
N                                             @note On this MS32 serie, setting trigger source to external trigger also set trigger polarity to rising edge
N                                                   (default setting for compatibility with some ADC on other MS32 families having this setting set by HW default value).
N                                                   In case of need to modify trigger edge, use function @ref MS32_ADC_REG_SetTriggerEdge().
N                                             This feature can be modified afterwards using unitary function @ref MS32_ADC_REG_SetTriggerSource(). */
N  uint32_t SequencerDiscont;            /*!< Set ADC group regular sequencer discontinuous mode: sequence subdivided and scan conversions interrupted every selected number of ranks.
N                                             This parameter can be a value of @ref ADC_EC_REG_SEQ_DISCONT_MODE
N                                             @note This parameter has an effect only if group regular sequencer is enabled
N                                                   (several ADC channels enabled in group regular sequencer).
N                                             This feature can be modified afterwards using unitary function @ref MS32_ADC_REG_SetSequencerDiscont(). */
N  uint32_t ContinuousMode;              /*!< Set ADC continuous conversion mode on ADC group regular, whether ADC conversions are performed in single mode (one conversion per trigger) or in continuous mode (after the first trigger, following conversions launched successively automatically).
N                                             This parameter can be a value of @ref ADC_EC_REG_CONTINUOUS_MODE
N                                             Note: It is not possible to enable both ADC group regular continuous mode and discontinuous mode.
N                                             This feature can be modified afterwards using unitary function @ref MS32_ADC_REG_SetContinuousMode(). */
N  uint32_t DMATransfer;                 /*!< Set ADC group regular conversion data transfer: no transfer or transfer by DMA, and DMA requests mode.
N                                             This parameter can be a value of @ref ADC_EC_REG_DMA_TRANSFER
N                                             This feature can be modified afterwards using unitary function @ref MS32_ADC_REG_SetDMATransfer(). */
N  uint32_t Overrun;                     /*!< Set ADC group regular behavior in case of overrun:
N                                             data preserved or overwritten.
N                                             This parameter can be a value of @ref ADC_EC_REG_OVR_DATA_BEHAVIOR
N                                             This feature can be modified afterwards using unitary function @ref MS32_ADC_REG_SetOverrun(). */
N} MS32_ADC_REG_InitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup ADC_EC_FLAG ADC flags
N  * @brief    Flags defines which can be used with MS32_ADC_ReadReg function
N  * @{
N  */
N#define MS32_ADC_FLAG_ADRDY                  ADC_ISR_ADRDY      /*!< ADC flag ADC instance ready */
N#define MS32_ADC_FLAG_EOC                    ADC_ISR_EOC        /*!< ADC flag ADC group regular end of unitary conversion */
N#define MS32_ADC_FLAG_EOS                    ADC_ISR_EOS        /*!< ADC flag ADC group regular end of sequence conversions */
N#define MS32_ADC_FLAG_OVR                    ADC_ISR_OVR        /*!< ADC flag ADC group regular overrun */
N#define MS32_ADC_FLAG_EOSMP                  ADC_ISR_EOSMP      /*!< ADC flag ADC group regular end of sampling phase */
N#define MS32_ADC_FLAG_AWD1                   ADC_ISR_AWD        /*!< ADC flag ADC analog watchdog 1 */
N
N#define MS32_ADC_FLAG_ALL                    (ADC_ISR_ADRDY | ADC_ISR_EOC | ADC_ISR_EOS | ADC_ISR_OVR | ADC_ISR_EOSMP | ADC_ISR_AWD)
N
N
N/** @defgroup ADC_EC_IT ADC interruptions for configuration (interruption enable or disable)
N  * @brief    IT defines which can be used with MS32_ADC_ReadReg and  MS32_ADC_WriteReg functions
N  * @{
N  */
N#define MS32_ADC_IT_ADRDY                    ADC_IER_ADRDYIE    /*!< ADC interruption ADC instance ready */
N#define MS32_ADC_IT_EOC                      ADC_IER_EOCIE      /*!< ADC interruption ADC group regular end of unitary conversion */
N#define MS32_ADC_IT_EOS                      ADC_IER_EOSEQIE    /*!< ADC interruption ADC group regular end of sequence conversions */
N#define MS32_ADC_IT_OVR                      ADC_IER_OVRIE      /*!< ADC interruption ADC group regular overrun */
N#define MS32_ADC_IT_EOSMP                    ADC_IER_EOSMPIE    /*!< ADC interruption ADC group regular end of sampling phase */
N#define MS32_ADC_IT_AWD1                     ADC_IER_AWDIE      /*!< ADC interruption ADC analog watchdog 1 */
N
N#define MS32_ADC_IT_ALL                      (ADC_IER_ADRDYIE | ADC_IER_EOCIE | ADC_IER_EOSEQIE | ADC_IER_OVRIE | ADC_IER_EOSMPIE | ADC_IER_AWDIE)
N
N
N/** @defgroup ADC_EC_REGISTERS  ADC registers compliant with specific purpose
N  * @{
N  */
N/* List of ADC registers intended to be used (most commonly) with             */
N/* DMA transfer.                                                              */
N/* Refer to function @ref MS32_ADC_DMA_GetRegAddr().                          */
N#define MS32_ADC_DMA_REG_REGULAR_DATA        (0x00000000U) /* ADC group regular conversion data register (corresponding to register DR) to be used with ADC configured in independent mode. Without DMA transfer, register accessed by LL function @ref MS32_ADC_REG_ReadConversionData32() and other functions @ref MS32_ADC_REG_ReadConversionDatax() */
N
N
N/** @defgroup ADC_EC_COMMON_PATH_INTERNAL  ADC common - Measurement path to internal channels
N  * @{
N  */
N/* Note: Other measurement paths to internal channels may be available        */
N/*       (connections to other peripherals).                                  */
N/*       If they are not listed below, they do not require any specific       */
N/*       path enable. In this case, Access to measurement path is done        */
N/*       only by selecting the corresponding ADC internal channel.            */
N#define MS32_ADC_PATH_INTERNAL_NONE          (0x00000000U)/*!< ADC measurement pathes all disabled */
N#define MS32_ADC_PATH_INTERNAL_VREFINT       (ADC_CCR_VREFEN)       /*!< ADC measurement path to internal channel VrefInt */
N#define MS32_ADC_PATH_INTERNAL_TEMPSENSOR    (ADC_CCR_TSEN)         /*!< ADC measurement path to internal channel temperature sensor */
N#define MS32_ADC_PATH_INTERNAL_VBAT          (ADC_CCR_VBATEN)       /*!< ADC measurement path to internal channel Vbat */
N
N/** @defgroup ADC_EC_CLOCK_SOURCE  ADC instance - Clock source
N  * @{
N  */
N#define MS32_ADC_CLOCK_SYNC_PCLK_DIV4        (ADC_CFGR2_CKMODE_1)   /*!< ADC synchronous clock derived from AHB clock divided by 4 */
N#define MS32_ADC_CLOCK_SYNC_PCLK_DIV2        (ADC_CFGR2_CKMODE_0)   /*!< ADC synchronous clock derived from AHB clock divided by 2 */
N#define MS32_ADC_CLOCK_ASYNC                 (0x00000000U)          /*!< ADC asynchronous clock. On this MS32 serie, asynchronous clock has no prescaler. */
N
N/** @defgroup ADC_EC_RESOLUTION  ADC instance - Resolution
N  * @{
N  */
N#define MS32_ADC_RESOLUTION_12B              (0x00000000U)                       /*!< ADC resolution 12 bits */
N#define MS32_ADC_RESOLUTION_10B              (                  ADC_CFGR1_RES_0) /*!< ADC resolution 10 bits */
N#define MS32_ADC_RESOLUTION_8B               (ADC_CFGR1_RES_1                  ) /*!< ADC resolution  8 bits */
N#define MS32_ADC_RESOLUTION_6B               (ADC_CFGR1_RES_1 | ADC_CFGR1_RES_0) /*!< ADC resolution  6 bits */
N
N/** @defgroup ADC_EC_DATA_ALIGN  ADC instance - Data alignment
N  * @{
N  */
N#define MS32_ADC_DATA_ALIGN_RIGHT            (0x00000000U)          /*!< ADC conversion data alignment: right aligned (alignment on data register LSB bit 0)*/
N#define MS32_ADC_DATA_ALIGN_LEFT             (ADC_CFGR1_ALIGN)      /*!< ADC conversion data alignment: left aligned (aligment on data register MSB bit 15)*/
N
N/** @defgroup ADC_EC_LP_MODE  ADC instance - Low power mode
N  * @{
N  */
N#define MS32_ADC_LP_MODE_NONE                (0x00000000U)                       /*!< No ADC low power mode activated */
N#define MS32_ADC_LP_AUTOWAIT                 (ADC_CFGR1_WAIT)                    /*!< ADC low power mode auto delay: Dynamic low power mode, ADC conversions are performed only when necessary (when previous ADC conversion data is read). See description with function @ref MS32_ADC_SetLowPowerMode(). */
N#define MS32_ADC_LP_AUTOPOWEROFF             (ADC_CFGR1_AUTOFF)                  /*!< ADC low power mode auto power-off: the ADC automatically powers-off after a ADC conversion and automatically wakes up when a new ADC conversion is triggered (with startup time between trigger and start of sampling). See description with function @ref MS32_ADC_SetLowPowerMode(). Note: On MS32F0, if enabled, this feature also turns off the ADC dedicated 14 MHz RC oscillator (HSI14) during auto wait phase. */
N#define MS32_ADC_LP_AUTOWAIT_AUTOPOWEROFF    (ADC_CFGR1_WAIT | ADC_CFGR1_AUTOFF) /*!< ADC low power modes auto wait and auto power-off combined. See description with function @ref MS32_ADC_SetLowPowerMode(). */
N
N/** @defgroup ADC_EC_GROUPS  ADC instance - Groups
N  * @{
N  */
N#define MS32_ADC_GROUP_REGULAR               (0x00000001U) /*!< ADC group regular (available on all MS32 devices) */
N
N/** @defgroup ADC_EC_CHANNEL  ADC instance - Channel number
N  * @{
N  */
N#define MS32_ADC_CHANNEL_0                   (ADC_CHANNEL_0_NUMBER  | ADC_CHANNEL_0_BITFIELD )  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN0  */
N#define MS32_ADC_CHANNEL_1                   (ADC_CHANNEL_1_NUMBER  | ADC_CHANNEL_1_BITFIELD )  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN1  */
N#define MS32_ADC_CHANNEL_2                   (ADC_CHANNEL_2_NUMBER  | ADC_CHANNEL_2_BITFIELD )  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN2  */
N#define MS32_ADC_CHANNEL_3                   (ADC_CHANNEL_3_NUMBER  | ADC_CHANNEL_3_BITFIELD )  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN3  */
N#define MS32_ADC_CHANNEL_4                   (ADC_CHANNEL_4_NUMBER  | ADC_CHANNEL_4_BITFIELD )  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN4  */
N#define MS32_ADC_CHANNEL_5                   (ADC_CHANNEL_5_NUMBER  | ADC_CHANNEL_5_BITFIELD )  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN5  */
N#define MS32_ADC_CHANNEL_6                   (ADC_CHANNEL_6_NUMBER  | ADC_CHANNEL_6_BITFIELD )  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN6  */
N#define MS32_ADC_CHANNEL_7                   (ADC_CHANNEL_7_NUMBER  | ADC_CHANNEL_7_BITFIELD )  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN7  */
N#define MS32_ADC_CHANNEL_8                   (ADC_CHANNEL_8_NUMBER  | ADC_CHANNEL_8_BITFIELD )  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN8  */
N#define MS32_ADC_CHANNEL_9                   (ADC_CHANNEL_9_NUMBER  | ADC_CHANNEL_9_BITFIELD )  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN9  */
N#define MS32_ADC_CHANNEL_10                  (ADC_CHANNEL_10_NUMBER | ADC_CHANNEL_10_BITFIELD)  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN10 */
N#define MS32_ADC_CHANNEL_11                  (ADC_CHANNEL_11_NUMBER | ADC_CHANNEL_11_BITFIELD)  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN11 */
N#define MS32_ADC_CHANNEL_12                  (ADC_CHANNEL_12_NUMBER | ADC_CHANNEL_12_BITFIELD)  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN12 */
N#define MS32_ADC_CHANNEL_13                  (ADC_CHANNEL_13_NUMBER | ADC_CHANNEL_13_BITFIELD)  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN13 */
N#define MS32_ADC_CHANNEL_14                  (ADC_CHANNEL_14_NUMBER | ADC_CHANNEL_14_BITFIELD)  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN14 */
N#define MS32_ADC_CHANNEL_15                  (ADC_CHANNEL_15_NUMBER | ADC_CHANNEL_15_BITFIELD)  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN15 */
N#define MS32_ADC_CHANNEL_16                  (ADC_CHANNEL_16_NUMBER | ADC_CHANNEL_16_BITFIELD)  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN16 */
N#define MS32_ADC_CHANNEL_17                  (ADC_CHANNEL_17_NUMBER | ADC_CHANNEL_17_BITFIELD)  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN17 */
N#define MS32_ADC_CHANNEL_18                  (ADC_CHANNEL_18_NUMBER | ADC_CHANNEL_18_BITFIELD)  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN18 */
N#define MS32_ADC_CHANNEL_19                  (ADC_CHANNEL_19_NUMBER | ADC_CHANNEL_19_BITFIELD)  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN19 */
N#define MS32_ADC_CHANNEL_20                  (ADC_CHANNEL_20_NUMBER | ADC_CHANNEL_20_BITFIELD)  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN20 */
N#define MS32_ADC_CHANNEL_21                  (ADC_CHANNEL_21_NUMBER | ADC_CHANNEL_21_BITFIELD)  /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN21 */
N#define MS32_ADC_CHANNEL_VREFINT             (MS32_ADC_CHANNEL_17 | ADC_CHANNEL_ID_INTERNAL_CH) /*!< ADC internal channel connected to VrefInt: Internal voltage reference. */
N#define MS32_ADC_CHANNEL_TEMPSENSOR          (MS32_ADC_CHANNEL_16 | ADC_CHANNEL_ID_INTERNAL_CH) /*!< ADC internal channel connected to Temperature sensor. */
N#define MS32_ADC_CHANNEL_VBAT                (MS32_ADC_CHANNEL_18 | ADC_CHANNEL_ID_INTERNAL_CH) /*!< ADC internal channel connected to Vbat/2: Vbat voltage through a divider ladder of factor 1/2 to have Vbat always below Vdda. */
N#define MS32_ADC_CHANNEL_OPAMP1              (MS32_ADC_CHANNEL_19 | ADC_CHANNEL_ID_INTERNAL_CH) /*!< ADC internal channel connected to operational amplifier1. */
N#define MS32_ADC_CHANNEL_OPAMP2              (MS32_ADC_CHANNEL_20 | ADC_CHANNEL_ID_INTERNAL_CH) /*!< ADC internal channel connected to operational amplifier2. */
N#define MS32_ADC_CHANNEL_OPAMP3              (MS32_ADC_CHANNEL_21 | ADC_CHANNEL_ID_INTERNAL_CH) /*!< ADC internal channel connected to operational amplifier3. */
N
N/** @defgroup ADC_EC_REG_TRIGGER_SOURCE  ADC group regular - Trigger source
N  * @{
N  */
N#define MS32_ADC_REG_TRIG_SOFTWARE           (0x00000000U)                                                             /*!< ADC group regular conversion trigger internal: SW start. */
N#define MS32_ADC_REG_TRIG_EXT_TIM1_TRGO      (ADC_REG_TRIG_EXT_EDGE_DEFAULT)                                           /*!< ADC group regular conversion trigger from external IP: TIM1 TRGO. Trigger edge set to rising edge (default setting). */
N#define MS32_ADC_REG_TRIG_EXT_TIM1_CH4       (ADC_CFGR1_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                      /*!< ADC group regular conversion trigger from external IP: TIM1 channel 4 event (capture compare: input capture or output capture). Trigger edge set to rising edge (default setting). */
N#define MS32_ADC_REG_TRIG_EXT_TIM2_TRGO      (ADC_CFGR1_EXTSEL_1 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                      /*!< ADC group regular conversion trigger from external IP: TIM2 TRGO. Trigger edge set to rising edge (default setting). */
N#define MS32_ADC_REG_TRIG_EXT_TIM3_TRGO      (ADC_CFGR1_EXTSEL_1 | ADC_CFGR1_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT) /*!< ADC group regular conversion trigger from external IP: TIM3 TRGO. Trigger edge set to rising edge (default setting). */
N#define MS32_ADC_REG_TRIG_EXT_TIM15_TRGO     (ADC_CFGR1_EXTSEL_2 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                      /*!< ADC group regular conversion trigger from external IP: TIM15 TRGO. Trigger edge set to rising edge (default setting). */
N
N/** @defgroup ADC_EC_REG_TRIGGER_EDGE  ADC group regular - Trigger edge
N  * @{
N  */
N#define MS32_ADC_REG_TRIG_EXT_RISING         (                    ADC_CFGR1_EXTEN_0) /*!< ADC group regular conversion trigger polarity set to rising edge */
N#define MS32_ADC_REG_TRIG_EXT_FALLING        (ADC_CFGR1_EXTEN_1                    ) /*!< ADC group regular conversion trigger polarity set to falling edge */
N#define MS32_ADC_REG_TRIG_EXT_RISINGFALLING  (ADC_CFGR1_EXTEN_1 | ADC_CFGR1_EXTEN_0) /*!< ADC group regular conversion trigger polarity set to both rising and falling edges */
N
N/** @defgroup ADC_EC_REG_CONTINUOUS_MODE  ADC group regular - Continuous mode
N* @{
N*/
N#define MS32_ADC_REG_CONV_SINGLE             (0x00000000U) /*!< ADC conversions are performed in single mode: one conversion per trigger */
N#define MS32_ADC_REG_CONV_CONTINUOUS         (ADC_CFGR1_CONT)        /*!< ADC conversions are performed in continuous mode: after the first trigger, following conversions launched successively automatically */
N
N/** @defgroup ADC_EC_REG_DMA_TRANSFER  ADC group regular - DMA transfer of ADC conversion data
N  * @{
N  */
N#define MS32_ADC_REG_DMA_TRANSFER_NONE       (0x00000000U)              /*!< ADC conversions are not transferred by DMA */
N#define MS32_ADC_REG_DMA_TRANSFER_LIMITED    (                   ADC_CFGR1_DMAEN) /*!< ADC conversion data are transferred by DMA, in limited mode (one shot mode): DMA transfer requests are stopped when number of DMA data transfers (number of ADC conversions) is reached. This ADC mode is intended to be used with DMA mode non-circular. */
N#define MS32_ADC_REG_DMA_TRANSFER_UNLIMITED  (ADC_CFGR1_DMACFG | ADC_CFGR1_DMAEN) /*!< ADC conversion data are transferred by DMA, in unlimited mode: DMA transfer requests are unlimited, whatever number of DMA data transferred (number of ADC conversions). This ADC mode is intended to be used with DMA mode circular. */
N
N/** @defgroup ADC_EC_REG_OVR_DATA_BEHAVIOR  ADC group regular - Overrun behavior on conversion data
N* @{
N*/
N#define MS32_ADC_REG_OVR_DATA_PRESERVED      (0x00000000U)/*!< ADC group regular behavior in case of overrun: data preserved */
N#define MS32_ADC_REG_OVR_DATA_OVERWRITTEN    (ADC_CFGR1_OVRMOD)     /*!< ADC group regular behavior in case of overrun: data overwritten */
N
N/** @defgroup ADC_EC_REG_SEQ_SCAN_DIRECTION  ADC group regular - Sequencer scan direction
N  * @{
N  */
N#define MS32_ADC_REG_SEQ_SCAN_DIR_FORWARD    (0x00000000U)/*!< ADC group regular sequencer scan direction forward: from lowest channel number to highest channel number (scan of all ranks, ADC conversion of ranks with channels enabled in sequencer). On some other MS32 families, this setting is not available and the default scan direction is forward. */
N#define MS32_ADC_REG_SEQ_SCAN_DIR_BACKWARD   (ADC_CFGR1_SCANDIR)    /*!< ADC group regular sequencer scan direction backward: from highest channel number to lowest channel number (scan of all ranks, ADC conversion of ranks with channels enabled in sequencer) */
N
N/** @defgroup ADC_EC_REG_SEQ_DISCONT_MODE  ADC group regular - Sequencer discontinuous mode
N  * @{
N  */
N#define MS32_ADC_REG_SEQ_DISCONT_DISABLE     (0x00000000U)                                                          /*!< ADC group regular sequencer discontinuous mode disable */
N#define MS32_ADC_REG_SEQ_DISCONT_1RANK       (ADC_CFGR1_DISCEN)                                                               /*!< ADC group regular sequencer discontinuous mode enable with sequence interruption every rank */
N
N/** @defgroup ADC_EC_CHANNEL_SAMPLINGTIME  Channel - Sampling time
N  * @{
N  */
N#define MS32_ADC_SAMPLINGTIME_1CYCLE_5       (0x00000000U)                               /*!< Sampling time 1.5 ADC clock cycle */
N#define MS32_ADC_SAMPLINGTIME_7CYCLES_5      (ADC_SMPR_SMP_0)                                      /*!< Sampling time 7.5 ADC clock cycles */
N#define MS32_ADC_SAMPLINGTIME_13CYCLES_5     (ADC_SMPR_SMP_1)                                      /*!< Sampling time 13.5 ADC clock cycles */
N#define MS32_ADC_SAMPLINGTIME_28CYCLES_5     (ADC_SMPR_SMP_1 | ADC_SMPR_SMP_0)                     /*!< Sampling time 28.5 ADC clock cycles */
N#define MS32_ADC_SAMPLINGTIME_41CYCLES_5     (ADC_SMPR_SMP_2)                                      /*!< Sampling time 41.5 ADC clock cycles */
N#define MS32_ADC_SAMPLINGTIME_55CYCLES_5     (ADC_SMPR_SMP_2 | ADC_SMPR_SMP_0)                     /*!< Sampling time 55.5 ADC clock cycles */
N#define MS32_ADC_SAMPLINGTIME_71CYCLES_5     (ADC_SMPR_SMP_2 | ADC_SMPR_SMP_1)                     /*!< Sampling time 71.5 ADC clock cycles */
N#define MS32_ADC_SAMPLINGTIME_239CYCLES_5    (ADC_SMPR_SMP_2 | ADC_SMPR_SMP_1 | ADC_SMPR_SMP_0)    /*!< Sampling time 239.5 ADC clock cycles */
N
N/** @defgroup ADC_EC_AWD_NUMBER Analog watchdog - Analog watchdog number
N  * @{
N  */
N#define MS32_ADC_AWD1                        (ADC_AWD_CR1_CHANNEL_MASK  | ADC_AWD_CR1_REGOFFSET) /*!< ADC analog watchdog number 1 */
N
N/** @defgroup ADC_EC_AWD_CHANNELS  Analog watchdog - Monitored channels
N  * @{
N  */
N#define MS32_ADC_AWD_DISABLE                 (0x00000000U)                                                                                /*!< ADC analog watchdog monitoring disabled */
N#define MS32_ADC_AWD_AMS32_CHANNELS_REG      (                                                    ADC_CFGR1_AWDEN                     )   /*!< ADC analog watchdog monitoring of all channels, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_0_REG           ((MS32_ADC_CHANNEL_0  & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN0, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_1_REG           ((MS32_ADC_CHANNEL_1  & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN1, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_2_REG           ((MS32_ADC_CHANNEL_2  & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN2, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_3_REG           ((MS32_ADC_CHANNEL_3  & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN3, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_4_REG           ((MS32_ADC_CHANNEL_4  & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN4, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_5_REG           ((MS32_ADC_CHANNEL_5  & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN5, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_6_REG           ((MS32_ADC_CHANNEL_6  & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN6, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_7_REG           ((MS32_ADC_CHANNEL_7  & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN7, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_8_REG           ((MS32_ADC_CHANNEL_8  & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN8, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_9_REG           ((MS32_ADC_CHANNEL_9  & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN9, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_10_REG          ((MS32_ADC_CHANNEL_10 & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN10, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_11_REG          ((MS32_ADC_CHANNEL_11 & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN11, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_12_REG          ((MS32_ADC_CHANNEL_12 & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN12, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_13_REG          ((MS32_ADC_CHANNEL_13 & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN13, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_14_REG          ((MS32_ADC_CHANNEL_14 & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN14, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_15_REG          ((MS32_ADC_CHANNEL_15 & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN15, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_16_REG          ((MS32_ADC_CHANNEL_16 & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN16, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_17_REG          ((MS32_ADC_CHANNEL_17 & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN17, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_18_REG          ((MS32_ADC_CHANNEL_18 & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN18, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_19_REG          ((MS32_ADC_CHANNEL_19 & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN19, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_20_REG          ((MS32_ADC_CHANNEL_20 & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN20, converted by group regular only */
N#define MS32_ADC_AWD_CHANNEL_21_REG          ((MS32_ADC_CHANNEL_21 & ADC_CHANNEL_ID_MASK)         | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN21, converted by group regular only */
N#define MS32_ADC_AWD_CH_VREFINT_REG          ((MS32_ADC_CHANNEL_VREFINT    & ADC_CHANNEL_ID_MASK) | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC internal channel connected to VrefInt: Internal voltage reference, converted by group regular only */
N#define MS32_ADC_AWD_CH_TEMPSENSOR_REG       ((MS32_ADC_CHANNEL_TEMPSENSOR & ADC_CHANNEL_ID_MASK) | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC internal channel connected to Temperature sensor, converted by group regular only */
N#define MS32_ADC_AWD_CH_VBAT_REG             ((MS32_ADC_CHANNEL_VBAT       & ADC_CHANNEL_ID_MASK) | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC internal channel connected to Vbat/3: Vbat voltage through a divider ladder of factor 1/3 to have Vbat always below Vdda, converted by group regular only */
N#define MS32_ADC_AWD_CH_OPAMP1_REG           ((MS32_ADC_CHANNEL_OPAMP1     & ADC_CHANNEL_ID_MASK) | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC internal channel connected to operational amplifier1, converted by group regular only */
N#define MS32_ADC_AWD_CH_OPAMP2_REG           ((MS32_ADC_CHANNEL_OPAMP2     & ADC_CHANNEL_ID_MASK) | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC internal channel connected to operational amplifier2, converted by group regular only */
N#define MS32_ADC_AWD_CH_OPAMP3_REG           ((MS32_ADC_CHANNEL_OPAMP3     & ADC_CHANNEL_ID_MASK) | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)   /*!< ADC analog watchdog monitoring of ADC internal channel connected to operational amplifier3, converted by group regular only */
N
N/** @defgroup ADC_EC_AWD_THRESHOLDS  Analog watchdog - Thresholds
N  * @{
N  */
N#define MS32_ADC_AWD_THRESHOLD_HIGH          (ADC_TR_HT            )     /*!< ADC analog watchdog threshold high */
N#define MS32_ADC_AWD_THRESHOLD_LOW           (            ADC_TR_LT)     /*!< ADC analog watchdog threshold low */
N#define MS32_ADC_AWD_THRESHOLDS_HIGH_LOW     (ADC_TR_HT | ADC_TR_LT)     /*!< ADC analog watchdog both thresholds high and low concatenated into the same data */
N
N
N/** @defgroup ADC_EC_HW_DELAYS  Definitions of ADC hardware constraints delays
N  * @note   Only ADC IP HW delays are defined in ADC LL driver driver,
N  *         not timeout values.
N  *         For details on delays values, refer to descriptions in source code
N  *         above each literal definition.
N  * @{
N  */
N
N/* Note: Only ADC IP HW delays are defined in ADC LL driver driver,           */
N/*       not timeout values.                                                  */
N/*       Timeout values for ADC operations are dependent to device clock      */
N/*       configuration (system clock versus ADC clock),                       */
N/*       and therefore must be defined in user application.                   */
N/*       Indications for estimation of ADC timeout delays, for this           */
N/*       MS32 serie:                                                         */
N/*       - ADC calibration time: maximum delay is 83/fADC.                    */
N/*         (refer to device datasheet, parameter "tCAL")                      */
N/*       - ADC enable time: maximum delay is 1 conversion cycle.              */
N/*         (refer to device datasheet, parameter "tSTAB")                     */
N/*       - ADC disable time: maximum delay should be a few ADC clock cycles   */
N/*       - ADC stop conversion time: maximum delay should be a few ADC clock  */
N/*         cycles                                                             */
N/*       - ADC conversion time: duration depending on ADC clock and ADC       */
N/*         configuration.                                                     */
N/*         (refer to device reference manual, section "Timing")               */
N
N
N/* Delay for internal voltage reference stabilization time.                   */
N/* Delay set to maximum value (refer to device datasheet,                     */
N/* parameter "tSTART").                                                       */
N/* Unit: us                                                                   */
N#define MS32_ADC_DELAY_VREFINT_STAB_US       (  10U)  /*!< Delay for internal voltage reference stabilization time */
N
N/* Delay for temperature sensor stabilization time.                           */
N/* Literal set to maximum value (refer to device datasheet,                   */
N/* parameter "tSTART").                                                       */
N/* Unit: us                                                                   */
N#define MS32_ADC_DELAY_TEMPSENSOR_STAB_US    (  10U)  /*!< Delay for temperature sensor stabilization time */
N
N/* Delay required between ADC end of calibration and ADC enable.              */
N/* Note: On this MS32 serie, a minimum number of ADC clock cycles            */
N/*       are required between ADC end of calibration and ADC enable.          */
N/*       Wait time can be computed in user application by waiting for the     */
N/*       equivalent number of CPU cycles, by taking into account              */
N/*       ratio of CPU clock versus ADC clock prescalers.                      */
N/* Unit: ADC clock cycles.                                                    */
N#define MS32_ADC_DELAY_CALIB_ENABLE_ADC_CYCLES ( 2U)  /*!< Delay required between ADC end of calibration and ADC enable */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup ADC_MS32_EM_WRITE_READ Common write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in ADC register
N  * @param  __INSTANCE__ ADC Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_ADC_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in ADC register
N  * @param  __INSTANCE__ ADC Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_ADC_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N
N
N/** @defgroup ADC_MS32_EM_HELPER_MACRO ADC helper macro
N  * @{
N  */
N
N/**
N  * @brief  Helper macro to get ADC channel number in decimal format
N  *         from literals MS32_ADC_CHANNEL_x.
N  * @note   Example:
N  *           __MS32_ADC_CHANNEL_TO_DECIMAL_NB(MS32_ADC_CHANNEL_4)
N  *           will return decimal number "4".
N  * @note   The input can be a value from functions where a channel
N  *         number is returned, either defined with number
N  *         or with bitfield (only one bit must be set).
N  * @param  __CHANNEL__ This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_CHANNEL_0
N  *         @arg @ref MS32_ADC_CHANNEL_1
N  *         @arg @ref MS32_ADC_CHANNEL_2
N  *         @arg @ref MS32_ADC_CHANNEL_3
N  *         @arg @ref MS32_ADC_CHANNEL_4
N  *         @arg @ref MS32_ADC_CHANNEL_5
N  *         @arg @ref MS32_ADC_CHANNEL_6
N  *         @arg @ref MS32_ADC_CHANNEL_7
N  *         @arg @ref MS32_ADC_CHANNEL_8
N  *         @arg @ref MS32_ADC_CHANNEL_9
N  *         @arg @ref MS32_ADC_CHANNEL_10
N  *         @arg @ref MS32_ADC_CHANNEL_11
N  *         @arg @ref MS32_ADC_CHANNEL_12
N  *         @arg @ref MS32_ADC_CHANNEL_13
N  *         @arg @ref MS32_ADC_CHANNEL_14
N  *         @arg @ref MS32_ADC_CHANNEL_15
N  *         @arg @ref MS32_ADC_CHANNEL_16
N  *         @arg @ref MS32_ADC_CHANNEL_17
N  *         @arg @ref MS32_ADC_CHANNEL_18
N  *         @arg @ref MS32_ADC_CHANNEL_19
N  *         @arg @ref MS32_ADC_CHANNEL_20
N  *         @arg @ref MS32_ADC_CHANNEL_21
N  *         @arg @ref MS32_ADC_CHANNEL_VREFINT
N  *         @arg @ref MS32_ADC_CHANNEL_TEMPSENSOR
N  *         @arg @ref MS32_ADC_CHANNEL_VBAT
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP1
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP2
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP3
N  *
N  * @retval Value between Min_Data=0 and Max_Data=18
N  */
N#define __MS32_ADC_CHANNEL_TO_DECIMAL_NB(__CHANNEL__)                                                                   \
N  ((((__CHANNEL__) & ADC_CHANNEL_ID_BITFIELD_MASK) == 0U)                                                               \
N    ? (                                                                                                                 \
N       ((__CHANNEL__) & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS                              \
N      )                                                                                                                 \
N      :                                                                                                                 \
N      (                                                                                                                 \
N       (((__CHANNEL__) & ADC_CHSELR_CHSEL0) == ADC_CHSELR_CHSEL0) ? (0U) :                                              \
N        (                                                                                                               \
N         (((__CHANNEL__) & ADC_CHSELR_CHSEL1) == ADC_CHSELR_CHSEL1) ? (1U) :                                            \
N          (                                                                                                             \
N           (((__CHANNEL__) & ADC_CHSELR_CHSEL2) == ADC_CHSELR_CHSEL2) ? (2U) :                                          \
N            (                                                                                                           \
N             (((__CHANNEL__) & ADC_CHSELR_CHSEL3) == ADC_CHSELR_CHSEL3) ? (3U) :                                        \
N              (                                                                                                         \
N               (((__CHANNEL__) & ADC_CHSELR_CHSEL4) == ADC_CHSELR_CHSEL4) ? (4U) :                                      \
N                (                                                                                                       \
N                 (((__CHANNEL__) & ADC_CHSELR_CHSEL5) == ADC_CHSELR_CHSEL5) ? (5U) :                                    \
N                  (                                                                                                     \
N                   (((__CHANNEL__) & ADC_CHSELR_CHSEL6) == ADC_CHSELR_CHSEL6) ? (6U) :                                  \
N                    (                                                                                                   \
N                     (((__CHANNEL__) & ADC_CHSELR_CHSEL7) == ADC_CHSELR_CHSEL7) ? (7U) :                                \
N                      (                                                                                                 \
N                       (((__CHANNEL__) & ADC_CHSELR_CHSEL8) == ADC_CHSELR_CHSEL8) ? (8U) :                              \
N                        (                                                                                               \
N                         (((__CHANNEL__) & ADC_CHSELR_CHSEL9) == ADC_CHSELR_CHSEL9) ? (9U) :                            \
N                          (                                                                                             \
N                           (((__CHANNEL__) & ADC_CHSELR_CHSEL10) == ADC_CHSELR_CHSEL10) ? (10U) :                       \
N                            (                                                                                           \
N                             (((__CHANNEL__) & ADC_CHSELR_CHSEL11) == ADC_CHSELR_CHSEL11) ? (11U) :                     \
N                              (                                                                                         \
N                               (((__CHANNEL__) & ADC_CHSELR_CHSEL12) == ADC_CHSELR_CHSEL12) ? (12U) :                   \
N                                (                                                                                       \
N                                 (((__CHANNEL__) & ADC_CHSELR_CHSEL13) == ADC_CHSELR_CHSEL13) ? (13U) :                 \
N                                  (                                                                                     \
N                                   (((__CHANNEL__) & ADC_CHSELR_CHSEL14) == ADC_CHSELR_CHSEL14) ? (14U) :               \
N                                    (                                                                                   \
N                                     (((__CHANNEL__) & ADC_CHSELR_CHSEL15) == ADC_CHSELR_CHSEL15) ? (15U) :             \
N                                      (                                                                                 \
N                                       (((__CHANNEL__) & ADC_CHSELR_CHSEL16) == ADC_CHSELR_CHSEL16) ? (16U) :           \
N                                        (                                                                               \
N                                         (((__CHANNEL__) & ADC_CHSELR_CHSEL17) == ADC_CHSELR_CHSEL17) ? (17U) :         \
N                                          (                                                                             \
N                                           (((__CHANNEL__) & ADC_CHSELR_CHSEL18) == ADC_CHSELR_CHSEL18) ? (18U) :       \
N                                            (                                                                           \
N                                             (((__CHANNEL__) & ADC_CHSELR_CHSEL19) == ADC_CHSELR_CHSEL19) ? (19U) :     \
N                                              (                                                                         \
N                                               (((__CHANNEL__) & ADC_CHSELR_CHSEL20) == ADC_CHSELR_CHSEL20) ? (20U) :   \
N                                                (                                                                       \
N                                                 (((__CHANNEL__) & ADC_CHSELR_CHSEL21) == ADC_CHSELR_CHSEL21) ? (21U) : \
N                                                  (0U)                                                                  \
N                                                )                                                                       \
N                                              )                                                                         \
N                                            )                                                                           \
N                                          )                                                                             \
N                                        )                                                                               \
N                                      )                                                                                 \
N                                    )                                                                                   \
N                                  )                                                                                     \
N                                )                                                                                       \
N                              )                                                                                         \
N                            )                                                                                           \
N                          )                                                                                             \
N                        )                                                                                               \
N                      )                                                                                                 \
N                    )                                                                                                   \
N                  )                                                                                                     \
N                )                                                                                                       \
N              )                                                                                                         \
N            )                                                                                                           \
N          )                                                                                                             \
N        )                                                                                                               \
N      )                                                                                                                 \
N  )      
X#define __MS32_ADC_CHANNEL_TO_DECIMAL_NB(__CHANNEL__)                                                                     ((((__CHANNEL__) & ADC_CHANNEL_ID_BITFIELD_MASK) == 0U)                                                                   ? (                                                                                                                        ((__CHANNEL__) & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS                                    )                                                                                                                       :                                                                                                                       (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL0) == ADC_CHSELR_CHSEL0) ? (0U) :                                                      (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL1) == ADC_CHSELR_CHSEL1) ? (1U) :                                                      (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL2) == ADC_CHSELR_CHSEL2) ? (2U) :                                                      (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL3) == ADC_CHSELR_CHSEL3) ? (3U) :                                                      (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL4) == ADC_CHSELR_CHSEL4) ? (4U) :                                                      (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL5) == ADC_CHSELR_CHSEL5) ? (5U) :                                                      (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL6) == ADC_CHSELR_CHSEL6) ? (6U) :                                                      (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL7) == ADC_CHSELR_CHSEL7) ? (7U) :                                                      (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL8) == ADC_CHSELR_CHSEL8) ? (8U) :                                                      (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL9) == ADC_CHSELR_CHSEL9) ? (9U) :                                                      (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL10) == ADC_CHSELR_CHSEL10) ? (10U) :                                                   (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL11) == ADC_CHSELR_CHSEL11) ? (11U) :                                                   (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL12) == ADC_CHSELR_CHSEL12) ? (12U) :                                                   (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL13) == ADC_CHSELR_CHSEL13) ? (13U) :                                                   (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL14) == ADC_CHSELR_CHSEL14) ? (14U) :                                                   (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL15) == ADC_CHSELR_CHSEL15) ? (15U) :                                                   (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL16) == ADC_CHSELR_CHSEL16) ? (16U) :                                                   (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL17) == ADC_CHSELR_CHSEL17) ? (17U) :                                                   (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL18) == ADC_CHSELR_CHSEL18) ? (18U) :                                                   (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL19) == ADC_CHSELR_CHSEL19) ? (19U) :                                                   (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL20) == ADC_CHSELR_CHSEL20) ? (20U) :                                                   (                                                                                                                        (((__CHANNEL__) & ADC_CHSELR_CHSEL21) == ADC_CHSELR_CHSEL21) ? (21U) :                                                   (0U)                                                                                                                  )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                     )                                                                                                                   )      
N
N/**
N  * @brief  Helper macro to get ADC channel in literal format MS32_ADC_CHANNEL_x
N  *         from number in decimal format.
N  * @note   Example:
N  *           __MS32_ADC_DECIMAL_NB_TO_CHANNEL(4)
N  *           will return a data equivalent to "MS32_ADC_CHANNEL_4".
N  * @param  __DECIMAL_NB__ Value between Min_Data=0 and Max_Data=18
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_CHANNEL_0
N  *         @arg @ref MS32_ADC_CHANNEL_1
N  *         @arg @ref MS32_ADC_CHANNEL_2
N  *         @arg @ref MS32_ADC_CHANNEL_3
N  *         @arg @ref MS32_ADC_CHANNEL_4
N  *         @arg @ref MS32_ADC_CHANNEL_5
N  *         @arg @ref MS32_ADC_CHANNEL_6
N  *         @arg @ref MS32_ADC_CHANNEL_7
N  *         @arg @ref MS32_ADC_CHANNEL_8
N  *         @arg @ref MS32_ADC_CHANNEL_9
N  *         @arg @ref MS32_ADC_CHANNEL_10
N  *         @arg @ref MS32_ADC_CHANNEL_11
N  *         @arg @ref MS32_ADC_CHANNEL_12
N  *         @arg @ref MS32_ADC_CHANNEL_13
N  *         @arg @ref MS32_ADC_CHANNEL_14
N  *         @arg @ref MS32_ADC_CHANNEL_15
N  *         @arg @ref MS32_ADC_CHANNEL_16
N  *         @arg @ref MS32_ADC_CHANNEL_17
N  *         @arg @ref MS32_ADC_CHANNEL_18
N  *         @arg @ref MS32_ADC_CHANNEL_19
N  *         @arg @ref MS32_ADC_CHANNEL_20
N  *         @arg @ref MS32_ADC_CHANNEL_21
N  *         @arg @ref MS32_ADC_CHANNEL_VREFINT    (1)
N  *         @arg @ref MS32_ADC_CHANNEL_TEMPSENSOR (1)
N  *         @arg @ref MS32_ADC_CHANNEL_VBAT       (1)
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP1     (1)
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP2     (1)
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP3     (1)
N  *
N  *         (1) For ADC channel read back from ADC register,
N  *             comparison with internal channel parameter to be done
N  *             using helper macro @ref __MS32_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
N  */
N#define __MS32_ADC_DECIMAL_NB_TO_CHANNEL(__DECIMAL_NB__)                         \
N  (                                                                            \
N   ((__DECIMAL_NB__) << ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) |                 \
N   (ADC_CHSELR_CHSEL0 << (__DECIMAL_NB__))                                     \
N  )
X#define __MS32_ADC_DECIMAL_NB_TO_CHANNEL(__DECIMAL_NB__)                           (                                                                               ((__DECIMAL_NB__) << ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) |                    (ADC_CHSELR_CHSEL0 << (__DECIMAL_NB__))                                       )
N
N/**
N  * @brief  Helper macro to determine whether the selected channel
N  *         corresponds to literal definitions of driver.
N  * @note   The different literal definitions of ADC channels are:
N  *         - ADC internal channel:
N  *           MS32_ADC_CHANNEL_VREFINT, MS32_ADC_CHANNEL_TEMPSENSOR, ...
N  *         - ADC external channel (channel connected to a GPIO pin):
N  *           MS32_ADC_CHANNEL_1, MS32_ADC_CHANNEL_2, ...
N  * @note   The channel parameter must be a value defined from literal
N  *         definition of a ADC internal channel (MS32_ADC_CHANNEL_VREFINT,
N  *         MS32_ADC_CHANNEL_TEMPSENSOR, ...),
N  *         ADC external channel (MS32_ADC_CHANNEL_1, MS32_ADC_CHANNEL_2, ...),
N  *         must not be a value from functions where a channel number is
N  *         returned from ADC registers,
N  *         because internal and external channels share the same channel
N  *         number in ADC registers. The differentiation is made only with
N  *         parameters definitions of driver.
N  * @param  __CHANNEL__ This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_CHANNEL_0
N  *         @arg @ref MS32_ADC_CHANNEL_1
N  *         @arg @ref MS32_ADC_CHANNEL_2
N  *         @arg @ref MS32_ADC_CHANNEL_3
N  *         @arg @ref MS32_ADC_CHANNEL_4
N  *         @arg @ref MS32_ADC_CHANNEL_5
N  *         @arg @ref MS32_ADC_CHANNEL_6
N  *         @arg @ref MS32_ADC_CHANNEL_7
N  *         @arg @ref MS32_ADC_CHANNEL_8
N  *         @arg @ref MS32_ADC_CHANNEL_9
N  *         @arg @ref MS32_ADC_CHANNEL_10
N  *         @arg @ref MS32_ADC_CHANNEL_11
N  *         @arg @ref MS32_ADC_CHANNEL_12
N  *         @arg @ref MS32_ADC_CHANNEL_13
N  *         @arg @ref MS32_ADC_CHANNEL_14
N  *         @arg @ref MS32_ADC_CHANNEL_15
N  *         @arg @ref MS32_ADC_CHANNEL_16
N  *         @arg @ref MS32_ADC_CHANNEL_17
N  *         @arg @ref MS32_ADC_CHANNEL_18
N  *         @arg @ref MS32_ADC_CHANNEL_19
N  *         @arg @ref MS32_ADC_CHANNEL_20
N  *         @arg @ref MS32_ADC_CHANNEL_21
N  *         @arg @ref MS32_ADC_CHANNEL_VREFINT
N  *         @arg @ref MS32_ADC_CHANNEL_TEMPSENSOR
N  *         @arg @ref MS32_ADC_CHANNEL_VBAT
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP1
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP2
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP3
N  *
N  * @retval Value "0" if the channel corresponds to a parameter definition of a ADC external channel (channel connected to a GPIO pin).
N  *         Value "1" if the channel corresponds to a parameter definition of a ADC internal channel.
N  */
N#define __MS32_ADC_IS_CHANNEL_INTERNAL(__CHANNEL__)                              \
N  (((__CHANNEL__) & ADC_CHANNEL_ID_INTERNAL_CH_MASK) != 0U)
X#define __MS32_ADC_IS_CHANNEL_INTERNAL(__CHANNEL__)                                (((__CHANNEL__) & ADC_CHANNEL_ID_INTERNAL_CH_MASK) != 0U)
N
N/**
N  * @brief  Helper macro to convert a channel defined from parameter
N  *         definition of a ADC internal channel (MS32_ADC_CHANNEL_VREFINT,
N  *         MS32_ADC_CHANNEL_TEMPSENSOR, ...),
N  *         to its equivalent parameter definition of a ADC external channel
N  *         (MS32_ADC_CHANNEL_1, MS32_ADC_CHANNEL_2, ...).
N  * @note   The channel parameter can be, additionally to a value
N  *         defined from parameter definition of a ADC internal channel
N  *         (MS32_ADC_CHANNEL_VREFINT, MS32_ADC_CHANNEL_TEMPSENSOR, ...),
N  *         a value defined from parameter definition of
N  *         ADC external channel (MS32_ADC_CHANNEL_1, MS32_ADC_CHANNEL_2, ...)
N  *         or a value from functions where a channel number is returned
N  *         from ADC registers.
N  * @param  __CHANNEL__ This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_CHANNEL_0
N  *         @arg @ref MS32_ADC_CHANNEL_1
N  *         @arg @ref MS32_ADC_CHANNEL_2
N  *         @arg @ref MS32_ADC_CHANNEL_3
N  *         @arg @ref MS32_ADC_CHANNEL_4
N  *         @arg @ref MS32_ADC_CHANNEL_5
N  *         @arg @ref MS32_ADC_CHANNEL_6
N  *         @arg @ref MS32_ADC_CHANNEL_7
N  *         @arg @ref MS32_ADC_CHANNEL_8
N  *         @arg @ref MS32_ADC_CHANNEL_9
N  *         @arg @ref MS32_ADC_CHANNEL_10
N  *         @arg @ref MS32_ADC_CHANNEL_11
N  *         @arg @ref MS32_ADC_CHANNEL_12
N  *         @arg @ref MS32_ADC_CHANNEL_13
N  *         @arg @ref MS32_ADC_CHANNEL_14
N  *         @arg @ref MS32_ADC_CHANNEL_15
N  *         @arg @ref MS32_ADC_CHANNEL_16
N  *         @arg @ref MS32_ADC_CHANNEL_17
N  *         @arg @ref MS32_ADC_CHANNEL_18
N  *         @arg @ref MS32_ADC_CHANNEL_19
N  *         @arg @ref MS32_ADC_CHANNEL_20
N  *         @arg @ref MS32_ADC_CHANNEL_21
N  *         @arg @ref MS32_ADC_CHANNEL_VREFINT
N  *         @arg @ref MS32_ADC_CHANNEL_TEMPSENSOR
N  *         @arg @ref MS32_ADC_CHANNEL_VBAT
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP1
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP2
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP3
N  *
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_CHANNEL_0
N  *         @arg @ref MS32_ADC_CHANNEL_1
N  *         @arg @ref MS32_ADC_CHANNEL_2
N  *         @arg @ref MS32_ADC_CHANNEL_3
N  *         @arg @ref MS32_ADC_CHANNEL_4
N  *         @arg @ref MS32_ADC_CHANNEL_5
N  *         @arg @ref MS32_ADC_CHANNEL_6
N  *         @arg @ref MS32_ADC_CHANNEL_7
N  *         @arg @ref MS32_ADC_CHANNEL_8
N  *         @arg @ref MS32_ADC_CHANNEL_9
N  *         @arg @ref MS32_ADC_CHANNEL_10
N  *         @arg @ref MS32_ADC_CHANNEL_11
N  *         @arg @ref MS32_ADC_CHANNEL_12
N  *         @arg @ref MS32_ADC_CHANNEL_13
N  *         @arg @ref MS32_ADC_CHANNEL_14
N  *         @arg @ref MS32_ADC_CHANNEL_15
N  *         @arg @ref MS32_ADC_CHANNEL_16
N  *         @arg @ref MS32_ADC_CHANNEL_17
N  *         @arg @ref MS32_ADC_CHANNEL_18
N  *         @arg @ref MS32_ADC_CHANNEL_19
N  *         @arg @ref MS32_ADC_CHANNEL_20
N  *         @arg @ref MS32_ADC_CHANNEL_21
N  */
N#define __MS32_ADC_CHANNEL_INTERNAL_TO_EXTERNAL(__CHANNEL__)                     \
N  ((__CHANNEL__) & ~ADC_CHANNEL_ID_INTERNAL_CH_MASK)
X#define __MS32_ADC_CHANNEL_INTERNAL_TO_EXTERNAL(__CHANNEL__)                       ((__CHANNEL__) & ~ADC_CHANNEL_ID_INTERNAL_CH_MASK)
N
N/**
N  * @brief  Helper macro to determine whether the internal channel
N  *         selected is available on the ADC instance selected.
N  * @note   The channel parameter must be a value defined from parameter
N  *         definition of a ADC internal channel (MS32_ADC_CHANNEL_VREFINT,
N  *         MS32_ADC_CHANNEL_TEMPSENSOR, ...),
N  *         must not be a value defined from parameter definition of
N  *         ADC external channel (MS32_ADC_CHANNEL_1, MS32_ADC_CHANNEL_2, ...)
N  *         or a value from functions where a channel number is
N  *         returned from ADC registers,
N  *         because internal and external channels share the same channel
N  *         number in ADC registers. The differentiation is made only with
N  *         parameters definitions of driver.
N  * @param  __ADC_INSTANCE__ ADC instance
N  * @param  __CHANNEL__ This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_CHANNEL_VREFINT
N  *         @arg @ref MS32_ADC_CHANNEL_TEMPSENSOR
N  *         @arg @ref MS32_ADC_CHANNEL_VBAT
N  *
N  * @retval Value "0" if the internal channel selected is not available on the ADC instance selected.
N  *         Value "1" if the internal channel selected is available on the ADC instance selected.
N  */
N#define __MS32_ADC_IS_CHANNEL_INTERNAL_AVAILABLE(__ADC_INSTANCE__, __CHANNEL__)  \
N  (                                                                              \
N    ((__CHANNEL__) == MS32_ADC_CHANNEL_VREFINT)    ||                            \
N    ((__CHANNEL__) == MS32_ADC_CHANNEL_TEMPSENSOR) ||                            \
N    ((__CHANNEL__) == MS32_ADC_CHANNEL_VBAT)                                     \
N  )
X#define __MS32_ADC_IS_CHANNEL_INTERNAL_AVAILABLE(__ADC_INSTANCE__, __CHANNEL__)    (                                                                                  ((__CHANNEL__) == MS32_ADC_CHANNEL_VREFINT)    ||                                ((__CHANNEL__) == MS32_ADC_CHANNEL_TEMPSENSOR) ||                                ((__CHANNEL__) == MS32_ADC_CHANNEL_VBAT)                                       )
N
N/**
N  * @brief  Helper macro to define ADC analog watchdog parameter:
N  *         define a single channel to monitor with analog watchdog
N  *         from sequencer channel and groups definition.
N  * @note   To be used with function @ref MS32_ADC_SetAnalogWDMonitChannels().
N  *         Example:
N  *           MS32_ADC_SetAnalogWDMonitChannels(
N  *             ADC1, MS32_ADC_AWD1,
N  *             __MS32_ADC_ANALOGWD_CHANNEL_GROUP(MS32_ADC_CHANNEL4, MS32_ADC_GROUP_REGULAR))
N  * @param  __CHANNEL__ This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_CHANNEL_0
N  *         @arg @ref MS32_ADC_CHANNEL_1
N  *         @arg @ref MS32_ADC_CHANNEL_2
N  *         @arg @ref MS32_ADC_CHANNEL_3
N  *         @arg @ref MS32_ADC_CHANNEL_4
N  *         @arg @ref MS32_ADC_CHANNEL_5
N  *         @arg @ref MS32_ADC_CHANNEL_6
N  *         @arg @ref MS32_ADC_CHANNEL_7
N  *         @arg @ref MS32_ADC_CHANNEL_8
N  *         @arg @ref MS32_ADC_CHANNEL_9
N  *         @arg @ref MS32_ADC_CHANNEL_10
N  *         @arg @ref MS32_ADC_CHANNEL_11
N  *         @arg @ref MS32_ADC_CHANNEL_12
N  *         @arg @ref MS32_ADC_CHANNEL_13
N  *         @arg @ref MS32_ADC_CHANNEL_14
N  *         @arg @ref MS32_ADC_CHANNEL_15
N  *         @arg @ref MS32_ADC_CHANNEL_16
N  *         @arg @ref MS32_ADC_CHANNEL_17
N  *         @arg @ref MS32_ADC_CHANNEL_18
N  *         @arg @ref MS32_ADC_CHANNEL_19
N  *         @arg @ref MS32_ADC_CHANNEL_20
N  *         @arg @ref MS32_ADC_CHANNEL_21
N  *         @arg @ref MS32_ADC_CHANNEL_VREFINT    (1)
N  *         @arg @ref MS32_ADC_CHANNEL_TEMPSENSOR (1)
N  *         @arg @ref MS32_ADC_CHANNEL_VBAT       (1)
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP1     (1)
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP2     (1)
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP3     (1)
N  *
N  *         (1) For ADC channel read back from ADC register,
N  *             comparison with internal channel parameter to be done
N  *             using helper macro @ref __MS32_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
N  * @param  __GROUP__ This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_GROUP_REGULAR
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_AWD_DISABLE
N  *         @arg @ref MS32_ADC_AWD_AMS32_CHANNELS_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_0_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_1_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_2_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_3_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_4_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_5_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_6_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_7_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_8_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_9_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_10_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_11_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_12_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_13_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_14_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_15_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_16_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_17_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_18_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_19_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_20_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_21_REG
N  *         @arg @ref MS32_ADC_AWD_CH_VREFINT_REG
N  *         @arg @ref MS32_ADC_AWD_CH_TEMPSENSOR_REG
N  *         @arg @ref MS32_ADC_AWD_CH_VBAT_REG
N  *         @arg @ref MS32_ADC_AWD_CH_OPAMP1_REG
N  *         @arg @ref MS32_ADC_AWD_CH_OPAMP2_REG
N  *         @arg @ref MS32_ADC_AWD_CH_OPAMP3_REG
N  */
N#define __MS32_ADC_ANALOGWD_CHANNEL_GROUP(__CHANNEL__, __GROUP__)                                           \
N  (((__CHANNEL__) & ADC_CHANNEL_ID_MASK) | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)
X#define __MS32_ADC_ANALOGWD_CHANNEL_GROUP(__CHANNEL__, __GROUP__)                                             (((__CHANNEL__) & ADC_CHANNEL_ID_MASK) | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL)
N
N/**
N  * @brief  Helper macro to set the value of ADC analog watchdog threshold high
N  *         or low in function of ADC resolution, when ADC resolution is
N  *         different of 12 bits.
N  * @note   To be used with function @ref MS32_ADC_ConfigAnalogWDThresholds()
N  *         or @ref MS32_ADC_SetAnalogWDThresholds().
N  *         Example, with a ADC resolution of 8 bits, to set the value of
N  *         analog watchdog threshold high (on 8 bits):
N  *           MS32_ADC_SetAnalogWDThresholds
N  *            (< ADCx param >,
N  *             __MS32_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION(MS32_ADC_RESOLUTION_8B, <threshold_value_8_bits>)
N  *            );
N  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_RESOLUTION_12B
N  *         @arg @ref MS32_ADC_RESOLUTION_10B
N  *         @arg @ref MS32_ADC_RESOLUTION_8B
N  *         @arg @ref MS32_ADC_RESOLUTION_6B
N  * @param  __AWD_THRESHOLD__ Value between Min_Data=0x000 and Max_Data=0xFFF
N  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
N  */
N#define __MS32_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION(__ADC_RESOLUTION__, __AWD_THRESHOLD__) \
N  ((__AWD_THRESHOLD__) << ((__ADC_RESOLUTION__) >> (ADC_CFGR1_RES_BITOFFSET_POS - 1U )))
X#define __MS32_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION(__ADC_RESOLUTION__, __AWD_THRESHOLD__)   ((__AWD_THRESHOLD__) << ((__ADC_RESOLUTION__) >> (ADC_CFGR1_RES_BITOFFSET_POS - 1U )))
N
N/**
N  * @brief  Helper macro to get the value of ADC analog watchdog threshold high
N  *         or low in function of ADC resolution, when ADC resolution is
N  *         different of 12 bits.
N  * @note   To be used with function @ref MS32_ADC_GetAnalogWDThresholds().
N  *         Example, with a ADC resolution of 8 bits, to get the value of
N  *         analog watchdog threshold high (on 8 bits):
N  *           < threshold_value_6_bits > = __MS32_ADC_ANALOGWD_GET_THRESHOLD_RESOLUTION
N  *            (MS32_ADC_RESOLUTION_8B,
N  *             MS32_ADC_GetAnalogWDThresholds(<ADCx param>, MS32_ADC_AWD_THRESHOLD_HIGH)
N  *            );
N  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_RESOLUTION_12B
N  *         @arg @ref MS32_ADC_RESOLUTION_10B
N  *         @arg @ref MS32_ADC_RESOLUTION_8B
N  *         @arg @ref MS32_ADC_RESOLUTION_6B
N  * @param  __AWD_THRESHOLD_12_BITS__ Value between Min_Data=0x000 and Max_Data=0xFFF
N  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
N  */
N#define __MS32_ADC_ANALOGWD_GET_THRESHOLD_RESOLUTION(__ADC_RESOLUTION__, __AWD_THRESHOLD_12_BITS__) \
N  ((__AWD_THRESHOLD_12_BITS__) >> ((__ADC_RESOLUTION__) >> (ADC_CFGR1_RES_BITOFFSET_POS - 1U )))
X#define __MS32_ADC_ANALOGWD_GET_THRESHOLD_RESOLUTION(__ADC_RESOLUTION__, __AWD_THRESHOLD_12_BITS__)   ((__AWD_THRESHOLD_12_BITS__) >> ((__ADC_RESOLUTION__) >> (ADC_CFGR1_RES_BITOFFSET_POS - 1U )))
N
N/**
N  * @brief  Helper macro to get the ADC analog watchdog threshold high
N  *         or low from raw value containing both thresholds concatenated.
N  * @note   To be used with function @ref MS32_ADC_GetAnalogWDThresholds().
N  *         Example, to get analog watchdog threshold high from the register raw value:
N  *           __MS32_ADC_ANALOGWD_THRESHOLDS_HIGH_LOW(MS32_ADC_AWD_THRESHOLD_HIGH, <raw_value_with_both_thresholds>);
N  * @param  __AWD_THRESHOLD_TYPE__ This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_AWD_THRESHOLD_HIGH
N  *         @arg @ref MS32_ADC_AWD_THRESHOLD_LOW
N  * @param  __AWD_THRESHOLDS__ Value between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
N  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
N  */
N#define __MS32_ADC_ANALOGWD_THRESHOLDS_HIGH_LOW(__AWD_THRESHOLD_TYPE__, __AWD_THRESHOLDS__) \
N  (((__AWD_THRESHOLD_TYPE__) == MS32_ADC_AWD_THRESHOLD_LOW)                                 \
N    ? (                                                                                   \
N       (__AWD_THRESHOLDS__) & MS32_ADC_AWD_THRESHOLD_LOW                                    \
N      )                                                                                   \
N      :                                                                                   \
N      (                                                                                   \
N       ((__AWD_THRESHOLDS__) >> ADC_TR_HT_BITOFFSET_POS) & MS32_ADC_AWD_THRESHOLD_LOW       \
N      )                                                                                   \
N  )
X#define __MS32_ADC_ANALOGWD_THRESHOLDS_HIGH_LOW(__AWD_THRESHOLD_TYPE__, __AWD_THRESHOLDS__)   (((__AWD_THRESHOLD_TYPE__) == MS32_ADC_AWD_THRESHOLD_LOW)                                     ? (                                                                                          (__AWD_THRESHOLDS__) & MS32_ADC_AWD_THRESHOLD_LOW                                          )                                                                                         :                                                                                         (                                                                                          ((__AWD_THRESHOLDS__) >> ADC_TR_HT_BITOFFSET_POS) & MS32_ADC_AWD_THRESHOLD_LOW             )                                                                                     )
N
N/**
N  * @brief  Helper macro to select the ADC common instance
N  *         to which is belonging the selected ADC instance.
N  * @note   ADC common register instance can be used for:
N  *         - Set parameters common to several ADC instances
N  *         - Multimode (for devices with several ADC instances)
N  *         Refer to functions having argument "ADCxy_COMMON" as parameter.
N  * @param  __ADCx__ ADC instance
N  * @retval ADC common register instance
N  */
N#define __MS32_ADC_COMMON_INSTANCE(__ADCx__)                                     \
N  (ADC1_COMMON)
X#define __MS32_ADC_COMMON_INSTANCE(__ADCx__)                                       (ADC1_COMMON)
N
N/**
N  * @brief  Helper macro to check if all ADC instances sharing the same
N  *         ADC common instance are disabled.
N  * @note   This check is required by functions with setting conditioned to
N  *         ADC state:
N  *         All ADC instances of the ADC common group must be disabled.
N  *         Refer to functions having argument "ADCxy_COMMON" as parameter.
N  * @note   On devices with only 1 ADC common instance, parameter of this macro
N  *         is useless and can be ignored (parameter kept for compatibility
N  *         with devices featuring several ADC common instances).
N  * @param  __ADCXY_COMMON__ ADC common instance
N  *         (can be set directly from CMSIS definition or by using helper macro @ref __MS32_ADC_COMMON_INSTANCE() )
N  * @retval Value "0" if all ADC instances sharing the same ADC common instance
N  *         are disabled.
N  *         Value "1" if at least one ADC instance sharing the same ADC common instance
N  *         is enabled.
N  */
N#define __MS32_ADC_IS_ENABLED_AMS32_COMMON_INSTANCE(__ADCXY_COMMON__)              \
N  MS32_ADC_IsEnabled(ADC1)
X#define __MS32_ADC_IS_ENABLED_AMS32_COMMON_INSTANCE(__ADCXY_COMMON__)                MS32_ADC_IsEnabled(ADC1)
N
N/**
N  * @brief  Helper macro to define the ADC conversion data full-scale digital
N  *         value corresponding to the selected ADC resolution.
N  * @note   ADC conversion data full-scale corresponds to voltage range
N  *         determined by analog voltage references Vref+ and Vref-
N  *         (refer to reference manual).
N  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_RESOLUTION_12B
N  *         @arg @ref MS32_ADC_RESOLUTION_10B
N  *         @arg @ref MS32_ADC_RESOLUTION_8B
N  *         @arg @ref MS32_ADC_RESOLUTION_6B
N  * @retval ADC conversion data equivalent voltage value (unit: mVolt)
N  */
N#define __MS32_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__)                             \
N  (0xFFFU >> ((__ADC_RESOLUTION__) >> (ADC_CFGR1_RES_BITOFFSET_POS - 1U)))
X#define __MS32_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__)                               (0xFFFU >> ((__ADC_RESOLUTION__) >> (ADC_CFGR1_RES_BITOFFSET_POS - 1U)))
N
N/**
N  * @brief  Helper macro to convert the ADC conversion data from
N  *         a resolution to another resolution.
N  * @param  __DATA__ ADC conversion data to be converted
N  * @param  __ADC_RESOLUTION_CURRENT__ Resolution of to the data to be converted
N  *         This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_RESOLUTION_12B
N  *         @arg @ref MS32_ADC_RESOLUTION_10B
N  *         @arg @ref MS32_ADC_RESOLUTION_8B
N  *         @arg @ref MS32_ADC_RESOLUTION_6B
N  * @param  __ADC_RESOLUTION_TARGET__ Resolution of the data after conversion
N  *         This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_RESOLUTION_12B
N  *         @arg @ref MS32_ADC_RESOLUTION_10B
N  *         @arg @ref MS32_ADC_RESOLUTION_8B
N  *         @arg @ref MS32_ADC_RESOLUTION_6B
N  * @retval ADC conversion data to the requested resolution
N  */
N#define __MS32_ADC_CONVERT_DATA_RESOLUTION(__DATA__, __ADC_RESOLUTION_CURRENT__, __ADC_RESOLUTION_TARGET__) \
N  (((__DATA__)                                                                 \
N    << ((__ADC_RESOLUTION_CURRENT__) >> (ADC_CFGR1_RES_BITOFFSET_POS - 1U)))   \
N   >> ((__ADC_RESOLUTION_TARGET__) >> (ADC_CFGR1_RES_BITOFFSET_POS - 1U))      \
N  )
X#define __MS32_ADC_CONVERT_DATA_RESOLUTION(__DATA__, __ADC_RESOLUTION_CURRENT__, __ADC_RESOLUTION_TARGET__)   (((__DATA__)                                                                     << ((__ADC_RESOLUTION_CURRENT__) >> (ADC_CFGR1_RES_BITOFFSET_POS - 1U)))      >> ((__ADC_RESOLUTION_TARGET__) >> (ADC_CFGR1_RES_BITOFFSET_POS - 1U))        )
N
N/**
N  * @brief  Helper macro to calculate the voltage (unit: mVolt)
N  *         corresponding to a ADC conversion data (unit: digital value).
N  * @note   Analog reference voltage (Vref+) must be either known from
N  *         user board environment or can be calculated using ADC measurement
N  *         and ADC helper macro @ref __MS32_ADC_CALC_VREFANALOG_VOLTAGE().
N  * @param  __VREFANALOG_VOLTAGE__ Analog reference voltage (unit: mV)
N  * @param  __ADC_DATA__ ADC conversion data (resolution 12 bits)
N  *                       (unit: digital value).
N  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_RESOLUTION_12B
N  *         @arg @ref MS32_ADC_RESOLUTION_10B
N  *         @arg @ref MS32_ADC_RESOLUTION_8B
N  *         @arg @ref MS32_ADC_RESOLUTION_6B
N  * @retval ADC conversion data equivalent voltage value (unit: mVolt)
N  */
N#define __MS32_ADC_CALC_DATA_TO_VOLTAGE(__VREFANALOG_VOLTAGE__,\
N                                      __ADC_DATA__,\
N                                      __ADC_RESOLUTION__)                      \
N  ((__ADC_DATA__) * (__VREFANALOG_VOLTAGE__)                                   \
N   / __MS32_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__)                                \
N  )
X#define __MS32_ADC_CALC_DATA_TO_VOLTAGE(__VREFANALOG_VOLTAGE__,                                      __ADC_DATA__,                                      __ADC_RESOLUTION__)                        ((__ADC_DATA__) * (__VREFANALOG_VOLTAGE__)                                      / __MS32_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__)                                  )
N
N/**
N  * @brief  Helper macro to calculate analog reference voltage (Vref+)
N  *         (unit: mVolt) from ADC conversion data of internal voltage
N  *         reference VrefInt.
N  * @note   Computation is using VrefInt calibration value
N  *         stored in system memory for each device during production.
N  * @note   This voltage depends on user board environment: voltage level
N  *         connected to pin Vref+.
N  *         On devices with small package, the pin Vref+ is not present
N  *         and internally bonded to pin Vdda.
N  * @note   On this MS32 serie, calibration data of internal voltage reference
N  *         VrefInt corresponds to a resolution of 12 bits,
N  *         this is the recommended ADC resolution to convert voltage of
N  *         internal voltage reference VrefInt.
N  *         Otherwise, this macro performs the processing to scale
N  *         ADC conversion data to 12 bits.
N  * @param  __VREFINT_ADC_DATA__ ADC conversion data (resolution 12 bits)
N  *         of internal voltage reference VrefInt (unit: digital value).
N  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_RESOLUTION_12B
N  *         @arg @ref MS32_ADC_RESOLUTION_10B
N  *         @arg @ref MS32_ADC_RESOLUTION_8B
N  *         @arg @ref MS32_ADC_RESOLUTION_6B
N  * @retval Analog reference voltage (unit: mV)
N  */
N#define __MS32_ADC_CALC_VREFANALOG_VOLTAGE(__VREFINT_ADC_DATA__,\
N                                         __ADC_RESOLUTION__)                   \
N  (((uint32_t)(*VREFINT_CAL_ADDR) * VREFINT_CAL_VREF)                          \
N    / __MS32_ADC_CONVERT_DATA_RESOLUTION((__VREFINT_ADC_DATA__),                 \
N                                       (__ADC_RESOLUTION__),                   \
N                                       MS32_ADC_RESOLUTION_12B)                  \
N  )
X#define __MS32_ADC_CALC_VREFANALOG_VOLTAGE(__VREFINT_ADC_DATA__,                                         __ADC_RESOLUTION__)                     (((uint32_t)(*VREFINT_CAL_ADDR) * VREFINT_CAL_VREF)                              / __MS32_ADC_CONVERT_DATA_RESOLUTION((__VREFINT_ADC_DATA__),                                                        (__ADC_RESOLUTION__),                                                          MS32_ADC_RESOLUTION_12B)                    )
N
N/**
N  * @brief  Helper macro to calculate the temperature (unit: degree Celsius)
N  *         from ADC conversion data of internal temperature sensor.
N  * @note   Computation is using temperature sensor calibration values
N  *         stored in system memory for each device during production.
N  * @note   Calculation formula:
N  *           Temperature = ((TS_ADC_DATA - TS_CAL1)
N  *                           * (TS_CAL2_TEMP - TS_CAL1_TEMP))
N  *                         / (TS_CAL2 - TS_CAL1) + TS_CAL1_TEMP
N  *           with TS_ADC_DATA = temperature sensor raw data measured by ADC
N  *                Avg_Slope = (TS_CAL2 - TS_CAL1)
N  *                            / (TS_CAL2_TEMP - TS_CAL1_TEMP)
N  *                TS_CAL1   = equivalent TS_ADC_DATA at temperature
N  *                            TEMP_DEGC_CAL1 (calibrated in factory)
N  *                TS_CAL2   = equivalent TS_ADC_DATA at temperature
N  *                            TEMP_DEGC_CAL2 (calibrated in factory)
N  *         Caution: Calculation relevancy under reserve that calibration
N  *                  parameters are correct (address and data).
N  *                  To calculate temperature using temperature sensor
N  *                  datasheet typical values (generic values less, therefore
N  *                  less accurate than calibrated values),
N  *                  use helper macro @ref __MS32_ADC_CALC_TEMPERATURE_TYP_PARAMS().
N  * @note   As calculation input, the analog reference voltage (Vref+) must be
N  *         defined as it impacts the ADC LSB equivalent voltage.
N  * @note   Analog reference voltage (Vref+) must be either known from
N  *         user board environment or can be calculated using ADC measurement
N  *         and ADC helper macro @ref __MS32_ADC_CALC_VREFANALOG_VOLTAGE().
N  * @note   On this MS32 serie, calibration data of temperature sensor
N  *         corresponds to a resolution of 12 bits,
N  *         this is the recommended ADC resolution to convert voltage of
N  *         temperature sensor.
N  *         Otherwise, this macro performs the processing to scale
N  *         ADC conversion data to 12 bits.
N  * @param  __VREFANALOG_VOLTAGE__  Analog reference voltage (unit: mV)
N  * @param  __TEMPSENSOR_ADC_DATA__ ADC conversion data of internal
N  *                                 temperature sensor (unit: digital value).
N  * @param  __ADC_RESOLUTION__      ADC resolution at which internal temperature
N  *                                 sensor voltage has been measured.
N  *         This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_RESOLUTION_12B
N  *         @arg @ref MS32_ADC_RESOLUTION_10B
N  *         @arg @ref MS32_ADC_RESOLUTION_8B
N  *         @arg @ref MS32_ADC_RESOLUTION_6B
N  * @retval Temperature (unit: degree Celsius)
N  */
N#define __MS32_ADC_CALC_TEMPERATURE(__VREFANALOG_VOLTAGE__,\
N                                  __TEMPSENSOR_ADC_DATA__,\
N                                  __ADC_RESOLUTION__)                              \
N  (((( ((int32_t)((__MS32_ADC_CONVERT_DATA_RESOLUTION((__TEMPSENSOR_ADC_DATA__),     \
N                                                    (__ADC_RESOLUTION__),          \
N                                                    MS32_ADC_RESOLUTION_12B)         \
N                   * (__VREFANALOG_VOLTAGE__))                                     \
N                  / TEMPSENSOR_CAL_VREFANALOG)                                     \
N        - (int32_t) *TEMPSENSOR_CAL1_ADDR)                                         \
N     ) * (int32_t)(TEMPSENSOR_CAL2_TEMP - TEMPSENSOR_CAL1_TEMP)                    \
N    ) / (int32_t)((int32_t)*TEMPSENSOR_CAL2_ADDR - (int32_t)*TEMPSENSOR_CAL1_ADDR) \
N   ) + TEMPSENSOR_CAL1_TEMP                                                        \
N  )
X#define __MS32_ADC_CALC_TEMPERATURE(__VREFANALOG_VOLTAGE__,                                  __TEMPSENSOR_ADC_DATA__,                                  __ADC_RESOLUTION__)                                (((( ((int32_t)((__MS32_ADC_CONVERT_DATA_RESOLUTION((__TEMPSENSOR_ADC_DATA__),                                                         (__ADC_RESOLUTION__),                                                              MS32_ADC_RESOLUTION_12B)                            * (__VREFANALOG_VOLTAGE__))                                                       / TEMPSENSOR_CAL_VREFANALOG)                                             - (int32_t) *TEMPSENSOR_CAL1_ADDR)                                              ) * (int32_t)(TEMPSENSOR_CAL2_TEMP - TEMPSENSOR_CAL1_TEMP)                        ) / (int32_t)((int32_t)*TEMPSENSOR_CAL2_ADDR - (int32_t)*TEMPSENSOR_CAL1_ADDR)    ) + TEMPSENSOR_CAL1_TEMP                                                          )
N
N/**
N  * @brief  Helper macro to calculate the temperature (unit: degree Celsius)
N  *         from ADC conversion data of internal temperature sensor.
N  * @note   Computation is using temperature sensor typical values
N  *         (refer to device datasheet).
N  * @note   Calculation formula:
N  *           Temperature = (TS_TYP_CALx_VOLT(uV) - TS_ADC_DATA * Conversion_uV)
N  *                         / Avg_Slope + CALx_TEMP
N  *           with TS_ADC_DATA      = temperature sensor raw data measured by ADC
N  *                                   (unit: digital value)
N  *                Avg_Slope        = temperature sensor slope
N  *                                   (unit: uV/Degree Celsius)
N  *                TS_TYP_CALx_VOLT = temperature sensor digital value at
N  *                                   temperature CALx_TEMP (unit: mV)
N  *         Caution: Calculation relevancy under reserve the temperature sensor
N  *                  of the current device has characteristics in line with
N  *                  datasheet typical values.
N  *                  If temperature sensor calibration values are available on
N  *                  on this device (presence of macro __MS32_ADC_CALC_TEMPERATURE()),
N  *                  temperature calculation will be more accurate using
N  *                  helper macro @ref __MS32_ADC_CALC_TEMPERATURE().
N  * @note   As calculation input, the analog reference voltage (Vref+) must be
N  *         defined as it impacts the ADC LSB equivalent voltage.
N  * @note   Analog reference voltage (Vref+) must be either known from
N  *         user board environment or can be calculated using ADC measurement
N  *         and ADC helper macro @ref __MS32_ADC_CALC_VREFANALOG_VOLTAGE().
N  * @note   ADC measurement data must correspond to a resolution of 12bits
N  *         (full scale digital value 4095). If not the case, the data must be
N  *         preliminarily rescaled to an equivalent resolution of 12 bits.
N  * @param  __TEMPSENSOR_TYP_AVGSLOPE__   Device datasheet data: Temperature sensor slope typical value (unit: uV/DegCelsius).
N  *                                       On MS32F0, refer to device datasheet parameter "Avg_Slope".
N  * @param  __TEMPSENSOR_TYP_CALX_V__     Device datasheet data: Temperature sensor voltage typical value (at temperature and Vref+ defined in parameters below) (unit: mV).
N  *                                       On MS32F0, refer to device datasheet parameter "V30" (corresponding to TS_CAL1).
N  * @param  __TEMPSENSOR_CALX_TEMP__      Device datasheet data: Temperature at which temperature sensor voltage (see parameter above) is corresponding (unit: mV)
N  * @param  __VREFANALOG_VOLTAGE__        Analog voltage reference (Vref+) voltage (unit: mV)
N  * @param  __TEMPSENSOR_ADC_DATA__       ADC conversion data of internal temperature sensor (unit: digital value).
N  * @param  __ADC_RESOLUTION__            ADC resolution at which internal temperature sensor voltage has been measured.
N  *         This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_RESOLUTION_12B
N  *         @arg @ref MS32_ADC_RESOLUTION_10B
N  *         @arg @ref MS32_ADC_RESOLUTION_8B
N  *         @arg @ref MS32_ADC_RESOLUTION_6B
N  * @retval Temperature (unit: degree Celsius)
N  */
N#define __MS32_ADC_CALC_TEMPERATURE_TYP_PARAMS(__TEMPSENSOR_TYP_AVGSLOPE__,    \
N                                             __TEMPSENSOR_TYP_CALX_V__,        \
N                                             __TEMPSENSOR_CALX_TEMP__,         \
N                                             __VREFANALOG_VOLTAGE__,           \
N                                             __TEMPSENSOR_ADC_DATA__,          \
N                                             __ADC_RESOLUTION__)               \
N  ((( (                                                                        \
N       (int32_t)(((__TEMPSENSOR_TYP_CALX_V__))                                 \
N                 * 1000)                                                       \
N       -                                                                       \
N       (int32_t)((((__TEMPSENSOR_ADC_DATA__) * (__VREFANALOG_VOLTAGE__))       \
N                  / __MS32_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__))              \
N                 * 1000)                                                       \
N      )                                                                        \
N    ) / (__TEMPSENSOR_TYP_AVGSLOPE__)                                          \
N   ) + (__TEMPSENSOR_CALX_TEMP__)                                              \
N  )
X#define __MS32_ADC_CALC_TEMPERATURE_TYP_PARAMS(__TEMPSENSOR_TYP_AVGSLOPE__,                                                 __TEMPSENSOR_TYP_CALX_V__,                                                     __TEMPSENSOR_CALX_TEMP__,                                                      __VREFANALOG_VOLTAGE__,                                                        __TEMPSENSOR_ADC_DATA__,                                                       __ADC_RESOLUTION__)                 ((( (                                                                               (int32_t)(((__TEMPSENSOR_TYP_CALX_V__))                                                  * 1000)                                                              -                                                                              (int32_t)((((__TEMPSENSOR_ADC_DATA__) * (__VREFANALOG_VOLTAGE__))                         / __MS32_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__))                               * 1000)                                                             )                                                                            ) / (__TEMPSENSOR_TYP_AVGSLOPE__)                                             ) + (__TEMPSENSOR_CALX_TEMP__)                                                )
N
N
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup ADC_EF_DMA_Management ADC DMA management
N  * @{
N  */
N/* Note: LL ADC functions to set DMA transfer are located into sections of    */
N/*       configuration of ADC instance, groups and multimode (if available):  */
N/*       @ref MS32_ADC_REG_SetDMATransfer(), ...                                */
N
N/**
N  * @brief  Function to help to configure DMA transfer from ADC: retrieve the
N  *         ADC register address from ADC instance and a list of ADC registers
N  *         intended to be used (most commonly) with DMA transfer.
N  * @note   These ADC registers are data registers:
N  *         when ADC conversion data is available in ADC data registers,
N  *         ADC generates a DMA transfer request.
N  * @note   This macro is intended to be used with LL DMA driver, refer to
N  *         function "MS32_DMA_ConfigAddresses()".
N  *         Example:
N  *           MS32_DMA_ConfigAddresses(DMA1,
N  *                                  MS32_DMA_CHANNEL_1,
N  *                                  MS32_ADC_DMA_GetRegAddr(ADC1, MS32_ADC_DMA_REG_REGULAR_DATA),
N  *                                  (uint32_t)&< array or variable >,
N  *                                  MS32_DMA_DIRECTION_PERIPH_TO_MEMORY);
N  * @note   For devices with several ADC: in multimode, some devices
N  *         use a different data register outside of ADC instance scope
N  *         (common data register). This macro manages this register difference,
N  *         only ADC instance has to be set as parameter.
N  * @rmtoll DR       DATA           MS32_ADC_DMA_GetRegAddr
N  * @param  ADCx ADC instance
N  * @param  Register This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_DMA_REG_REGULAR_DATA
N  * @retval ADC register address
N  */
N__STATIC_INLINE uint32_t MS32_ADC_DMA_GetRegAddr(ADC_TypeDef *ADCx, uint32_t Register) {
Xstatic __inline uint32_t MS32_ADC_DMA_GetRegAddr(ADC_TypeDef *ADCx, uint32_t Register) {
N  /* Retrieve address of register DR */
N  return (uint32_t)&(ADCx->DR);
N}
N
N
N/** @defgroup ADC_EF_Configuration_ADC_Common Configuration of ADC hierarchical scope: common to several ADC instances
N  * @{
N  */
N
N/**
N  * @brief  Set parameter common to several ADC: measurement path to internal
N  *         channels (VrefInt, temperature sensor, ...).
N  * @note   One or several values can be selected.
N  *         Example: (MS32_ADC_PATH_INTERNAL_VREFINT |
N  *                   MS32_ADC_PATH_INTERNAL_TEMPSENSOR)
N  * @note   Stabilization time of measurement path to internal channel:
N  *         After enabling internal paths, before starting ADC conversion,
N  *         a delay is required for internal voltage reference and
N  *         temperature sensor stabilization time.
N  *         Refer to device datasheet.
N  *         Refer to literal @ref MS32_ADC_DELAY_VREFINT_STAB_US.
N  *         Refer to literal @ref MS32_ADC_DELAY_TEMPSENSOR_STAB_US.
N  * @note   ADC internal channel sampling time constraint:
N  *         For ADC conversion of internal channels,
N  *         a sampling time minimum value is required.
N  *         Refer to device datasheet.
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         All ADC instances of the ADC common group must be disabled.
N  *         This check can be done with function @ref MS32_ADC_IsEnabled() for each
N  *         ADC instance or by using helper macro helper macro
N  *         @ref __MS32_ADC_IS_ENABLED_AMS32_COMMON_INSTANCE().
N  * @rmtoll CCR      VREFEN         MS32_ADC_SetCommonPathInternalCh\n
N  *         CCR      TSEN           MS32_ADC_SetCommonPathInternalCh\n
N  *         CCR      VBATEN         MS32_ADC_SetCommonPathInternalCh
N  * @param  ADCxy_COMMON ADC common instance
N  *         (can be set directly from CMSIS definition or by using helper macro @ref __MS32_ADC_COMMON_INSTANCE() )
N  * @param  PathInternal This parameter can be a combination of the following values:
N  *         @arg @ref MS32_ADC_PATH_INTERNAL_NONE
N  *         @arg @ref MS32_ADC_PATH_INTERNAL_VREFINT
N  *         @arg @ref MS32_ADC_PATH_INTERNAL_TEMPSENSOR
N  *         @arg @ref MS32_ADC_PATH_INTERNAL_VBAT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_SetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal) {
Xstatic __inline void MS32_ADC_SetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal) {
N  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
X  (((ADCxy_COMMON->CCR)) = ((((((ADCxy_COMMON->CCR))) & (~((0x1UL << (22U)) | (0x1UL << (23U)) | (0x1UL << (24U))))) | (PathInternal))));
N}
N
N/**
N  * @brief  Get parameter common to several ADC: measurement path to internal
N  *         channels (VrefInt, temperature sensor, ...).
N  * @note   One or several values can be selected.
N  *         Example: (MS32_ADC_PATH_INTERNAL_VREFINT |
N  *                   MS32_ADC_PATH_INTERNAL_TEMPSENSOR)
N  * @rmtoll CCR      VREFEN         MS32_ADC_GetCommonPathInternalCh\n
N  *         CCR      TSEN           MS32_ADC_GetCommonPathInternalCh\n
N  *         CCR      VBATEN         MS32_ADC_GetCommonPathInternalCh
N  * @param  ADCxy_COMMON ADC common instance
N  *         (can be set directly from CMSIS definition or by using helper macro @ref __MS32_ADC_COMMON_INSTANCE() )
N  * @retval Returned value can be a combination of the following values:
N  *         @arg @ref MS32_ADC_PATH_INTERNAL_NONE
N  *         @arg @ref MS32_ADC_PATH_INTERNAL_VREFINT
N  *         @arg @ref MS32_ADC_PATH_INTERNAL_TEMPSENSOR
N  *         @arg @ref MS32_ADC_PATH_INTERNAL_VBAT
N  */
N__STATIC_INLINE uint32_t MS32_ADC_GetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON) {
Xstatic __inline uint32_t MS32_ADC_GetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON) {
N  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
X  return (uint32_t)(((ADCxy_COMMON->CCR) & ((0x1UL << (22U)) | (0x1UL << (23U)) | (0x1UL << (24U)))));
N}
N
N
N/** @defgroup ADC_EF_Configuration_ADC_Instance Configuration of ADC hierarchical scope: ADC instance
N  * @{
N  */
N
N/**
N  * @brief  Set ADC instance clock source and prescaler.
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled.
N  * @rmtoll CFGR2    CKMODE         MS32_ADC_SetClock
N  * @param  ADCx ADC instance
N  * @param  ClockSource This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_CLOCK_SYNC_PCLK_DIV4
N  *         @arg @ref MS32_ADC_CLOCK_SYNC_PCLK_DIV2
N  *         @arg @ref MS32_ADC_CLOCK_ASYNC (1)
N  *
N  *         (1) On this MS32 serie, synchronous clock has no prescaler.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_SetClock(ADC_TypeDef *ADCx, uint32_t ClockSource) {
Xstatic __inline void MS32_ADC_SetClock(ADC_TypeDef *ADCx, uint32_t ClockSource) {
N  MODIFY_REG(ADCx->CFGR2, ADC_CFGR2_CKMODE, ClockSource);
X  (((ADCx->CFGR2)) = ((((((ADCx->CFGR2))) & (~((0x3UL << (30U))))) | (ClockSource))));
N}
N
N/**
N  * @brief  Get ADC instance clock source and prescaler.
N  * @rmtoll CFGR2    CKMODE         MS32_ADC_GetClock
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_CLOCK_SYNC_PCLK_DIV4
N  *         @arg @ref MS32_ADC_CLOCK_SYNC_PCLK_DIV2
N  *         @arg @ref MS32_ADC_CLOCK_ASYNC (1)
N  *
N  *         (1) On this MS32 serie, synchronous clock has no prescaler.
N  */
N__STATIC_INLINE uint32_t MS32_ADC_GetClock(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_GetClock(ADC_TypeDef *ADCx) {
N  return (uint32_t)(READ_BIT(ADCx->CFGR2, ADC_CFGR2_CKMODE));
X  return (uint32_t)(((ADCx->CFGR2) & ((0x3UL << (30U)))));
N}
N
N/**
N  * @brief  Set ADC resolution.
N  *         Refer to reference manual for alignments formats
N  *         dependencies to ADC resolutions.
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR1    RES            MS32_ADC_SetResolution
N  * @param  ADCx ADC instance
N  * @param  Resolution This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_RESOLUTION_12B
N  *         @arg @ref MS32_ADC_RESOLUTION_10B
N  *         @arg @ref MS32_ADC_RESOLUTION_8B
N  *         @arg @ref MS32_ADC_RESOLUTION_6B
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_SetResolution(ADC_TypeDef *ADCx, uint32_t Resolution) {
Xstatic __inline void MS32_ADC_SetResolution(ADC_TypeDef *ADCx, uint32_t Resolution) {
N  MODIFY_REG(ADCx->CFGR1, ADC_CFGR1_RES, Resolution);
X  (((ADCx->CFGR1)) = ((((((ADCx->CFGR1))) & (~((0x3UL << (3U))))) | (Resolution))));
N}
N
N/**
N  * @brief  Get ADC resolution.
N  *         Refer to reference manual for alignments formats
N  *         dependencies to ADC resolutions.
N  * @rmtoll CFGR1    RES            MS32_ADC_GetResolution
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_RESOLUTION_12B
N  *         @arg @ref MS32_ADC_RESOLUTION_10B
N  *         @arg @ref MS32_ADC_RESOLUTION_8B
N  *         @arg @ref MS32_ADC_RESOLUTION_6B
N  */
N__STATIC_INLINE uint32_t MS32_ADC_GetResolution(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_GetResolution(ADC_TypeDef *ADCx) {
N  return (uint32_t)(READ_BIT(ADCx->CFGR1, ADC_CFGR1_RES));
X  return (uint32_t)(((ADCx->CFGR1) & ((0x3UL << (3U)))));
N}
N
N/**
N  * @brief  Set ADC conversion data alignment.
N  * @note   Refer to reference manual for alignments formats
N  *         dependencies to ADC resolutions.
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR1    ALIGN          MS32_ADC_SetDataAlignment
N  * @param  ADCx ADC instance
N  * @param  DataAlignment This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_DATA_ALIGN_RIGHT
N  *         @arg @ref MS32_ADC_DATA_ALIGN_LEFT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_SetDataAlignment(ADC_TypeDef *ADCx, uint32_t DataAlignment) {
Xstatic __inline void MS32_ADC_SetDataAlignment(ADC_TypeDef *ADCx, uint32_t DataAlignment) {
N  MODIFY_REG(ADCx->CFGR1, ADC_CFGR1_ALIGN, DataAlignment);
X  (((ADCx->CFGR1)) = ((((((ADCx->CFGR1))) & (~((0x1UL << (5U))))) | (DataAlignment))));
N}
N
N/**
N  * @brief  Get ADC conversion data alignment.
N  * @note   Refer to reference manual for alignments formats
N  *         dependencies to ADC resolutions.
N  * @rmtoll CFGR1    ALIGN          MS32_ADC_GetDataAlignment
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_DATA_ALIGN_RIGHT
N  *         @arg @ref MS32_ADC_DATA_ALIGN_LEFT
N  */
N__STATIC_INLINE uint32_t MS32_ADC_GetDataAlignment(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_GetDataAlignment(ADC_TypeDef *ADCx) {
N  return (uint32_t)(READ_BIT(ADCx->CFGR1, ADC_CFGR1_ALIGN));
X  return (uint32_t)(((ADCx->CFGR1) & ((0x1UL << (5U)))));
N}
N
N/**
N  * @brief  Set ADC low power mode.
N  * @note   Description of ADC low power modes:
N  *         - ADC low power mode "auto wait": Dynamic low power mode,
N  *           ADC conversions occurrences are limited to the minimum necessary
N  *           in order to reduce power consumption.
N  *           New ADC conversion starts only when the previous
N  *           unitary conversion data (for ADC group regular)
N  *           has been retrieved by user software.
N  *           In the meantime, ADC remains idle: does not performs any
N  *           other conversion.
N  *           This mode allows to automatically adapt the ADC conversions
N  *           triggers to the speed of the software that reads the data.
N  *           Moreover, this avoids risk of overrun for low frequency
N  *           applications.
N  *           How to use this low power mode:
N  *           - Do not use with interruption or DMA since these modes
N  *             have to clear immediately the EOC flag to free the
N  *             IRQ vector sequencer.
N  *           - Do use with polling: 1. Start conversion,
N  *             2. Later on, when conversion data is needed: poll for end of
N  *             conversion  to ensure that conversion is completed and
N  *             retrieve ADC conversion data. This will trig another
N  *             ADC conversion start.
N  *         - ADC low power mode "auto power-off" (feature available on
N  *           this device if parameter MS32_ADC_LP_MODE_AUTOOFF is available):
N  *           the ADC automatically powers-off after a conversion and
N  *           automatically wakes up when a new conversion is triggered
N  *           (with startup time between trigger and start of sampling).
N  *           This feature can be combined with low power mode "auto wait".
N  * @note   With ADC low power mode "auto wait", the ADC conversion data read
N  *         is corresponding to previous ADC conversion start, independently
N  *         of delay during which ADC was idle.
N  *         Therefore, the ADC conversion data may be outdated: does not
N  *         correspond to the current voltage level on the selected
N  *         ADC channel.
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR1    WAIT           MS32_ADC_SetLowPowerMode\n
N  *         CFGR1    AUTOFF         MS32_ADC_SetLowPowerMode
N  * @param  ADCx ADC instance
N  * @param  LowPowerMode This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_LP_MODE_NONE
N  *         @arg @ref MS32_ADC_LP_AUTOWAIT
N  *         @arg @ref MS32_ADC_LP_AUTOPOWEROFF
N  *         @arg @ref MS32_ADC_LP_AUTOWAIT_AUTOPOWEROFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_SetLowPowerMode(ADC_TypeDef *ADCx, uint32_t LowPowerMode) {
Xstatic __inline void MS32_ADC_SetLowPowerMode(ADC_TypeDef *ADCx, uint32_t LowPowerMode) {
N  MODIFY_REG(ADCx->CFGR1, (ADC_CFGR1_WAIT | ADC_CFGR1_AUTOFF), LowPowerMode);
X  (((ADCx->CFGR1)) = ((((((ADCx->CFGR1))) & (~(((0x1UL << (14U)) | (0x1UL << (15U)))))) | (LowPowerMode))));
N}
N
N/**
N  * @brief  Get ADC low power mode:
N  * @note   Description of ADC low power modes:
N  *         - ADC low power mode "auto wait": Dynamic low power mode,
N  *           ADC conversions occurrences are limited to the minimum necessary
N  *           in order to reduce power consumption.
N  *           New ADC conversion starts only when the previous
N  *           unitary conversion data (for ADC group regular)
N  *           has been retrieved by user software.
N  *           In the meantime, ADC remains idle: does not performs any
N  *           other conversion.
N  *           This mode allows to automatically adapt the ADC conversions
N  *           triggers to the speed of the software that reads the data.
N  *           Moreover, this avoids risk of overrun for low frequency
N  *           applications.
N  *           How to use this low power mode:
N  *           - Do not use with interruption or DMA since these modes
N  *             have to clear immediately the EOC flag to free the
N  *             IRQ vector sequencer.
N  *           - Do use with polling: 1. Start conversion,
N  *             2. Later on, when conversion data is needed: poll for end of
N  *             conversion  to ensure that conversion is completed and
N  *             retrieve ADC conversion data. This will trig another
N  *             ADC conversion start.
N  *         - ADC low power mode "auto power-off" (feature available on
N  *           this device if parameter MS32_ADC_LP_MODE_AUTOOFF is available):
N  *           the ADC automatically powers-off after a conversion and
N  *           automatically wakes up when a new conversion is triggered
N  *           (with startup time between trigger and start of sampling).
N  *           This feature can be combined with low power mode "auto wait".
N  * @note   With ADC low power mode "auto wait", the ADC conversion data read
N  *         is corresponding to previous ADC conversion start, independently
N  *         of delay during which ADC was idle.
N  *         Therefore, the ADC conversion data may be outdated: does not
N  *         correspond to the current voltage level on the selected
N  *         ADC channel.
N  * @rmtoll CFGR1    WAIT           MS32_ADC_GetLowPowerMode\n
N  *         CFGR1    AUTOFF         MS32_ADC_GetLowPowerMode
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_LP_MODE_NONE
N  *         @arg @ref MS32_ADC_LP_AUTOWAIT
N  *         @arg @ref MS32_ADC_LP_AUTOPOWEROFF
N  *         @arg @ref MS32_ADC_LP_AUTOWAIT_AUTOPOWEROFF
N  */
N__STATIC_INLINE uint32_t MS32_ADC_GetLowPowerMode(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_GetLowPowerMode(ADC_TypeDef *ADCx) {
N  return (uint32_t)(READ_BIT(ADCx->CFGR1, (ADC_CFGR1_WAIT | ADC_CFGR1_AUTOFF)));
X  return (uint32_t)(((ADCx->CFGR1) & (((0x1UL << (14U)) | (0x1UL << (15U))))));
N}
N
N/**
N  * @brief  Set sampling time common to a group of channels.
N  * @note   Unit: ADC clock cycles.
N  * @note   On this MS32 serie, sampling time scope is on ADC instance:
N  *         Sampling time common to all channels.
N  *         (on some other MS32 families, sampling time is channel wise)
N  * @note   In case of internal channel (VrefInt, TempSensor, ...) to be
N  *         converted:
N  *         sampling time constraints must be respected (sampling time can be
N  *         adjusted in function of ADC clock frequency and sampling time
N  *         setting).
N  *         Refer to device datasheet for timings values (parameters TS_vrefint,
N  *         TS_temp, ...).
N  * @note   Conversion time is the addition of sampling time and processing time.
N  *         On this MS32 serie, ADC processing time is:
N  *         - 12.5 ADC clock cycles at ADC resolution 12 bits
N  *         - 10.5 ADC clock cycles at ADC resolution 10 bits
N  *         - 8.5 ADC clock cycles at ADC resolution 8 bits
N  *         - 6.5 ADC clock cycles at ADC resolution 6 bits
N  * @note   In case of ADC conversion of internal channel (VrefInt,
N  *         temperature sensor, ...), a sampling time minimum value
N  *         is required.
N  *         Refer to device datasheet.
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll SMPR     SMP            MS32_ADC_SetSamplingTimeCommonChannels
N  * @param  ADCx ADC instance
N  * @param  SamplingTime This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_1CYCLE_5
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_7CYCLES_5
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_13CYCLES_5
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_28CYCLES_5
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_41CYCLES_5
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_55CYCLES_5
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_71CYCLES_5
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_239CYCLES_5
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_SetSamplingTimeCommonChannels(ADC_TypeDef *ADCx, uint32_t SamplingTime) {
Xstatic __inline void MS32_ADC_SetSamplingTimeCommonChannels(ADC_TypeDef *ADCx, uint32_t SamplingTime) {
N  MODIFY_REG(ADCx->SMPR, ADC_SMPR_SMP, SamplingTime);
X  (((ADCx->SMPR)) = ((((((ADCx->SMPR))) & (~((0x7UL << (0U))))) | (SamplingTime))));
N}
N
N/**
N  * @brief  Get sampling time common to a group of channels.
N  * @note   Unit: ADC clock cycles.
N  * @note   On this MS32 serie, sampling time scope is on ADC instance:
N  *         Sampling time common to all channels.
N  *         (on some other MS32 families, sampling time is channel wise)
N  * @note   Conversion time is the addition of sampling time and processing time.
N  *         Refer to reference manual for ADC processing time of
N  *         this MS32 serie.
N  * @rmtoll SMPR     SMP            MS32_ADC_GetSamplingTimeCommonChannels
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_1CYCLE_5
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_7CYCLES_5
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_13CYCLES_5
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_28CYCLES_5
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_41CYCLES_5
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_55CYCLES_5
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_71CYCLES_5
N  *         @arg @ref MS32_ADC_SAMPLINGTIME_239CYCLES_5
N  */
N__STATIC_INLINE uint32_t MS32_ADC_GetSamplingTimeCommonChannels(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_GetSamplingTimeCommonChannels(ADC_TypeDef *ADCx) {
N  return (uint32_t)(READ_BIT(ADCx->SMPR, ADC_SMPR_SMP));
X  return (uint32_t)(((ADCx->SMPR) & ((0x7UL << (0U)))));
N}
N
N
N/** @defgroup ADC_EF_Configuration_ADC_Group_Regular Configuration of ADC hierarchical scope: group regular
N  * @{
N  */
N
N/**
N  * @brief  Set ADC group regular conversion trigger source:
N  *         internal (SW start) or from external IP (timer event,
N  *         external interrupt line).
N  * @note   On this MS32 serie, setting trigger source to external trigger
N  *         also set trigger polarity to rising edge
N  *         (default setting for compatibility with some ADC on other
N  *         MS32 families having this setting set by HW default value).
N  *         In case of need to modify trigger edge, use
N  *         function @ref MS32_ADC_REG_SetTriggerEdge().
N  * @note   Availability of parameters of trigger sources from timer
N  *         depends on timers availability on the selected device.
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR1    EXTSEL         MS32_ADC_REG_SetTriggerSource\n
N  *         CFGR1    EXTEN          MS32_ADC_REG_SetTriggerSource
N  * @param  ADCx ADC instance
N  * @param  TriggerSource This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_REG_TRIG_SOFTWARE
N  *         @arg @ref MS32_ADC_REG_TRIG_EXT_TIM1_TRGO
N  *         @arg @ref MS32_ADC_REG_TRIG_EXT_TIM1_CH4
N  *         @arg @ref MS32_ADC_REG_TRIG_EXT_TIM2_TRGO
N  *         @arg @ref MS32_ADC_REG_TRIG_EXT_TIM3_TRGO
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_REG_SetTriggerSource(ADC_TypeDef *ADCx, uint32_t TriggerSource) {
Xstatic __inline void MS32_ADC_REG_SetTriggerSource(ADC_TypeDef *ADCx, uint32_t TriggerSource) {
N  MODIFY_REG(ADCx->CFGR1, ADC_CFGR1_EXTEN | ADC_CFGR1_EXTSEL, TriggerSource);
X  (((ADCx->CFGR1)) = ((((((ADCx->CFGR1))) & (~((0x3UL << (10U)) | (0x7UL << (6U))))) | (TriggerSource))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion trigger source:
N  *         internal (SW start) or from external IP (timer event,
N  *         external interrupt line).
N  * @note   To determine whether group regular trigger source is
N  *         internal (SW start) or external, without detail
N  *         of which peripheral is selected as external trigger,
N  *         (equivalent to
N  *         "if(MS32_ADC_REG_GetTriggerSource(ADC1) == MS32_ADC_REG_TRIG_SOFTWARE)")
N  *         use function @ref MS32_ADC_REG_IsTriggerSourceSWStart.
N  * @note   Availability of parameters of trigger sources from timer
N  *         depends on timers availability on the selected device.
N  * @rmtoll CFGR1    EXTSEL         MS32_ADC_REG_GetTriggerSource\n
N  *         CFGR1    EXTEN          MS32_ADC_REG_GetTriggerSource
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_REG_TRIG_SOFTWARE
N  *         @arg @ref MS32_ADC_REG_TRIG_EXT_TIM1_TRGO
N  *         @arg @ref MS32_ADC_REG_TRIG_EXT_TIM1_CH4
N  *         @arg @ref MS32_ADC_REG_TRIG_EXT_TIM2_TRGO
N  *         @arg @ref MS32_ADC_REG_TRIG_EXT_TIM3_TRGO
N  */
N__STATIC_INLINE uint32_t MS32_ADC_REG_GetTriggerSource(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_REG_GetTriggerSource(ADC_TypeDef *ADCx) {
N  register uint32_t TriggerSource = READ_BIT(ADCx->CFGR1, ADC_CFGR1_EXTSEL | ADC_CFGR1_EXTEN);
X  register uint32_t TriggerSource = ((ADCx->CFGR1) & ((0x7UL << (6U)) | (0x3UL << (10U))));
N
N  /* Value for shift of {0; 4; 8; 12} depending on value of bitfield          */
N  /* corresponding to ADC_CFGR1_EXTEN {0; 1; 2; 3}.                           */
N  register uint32_t ShiftExten = ((TriggerSource & ADC_CFGR1_EXTEN) >> (ADC_REG_TRIG_EXTEN_BITOFFSET_POS - 2U));
X  register uint32_t ShiftExten = ((TriggerSource & (0x3UL << (10U))) >> ((10U) - 2U));
N
N  /* Set bitfield corresponding to ADC_CFGR1_EXTEN and ADC_CFGR1_EXTSEL       */
N  /* to match with triggers literals definition.                              */
N  return ((TriggerSource
N           & (ADC_REG_TRIG_SOURCE_MASK >> ShiftExten) & ADC_CFGR1_EXTSEL)
X           & (((((0x00000000U) & (0x7UL << (6U))) << (4U * 0U)) | (((0x7UL << (6U))) << (4U * 1U)) | (((0x7UL << (6U))) << (4U * 2U)) | (((0x7UL << (6U))) << (4U * 3U)) ) >> ShiftExten) & (0x7UL << (6U)))
N          | ((ADC_REG_TRIG_EDGE_MASK >> ShiftExten) & ADC_CFGR1_EXTEN)
X          | ((((((0x00000000U) & (0x3UL << (10U))) << (4U * 0U)) | ((((0x1UL << (10U)))) << (4U * 1U)) | ((((0x1UL << (10U)))) << (4U * 2U)) | ((((0x1UL << (10U)))) << (4U * 3U)) ) >> ShiftExten) & (0x3UL << (10U)))
N         );
N}
N
N/**
N  * @brief  Get ADC group regular conversion trigger source internal (SW start)
N            or external.
N  * @note   In case of group regular trigger source set to external trigger,
N  *         to determine which peripheral is selected as external trigger,
N  *         use function @ref MS32_ADC_REG_GetTriggerSource().
N  * @rmtoll CFGR1    EXTEN          MS32_ADC_REG_IsTriggerSourceSWStart
N  * @param  ADCx ADC instance
N  * @retval Value "0" if trigger source external trigger
N  *         Value "1" if trigger source SW start.
N  */
N__STATIC_INLINE uint32_t MS32_ADC_REG_IsTriggerSourceSWStart(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_REG_IsTriggerSourceSWStart(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->CFGR1, ADC_CFGR1_EXTEN) == (MS32_ADC_REG_TRIG_SOFTWARE & ADC_CFGR1_EXTEN));
X  return (((ADCx->CFGR1) & ((0x3UL << (10U)))) == ((0x00000000U) & (0x3UL << (10U))));
N}
N
N/**
N  * @brief  Set ADC group regular conversion trigger polarity.
N  * @note   Applicable only for trigger source set to external trigger.
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR1    EXTEN          MS32_ADC_REG_SetTriggerEdge
N  * @param  ADCx ADC instance
N  * @param  ExternalTriggerEdge This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_REG_TRIG_EXT_RISING
N  *         @arg @ref MS32_ADC_REG_TRIG_EXT_FALLING
N  *         @arg @ref MS32_ADC_REG_TRIG_EXT_RISINGFALLING
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_REG_SetTriggerEdge(ADC_TypeDef *ADCx, uint32_t ExternalTriggerEdge) {
Xstatic __inline void MS32_ADC_REG_SetTriggerEdge(ADC_TypeDef *ADCx, uint32_t ExternalTriggerEdge) {
N  MODIFY_REG(ADCx->CFGR1, ADC_CFGR1_EXTEN, ExternalTriggerEdge);
X  (((ADCx->CFGR1)) = ((((((ADCx->CFGR1))) & (~((0x3UL << (10U))))) | (ExternalTriggerEdge))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion trigger polarity.
N  * @note   Applicable only for trigger source set to external trigger.
N  * @rmtoll CFGR1    EXTEN          MS32_ADC_REG_GetTriggerEdge
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_REG_TRIG_EXT_RISING
N  *         @arg @ref MS32_ADC_REG_TRIG_EXT_FALLING
N  *         @arg @ref MS32_ADC_REG_TRIG_EXT_RISINGFALLING
N  */
N__STATIC_INLINE uint32_t MS32_ADC_REG_GetTriggerEdge(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_REG_GetTriggerEdge(ADC_TypeDef *ADCx) {
N  return (uint32_t)(READ_BIT(ADCx->CFGR1, ADC_CFGR1_EXTEN));
X  return (uint32_t)(((ADCx->CFGR1) & ((0x3UL << (10U)))));
N}
N
N
N/**
N  * @brief  Set ADC group regular sequencer scan direction.
N  * @note   On some other MS32 families, this setting is not available and
N  *         the default scan direction is forward.
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR1    SCANDIR        MS32_ADC_REG_SetSequencerScanDirection
N  * @param  ADCx ADC instance
N  * @param  ScanDirection This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_REG_SEQ_SCAN_DIR_FORWARD
N  *         @arg @ref MS32_ADC_REG_SEQ_SCAN_DIR_BACKWARD
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_REG_SetSequencerScanDirection(ADC_TypeDef *ADCx, uint32_t ScanDirection) {
Xstatic __inline void MS32_ADC_REG_SetSequencerScanDirection(ADC_TypeDef *ADCx, uint32_t ScanDirection) {
N  MODIFY_REG(ADCx->CFGR1, ADC_CFGR1_SCANDIR, ScanDirection);
X  (((ADCx->CFGR1)) = ((((((ADCx->CFGR1))) & (~((0x1UL << (2U))))) | (ScanDirection))));
N}
N
N/**
N  * @brief  Get ADC group regular sequencer scan direction.
N  * @note   On some other MS32 families, this setting is not available and
N  *         the default scan direction is forward.
N  * @rmtoll CFGR1    SCANDIR        MS32_ADC_REG_GetSequencerScanDirection
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_REG_SEQ_SCAN_DIR_FORWARD
N  *         @arg @ref MS32_ADC_REG_SEQ_SCAN_DIR_BACKWARD
N  */
N__STATIC_INLINE uint32_t MS32_ADC_REG_GetSequencerScanDirection(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_REG_GetSequencerScanDirection(ADC_TypeDef *ADCx) {
N  return (uint32_t)(READ_BIT(ADCx->CFGR1, ADC_CFGR1_SCANDIR));
X  return (uint32_t)(((ADCx->CFGR1) & ((0x1UL << (2U)))));
N}
N
N/**
N  * @brief  Set ADC group regular sequencer discontinuous mode:
N  *         sequence subdivided and scan conversions interrupted every selected
N  *         number of ranks.
N  * @note   It is not possible to enable both ADC group regular
N  *         continuous mode and sequencer discontinuous mode.
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR1    DISCEN         MS32_ADC_REG_SetSequencerDiscont\n
N  * @param  ADCx ADC instance
N  * @param  SeqDiscont This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_REG_SEQ_DISCONT_DISABLE
N  *         @arg @ref MS32_ADC_REG_SEQ_DISCONT_1RANK
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_REG_SetSequencerDiscont(ADC_TypeDef *ADCx, uint32_t SeqDiscont) {
Xstatic __inline void MS32_ADC_REG_SetSequencerDiscont(ADC_TypeDef *ADCx, uint32_t SeqDiscont) {
N  MODIFY_REG(ADCx->CFGR1, ADC_CFGR1_DISCEN, SeqDiscont);
X  (((ADCx->CFGR1)) = ((((((ADCx->CFGR1))) & (~((0x1UL << (16U))))) | (SeqDiscont))));
N}
N
N/**
N  * @brief  Get ADC group regular sequencer discontinuous mode:
N  *         sequence subdivided and scan conversions interrupted every selected
N  *         number of ranks.
N  * @rmtoll CFGR1    DISCEN         MS32_ADC_REG_GetSequencerDiscont\n
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_REG_SEQ_DISCONT_DISABLE
N  *         @arg @ref MS32_ADC_REG_SEQ_DISCONT_1RANK
N  */
N__STATIC_INLINE uint32_t MS32_ADC_REG_GetSequencerDiscont(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_REG_GetSequencerDiscont(ADC_TypeDef *ADCx) {
N  return (uint32_t)(READ_BIT(ADCx->CFGR1, ADC_CFGR1_DISCEN));
X  return (uint32_t)(((ADCx->CFGR1) & ((0x1UL << (16U)))));
N}
N
N/**
N  * @brief  Set ADC group regular sequence: channel on rank corresponding to
N  *         channel number.
N  * @note   This function performs:
N  *         - Channels ordering into each rank of scan sequence:
N  *           rank of each channel is fixed by channel HW number
N  *           (channel 0 fixed on rank 0, channel 1 fixed on rank1, ...).
N  *         - Set channels selected by overwriting the current sequencer
N  *           configuration.
N  * @note   On this MS32 serie, ADC group regular sequencer is
N  *         not fully configurable: sequencer length and each rank
N  *         affectation to a channel are fixed by channel HW number.
N  * @note   Depending on devices and packages, some channels may not be available.
N  *         Refer to device datasheet for channels availability.
N  * @note   On this MS32 serie, to measure internal channels (VrefInt,
N  *         TempSensor, ...), measurement paths to internal channels must be
N  *         enabled separately.
N  *         This can be done using function @ref MS32_ADC_SetCommonPathInternalCh().
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @note   One or several values can be selected.
N  *         Example: (MS32_ADC_CHANNEL_4 | MS32_ADC_CHANNEL_12 | ...)
N  * @rmtoll CHSELR   CHSEL0         MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL1         MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL2         MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL3         MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL4         MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL5         MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL6         MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL7         MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL8         MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL9         MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL10        MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL11        MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL12        MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL13        MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL14        MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL15        MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL16        MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL17        MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL18        MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL19        MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL20        MS32_ADC_REG_SetSequencerChannels\n
N  *         CHSELR   CHSEL21        MS32_ADC_REG_SetSequencerChannels
N  * @param  ADCx ADC instance
N  * @param  Channel This parameter can be a combination of the following values:
N  *         @arg @ref MS32_ADC_CHANNEL_0
N  *         @arg @ref MS32_ADC_CHANNEL_1
N  *         @arg @ref MS32_ADC_CHANNEL_2
N  *         @arg @ref MS32_ADC_CHANNEL_3
N  *         @arg @ref MS32_ADC_CHANNEL_4
N  *         @arg @ref MS32_ADC_CHANNEL_5
N  *         @arg @ref MS32_ADC_CHANNEL_6
N  *         @arg @ref MS32_ADC_CHANNEL_7
N  *         @arg @ref MS32_ADC_CHANNEL_8
N  *         @arg @ref MS32_ADC_CHANNEL_9
N  *         @arg @ref MS32_ADC_CHANNEL_10
N  *         @arg @ref MS32_ADC_CHANNEL_11
N  *         @arg @ref MS32_ADC_CHANNEL_12
N  *         @arg @ref MS32_ADC_CHANNEL_13
N  *         @arg @ref MS32_ADC_CHANNEL_14
N  *         @arg @ref MS32_ADC_CHANNEL_15
N  *         @arg @ref MS32_ADC_CHANNEL_16
N  *         @arg @ref MS32_ADC_CHANNEL_17
N  *         @arg @ref MS32_ADC_CHANNEL_18
N  *         @arg @ref MS32_ADC_CHANNEL_19
N  *         @arg @ref MS32_ADC_CHANNEL_20
N  *         @arg @ref MS32_ADC_CHANNEL_21
N  *         @arg @ref MS32_ADC_CHANNEL_VREFINT
N  *         @arg @ref MS32_ADC_CHANNEL_TEMPSENSOR
N  *         @arg @ref MS32_ADC_CHANNEL_VBAT
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP1
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP2
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP3
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_REG_SetSequencerChannels(ADC_TypeDef *ADCx, uint32_t Channel) {
Xstatic __inline void MS32_ADC_REG_SetSequencerChannels(ADC_TypeDef *ADCx, uint32_t Channel) {
N  /* Parameter "Channel" is used with masks because containing                */
N  /* other bits reserved for other purpose.                                   */
N  WRITE_REG(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
X  ((ADCx->CHSELR) = ((Channel & ((0x3FFFFFUL << (0U))))));
N}
N
N/**
N  * @brief  Add channel to ADC group regular sequence: channel on rank corresponding to
N  *         channel number.
N  * @note   This function performs:
N  *         - Channels ordering into each rank of scan sequence:
N  *           rank of each channel is fixed by channel HW number
N  *           (channel 0 fixed on rank 0, channel 1 fixed on rank1, ...).
N  *         - Set channels selected by adding them to the current sequencer
N  *           configuration.
N  * @note   On this MS32 serie, ADC group regular sequencer is
N  *         not fully configurable: sequencer length and each rank
N  *         affectation to a channel are fixed by channel HW number.
N  * @note   Depending on devices and packages, some channels may not be available.
N  *         Refer to device datasheet for channels availability.
N  * @note   On this MS32 serie, to measure internal channels (VrefInt,
N  *         TempSensor, ...), measurement paths to internal channels must be
N  *         enabled separately.
N  *         This can be done using function @ref MS32_ADC_SetCommonPathInternalCh().
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @note   One or several values can be selected.
N  *         Example: (MS32_ADC_CHANNEL_4 | MS32_ADC_CHANNEL_12 | ...)
N  * @rmtoll CHSELR   CHSEL0         MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL1         MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL2         MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL3         MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL4         MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL5         MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL6         MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL7         MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL8         MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL9         MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL10        MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL11        MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL12        MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL13        MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL14        MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL15        MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL16        MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL17        MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL18        MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL19        MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL20        MS32_ADC_REG_SetSequencerChAdd\n
N  *         CHSELR   CHSEL21        MS32_ADC_REG_SetSequencerChAdd
N  * @param  ADCx ADC instance
N  * @param  Channel This parameter can be a combination of the following values:
N  *         @arg @ref MS32_ADC_CHANNEL_0
N  *         @arg @ref MS32_ADC_CHANNEL_1
N  *         @arg @ref MS32_ADC_CHANNEL_2
N  *         @arg @ref MS32_ADC_CHANNEL_3
N  *         @arg @ref MS32_ADC_CHANNEL_4
N  *         @arg @ref MS32_ADC_CHANNEL_5
N  *         @arg @ref MS32_ADC_CHANNEL_6
N  *         @arg @ref MS32_ADC_CHANNEL_7
N  *         @arg @ref MS32_ADC_CHANNEL_8
N  *         @arg @ref MS32_ADC_CHANNEL_9
N  *         @arg @ref MS32_ADC_CHANNEL_10
N  *         @arg @ref MS32_ADC_CHANNEL_11
N  *         @arg @ref MS32_ADC_CHANNEL_12
N  *         @arg @ref MS32_ADC_CHANNEL_13
N  *         @arg @ref MS32_ADC_CHANNEL_14
N  *         @arg @ref MS32_ADC_CHANNEL_15
N  *         @arg @ref MS32_ADC_CHANNEL_16
N  *         @arg @ref MS32_ADC_CHANNEL_17
N  *         @arg @ref MS32_ADC_CHANNEL_18
N  *         @arg @ref MS32_ADC_CHANNEL_19
N  *         @arg @ref MS32_ADC_CHANNEL_20
N  *         @arg @ref MS32_ADC_CHANNEL_21
N  *         @arg @ref MS32_ADC_CHANNEL_VREFINT
N  *         @arg @ref MS32_ADC_CHANNEL_TEMPSENSOR
N  *         @arg @ref MS32_ADC_CHANNEL_VBAT
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP1
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP2
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP3
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_REG_SetSequencerChAdd(ADC_TypeDef *ADCx, uint32_t Channel) {
Xstatic __inline void MS32_ADC_REG_SetSequencerChAdd(ADC_TypeDef *ADCx, uint32_t Channel) {
N  /* Parameter "Channel" is used with masks because containing                */
N  /* other bits reserved for other purpose.                                   */
N  SET_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
X  ((ADCx->CHSELR) |= ((Channel & ((0x3FFFFFUL << (0U))))));
N}
N
N/**
N  * @brief  Remove channel to ADC group regular sequence: channel on rank corresponding to
N  *         channel number.
N  * @note   This function performs:
N  *         - Channels ordering into each rank of scan sequence:
N  *           rank of each channel is fixed by channel HW number
N  *           (channel 0 fixed on rank 0, channel 1 fixed on rank1, ...).
N  *         - Set channels selected by removing them to the current sequencer
N  *           configuration.
N  * @note   On this MS32 serie, ADC group regular sequencer is
N  *         not fully configurable: sequencer length and each rank
N  *         affectation to a channel are fixed by channel HW number.
N  * @note   Depending on devices and packages, some channels may not be available.
N  *         Refer to device datasheet for channels availability.
N  * @note   On this MS32 serie, to measure internal channels (VrefInt,
N  *         TempSensor, ...), measurement paths to internal channels must be
N  *         enabled separately.
N  *         This can be done using function @ref MS32_ADC_SetCommonPathInternalCh().
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @note   One or several values can be selected.
N  *         Example: (MS32_ADC_CHANNEL_4 | MS32_ADC_CHANNEL_12 | ...)
N  * @rmtoll CHSELR   CHSEL0         MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL1         MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL2         MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL3         MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL4         MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL5         MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL6         MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL7         MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL8         MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL9         MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL10        MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL11        MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL12        MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL13        MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL14        MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL15        MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL16        MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL17        MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL18        MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL19        MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL20        MS32_ADC_REG_SetSequencerChRem\n
N  *         CHSELR   CHSEL21        MS32_ADC_REG_SetSequencerChRem
N  * @param  ADCx ADC instance
N  * @param  Channel This parameter can be a combination of the following values:
N  *         @arg @ref MS32_ADC_CHANNEL_0
N  *         @arg @ref MS32_ADC_CHANNEL_1
N  *         @arg @ref MS32_ADC_CHANNEL_2
N  *         @arg @ref MS32_ADC_CHANNEL_3
N  *         @arg @ref MS32_ADC_CHANNEL_4
N  *         @arg @ref MS32_ADC_CHANNEL_5
N  *         @arg @ref MS32_ADC_CHANNEL_6
N  *         @arg @ref MS32_ADC_CHANNEL_7
N  *         @arg @ref MS32_ADC_CHANNEL_8
N  *         @arg @ref MS32_ADC_CHANNEL_9
N  *         @arg @ref MS32_ADC_CHANNEL_10
N  *         @arg @ref MS32_ADC_CHANNEL_11
N  *         @arg @ref MS32_ADC_CHANNEL_12
N  *         @arg @ref MS32_ADC_CHANNEL_13
N  *         @arg @ref MS32_ADC_CHANNEL_14
N  *         @arg @ref MS32_ADC_CHANNEL_15
N  *         @arg @ref MS32_ADC_CHANNEL_16
N  *         @arg @ref MS32_ADC_CHANNEL_17
N  *         @arg @ref MS32_ADC_CHANNEL_18
N  *         @arg @ref MS32_ADC_CHANNEL_19
N  *         @arg @ref MS32_ADC_CHANNEL_20
N  *         @arg @ref MS32_ADC_CHANNEL_21
N  *         @arg @ref MS32_ADC_CHANNEL_VREFINT
N  *         @arg @ref MS32_ADC_CHANNEL_TEMPSENSOR
N  *         @arg @ref MS32_ADC_CHANNEL_VBAT
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP1
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP2
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP3
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_REG_SetSequencerChRem(ADC_TypeDef *ADCx, uint32_t Channel) {
Xstatic __inline void MS32_ADC_REG_SetSequencerChRem(ADC_TypeDef *ADCx, uint32_t Channel) {
N  /* Parameter "Channel" is used with masks because containing                */
N  /* other bits reserved for other purpose.                                   */
N  CLEAR_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
X  ((ADCx->CHSELR) &= ~((Channel & ((0x3FFFFFUL << (0U))))));
N}
N
N/**
N  * @brief  Get ADC group regular sequence: channel on rank corresponding to
N  *         channel number.
N  * @note   This function performs:
N  *         - Channels order reading into each rank of scan sequence:
N  *           rank of each channel is fixed by channel HW number
N  *           (channel 0 fixed on rank 0, channel 1 fixed on rank1, ...).
N  * @note   On this MS32 serie, ADC group regular sequencer is
N  *         not fully configurable: sequencer length and each rank
N  *         affectation to a channel are fixed by channel HW number.
N  * @note   Depending on devices and packages, some channels may not be available.
N  *         Refer to device datasheet for channels availability.
N  * @note   On this MS32 serie, to measure internal channels (VrefInt,
N  *         TempSensor, ...), measurement paths to internal channels must be
N  *         enabled separately.
N  *         This can be done using function @ref MS32_ADC_SetCommonPathInternalCh().
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @note   One or several values can be retrieved.
N  *         Example: (MS32_ADC_CHANNEL_4 | MS32_ADC_CHANNEL_12 | ...)
N  * @rmtoll CHSELR   CHSEL0         MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL1         MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL2         MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL3         MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL4         MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL5         MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL6         MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL7         MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL8         MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL9         MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL10        MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL11        MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL12        MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL13        MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL14        MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL15        MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL16        MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL17        MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL18        MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL19        MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL20        MS32_ADC_REG_GetSequencerChannels\n
N  *         CHSELR   CHSEL21        MS32_ADC_REG_GetSequencerChannels
N  * @param  ADCx ADC instance
N  * @retval Returned value can be a combination of the following values:
N  *         @arg @ref MS32_ADC_CHANNEL_0
N  *         @arg @ref MS32_ADC_CHANNEL_1
N  *         @arg @ref MS32_ADC_CHANNEL_2
N  *         @arg @ref MS32_ADC_CHANNEL_3
N  *         @arg @ref MS32_ADC_CHANNEL_4
N  *         @arg @ref MS32_ADC_CHANNEL_5
N  *         @arg @ref MS32_ADC_CHANNEL_6
N  *         @arg @ref MS32_ADC_CHANNEL_7
N  *         @arg @ref MS32_ADC_CHANNEL_8
N  *         @arg @ref MS32_ADC_CHANNEL_9
N  *         @arg @ref MS32_ADC_CHANNEL_10
N  *         @arg @ref MS32_ADC_CHANNEL_11
N  *         @arg @ref MS32_ADC_CHANNEL_12
N  *         @arg @ref MS32_ADC_CHANNEL_13
N  *         @arg @ref MS32_ADC_CHANNEL_14
N  *         @arg @ref MS32_ADC_CHANNEL_15
N  *         @arg @ref MS32_ADC_CHANNEL_16
N  *         @arg @ref MS32_ADC_CHANNEL_17
N  *         @arg @ref MS32_ADC_CHANNEL_18
N  *         @arg @ref MS32_ADC_CHANNEL_19
N  *         @arg @ref MS32_ADC_CHANNEL_20
N  *         @arg @ref MS32_ADC_CHANNEL_21
N  *         @arg @ref MS32_ADC_CHANNEL_VREFINT
N  *         @arg @ref MS32_ADC_CHANNEL_TEMPSENSOR
N  *         @arg @ref MS32_ADC_CHANNEL_VBAT
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP1
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP2
N  *         @arg @ref MS32_ADC_CHANNEL_OPAMP3
N  */
N__STATIC_INLINE uint32_t MS32_ADC_REG_GetSequencerChannels(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_REG_GetSequencerChannels(ADC_TypeDef *ADCx) {
N  register uint32_t ChannelsBitfield = READ_BIT(ADCx->CHSELR, ADC_CHSELR_CHSEL);
X  register uint32_t ChannelsBitfield = ((ADCx->CHSELR) & ((0x3FFFFFUL << (0U))));
N
N  return (   (((ChannelsBitfield & ADC_CHSELR_CHSEL0) >> ADC_CHSELR_CHSEL0_BITOFFSET_POS) * MS32_ADC_CHANNEL_0)
X  return (   (((ChannelsBitfield & (0x1UL << (0U))) >> ( 0U)) * ((0x00000000U) | ((0x1UL << (0U))) ))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL1) >> ADC_CHSELR_CHSEL1_BITOFFSET_POS) * MS32_ADC_CHANNEL_1)
X           | (((ChannelsBitfield & (0x1UL << (1U))) >> ( 1U)) * (( (0x01UL << (26U))) | ((0x1UL << (1U))) ))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL2) >> ADC_CHSELR_CHSEL2_BITOFFSET_POS) * MS32_ADC_CHANNEL_2)
X           | (((ChannelsBitfield & (0x1UL << (2U))) >> ( 2U)) * (( (0x02UL << (26U)) ) | ((0x1UL << (2U))) ))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL3) >> ADC_CHSELR_CHSEL3_BITOFFSET_POS) * MS32_ADC_CHANNEL_3)
X           | (((ChannelsBitfield & (0x1UL << (3U))) >> ( 3U)) * (( (0x02UL << (26U)) | (0x01UL << (26U))) | ((0x1UL << (3U))) ))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL4) >> ADC_CHSELR_CHSEL4_BITOFFSET_POS) * MS32_ADC_CHANNEL_4)
X           | (((ChannelsBitfield & (0x1UL << (4U))) >> ( 4U)) * (( (0x04UL << (26U)) ) | ((0x1UL << (4U))) ))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL5) >> ADC_CHSELR_CHSEL5_BITOFFSET_POS) * MS32_ADC_CHANNEL_5)
X           | (((ChannelsBitfield & (0x1UL << (5U))) >> ( 5U)) * (( (0x04UL << (26U)) | (0x01UL << (26U))) | ((0x1UL << (5U))) ))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL6) >> ADC_CHSELR_CHSEL6_BITOFFSET_POS) * MS32_ADC_CHANNEL_6)
X           | (((ChannelsBitfield & (0x1UL << (6U))) >> ( 6U)) * (( (0x04UL << (26U)) | (0x02UL << (26U)) ) | ((0x1UL << (6U))) ))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL7) >> ADC_CHSELR_CHSEL7_BITOFFSET_POS) * MS32_ADC_CHANNEL_7)
X           | (((ChannelsBitfield & (0x1UL << (7U))) >> ( 7U)) * (( (0x04UL << (26U)) | (0x02UL << (26U)) | (0x01UL << (26U))) | ((0x1UL << (7U))) ))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL8) >> ADC_CHSELR_CHSEL8_BITOFFSET_POS) * MS32_ADC_CHANNEL_8)
X           | (((ChannelsBitfield & (0x1UL << (8U))) >> ( 8U)) * (( (0x08UL << (26U)) ) | ((0x1UL << (8U))) ))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL9) >> ADC_CHSELR_CHSEL9_BITOFFSET_POS) * MS32_ADC_CHANNEL_9)
X           | (((ChannelsBitfield & (0x1UL << (9U))) >> ( 9U)) * (( (0x08UL << (26U)) | (0x01UL << (26U))) | ((0x1UL << (9U))) ))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL10) >> ADC_CHSELR_CHSEL10_BITOFFSET_POS) * MS32_ADC_CHANNEL_10)
X           | (((ChannelsBitfield & (0x1UL << (10U))) >> (10U)) * (( (0x08UL << (26U)) | (0x02UL << (26U)) ) | ((0x1UL << (10U)))))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL11) >> ADC_CHSELR_CHSEL11_BITOFFSET_POS) * MS32_ADC_CHANNEL_11)
X           | (((ChannelsBitfield & (0x1UL << (11U))) >> (11U)) * (( (0x08UL << (26U)) | (0x02UL << (26U)) | (0x01UL << (26U))) | ((0x1UL << (11U)))))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL12) >> ADC_CHSELR_CHSEL12_BITOFFSET_POS) * MS32_ADC_CHANNEL_12)
X           | (((ChannelsBitfield & (0x1UL << (12U))) >> (12U)) * (( (0x08UL << (26U)) | (0x04UL << (26U)) ) | ((0x1UL << (12U)))))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL13) >> ADC_CHSELR_CHSEL13_BITOFFSET_POS) * MS32_ADC_CHANNEL_13)
X           | (((ChannelsBitfield & (0x1UL << (13U))) >> (13U)) * (( (0x08UL << (26U)) | (0x04UL << (26U)) | (0x01UL << (26U))) | ((0x1UL << (13U)))))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL14) >> ADC_CHSELR_CHSEL14_BITOFFSET_POS) * MS32_ADC_CHANNEL_14)
X           | (((ChannelsBitfield & (0x1UL << (14U))) >> (14U)) * (( (0x08UL << (26U)) | (0x04UL << (26U)) | (0x02UL << (26U)) ) | ((0x1UL << (14U)))))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL15) >> ADC_CHSELR_CHSEL15_BITOFFSET_POS) * MS32_ADC_CHANNEL_15)
X           | (((ChannelsBitfield & (0x1UL << (15U))) >> (15U)) * (( (0x08UL << (26U)) | (0x04UL << (26U)) | (0x02UL << (26U)) | (0x01UL << (26U))) | ((0x1UL << (15U)))))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL16) >> ADC_CHSELR_CHSEL16_BITOFFSET_POS) * MS32_ADC_CHANNEL_16)
X           | (((ChannelsBitfield & (0x1UL << (16U))) >> (16U)) * (((0x10UL << (26U)) ) | ((0x1UL << (16U)))))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL17) >> ADC_CHSELR_CHSEL17_BITOFFSET_POS) * MS32_ADC_CHANNEL_17)
X           | (((ChannelsBitfield & (0x1UL << (17U))) >> (17U)) * (((0x10UL << (26U)) | (0x01UL << (26U))) | ((0x1UL << (17U)))))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL18) >> ADC_CHSELR_CHSEL18_BITOFFSET_POS) * MS32_ADC_CHANNEL_18)
X           | (((ChannelsBitfield & (0x1UL << (18U))) >> (18U)) * (((0x10UL << (26U)) | (0x02UL << (26U)) ) | ((0x1UL << (18U)))))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL19) >> ADC_CHSELR_CHSEL19_BITOFFSET_POS) * MS32_ADC_CHANNEL_19)
X           | (((ChannelsBitfield & (0x1UL << (19U))) >> (19U)) * (((0x10UL << (26U)) | (0x02UL << (26U)) | (0x01UL << (26U))) | ((0x1UL << (19U)))))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL20) >> ADC_CHSELR_CHSEL20_BITOFFSET_POS) * MS32_ADC_CHANNEL_20)
X           | (((ChannelsBitfield & (0x1UL << (20U))) >> (20U)) * (((0x10UL << (26U)) | (0x04UL << (26U)) ) | ((0x1UL << (20U)))))
N           | (((ChannelsBitfield & ADC_CHSELR_CHSEL21) >> ADC_CHSELR_CHSEL21_BITOFFSET_POS) * MS32_ADC_CHANNEL_21)
X           | (((ChannelsBitfield & (0x1UL << (21U))) >> (21U)) * (((0x10UL << (26U)) | (0x04UL << (26U)) | (0x01UL << (26U))) | ((0x1UL << (21U)))))
N         );
N}
N/**
N  * @brief  Set ADC continuous conversion mode on ADC group regular.
N  * @note   Description of ADC continuous conversion mode:
N  *         - single mode: one conversion per trigger
N  *         - continuous mode: after the first trigger, following
N  *           conversions launched successively automatically.
N  * @note   It is not possible to enable both ADC group regular
N  *         continuous mode and sequencer discontinuous mode.
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR1    CONT           MS32_ADC_REG_SetContinuousMode
N  * @param  ADCx ADC instance
N  * @param  Continuous This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_REG_CONV_SINGLE
N  *         @arg @ref MS32_ADC_REG_CONV_CONTINUOUS
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_REG_SetContinuousMode(ADC_TypeDef *ADCx, uint32_t Continuous) {
Xstatic __inline void MS32_ADC_REG_SetContinuousMode(ADC_TypeDef *ADCx, uint32_t Continuous) {
N  MODIFY_REG(ADCx->CFGR1, ADC_CFGR1_CONT, Continuous);
X  (((ADCx->CFGR1)) = ((((((ADCx->CFGR1))) & (~((0x1UL << (13U))))) | (Continuous))));
N}
N
N/**
N  * @brief  Get ADC continuous conversion mode on ADC group regular.
N  * @note   Description of ADC continuous conversion mode:
N  *         - single mode: one conversion per trigger
N  *         - continuous mode: after the first trigger, following
N  *           conversions launched successively automatically.
N  * @rmtoll CFGR1    CONT           MS32_ADC_REG_GetContinuousMode
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_REG_CONV_SINGLE
N  *         @arg @ref MS32_ADC_REG_CONV_CONTINUOUS
N  */
N__STATIC_INLINE uint32_t MS32_ADC_REG_GetContinuousMode(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_REG_GetContinuousMode(ADC_TypeDef *ADCx) {
N  return (uint32_t)(READ_BIT(ADCx->CFGR1, ADC_CFGR1_CONT));
X  return (uint32_t)(((ADCx->CFGR1) & ((0x1UL << (13U)))));
N}
N
N/**
N  * @brief  Set ADC group regular conversion data transfer: no transfer or
N  *         transfer by DMA, and DMA requests mode.
N  * @note   If transfer by DMA selected, specifies the DMA requests
N  *         mode:
N  *         - Limited mode (One shot mode): DMA transfer requests are stopped
N  *           when number of DMA data transfers (number of
N  *           ADC conversions) is reached.
N  *           This ADC mode is intended to be used with DMA mode non-circular.
N  *         - Unlimited mode: DMA transfer requests are unlimited,
N  *           whatever number of DMA data transfers (number of
N  *           ADC conversions).
N  *           This ADC mode is intended to be used with DMA mode circular.
N  * @note   If ADC DMA requests mode is set to unlimited and DMA is set to
N  *         mode non-circular:
N  *         when DMA transfers size will be reached, DMA will stop transfers of
N  *         ADC conversions data ADC will raise an overrun error
N  *        (overrun flag and interruption if enabled).
N  * @note   To configure DMA source address (peripheral address),
N  *         use function @ref MS32_ADC_DMA_GetRegAddr().
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR1    DMAEN          MS32_ADC_REG_SetDMATransfer\n
N  *         CFGR1    DMACFG         MS32_ADC_REG_SetDMATransfer
N  * @param  ADCx ADC instance
N  * @param  DMATransfer This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_REG_DMA_TRANSFER_NONE
N  *         @arg @ref MS32_ADC_REG_DMA_TRANSFER_LIMITED
N  *         @arg @ref MS32_ADC_REG_DMA_TRANSFER_UNLIMITED
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_REG_SetDMATransfer(ADC_TypeDef *ADCx, uint32_t DMATransfer) {
Xstatic __inline void MS32_ADC_REG_SetDMATransfer(ADC_TypeDef *ADCx, uint32_t DMATransfer) {
N  MODIFY_REG(ADCx->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG, DMATransfer);
X  (((ADCx->CFGR1)) = ((((((ADCx->CFGR1))) & (~((0x1UL << (0U)) | (0x1UL << (1U))))) | (DMATransfer))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion data transfer: no transfer or
N  *         transfer by DMA, and DMA requests mode.
N  * @note   If transfer by DMA selected, specifies the DMA requests
N  *         mode:
N  *         - Limited mode (One shot mode): DMA transfer requests are stopped
N  *           when number of DMA data transfers (number of
N  *           ADC conversions) is reached.
N  *           This ADC mode is intended to be used with DMA mode non-circular.
N  *         - Unlimited mode: DMA transfer requests are unlimited,
N  *           whatever number of DMA data transfers (number of
N  *           ADC conversions).
N  *           This ADC mode is intended to be used with DMA mode circular.
N  * @note   If ADC DMA requests mode is set to unlimited and DMA is set to
N  *         mode non-circular:
N  *         when DMA transfers size will be reached, DMA will stop transfers of
N  *         ADC conversions data ADC will raise an overrun error
N  *         (overrun flag and interruption if enabled).
N  * @note   To configure DMA source address (peripheral address),
N  *         use function @ref MS32_ADC_DMA_GetRegAddr().
N  * @rmtoll CFGR1    DMAEN          MS32_ADC_REG_GetDMATransfer\n
N  *         CFGR1    DMACFG         MS32_ADC_REG_GetDMATransfer
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_REG_DMA_TRANSFER_NONE
N  *         @arg @ref MS32_ADC_REG_DMA_TRANSFER_LIMITED
N  *         @arg @ref MS32_ADC_REG_DMA_TRANSFER_UNLIMITED
N  */
N__STATIC_INLINE uint32_t MS32_ADC_REG_GetDMATransfer(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_REG_GetDMATransfer(ADC_TypeDef *ADCx) {
N  return (uint32_t)(READ_BIT(ADCx->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG));
X  return (uint32_t)(((ADCx->CFGR1) & ((0x1UL << (0U)) | (0x1UL << (1U)))));
N}
N
N/**
N  * @brief  Set ADC group regular behavior in case of overrun:
N  *         data preserved or overwritten.
N  * @note   Compatibility with devices without feature overrun:
N  *         other devices without this feature have a behavior
N  *         equivalent to data overwritten.
N  *         The default setting of overrun is data preserved.
N  *         Therefore, for compatibility with all devices, parameter
N  *         overrun should be set to data overwritten.
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR1    OVRMOD         MS32_ADC_REG_SetOverrun
N  * @param  ADCx ADC instance
N  * @param  Overrun This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_REG_OVR_DATA_PRESERVED
N  *         @arg @ref MS32_ADC_REG_OVR_DATA_OVERWRITTEN
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_REG_SetOverrun(ADC_TypeDef *ADCx, uint32_t Overrun) {
Xstatic __inline void MS32_ADC_REG_SetOverrun(ADC_TypeDef *ADCx, uint32_t Overrun) {
N  MODIFY_REG(ADCx->CFGR1, ADC_CFGR1_OVRMOD, Overrun);
X  (((ADCx->CFGR1)) = ((((((ADCx->CFGR1))) & (~((0x1UL << (12U))))) | (Overrun))));
N}
N
N/**
N  * @brief  Get ADC group regular behavior in case of overrun:
N  *         data preserved or overwritten.
N  * @rmtoll CFGR1    OVRMOD         MS32_ADC_REG_GetOverrun
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_REG_OVR_DATA_PRESERVED
N  *         @arg @ref MS32_ADC_REG_OVR_DATA_OVERWRITTEN
N  */
N__STATIC_INLINE uint32_t MS32_ADC_REG_GetOverrun(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_REG_GetOverrun(ADC_TypeDef *ADCx) {
N  return (uint32_t)(READ_BIT(ADCx->CFGR1, ADC_CFGR1_OVRMOD));
X  return (uint32_t)(((ADCx->CFGR1) & ((0x1UL << (12U)))));
N}
N
N
N
N/** @defgroup ADC_EF_Configuration_ADC_AnalogWatchdog Configuration of ADC transversal scope: analog watchdog
N  * @{
N  */
N
N/**
N  * @brief  Set ADC analog watchdog monitored channels:
N  *         a single channel or all channels,
N  *         on ADC group regular.
N  * @note   Once monitored channels are selected, analog watchdog
N  *         is enabled.
N  * @note   In case of need to define a single channel to monitor
N  *         with analog watchdog from sequencer channel definition,
N  *         use helper macro @ref __MS32_ADC_ANALOGWD_CHANNEL_GROUP().
N  * @note   On this MS32 serie, there is only 1 kind of analog watchdog
N  *         instance:
N  *         - AWD standard (instance AWD1):
N  *           - channels monitored: can monitor 1 channel or all channels.
N  *           - groups monitored: ADC group regular.
N  *           - resolution: resolution is not limited (corresponds to
N  *             ADC resolution configured).
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR1    AWDCH          MS32_ADC_SetAnalogWDMonitChannels\n
N  *         CFGR1    AWDSGL         MS32_ADC_SetAnalogWDMonitChannels\n
N  *         CFGR1    AWDEN          MS32_ADC_SetAnalogWDMonitChannels
N  * @param  ADCx ADC instance
N  * @param  AWDChannelGroup This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_AWD_DISABLE
N  *         @arg @ref MS32_ADC_AWD_AMS32_CHANNELS_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_0_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_1_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_2_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_3_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_4_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_5_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_6_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_7_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_8_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_9_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_10_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_11_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_12_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_13_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_14_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_15_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_16_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_17_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_18_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_19_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_20_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_21_REG
N  *         @arg @ref MS32_ADC_AWD_CH_VREFINT_REG
N  *         @arg @ref MS32_ADC_AWD_CH_TEMPSENSOR_REG
N  *         @arg @ref MS32_ADC_AWD_CH_VBAT_REG
N  *         @arg @ref MS32_ADC_AWD_CH_OPAMP1_REG
N  *         @arg @ref MS32_ADC_AWD_CH_OPAMP2_REG
N  *         @arg @ref MS32_ADC_AWD_CH_OPAMP3_REG
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_SetAnalogWDMonitChannels(ADC_TypeDef *ADCx, uint32_t AWDChannelGroup) {
Xstatic __inline void MS32_ADC_SetAnalogWDMonitChannels(ADC_TypeDef *ADCx, uint32_t AWDChannelGroup) {
N  MODIFY_REG(ADCx->CFGR1,
N             (ADC_CFGR1_AWDCH | ADC_CFGR1_AWDSGL | ADC_CFGR1_AWDEN),
N             (AWDChannelGroup & ADC_AWD_CR_ALL_CHANNEL_MASK));
X  (((ADCx->CFGR1)) = ((((((ADCx->CFGR1))) & (~(((0x1FUL << (26U)) | (0x1UL << (22U)) | (0x1UL << (23U)))))) | ((AWDChannelGroup & (((0x1FUL << (26U)) | (0x1UL << (23U)) | (0x1UL << (22U)))))))));
N}
N
N/**
N  * @brief  Get ADC analog watchdog monitored channel.
N  * @note   Usage of the returned channel number:
N  *         - To reinject this channel into another function MS32_ADC_xxx:
N  *           the returned channel number is only partly formatted on definition
N  *           of literals MS32_ADC_CHANNEL_x. Therefore, it has to be compared
N  *           with parts of literals MS32_ADC_CHANNEL_x or using
N  *           helper macro @ref __MS32_ADC_CHANNEL_TO_DECIMAL_NB().
N  *           Then the selected literal MS32_ADC_CHANNEL_x can be used
N  *           as parameter for another function.
N  *         - To get the channel number in decimal format:
N  *           process the returned value with the helper macro
N  *           @ref __MS32_ADC_CHANNEL_TO_DECIMAL_NB().
N  *           Applicable only when the analog watchdog is set to monitor
N  *           one channel.
N  * @note   On this MS32 serie, there is only 1 kind of analog watchdog
N  *         instance:
N  *         - AWD standard (instance AWD1):
N  *           - channels monitored: can monitor 1 channel or all channels.
N  *           - groups monitored: ADC group regular.
N  *           - resolution: resolution is not limited (corresponds to
N  *             ADC resolution configured).
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR1    AWDCH          MS32_ADC_GetAnalogWDMonitChannels\n
N  *         CFGR1    AWDSGL         MS32_ADC_GetAnalogWDMonitChannels\n
N  *         CFGR1    AWDEN          MS32_ADC_GetAnalogWDMonitChannels
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_ADC_AWD_DISABLE
N  *         @arg @ref MS32_ADC_AWD_AMS32_CHANNELS_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_0_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_1_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_2_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_3_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_4_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_5_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_6_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_7_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_8_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_9_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_10_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_11_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_12_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_13_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_14_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_15_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_16_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_17_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_18_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_19_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_20_REG
N  *         @arg @ref MS32_ADC_AWD_CHANNEL_21_REG
N  */
N__STATIC_INLINE uint32_t MS32_ADC_GetAnalogWDMonitChannels(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_GetAnalogWDMonitChannels(ADC_TypeDef *ADCx) {
N  register uint32_t AWDChannelGroup = READ_BIT(ADCx->CFGR1, (ADC_CFGR1_AWDCH | ADC_CFGR1_AWDSGL | ADC_CFGR1_AWDEN));
X  register uint32_t AWDChannelGroup = ((ADCx->CFGR1) & (((0x1FUL << (26U)) | (0x1UL << (22U)) | (0x1UL << (23U)))));
N
N  /* Note: Set variable according to channel definition including channel ID  */
N  /*       with bitfield.                                                     */
N  register uint32_t AWDChannelSingle = ((AWDChannelGroup & ADC_CFGR1_AWDSGL) >> ADC_CFGR1_AWDSGL_BITOFFSET_POS);
X  register uint32_t AWDChannelSingle = ((AWDChannelGroup & (0x1UL << (22U))) >> (22U));
N  register uint32_t AWDChannelBitField = (ADC_CHANNEL_0_BITFIELD << ((AWDChannelGroup & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS));
X  register uint32_t AWDChannelBitField = (((0x1UL << (0U))) << ((AWDChannelGroup & ((0x1FUL << (26U)))) >> (26U)));
N
N  return (AWDChannelGroup | (AWDChannelBitField * AWDChannelSingle));
N}
N
N/**
N  * @brief  Set ADC analog watchdog thresholds value of both thresholds
N  *         high and low.
N  * @note   If value of only one threshold high or low must be set,
N  *         use function @ref MS32_ADC_SetAnalogWDThresholds().
N  * @note   In case of ADC resolution different of 12 bits,
N  *         analog watchdog thresholds data require a specific shift.
N  *         Use helper macro @ref __MS32_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION().
N  * @note   On this MS32 serie, there is only 1 kind of analog watchdog
N  *         instance:
N  *         - AWD standard (instance AWD1):
N  *           - channels monitored: can monitor 1 channel or all channels.
N  *           - groups monitored: ADC group regular.
N  *           - resolution: resolution is not limited (corresponds to
N  *             ADC resolution configured).
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll TR       HT             MS32_ADC_ConfigAnalogWDThresholds\n
N  *         TR       LT             MS32_ADC_ConfigAnalogWDThresholds
N  * @param  ADCx ADC instance
N  * @param  AWDThresholdHighValue Value between Min_Data=0x000 and Max_Data=0xFFF
N  * @param  AWDThresholdLowValue Value between Min_Data=0x000 and Max_Data=0xFFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_ConfigAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDThresholdHighValue, uint32_t AWDThresholdLowValue) {
Xstatic __inline void MS32_ADC_ConfigAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDThresholdHighValue, uint32_t AWDThresholdLowValue) {
N  MODIFY_REG(ADCx->TR,
N             ADC_TR_HT | ADC_TR_LT,
N             (AWDThresholdHighValue << ADC_TR_HT_BITOFFSET_POS) | AWDThresholdLowValue);
X  (((ADCx->TR)) = ((((((ADCx->TR))) & (~((0xFFFUL << (16U)) | (0xFFFUL << (0U))))) | ((AWDThresholdHighValue << (16U)) | AWDThresholdLowValue))));
N}
N
N/**
N  * @brief  Set ADC analog watchdog threshold value of threshold
N  *         high or low.
N  * @note   If values of both thresholds high or low must be set,
N  *         use function @ref MS32_ADC_ConfigAnalogWDThresholds().
N  * @note   In case of ADC resolution different of 12 bits,
N  *         analog watchdog thresholds data require a specific shift.
N  *         Use helper macro @ref __MS32_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION().
N  * @note   On this MS32 serie, there is only 1 kind of analog watchdog
N  *         instance:
N  *         - AWD standard (instance AWD1):
N  *           - channels monitored: can monitor 1 channel or all channels.
N  *           - groups monitored: ADC group regular.
N  *           - resolution: resolution is not limited (corresponds to
N  *             ADC resolution configured).
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll TR       HT             MS32_ADC_SetAnalogWDThresholds\n
N  *         TR       LT             MS32_ADC_SetAnalogWDThresholds
N  * @param  ADCx ADC instance
N  * @param  AWDThresholdsHighLow This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_AWD_THRESHOLD_HIGH
N  *         @arg @ref MS32_ADC_AWD_THRESHOLD_LOW
N  * @param  AWDThresholdValue Value between Min_Data=0x000 and Max_Data=0xFFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_SetAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDThresholdsHighLow, uint32_t AWDThresholdValue) {
Xstatic __inline void MS32_ADC_SetAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDThresholdsHighLow, uint32_t AWDThresholdValue) {
N  /* Parameter "AWDThresholdsHighLow" is used with mask "0x00000010"          */
N  /* to be equivalent to "POSITION_VAL(AWDThresholdsHighLow)": if threshold   */
N  /* high is selected, then data is shifted to LSB. Else(threshold low),      */
N  /* data is not shifted.                                                     */
N  MODIFY_REG(ADCx->TR,
N             AWDThresholdsHighLow,
N             AWDThresholdValue << ((AWDThresholdsHighLow >> ADC_TR_HT_BITOFFSET_POS) & 0x00000010U));
X  (((ADCx->TR)) = ((((((ADCx->TR))) & (~(AWDThresholdsHighLow))) | (AWDThresholdValue << ((AWDThresholdsHighLow >> (16U)) & 0x00000010U)))));
N}
N
N/**
N  * @brief  Get ADC analog watchdog threshold value of threshold high,
N  *         threshold low or raw data with ADC thresholds high and low
N  *         concatenated.
N  * @note   If raw data with ADC thresholds high and low is retrieved,
N  *         the data of each threshold high or low can be isolated
N  *         using helper macro:
N  *         @ref __MS32_ADC_ANALOGWD_THRESHOLDS_HIGH_LOW().
N  * @note   In case of ADC resolution different of 12 bits,
N  *         analog watchdog thresholds data require a specific shift.
N  *         Use helper macro @ref __MS32_ADC_ANALOGWD_GET_THRESHOLD_RESOLUTION().
N  * @rmtoll TR1      HT1            MS32_ADC_GetAnalogWDThresholds\n
N  *         TR2      HT2            MS32_ADC_GetAnalogWDThresholds\n
N  *         TR3      HT3            MS32_ADC_GetAnalogWDThresholds\n
N  *         TR1      LT1            MS32_ADC_GetAnalogWDThresholds\n
N  *         TR2      LT2            MS32_ADC_GetAnalogWDThresholds\n
N  *         TR3      LT3            MS32_ADC_GetAnalogWDThresholds
N  * @param  ADCx ADC instance
N  * @param  AWDThresholdsHighLow This parameter can be one of the following values:
N  *         @arg @ref MS32_ADC_AWD_THRESHOLD_HIGH
N  *         @arg @ref MS32_ADC_AWD_THRESHOLD_LOW
N  *         @arg @ref MS32_ADC_AWD_THRESHOLDS_HIGH_LOW
N  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
N*/
N__STATIC_INLINE uint32_t MS32_ADC_GetAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDThresholdsHighLow) {
Xstatic __inline uint32_t MS32_ADC_GetAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDThresholdsHighLow) {
N  /* Parameter "AWDThresholdsHighLow" is used with mask "0x00000010"          */
N  /* to be equivalent to "POSITION_VAL(AWDThresholdsHighLow)": if threshold   */
N  /* high is selected, then data is shifted to LSB. Else(threshold low or     */
N  /* both thresholds), data is not shifted.                                   */
N  return (uint32_t)(READ_BIT(ADCx->TR,
N                             (AWDThresholdsHighLow | ADC_TR_LT))
X  return (uint32_t)(((ADCx->TR) & ((AWDThresholdsHighLow | (0xFFFUL << (0U)))))
N                    >> ((~AWDThresholdsHighLow) & 0x00000010U)
N                   );
N}
N
N
N/** @defgroup ADC_EF_Operation_ADC_Instance Operation on ADC hierarchical scope: ADC instance
N  * @{
N  */
N
N/**
N  * @brief  Enable the selected ADC instance.
N  * @note   On this MS32 serie, after ADC enable, a delay for
N  *         ADC internal analog stabilization is required before performing a
N  *         ADC conversion start.
N  *         Refer to device datasheet, parameter tSTAB.
N  * @note   On this MS32 serie, flag MS32_ADC_FLAG_ADRDY is raised when the ADC
N  *         is enabled and when conversion clock is active.
N  *         (not only core clock: this ADC has a dual clock domain)
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be ADC disabled and ADC internal voltage regulator enabled.
N  * @rmtoll CR       ADEN           MS32_ADC_Enable
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_Enable(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_Enable(ADC_TypeDef *ADCx) {
N  /* Note: Write register with some additional bits forced to state reset     */
N  /*       instead of modifying only the selected bit for this function,      */
N  /*       to not interfere with bits with HW property "rs".                  */
N  MODIFY_REG(ADCx->CR,
N             ADC_CR_BITS_PROPERTY_RS,
N             ADC_CR_ADEN);
X  (((ADCx->CR)) = ((((((ADCx->CR))) & (~(((0x1UL << (31U)) | (0x1UL << (4U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U)))))) | ((0x1UL << (0U))))));
N}
N
N/**
N  * @brief  Disable the selected ADC instance.
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be not disabled. Must be enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CR       ADDIS          MS32_ADC_Disable
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_Disable(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_Disable(ADC_TypeDef *ADCx) {
N  /* Note: Write register with some additional bits forced to state reset     */
N  /*       instead of modifying only the selected bit for this function,      */
N  /*       to not interfere with bits with HW property "rs".                  */
N  MODIFY_REG(ADCx->CR,
N             ADC_CR_BITS_PROPERTY_RS,
N             ADC_CR_ADDIS);
X  (((ADCx->CR)) = ((((((ADCx->CR))) & (~(((0x1UL << (31U)) | (0x1UL << (4U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U)))))) | ((0x1UL << (1U))))));
N}
N
N/**
N  * @brief  Get the selected ADC instance enable state.
N  * @note   On this MS32 serie, flag MS32_ADC_FLAG_ADRDY is raised when the ADC
N  *         is enabled and when conversion clock is active.
N  *         (not only core clock: this ADC has a dual clock domain)
N  * @rmtoll CR       ADEN           MS32_ADC_IsEnabled
N  * @param  ADCx ADC instance
N  * @retval 0: ADC is disabled, 1: ADC is enabled.
N  */
N__STATIC_INLINE uint32_t MS32_ADC_IsEnabled(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_IsEnabled(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN));
X  return (((ADCx->CR) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Get the selected ADC instance disable state.
N  * @rmtoll CR       ADDIS          MS32_ADC_IsDisableOngoing
N  * @param  ADCx ADC instance
N  * @retval 0: no ADC disable command on going.
N  */
N__STATIC_INLINE uint32_t MS32_ADC_IsDisableOngoing(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_IsDisableOngoing(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS));
X  return (((ADCx->CR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Start ADC calibration in the mode single-ended
N  *         or differential (for devices with differential mode available).
N  * @note   On this MS32 serie, a minimum number of ADC clock cycles
N  *         are required between ADC end of calibration and ADC enable.
N  *         Refer to literal @ref MS32_ADC_DELAY_CALIB_ENABLE_ADC_CYCLES.
N  * @note   In case of usage of ADC with DMA transfer:
N  *         On this MS32 serie, ADC DMA transfer request should be disabled
N  *         during calibration:
N  *         Calibration factor is available in data register
N  *         and also transfered by DMA.
N  *         To not insert ADC calibration factor among ADC conversion data
N  *         in array variable, DMA transfer must be disabled during
N  *         calibration.
N  *         (DMA transfer setting backup and disable before calibration,
N  *         DMA transfer setting restore after calibration.
N  *         Refer to functions @ref MS32_ADC_REG_GetDMATransfer(),
N  *         @ref MS32_ADC_REG_SetDMATransfer() ).
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be ADC disabled.
N  * @rmtoll CR       ADCAL          MS32_ADC_StartCalibration
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_StartCalibration(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_StartCalibration(ADC_TypeDef *ADCx) {
N  /* Note: Write register with some additional bits forced to state reset     */
N  /*       instead of modifying only the selected bit for this function,      */
N  /*       to not interfere with bits with HW property "rs".                  */
N  MODIFY_REG(ADCx->CR,
N             ADC_CR_BITS_PROPERTY_RS,
N             ADC_CR_ADCAL);
X  (((ADCx->CR)) = ((((((ADCx->CR))) & (~(((0x1UL << (31U)) | (0x1UL << (4U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U)))))) | ((0x1UL << (31U))))));
N}
N
N/**
N  * @brief  Get ADC calibration state.
N  * @rmtoll CR       ADCAL          MS32_ADC_IsCalibrationOnGoing
N  * @param  ADCx ADC instance
N  * @retval 0: calibration complete, 1: calibration in progress.
N  */
N__STATIC_INLINE uint32_t MS32_ADC_IsCalibrationOnGoing(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_IsCalibrationOnGoing(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL));
X  return (((ADCx->CR) & ((0x1UL << (31U)))) == ((0x1UL << (31U))));
N}
N
N
N/** @defgroup ADC_EF_Operation_ADC_Group_Regular Operation on ADC hierarchical scope: group regular
N  * @{
N  */
N
N/**
N  * @brief  Start ADC group regular conversion.
N  * @note   On this MS32 serie, this function is relevant for both
N  *         internal trigger (SW start) and external trigger:
N  *         - If ADC trigger has been set to software start, ADC conversion
N  *           starts immediately.
N  *         - If ADC trigger has been set to external trigger, ADC conversion
N  *           will start at next trigger event (on the selected trigger edge)
N  *           following the ADC start conversion command.
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be enabled without conversion on going on group regular,
N  *         without conversion stop command on going on group regular,
N  *         without ADC disable command on going.
N  * @rmtoll CR       ADSTART        MS32_ADC_REG_StartConversion
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_REG_StartConversion(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_REG_StartConversion(ADC_TypeDef *ADCx) {
N  /* Note: Write register with some additional bits forced to state reset     */
N  /*       instead of modifying only the selected bit for this function,      */
N  /*       to not interfere with bits with HW property "rs".                  */
N  MODIFY_REG(ADCx->CR,
N             ADC_CR_BITS_PROPERTY_RS,
N             ADC_CR_ADSTART);
X  (((ADCx->CR)) = ((((((ADCx->CR))) & (~(((0x1UL << (31U)) | (0x1UL << (4U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U)))))) | ((0x1UL << (2U))))));
N}
N
N/**
N  * @brief  Stop ADC group regular conversion.
N  * @note   On this MS32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be enabled with conversion on going on group regular,
N  *         without ADC disable command on going.
N  * @rmtoll CR       ADSTP          MS32_ADC_REG_StopConversion
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_REG_StopConversion(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_REG_StopConversion(ADC_TypeDef *ADCx) {
N  /* Note: Write register with some additional bits forced to state reset     */
N  /*       instead of modifying only the selected bit for this function,      */
N  /*       to not interfere with bits with HW property "rs".                  */
N  MODIFY_REG(ADCx->CR,
N             ADC_CR_BITS_PROPERTY_RS,
N             ADC_CR_ADSTP);
X  (((ADCx->CR)) = ((((((ADCx->CR))) & (~(((0x1UL << (31U)) | (0x1UL << (4U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U)))))) | ((0x1UL << (4U))))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion state.
N  * @rmtoll CR       ADSTART        MS32_ADC_REG_IsConversionOngoing
N  * @param  ADCx ADC instance
N  * @retval 0: no conversion is on going on ADC group regular.
N  */
N__STATIC_INLINE uint32_t MS32_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART));
X  return (((ADCx->CR) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Get ADC group regular command of conversion stop state
N  * @rmtoll CR       ADSTP          MS32_ADC_REG_IsStopConversionOngoing
N  * @param  ADCx ADC instance
N  * @retval 0: no command of conversion stop is on going on ADC group regular.
N  */
N__STATIC_INLINE uint32_t MS32_ADC_REG_IsStopConversionOngoing(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_REG_IsStopConversionOngoing(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->CR, ADC_CR_ADSTP) == (ADC_CR_ADSTP));
X  return (((ADCx->CR) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion data, range fit for
N  *         all ADC configurations: all ADC resolutions and
N  *         all oversampling increased data width (for devices
N  *         with feature oversampling).
N  * @rmtoll DR       DATA           MS32_ADC_REG_ReadConversionData32
N  * @param  ADCx ADC instance
N  * @retval Value between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
N  */
N__STATIC_INLINE uint32_t MS32_ADC_REG_ReadConversionData32(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_REG_ReadConversionData32(ADC_TypeDef *ADCx) {
N  return (uint32_t)(READ_BIT(ADCx->DR, ADC_DR_DATA));
X  return (uint32_t)(((ADCx->DR) & ((0xFFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion data, range fit for
N  *         ADC resolution 12 bits.
N  * @note   For devices with feature oversampling: Oversampling
N  *         can increase data width, function for extended range
N  *         may be needed: @ref MS32_ADC_REG_ReadConversionData32.
N  * @rmtoll DR       DATA           MS32_ADC_REG_ReadConversionData12
N  * @param  ADCx ADC instance
N  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
N  */
N__STATIC_INLINE uint16_t MS32_ADC_REG_ReadConversionData12(ADC_TypeDef *ADCx) {
Xstatic __inline uint16_t MS32_ADC_REG_ReadConversionData12(ADC_TypeDef *ADCx) {
N  return (uint16_t)(READ_BIT(ADCx->DR, ADC_DR_DATA));
X  return (uint16_t)(((ADCx->DR) & ((0xFFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion data, range fit for
N  *         ADC resolution 10 bits.
N  * @note   For devices with feature oversampling: Oversampling
N  *         can increase data width, function for extended range
N  *         may be needed: @ref MS32_ADC_REG_ReadConversionData32.
N  * @rmtoll DR       DATA           MS32_ADC_REG_ReadConversionData10
N  * @param  ADCx ADC instance
N  * @retval Value between Min_Data=0x000 and Max_Data=0x3FF
N  */
N__STATIC_INLINE uint16_t MS32_ADC_REG_ReadConversionData10(ADC_TypeDef *ADCx) {
Xstatic __inline uint16_t MS32_ADC_REG_ReadConversionData10(ADC_TypeDef *ADCx) {
N  return (uint16_t)(READ_BIT(ADCx->DR, ADC_DR_DATA));
X  return (uint16_t)(((ADCx->DR) & ((0xFFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion data, range fit for
N  *         ADC resolution 8 bits.
N  * @note   For devices with feature oversampling: Oversampling
N  *         can increase data width, function for extended range
N  *         may be needed: @ref MS32_ADC_REG_ReadConversionData32.
N  * @rmtoll DR       DATA           MS32_ADC_REG_ReadConversionData8
N  * @param  ADCx ADC instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint8_t MS32_ADC_REG_ReadConversionData8(ADC_TypeDef *ADCx) {
Xstatic __inline uint8_t MS32_ADC_REG_ReadConversionData8(ADC_TypeDef *ADCx) {
N  return (uint8_t)(READ_BIT(ADCx->DR, ADC_DR_DATA));
X  return (uint8_t)(((ADCx->DR) & ((0xFFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion data, range fit for
N  *         ADC resolution 6 bits.
N  * @note   For devices with feature oversampling: Oversampling
N  *         can increase data width, function for extended range
N  *         may be needed: @ref MS32_ADC_REG_ReadConversionData32.
N  * @rmtoll DR       DATA           MS32_ADC_REG_ReadConversionData6
N  * @param  ADCx ADC instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0x3F
N  */
N__STATIC_INLINE uint8_t MS32_ADC_REG_ReadConversionData6(ADC_TypeDef *ADCx) {
Xstatic __inline uint8_t MS32_ADC_REG_ReadConversionData6(ADC_TypeDef *ADCx) {
N  return (uint8_t)(READ_BIT(ADCx->DR, ADC_DR_DATA));
X  return (uint8_t)(((ADCx->DR) & ((0xFFFFUL << (0U)))));
N}
N
N
N/** @defgroup ADC_EF_FLAG_Management ADC flag management
N  * @{
N  */
N
N/**
N  * @brief  Get flag ADC ready.
N  * @note   On this MS32 serie, flag MS32_ADC_FLAG_ADRDY is raised when the ADC
N  *         is enabled and when conversion clock is active.
N  *         (not only core clock: this ADC has a dual clock domain)
N  * @rmtoll ISR      ADRDY          MS32_ADC_IsActiveFlag_ADRDY
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_ADC_IsActiveFlag_ADRDY(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_IsActiveFlag_ADRDY(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->ISR, MS32_ADC_FLAG_ADRDY) == (MS32_ADC_FLAG_ADRDY));
X  return (((ADCx->ISR) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Get flag ADC group regular end of unitary conversion.
N  * @rmtoll ISR      EOC            MS32_ADC_IsActiveFlag_EOC
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_ADC_IsActiveFlag_EOC(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_IsActiveFlag_EOC(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->ISR, ADC_ISR_EOC) == (ADC_ISR_EOC));
X  return (((ADCx->ISR) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Get flag ADC group regular end of sequence conversions.
N  * @rmtoll ISR      EOSEQ          MS32_ADC_IsActiveFlag_EOS
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_ADC_IsActiveFlag_EOS(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_IsActiveFlag_EOS(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->ISR, MS32_ADC_FLAG_EOS) == (MS32_ADC_FLAG_EOS));
X  return (((ADCx->ISR) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Get flag ADC group regular overrun.
N  * @rmtoll ISR      OVR            MS32_ADC_IsActiveFlag_OVR
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_ADC_IsActiveFlag_OVR(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_IsActiveFlag_OVR(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->ISR, MS32_ADC_FLAG_OVR) == (MS32_ADC_FLAG_OVR));
X  return (((ADCx->ISR) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Get flag ADC group regular end of sampling phase.
N  * @rmtoll ISR      EOSMP          MS32_ADC_IsActiveFlag_EOSMP
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_ADC_IsActiveFlag_EOSMP(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_IsActiveFlag_EOSMP(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->ISR, MS32_ADC_FLAG_EOSMP) == (MS32_ADC_FLAG_EOSMP));
X  return (((ADCx->ISR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Get flag ADC analog watchdog 1 flag
N  * @rmtoll ISR      AWD            MS32_ADC_IsActiveFlag_AWD1
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_ADC_IsActiveFlag_AWD1(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_IsActiveFlag_AWD1(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->ISR, MS32_ADC_FLAG_AWD1) == (MS32_ADC_FLAG_AWD1));
X  return (((ADCx->ISR) & ((0x1UL << (7U)))) == ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Clear flag ADC ready.
N  * @note   On this MS32 serie, flag MS32_ADC_FLAG_ADRDY is raised when the ADC
N  *         is enabled and when conversion clock is active.
N  *         (not only core clock: this ADC has a dual clock domain)
N  * @rmtoll ISR      ADRDY          MS32_ADC_ClearFlag_ADRDY
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_ClearFlag_ADRDY(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_ClearFlag_ADRDY(ADC_TypeDef *ADCx) {
N  WRITE_REG(ADCx->ISR, MS32_ADC_FLAG_ADRDY);
X  ((ADCx->ISR) = ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Clear flag ADC group regular end of unitary conversion.
N  * @rmtoll ISR      EOC            MS32_ADC_ClearFlag_EOC
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_ClearFlag_EOC(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_ClearFlag_EOC(ADC_TypeDef *ADCx) {
N  WRITE_REG(ADCx->ISR, MS32_ADC_FLAG_EOC);
X  ((ADCx->ISR) = ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Clear flag ADC group regular end of sequence conversions.
N  * @rmtoll ISR      EOSEQ          MS32_ADC_ClearFlag_EOS
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_ClearFlag_EOS(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_ClearFlag_EOS(ADC_TypeDef *ADCx) {
N  WRITE_REG(ADCx->ISR, MS32_ADC_FLAG_EOS);
X  ((ADCx->ISR) = ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Clear flag ADC group regular overrun.
N  * @rmtoll ISR      OVR            MS32_ADC_ClearFlag_OVR
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_ClearFlag_OVR(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_ClearFlag_OVR(ADC_TypeDef *ADCx) {
N  WRITE_REG(ADCx->ISR, MS32_ADC_FLAG_OVR);
X  ((ADCx->ISR) = ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Clear flag ADC group regular end of sampling phase.
N  * @rmtoll ISR      EOSMP          MS32_ADC_ClearFlag_EOSMP
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_ClearFlag_EOSMP(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_ClearFlag_EOSMP(ADC_TypeDef *ADCx) {
N  WRITE_REG(ADCx->ISR, MS32_ADC_FLAG_EOSMP);
X  ((ADCx->ISR) = ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Clear flag ADC analog watchdog 1.
N  * @rmtoll ISR      AWD            MS32_ADC_ClearFlag_AWD1
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_ClearFlag_AWD1(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_ClearFlag_AWD1(ADC_TypeDef *ADCx) {
N  WRITE_REG(ADCx->ISR, MS32_ADC_FLAG_AWD1);
X  ((ADCx->ISR) = ((0x1UL << (7U))));
N}
N
N
N/** @defgroup ADC_EF_IT_Management ADC IT management
N  * @{
N  */
N
N/**
N  * @brief  Enable ADC ready.
N  * @rmtoll IER      ADRDYIE        MS32_ADC_EnableIT_ADRDY
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_EnableIT_ADRDY(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_EnableIT_ADRDY(ADC_TypeDef *ADCx) {
N  SET_BIT(ADCx->IER, MS32_ADC_IT_ADRDY);
X  ((ADCx->IER) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Enable interruption ADC group regular end of unitary conversion.
N  * @rmtoll IER      EOCIE          MS32_ADC_EnableIT_EOC
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_EnableIT_EOC(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_EnableIT_EOC(ADC_TypeDef *ADCx) {
N  SET_BIT(ADCx->IER, MS32_ADC_IT_EOC);
X  ((ADCx->IER) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Enable interruption ADC group regular end of sequence conversions.
N  * @rmtoll IER      EOSEQIE        MS32_ADC_EnableIT_EOS
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_EnableIT_EOS(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_EnableIT_EOS(ADC_TypeDef *ADCx) {
N  SET_BIT(ADCx->IER, MS32_ADC_IT_EOS);
X  ((ADCx->IER) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Enable ADC group regular interruption overrun.
N  * @rmtoll IER      OVRIE          MS32_ADC_EnableIT_OVR
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_EnableIT_OVR(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_EnableIT_OVR(ADC_TypeDef *ADCx) {
N  SET_BIT(ADCx->IER, MS32_ADC_IT_OVR);
X  ((ADCx->IER) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Enable interruption ADC group regular end of sampling.
N  * @rmtoll IER      EOSMPIE        MS32_ADC_EnableIT_EOSMP
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_EnableIT_EOSMP(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_EnableIT_EOSMP(ADC_TypeDef *ADCx) {
N  SET_BIT(ADCx->IER, MS32_ADC_IT_EOSMP);
X  ((ADCx->IER) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Enable interruption ADC analog watchdog 1.
N  * @rmtoll IER      AWDIE          MS32_ADC_EnableIT_AWD1
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_EnableIT_AWD1(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_EnableIT_AWD1(ADC_TypeDef *ADCx) {
N  SET_BIT(ADCx->IER, MS32_ADC_IT_AWD1);
X  ((ADCx->IER) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable interruption ADC ready.
N  * @rmtoll IER      ADRDYIE        MS32_ADC_DisableIT_ADRDY
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_DisableIT_ADRDY(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_DisableIT_ADRDY(ADC_TypeDef *ADCx) {
N  CLEAR_BIT(ADCx->IER, MS32_ADC_IT_ADRDY);
X  ((ADCx->IER) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable interruption ADC group regular end of unitary conversion.
N  * @rmtoll IER      EOCIE          MS32_ADC_DisableIT_EOC
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_DisableIT_EOC(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_DisableIT_EOC(ADC_TypeDef *ADCx) {
N  CLEAR_BIT(ADCx->IER, MS32_ADC_IT_EOC);
X  ((ADCx->IER) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Disable interruption ADC group regular end of sequence conversions.
N  * @rmtoll IER      EOSEQIE        MS32_ADC_DisableIT_EOS
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_DisableIT_EOS(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_DisableIT_EOS(ADC_TypeDef *ADCx) {
N  CLEAR_BIT(ADCx->IER, MS32_ADC_IT_EOS);
X  ((ADCx->IER) &= ~((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Disable interruption ADC group regular overrun.
N  * @rmtoll IER      OVRIE          MS32_ADC_DisableIT_OVR
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_DisableIT_OVR(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_DisableIT_OVR(ADC_TypeDef *ADCx) {
N  CLEAR_BIT(ADCx->IER, MS32_ADC_IT_OVR);
X  ((ADCx->IER) &= ~((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Disable interruption ADC group regular end of sampling.
N  * @rmtoll IER      EOSMPIE        MS32_ADC_DisableIT_EOSMP
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_DisableIT_EOSMP(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_DisableIT_EOSMP(ADC_TypeDef *ADCx) {
N  CLEAR_BIT(ADCx->IER, MS32_ADC_IT_EOSMP);
X  ((ADCx->IER) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable interruption ADC analog watchdog 1.
N  * @rmtoll IER      AWDIE          MS32_ADC_DisableIT_AWD1
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_ADC_DisableIT_AWD1(ADC_TypeDef *ADCx) {
Xstatic __inline void MS32_ADC_DisableIT_AWD1(ADC_TypeDef *ADCx) {
N  CLEAR_BIT(ADCx->IER, MS32_ADC_IT_AWD1);
X  ((ADCx->IER) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Get state of interruption ADC ready
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      ADRDYIE        MS32_ADC_IsEnabledIT_ADRDY
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_ADC_IsEnabledIT_ADRDY(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_IsEnabledIT_ADRDY(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->IER, MS32_ADC_IT_ADRDY) == (MS32_ADC_IT_ADRDY));
X  return (((ADCx->IER) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Get state of interruption ADC group regular end of unitary conversion
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      EOCIE          MS32_ADC_IsEnabledIT_EOC
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_ADC_IsEnabledIT_EOC(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_IsEnabledIT_EOC(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->IER, MS32_ADC_IT_EOC) == (MS32_ADC_IT_EOC));
X  return (((ADCx->IER) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Get state of interruption ADC group regular end of sequence conversions
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      EOSEQIE        MS32_ADC_IsEnabledIT_EOS
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_ADC_IsEnabledIT_EOS(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_IsEnabledIT_EOS(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->IER, MS32_ADC_IT_EOS) == (MS32_ADC_IT_EOS));
X  return (((ADCx->IER) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Get state of interruption ADC group regular overrun
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      OVRIE          MS32_ADC_IsEnabledIT_OVR
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_ADC_IsEnabledIT_OVR(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_IsEnabledIT_OVR(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->IER, MS32_ADC_IT_OVR) == (MS32_ADC_IT_OVR));
X  return (((ADCx->IER) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Get state of interruption ADC group regular end of sampling
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      EOSMPIE        MS32_ADC_IsEnabledIT_EOSMP
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_ADC_IsEnabledIT_EOSMP(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_IsEnabledIT_EOSMP(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->IER, MS32_ADC_IT_EOSMP) == (MS32_ADC_IT_EOSMP));
X  return (((ADCx->IER) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Get state of interruption ADC analog watchdog 1
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      AWDIE          MS32_ADC_IsEnabledIT_AWD1
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_ADC_IsEnabledIT_AWD1(ADC_TypeDef *ADCx) {
Xstatic __inline uint32_t MS32_ADC_IsEnabledIT_AWD1(ADC_TypeDef *ADCx) {
N  return (READ_BIT(ADCx->IER, MS32_ADC_IT_AWD1) == (MS32_ADC_IT_AWD1));
X  return (((ADCx->IER) & ((0x1UL << (7U)))) == ((0x1UL << (7U))));
N}
N
N
N/** @defgroup ADC_EF_Init Initialization and de-initialization functions
N  * @{
N  */
N
N/* Initialization of some features of ADC common parameters and multimode */
N/* Note: On this MS32 serie, there is no ADC common initialization           */
N/*       function.                                                            */
NErrorStatus MS32_ADC_CommonDeInit   (ADC_Common_TypeDef *AdcCommon);
N/* De-initialization of ADC instance */
NErrorStatus MS32_ADC_DeInit         (ADC_TypeDef *ADCx);
N/* Initialization of some features of ADC instance */
NErrorStatus MS32_ADC_Init           (ADC_TypeDef *ADCx, MS32_ADC_InitTypeDef *AdcInitStr);
Nvoid        MS32_ADC_StructInit     (MS32_ADC_InitTypeDef *AdcInitStr);
Nvoid        MS32_ADC_ITConfig       (ADC_TypeDef *ADCx, uint32_t InterruptFunc, uint32_t Priority);
N/* Initialization of some features of ADC instance and ADC group regular */
NErrorStatus MS32_ADC_REG_Init       (ADC_TypeDef *ADCx, MS32_ADC_REG_InitTypeDef *AdcRegInitStr);
Nvoid        MS32_ADC_REG_StructInit (MS32_ADC_REG_InitTypeDef *AdcRegInitStr);
N
N/** @defgroup ADC_EF_Application function
N  * @{
N  */
NFlagStatus MS32_ADC_GetStatusFlag (ADC_TypeDef *ADCx, uint32_t Flags);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_ADC_H */
N
N/******************************** END OF FILE *********************************/
L 64 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_bus.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_bus.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_BUS_H
S#define __MS32F0XX_BUS_H
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/* Includes ------------------------------------------------------------------*/
S#include "ms32f0xx.h"
S
S
S/* Private types -------------------------------------------------------------*/
S/* Private variables ---------------------------------------------------------*/
S/* Private constants ---------------------------------------------------------*/
S/* Private macros ------------------------------------------------------------*/
S/* Exported types ------------------------------------------------------------*/
S/* Exported constants --------------------------------------------------------*/
S/** @defgroup BUS_EC_AHB1_GRP1_PERIPH  AHB1 GRP1 PERIPH
S  * @{
S  */
S#define MS32_AHB1_GRP1_PERIPH_ALL            (uint32_t)0xFFFFFFFFU
S#define MS32_AHB1_GRP1_PERIPH_DMA1           RCC_AHBENR_DMAEN
S#define MS32_AHB1_GRP1_PERIPH_SRAM           RCC_AHBENR_SRAMEN
S#define MS32_AHB1_GRP1_PERIPH_FLITF          RCC_AHBENR_FLITFEN
S#define MS32_AHB1_GRP1_PERIPH_CRC            RCC_AHBENR_CRCEN
S#define MS32_AHB1_GRP1_PERIPH_GPIOA          RCC_AHBENR_GPIOAEN
S#define MS32_AHB1_GRP1_PERIPH_GPIOB          RCC_AHBENR_GPIOBEN
S#define MS32_AHB1_GRP1_PERIPH_GPIOC          RCC_AHBENR_GPIOCEN
S#define MS32_AHB1_GRP1_PERIPH_GPIOF          RCC_AHBENR_GPIOFEN
S
S
S/** @defgroup BUS_EC_APB1_GRP1_PERIPH  APB1 GRP1 PERIPH
S  * @{
S  */
S#define MS32_APB1_GRP1_PERIPH_ALL            (uint32_t)0xFFFFFFFFU
S#define MS32_APB1_GRP1_PERIPH_TIM2           RCC_APB1ENR_TIM2EN
S#define MS32_APB1_GRP1_PERIPH_TIM3           RCC_APB1ENR_TIM3EN
S#define MS32_APB1_GRP1_PERIPH_TIM14          RCC_APB1ENR_TIM14EN
S#define MS32_APB1_GRP1_PERIPH_WWDG           RCC_APB1ENR_WWDGEN
S#define MS32_APB1_GRP1_PERIPH_I2C1           RCC_APB1ENR_I2C1EN
S#define MS32_APB1_GRP1_PERIPH_PWR            RCC_APB1ENR_PWREN
S
S
S/** @defgroup BUS_EC_APB1_GRP2_PERIPH  APB1 GRP2 PERIPH
S  * @{
S  */
S#define MS32_APB1_GRP2_PERIPH_ALL            (uint32_t)0xFFFFFFFFU
S#define MS32_APB1_GRP2_PERIPH_SYSCFG         RCC_APB2ENR_SYSCFGCOMPEN
S#define MS32_APB1_GRP2_PERIPH_ADC1           RCC_APB2ENR_ADCEN
S#define MS32_APB1_GRP2_PERIPH_TIM1           RCC_APB2ENR_TIM1EN
S#define MS32_APB1_GRP2_PERIPH_SPI1           RCC_APB2ENR_SPI1EN
S#define MS32_APB1_GRP2_PERIPH_USART1         RCC_APB2ENR_USART1EN
S#define MS32_APB1_GRP2_PERIPH_TIM16          RCC_APB2ENR_TIM16EN
S#define MS32_APB1_GRP2_PERIPH_TIM17          RCC_APB2ENR_TIM17EN
S#define MS32_APB1_GRP2_PERIPH_DBGMCU         RCC_APB2ENR_DBGMCUEN
S
S
S/* Exported macro ------------------------------------------------------------*/
S/* Exported functions --------------------------------------------------------*/
S/** @defgroup BUS_MS32_EF_AHB1 AHB1
S  * @{
S  */
S
S/**
S  * @brief  Enable AHB1 peripherals clock.
S  * @rmtoll AHBENR       DMA1EN        MS32_AHB1_GRP1_EnableClock\n
S  *         AHBENR       SRAMEN        MS32_AHB1_GRP1_EnableClock\n
S  *         AHBENR       FLITFEN       MS32_AHB1_GRP1_EnableClock\n
S  *         AHBENR       CRCEN         MS32_AHB1_GRP1_EnableClock\n
S  *         AHBENR       GPIOAEN       MS32_AHB1_GRP1_EnableClock\n
S  *         AHBENR       GPIOBEN       MS32_AHB1_GRP1_EnableClock\n
S  *         AHBENR       GPIOCEN       MS32_AHB1_GRP1_EnableClock\n
S  *         AHBENR       GPIOFEN       MS32_AHB1_GRP1_EnableClock
S  * @param  Periphs This parameter can be a combination of the following values:
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_DMA1
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_SRAM
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_FLITF
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_CRC
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOA
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOB
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOC
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOF
S  * @retval None
S*/
S__STATIC_INLINE void MS32_AHB1_GRP1_EnableClock(uint32_t Periphs) {
S  __IO uint32_t tmpreg;
S  SET_BIT(RCC->AHBENR, Periphs);
S  /* Delay after an RCC peripheral clock enabling */
S  tmpreg = READ_BIT(RCC->AHBENR, Periphs);
S  (void)tmpreg;
S}
S
S/**
S  * @brief  Check if AHB1 peripheral clock is enabled or not
S  * @rmtoll AHBENR       DMA1EN        MS32_AHB1_GRP1_IsEnabledClock\n
S  *         AHBENR       SRAMEN        MS32_AHB1_GRP1_IsEnabledClock\n
S  *         AHBENR       FLITFEN       MS32_AHB1_GRP1_IsEnabledClock\n
S  *         AHBENR       CRCEN         MS32_AHB1_GRP1_IsEnabledClock\n
S  *         AHBENR       GPIOAEN       MS32_AHB1_GRP1_IsEnabledClock\n
S  *         AHBENR       GPIOBEN       MS32_AHB1_GRP1_IsEnabledClock\n
S  *         AHBENR       GPIOCEN       MS32_AHB1_GRP1_IsEnabledClock\n
S  *         AHBENR       GPIOFEN       MS32_AHB1_GRP1_IsEnabledClock
S  * @param  Periphs This parameter can be a combination of the following values:
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_DMA1
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_SRAM
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_FLITF
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_CRC
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOA
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOB
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOC
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOF
S  * @retval State of Periphs (1 or 0).
S*/
S__STATIC_INLINE uint32_t MS32_AHB1_GRP1_IsEnabledClock(uint32_t Periphs) {
S  return (READ_BIT(RCC->AHBENR, Periphs) == Periphs);
S}
S
S/**
S  * @brief  Disable AHB1 peripherals clock.
S  * @rmtoll AHBENR       DMA1EN        MS32_AHB1_GRP1_DisableClock\n
S  *         AHBENR       SRAMEN        MS32_AHB1_GRP1_DisableClock\n
S  *         AHBENR       FLITFEN       MS32_AHB1_GRP1_DisableClock\n
S  *         AHBENR       CRCEN         MS32_AHB1_GRP1_DisableClock\n
S  *         AHBENR       GPIOAEN       MS32_AHB1_GRP1_DisableClock\n
S  *         AHBENR       GPIOBEN       MS32_AHB1_GRP1_DisableClock\n
S  *         AHBENR       GPIOCEN       MS32_AHB1_GRP1_DisableClock\n
S  *         AHBENR       GPIOFEN       MS32_AHB1_GRP1_DisableClock
S  * @param  Periphs This parameter can be a combination of the following values:
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_DMA1
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_SRAM
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_FLITF
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_CRC
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOA
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOB
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOC
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOF
S  * @retval None
S*/
S__STATIC_INLINE void MS32_AHB1_GRP1_DisableClock(uint32_t Periphs) {
S  CLEAR_BIT(RCC->AHBENR, Periphs);
S}
S
S/**
S  * @brief  Force AHB1 peripherals reset.
S  * @rmtoll AHBRSTR      GPIOARST      MS32_AHB1_GRP1_ForceReset\n
S  *         AHBRSTR      GPIOBRST      MS32_AHB1_GRP1_ForceReset\n
S  *         AHBRSTR      GPIOCRST      MS32_AHB1_GRP1_ForceReset\n
S  *         AHBRSTR      GPIOFRST      MS32_AHB1_GRP1_ForceReset
S  * @param  Periphs This parameter can be a combination of the following values:
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_ALL
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOA
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOB
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOC
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOF
S  * @retval None
S*/
S__STATIC_INLINE void MS32_AHB1_GRP1_ForceReset(uint32_t Periphs) {
S  SET_BIT(RCC->AHBRSTR, Periphs);
S}
S
S/**
S  * @brief  Release AHB1 peripherals reset.
S  * @rmtoll AHBRSTR      GPIOARST      MS32_AHB1_GRP1_ReleaseReset\n
S  *         AHBRSTR      GPIOBRST      MS32_AHB1_GRP1_ReleaseReset\n
S  *         AHBRSTR      GPIOCRST      MS32_AHB1_GRP1_ReleaseReset
S  *         AHBRSTR      GPIOFRST      MS32_AHB1_GRP1_ReleaseReset
S  * @param  Periphs This parameter can be a combination of the following values:
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_ALL
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOA
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOB
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOC
S  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOF
S  * @retval None
S*/
S__STATIC_INLINE void MS32_AHB1_GRP1_ReleaseReset(uint32_t Periphs) {
S  CLEAR_BIT(RCC->AHBRSTR, Periphs);
S}
S
S
S/** @defgroup BUS_MS32_EF_APB1_GRP1 APB1 GRP1
S  * @{
S  */
S
S/**
S  * @brief  Enable APB1 peripherals clock (available in register 1).
S  * @rmtoll APB1ENR      TIM2EN        MS32_APB1_GRP1_EnableClock\n
S  *         APB1ENR      TIM3EN        MS32_APB1_GRP1_EnableClock\n
S  *         APB1ENR      TIM14EN       MS32_APB1_GRP1_EnableClock\n
S  *         APB1ENR      WWDGEN        MS32_APB1_GRP1_EnableClock\n
S  *         APB1ENR      I2C1EN        MS32_APB1_GRP1_EnableClock\n
S  *         APB1ENR      PWREN         MS32_APB1_GRP1_EnableClock
S  * @param  Periphs This parameter can be a combination of the following values:
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM2
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM3
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM14
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_WWDG
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_I2C1
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_PWR
S  * @retval None
S*/
S__STATIC_INLINE void MS32_APB1_GRP1_EnableClock(uint32_t Periphs) {
S  __IO uint32_t tmpreg;
S  SET_BIT(RCC->APB1ENR, Periphs);
S  /* Delay after an RCC peripheral clock enabling */
S  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
S  (void)tmpreg;
S}
S
S/**
S  * @brief  Check if APB1 peripheral clock is enabled or not (available in register 1).
S  * @rmtoll APB1ENR      TIM2EN        MS32_APB1_GRP1_IsEnabledClock\n
S  *         APB1ENR      TIM3EN        MS32_APB1_GRP1_IsEnabledClock\n
S  *         APB1ENR      TIM14EN       MS32_APB1_GRP1_IsEnabledClock\n
S  *         APB1ENR      WWDGEN        MS32_APB1_GRP1_IsEnabledClock\n
S  *         APB1ENR      I2C1EN        MS32_APB1_GRP1_IsEnabledClock\n
S  *         APB1ENR      PWREN         MS32_APB1_GRP1_IsEnabledClock
S  * @param  Periphs This parameter can be a combination of the following values:
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM2
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM3
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM14
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_WWDG
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_I2C1
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_PWR
S  * @retval State of Periphs (1 or 0).
S*/
S__STATIC_INLINE uint32_t MS32_APB1_GRP1_IsEnabledClock(uint32_t Periphs) {
S  return (READ_BIT(RCC->APB1ENR, Periphs) == Periphs);
S}
S
S/**
S  * @brief  Disable APB1 peripherals clock (available in register 1).
S  * @rmtoll APB1ENR      TIM2EN        MS32_APB1_GRP1_DisableClock\n
S  *         APB1ENR      TIM3EN        MS32_APB1_GRP1_DisableClock\n
S  *         APB1ENR      TIM14EN       MS32_APB1_GRP1_DisableClock\n
S  *         APB1ENR      WWDGEN        MS32_APB1_GRP1_DisableClock\n
S  *         APB1ENR      I2C1EN        MS32_APB1_GRP1_DisableClock\n
S  *         APB1ENR      PWREN         MS32_APB1_GRP1_DisableClock
S  * @param  Periphs This parameter can be a combination of the following values:
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM2
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM3
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM14
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_WWDG
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_I2C1
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_PWR
S  * @retval None
S*/
S__STATIC_INLINE void MS32_APB1_GRP1_DisableClock(uint32_t Periphs) {
S  CLEAR_BIT(RCC->APB1ENR, Periphs);
S}
S
S/**
S  * @brief  Force APB1 peripherals reset (available in register 1).
S  * @rmtoll APB1RSTR     TIM2RST       MS32_APB1_GRP1_ForceReset\n
S  *         APB1RSTR     TIM3RST       MS32_APB1_GRP1_ForceReset\n
S  *         APB1RSTR     TIM14RST      MS32_APB1_GRP1_ForceReset\n
S  *         APB1RSTR     WWDGRST       MS32_APB1_GRP1_ForceReset\n
S  *         APB1RSTR     I2C1RST       MS32_APB1_GRP1_ForceReset\n
S  *         APB1RSTR     PWRRST        MS32_APB1_GRP1_ForceReset
S  * @param  Periphs This parameter can be a combination of the following values:
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_ALL
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM2
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM3
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM14
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_WWDG
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_I2C1
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_PWR
S  * @retval None
S*/
S__STATIC_INLINE void MS32_APB1_GRP1_ForceReset(uint32_t Periphs) {
S  SET_BIT(RCC->APB1RSTR, Periphs);
S}
S
S/**
S  * @brief  Release APB1 peripherals reset (available in register 1).
S  * @rmtoll APB1RSTR     TIM2RST       MS32_APB1_GRP1_ReleaseReset\n
S  *         APB1RSTR     TIM3RST       MS32_APB1_GRP1_ReleaseReset\n
S  *         APB1RSTR     TIM14RST      MS32_APB1_GRP1_ReleaseReset\n
S  *         APB1RSTR     WWDGRST       MS32_APB1_GRP1_ReleaseReset\n
S  *         APB1RSTR     I2C1RST       MS32_APB1_GRP1_ReleaseReset\n
S  *         APB1RSTR     PWRRST        MS32_APB1_GRP1_ReleaseReset
S  * @param  Periphs This parameter can be a combination of the following values:
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_ALL
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM2
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM3
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM14
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_WWDG
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_I2C1
S  *         @arg @ref MS32_APB1_GRP1_PERIPH_PWR
S  * @retval None
S*/
S__STATIC_INLINE void MS32_APB1_GRP1_ReleaseReset(uint32_t Periphs) {
S  CLEAR_BIT(RCC->APB1RSTR, Periphs);
S}
S
S
S/** @defgroup BUS_MS32_EF_APB1_GRP2 APB1 GRP2
S  * @{
S  */
S
S/**
S  * @brief  Enable APB1 peripherals clock (available in register 2).
S  * @rmtoll APB2ENR      SYSCFGEN      MS32_APB1_GRP2_EnableClock\n
S  *         APB2ENR      ADC1EN        MS32_APB1_GRP2_EnableClock\n
S  *         APB2ENR      TIM1EN        MS32_APB1_GRP2_EnableClock\n
S  *         APB2ENR      SPI1EN        MS32_APB1_GRP2_EnableClock\n
S  *         APB2ENR      USART1EN      MS32_APB1_GRP2_EnableClock\n
S  *         APB2ENR      TIM16EN       MS32_APB1_GRP2_EnableClock\n
S  *         APB2ENR      TIM17EN       MS32_APB1_GRP2_EnableClock\n
S  *         APB2ENR      DBGMCUEN      MS32_APB1_GRP2_EnableClock
S  * @param  Periphs This parameter can be a combination of the following values:
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_SYSCFG
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_ADC1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_SPI1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_USART1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM16
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM17
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_DBGMCU
S  * @retval None
S*/
S__STATIC_INLINE void MS32_APB1_GRP2_EnableClock(uint32_t Periphs) {
S  __IO uint32_t tmpreg;
S  SET_BIT(RCC->APB2ENR, Periphs);
S  /* Delay after an RCC peripheral clock enabling */
S  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
S  (void)tmpreg;
S}
S
S/**
S  * @brief  Check if APB1 peripheral clock is enabled or not (available in register 2).
S  * @rmtoll APB2ENR      SYSCFGEN      MS32_APB1_GRP2_IsEnabledClock\n
S  *         APB2ENR      ADC1EN        MS32_APB1_GRP2_IsEnabledClock\n
S  *         APB2ENR      TIM1EN        MS32_APB1_GRP2_IsEnabledClock\n
S  *         APB2ENR      SPI1EN        MS32_APB1_GRP2_IsEnabledClock\n
S  *         APB2ENR      USART1EN      MS32_APB1_GRP2_IsEnabledClock\n
S  *         APB2ENR      TIM16EN       MS32_APB1_GRP2_IsEnabledClock\n
S  *         APB2ENR      TIM17EN       MS32_APB1_GRP2_IsEnabledClock\n
S  *         APB2ENR      DBGMCUEN      MS32_APB1_GRP2_IsEnabledClock
S  * @param  Periphs This parameter can be a combination of the following values:
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_SYSCFG
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_ADC1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_SPI1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_USART1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM16
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM17
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_DBGMCU
S  * @retval State of Periphs (1 or 0).
S*/
S__STATIC_INLINE uint32_t MS32_APB1_GRP2_IsEnabledClock(uint32_t Periphs) {
S  return (READ_BIT(RCC->APB2ENR, Periphs) == Periphs);
S}
S
S/**
S  * @brief  Disable APB1 peripherals clock (available in register 2).
S  * @rmtoll APB2ENR      SYSCFGEN      MS32_APB1_GRP2_DisableClock\n
S  *         APB2ENR      ADC1EN        MS32_APB1_GRP2_DisableClock\n
S  *         APB2ENR      TIM1EN        MS32_APB1_GRP2_DisableClock\n
S  *         APB2ENR      SPI1EN        MS32_APB1_GRP2_DisableClock\n
S  *         APB2ENR      USART1EN      MS32_APB1_GRP2_DisableClock\n
S  *         APB2ENR      TIM16EN       MS32_APB1_GRP2_DisableClock\n
S  *         APB2ENR      TIM17EN       MS32_APB1_GRP2_DisableClock\n
S  *         APB2ENR      DBGMCUEN      MS32_APB1_GRP2_DisableClock
S  * @param  Periphs This parameter can be a combination of the following values:
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_SYSCFG
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_ADC1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_SPI1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_USART1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM16
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM17
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_DBGMCU
S  * @retval None
S*/
S__STATIC_INLINE void MS32_APB1_GRP2_DisableClock(uint32_t Periphs) {
S  CLEAR_BIT(RCC->APB2ENR, Periphs);
S}
S
S/**
S  * @brief  Force APB1 peripherals reset (available in register 2).
S  * @rmtoll APB2RSTR     SYSCFGRST     MS32_APB1_GRP2_ForceReset\n
S  *         APB2RSTR     ADC1RST       MS32_APB1_GRP2_ForceReset\n
S  *         APB2RSTR     TIM1RST       MS32_APB1_GRP2_ForceReset\n
S  *         APB2RSTR     SPI1RST       MS32_APB1_GRP2_ForceReset\n
S  *         APB2RSTR     USART1RST     MS32_APB1_GRP2_ForceReset\n
S  *         APB2RSTR     TIM16RST      MS32_APB1_GRP2_ForceReset\n
S  *         APB2RSTR     TIM17RST      MS32_APB1_GRP2_ForceReset\n
S  *         APB2RSTR     DBGMCURST     MS32_APB1_GRP2_ForceReset
S  * @param  Periphs This parameter can be a combination of the following values:
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_ALL
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_SYSCFG
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_ADC1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_SPI1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_USART1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM16
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM17
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_DBGMCU
S  * @retval None
S*/
S__STATIC_INLINE void MS32_APB1_GRP2_ForceReset(uint32_t Periphs) {
S  SET_BIT(RCC->APB2RSTR, Periphs);
S}
S
S/**
S  * @brief  Release APB1 peripherals reset (available in register 2).
S  * @rmtoll APB2RSTR     SYSCFGRST     MS32_APB1_GRP2_ReleaseReset\n
S  *         APB2RSTR     ADC1RST       MS32_APB1_GRP2_ReleaseReset\n
S  *         APB2RSTR     TIM1RST       MS32_APB1_GRP2_ReleaseReset\n
S  *         APB2RSTR     SPI1RST       MS32_APB1_GRP2_ReleaseReset\n
S  *         APB2RSTR     USART1RST     MS32_APB1_GRP2_ReleaseReset\n
S  *         APB2RSTR     TIM16RST      MS32_APB1_GRP2_ReleaseReset\n
S  *         APB2RSTR     TIM17RST      MS32_APB1_GRP2_ReleaseReset\n
S  *         APB2RSTR     DBGMCURST     MS32_APB1_GRP2_ReleaseReset
S  * @param  Periphs This parameter can be a combination of the following values:
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_ALL
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_SYSCFG
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_ADC1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_SPI1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_USART1
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM16
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM17
S  *         @arg @ref MS32_APB1_GRP2_PERIPH_DBGMCU
S  * @retval None
S*/
S__STATIC_INLINE void MS32_APB1_GRP2_ReleaseReset(uint32_t Periphs) {
S  CLEAR_BIT(RCC->APB2RSTR, Periphs);
S}
S
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __MS32F0XX_BUS_H */
N
N/******************************** END OF FILE *********************************/
L 65 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_comp.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_comp.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_COMP_H
N#define __MS32F0XX_COMP_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/**
N  * @brief CMP Init Structure definition
N  */
Ntypedef struct {
N  uint32_t Lock;              /*!< The new state of the comparison register lock.
N                                   This parameter can be a value of @ref COMP_LOCK */
N  uint32_t OutputSel;         /*!< The new state of the comparison output selection.
N                                   This parameter can be a value of @ref COMP_OUTPUT_SELECT */
N  uint32_t OutputPolarity;    /*!< The new state of the comparison output polarity.
N                                   This parameter can be a value of @ref COMP_OUTPUT_POL */
N  uint32_t OutputFilter;      /*!< The new state of the comparison output filter.
N                                   This parameter can be a value of @ref COMP_OUTPUT_FILTER */
N  uint32_t CrvSel;            /*!< The new state of the comparison voltage reference selection.
N                                   This parameter can be a value of @ref COMP_CRV_SELECT */
N  uint32_t CrvDivSel;         /*!< The new state of the comparison voltage reference selection.
N                                   This parameter can be a value of @ref COMP_CRV_DIV_SELECT */
N  uint32_t NegativeSel;       /*!< The new state of the comparison negative selection.
N                                   This parameter can be a value of @ref COMP_NEG_SEL */
N  uint32_t PositionSel;       /*!< The new state of the comparison position selection.
N                                   This parameter can be a value of @ref COMP_POS_SEL */
N  uint32_t HysteresisSel;     /*!< The new state of the comparison hysteresis selection.
N                                   This parameter can be a value of @ref COMP_HYST_SELECT */
N} MS32_CMP_InitTypeDef;
N
N/**
N  * @brief CMP calibration Structure definition
N  */
Ntypedef struct {
N  uint8_t CmpPosCaliData;     /*!< The value of the comparison position calibration register. */
N  uint8_t CmpNegCaliData;     /*!< The value of the comparison negative calibration register. */
N} MS32_CMP_CaliTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup COMP_UNIT Comparison unit
N  * @{
N  */
N#define MS32_COMP1                     (0x00000001U)
N#define MS32_COMP2                     (0x00000002U)
N
N
N/** @defgroup COMP_LOCK Comparison lock
N  * @{
N  */
N#define MS32_COMP_UNLOCK               (0x00000000U)
N#define MS32_COMP_LOCK                 CMP_CPxCR_CPxLCK
N
N
N/** @defgroup COMP_OUTPUT Comparison output
N  * @{
N  */
N#define MS32_COMP_OUTPUT_LOW           (0x00000000U)
N#define MS32_COMP_OUTPUT_HIGH          CMP_CPxCR_CPxOUT
N
N
N/** @defgroup COMP_OUTPUT_SELECT Comparison output select
N  * @{
N  */
N#define MS32_COMP_OUT_TIM1_BKIN        (0x00000000U)
N#define MS32_COMP_OUT_TIM1_OCREF_CLR   CMP_CPxCR_CPxOUTSEL_0
N#define MS32_COMP_OUT_TIM1_IC1         CMP_CPxCR_CPxOUTSEL_1
N#define MS32_COMP_OUT_TIM2_IC4         (CMP_CPxCR_CPxOUTSEL_1 | CMP_CPxCR_CPxOUTSEL_0)
N#define MS32_COMP_OUT_TIM2_OCREF_CLR   CMP_CPxCR_CPxOUTSEL_2
N#define MS32_COMP_OUT_TIM3_IC1         (CMP_CPxCR_CPxOUTSEL_2 | CMP_CPxCR_CPxOUTSEL_0)
N#define MS32_COMP_OUT_TIM3_OCREF_CLR   (CMP_CPxCR_CPxOUTSEL_2 | CMP_CPxCR_CPxOUTSEL_1)
N
N
N/** @defgroup COMP_OUTPUT_POL Comparison output polarity
N  * @{
N  */
N#define MS32_COMP_OUT_POL_POS          (0x00000000U)
N#define MS32_COMP_OUT_POL_NEG          CMP_CPxCR_CPxPOL
N
N
N/** @defgroup COMP_OUTPUT_FILTER Comparison output filter
N  * @{
N  */
N#define MS32_COMP_OUT_FILTER_CLK1      (0x00000000U)
N#define MS32_COMP_OUT_FILTER_CLK4      CMP_CPxCR_CPxOFLT_0
N#define MS32_COMP_OUT_FILTER_CLK16     CMP_CPxCR_CPxOFLT_1
N#define MS32_COMP_OUT_FILTER_CLK32     (CMP_CPxCR_CPxOFLT_1 | CMP_CPxCR_CPxOFLT_0)
N#define MS32_COMP_OUT_FILTER_CLK64     CMP_CPxCR_CPxOFLT_2
N#define MS32_COMP_OUT_FILTER_CLK128    (CMP_CPxCR_CPxOFLT_2 | CMP_CPxCR_CPxOFLT_0)
N#define MS32_COMP_OUT_FILTER_CLK256    (CMP_CPxCR_CPxOFLT_2 | CMP_CPxCR_CPxOFLT_1)
N#define MS32_COMP_OUT_FILTER_CLK512    (CMP_CPxCR_CPxOFLT_2 | CMP_CPxCR_CPxOFLT_1 | CMP_CPxCR_CPxOFLT_0)
N
N
N/** @defgroup COMP_CRV_DIV_SELECT Comparison voltage reference division select
N  * @{
N  */
N#define MS32_COMP_CRV_1_DIV_8          (0x00000000U)
N#define MS32_COMP_CRV_2_DIV_8          CMP_CPxCR_CPxRVSEL_0
N#define MS32_COMP_CRV_3_DIV_8          CMP_CPxCR_CPxRVSEL_1
N#define MS32_COMP_CRV_4_DIV_8          (CMP_CPxCR_CPxRVSEL_1 | CMP_CPxCR_CPxRVSEL_0)
N#define MS32_COMP_CRV_5_DIV_8          CMP_CPxCR_CPxRVSEL_2
N#define MS32_COMP_CRV_6_DIV_8          (CMP_CPxCR_CPxRVSEL_2 | CMP_CPxCR_CPxRVSEL_0)
N#define MS32_COMP_CRV_7_DIV_8          (CMP_CPxCR_CPxRVSEL_2 | CMP_CPxCR_CPxRVSEL_1)
N#define MS32_COMP_CRV_8_DIV_8          (CMP_CPxCR_CPxRVSEL_2 | CMP_CPxCR_CPxRVSEL_1 | CMP_CPxCR_CPxRVSEL_0)
N
N
N/** @defgroup COMP_NEG_SELECT Comparison negative select
N  * @{
N  */
N#define MS32_COMP_NEG_PIN              (0x00000000U)
N#define MS32_COMP_NEG_CRV              CMP_CPxCR_CPxNSEL
N
N
N/** @defgroup COMP_POS_SELECT Comparison positive select
N  * @{
N  */
N#define MS32_COMP_POS_CPxP_PIN         (0x00000000U)
N#define MS32_COMP_POS_CPx2P_PIN        CMP_CPxCR_CPxPSEL_0
N#define MS32_COMP_POS_CPx3P_PIN        CMP_CPxCR_CPxPSEL_1
N#define MS32_COMP_POS_OP1OUT           (CMP_CPxCR_CPxPSEL_1 | CMP_CPxCR_CPxPSEL_0)
N#define MS32_COMP_POS_OP2OUT           CMP_CPxCR_CPxPSEL_2
N#define MS32_COMP_POS_OP3OUT           (CMP_CPxCR_CPxPSEL_2 | CMP_CPxCR_CPxPSEL_0)
N
N
N/** @defgroup COMP_HYST_SELECT Comparison hysteresis select
N  * @{
N  */
N#define MS32_COMP_HYST_0MV             (0x00000000U)
N#define MS32_COMP_HYST_15MV            CMP_CPxCR_CPxHYST_0
N#define MS32_COMP_HYST_30MV            CMP_CPxCR_CPxHYST_1
N#define MS32_COMP_HYST_90MV            (CMP_CPxCR_CPxHYST_1 | CMP_CPxCR_CPxHYST_0)
N
N
N/** @defgroup COMP_CRV_SELECT Comparison voltage reference select
N  * @{
N  */
N#define MS32_COMP_CRV_AVDD             (0x00000000U)
N#define MS32_COMP_CRV_VREF             CMP_CPANA_CP1VOLT
N
N
N/** @defgroup COMP_TI_Mode Comparison interrupt Mode
N  * @{
N  */
N#define MS32_COMP_IT_DISABLE           (0x00000000U)          /*!< Comparison interrupt disable */
N#define MS32_COMP_IT_ENABLE            (0x00000001U)          /*!< Comparison interrupt enable */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup COMP_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in COMP register
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_CMP_WriteReg(__REG__, __VALUE__) WRITE_REG(CMP_OP->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in COMP register
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_CMP_ReadReg(__REG__) READ_REG(CMP_OP->__REG__)
N
N
N/* Exported functions --------------------------------------------------------*/
N/**
N  * @brief  Enable comparision 1
N  * @rmtoll CP1CR           CMP1ON         MS32_CMP1_Enable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP1_Enable(void) {
Xstatic __inline void MS32_CMP1_Enable(void) {
N  SET_BIT(CMP_OP->CP1CR, CMP_CPxCR_CPxEN);
X  ((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable comparision 1
N  * @rmtoll CP1CR           CMP1ON         MS32_CMP1_Disable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP1_Disable(void) {
Xstatic __inline void MS32_CMP1_Disable(void) {
N  CLEAR_BIT(CMP_OP->CP1CR, CMP_CPxCR_CPxEN);
X  ((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Enable comparision 2
N  * @rmtoll CP2CR           CMP2ON         MS32_CMP2_Enable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP2_Enable(void) {
Xstatic __inline void MS32_CMP2_Enable(void) {
N  SET_BIT(CMP_OP->CP2CR, CMP_CPxCR_CPxEN);
X  ((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable comparision 2
N  * @rmtoll CP2CR           CMP2ON         MS32_CMP2_Disable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP2_Disable(void) {
Xstatic __inline void MS32_CMP2_Disable(void) {
N  CLEAR_BIT(CMP_OP->CP2CR, CMP_CPxCR_CPxEN);
X  ((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Select the hysteresis voltage by the Comparision 1
N  * @rmtoll CP1CR           CP2HYST        MS32_CMP1_SetHysteresisVoltage
N  * @param  HystVolt This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_HYST_0MV 
N  *         @arg @ref MS32_COMP_HYST_15MV
N  *         @arg @ref MS32_COMP_HYST_30MV
N  *         @arg @ref MS32_COMP_HYST_90MV
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP1_SetHysteresisVoltage(uint32_t HystVolt) {
Xstatic __inline void MS32_CMP1_SetHysteresisVoltage(uint32_t HystVolt) {
N  MODIFY_REG(CMP_OP->CP1CR, CMP_CPxCR_CPxHYST, HystVolt);
X  (((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR)) = ((((((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR))) & (~((0x3UL << (1U))))) | (HystVolt))));
N}
N
N/**
N  * @brief  Get the hysteresis voltage by the Comparision 1
N  * @rmtoll CP1CR           CP2HYST        MS32_CMP1_GetHysteresisVoltage
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_HYST_0MV 
N  *         @arg @ref MS32_COMP_HYST_15MV
N  *         @arg @ref MS32_COMP_HYST_30MV
N  *         @arg @ref MS32_COMP_HYST_90MV
N  */
N__STATIC_INLINE uint32_t MS32_CMP1_GetHysteresisVoltage(void) {
Xstatic __inline uint32_t MS32_CMP1_GetHysteresisVoltage(void) {
N  return (CMP_OP->CP1CR & CMP_CPxCR_CPxHYST);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR & (0x3UL << (1U)));
N}
N
N/**
N  * @brief  Select the hysteresis voltage by the Comparision 2
N  * @rmtoll CP2CR           CP2HYST        MS32_CMP2_SetHysteresisVoltage
N  * @param  HystVolt This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_HYST_0MV 
N  *         @arg @ref MS32_COMP_HYST_15MV
N  *         @arg @ref MS32_COMP_HYST_30MV
N  *         @arg @ref MS32_COMP_HYST_90MV
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP2_SetHysteresisVoltage(uint32_t HystVolt) {
Xstatic __inline void MS32_CMP2_SetHysteresisVoltage(uint32_t HystVolt) {
N  MODIFY_REG(CMP_OP->CP2CR, CMP_CPxCR_CPxHYST, HystVolt);
X  (((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR)) = ((((((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR))) & (~((0x3UL << (1U))))) | (HystVolt))));
N}
N
N/**
N  * @brief  Get the hysteresis voltage by the Comparision 2
N  * @rmtoll CP2CR           CP2HYST        MS32_CMP2_GetHysteresisVoltage
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_HYST_0MV 
N  *         @arg @ref MS32_COMP_HYST_15MV
N  *         @arg @ref MS32_COMP_HYST_30MV
N  *         @arg @ref MS32_COMP_HYST_90MV
N  */
N__STATIC_INLINE uint32_t MS32_CMP2_GetHysteresisVoltage(void) {
Xstatic __inline uint32_t MS32_CMP2_GetHysteresisVoltage(void) {
N  return (CMP_OP->CP2CR & CMP_CPxCR_CPxHYST);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR & (0x3UL << (1U)));
N}
N
N/**
N  * @brief  Select the positive input by the Comparision 1
N  * @rmtoll CP1CR           CP1PSEL        MS32_CMP1_SetPostiveInput
N  * @param  PosInput This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_POS_CPxP_PIN 
N  *         @arg @ref MS32_COMP_POS_CPx2P_PIN
N  *         @arg @ref MS32_COMP_POS_CPx3P_PIN
N  *         @arg @ref MS32_COMP_POS_OP1OUT   
N  *         @arg @ref MS32_COMP_POS_OP2OUT   
N  *         @arg @ref MS32_COMP_POS_OP3OUT   
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP1_SetPostiveInput(uint32_t PosInput) {
Xstatic __inline void MS32_CMP1_SetPostiveInput(uint32_t PosInput) {
N  MODIFY_REG(CMP_OP->CP1CR, CMP_CPxCR_CPxPSEL, PosInput);
X  (((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR)) = ((((((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR))) & (~((0x7UL << (3U))))) | (PosInput))));
N}
N
N/**
N  * @brief  Get the positive input by the Comparision 1
N  * @rmtoll CP1CR           CP1PSEL        MS32_CMP1_GetPostiveInput
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_POS_CPxP_PIN 
N  *         @arg @ref MS32_COMP_POS_CPx2P_PIN
N  *         @arg @ref MS32_COMP_POS_CPx3P_PIN
N  *         @arg @ref MS32_COMP_POS_OP1OUT   
N  *         @arg @ref MS32_COMP_POS_OP2OUT   
N  *         @arg @ref MS32_COMP_POS_OP3OUT   
N  */
N__STATIC_INLINE uint32_t MS32_CMP1_GetPostiveInput(void) {
Xstatic __inline uint32_t MS32_CMP1_GetPostiveInput(void) {
N  return (CMP_OP->CP1CR & CMP_CPxCR_CPxPSEL);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR & (0x7UL << (3U)));
N}
N
N/**
N  * @brief  Select the positive input by the Comparision 2
N  * @rmtoll CP2CR           CP2PSEL        MS32_CMP2_SetPostiveInput
N  * @param  PosInput This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_POS_CPxP_PIN
N  *         @arg @ref MS32_COMP_POS_OP1OUT  
N  *         @arg @ref MS32_COMP_POS_OP2OUT  
N  *         @arg @ref MS32_COMP_POS_OP3OUT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP2_SetPostiveInput(uint32_t PosInput) {
Xstatic __inline void MS32_CMP2_SetPostiveInput(uint32_t PosInput) {
N  if (PosInput <= MS32_COMP_POS_CPx3P_PIN) {
X  if (PosInput <= (0x02UL << (3U))) {
N    CLEAR_BIT(CMP_OP->CP2CR, CMP_CPxCR_CPxPSEL);
X    ((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR) &= ~((0x7UL << (3U))));
N  } else {
N    MODIFY_REG(CMP_OP->CP2CR, CMP_CPxCR_CPxPSEL, PosInput - 2);
X    (((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR)) = ((((((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR))) & (~((0x7UL << (3U))))) | (PosInput - 2))));
N  }
N}
N
N/**
N  * @brief  Get the positive input by the Comparision 2
N  * @rmtoll CP2CR           CP2PSEL        MS32_CMP2_GetPostiveInput
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_POS_CPxP_PIN
N  *         @arg @ref MS32_COMP_POS_OP1OUT  
N  *         @arg @ref MS32_COMP_POS_OP2OUT  
N  *         @arg @ref MS32_COMP_POS_OP3OUT
N  */
N__STATIC_INLINE uint32_t MS32_CMP2_GetPostiveInput(void) {
Xstatic __inline uint32_t MS32_CMP2_GetPostiveInput(void) {
N  uint32_t PosInput;
N
N  PosInput = CMP_OP->CP2CR & CMP_CPxCR_CPxPSEL;
X  PosInput = ((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR & (0x7UL << (3U));
N  if (PosInput) {
N    PosInput += (MS32_COMP_POS_OP1OUT - MS32_COMP_POS_CPx2P_PIN);
X    PosInput += (((0x02UL << (3U)) | (0x01UL << (3U))) - (0x01UL << (3U)));
N  }
N  return PosInput;
N}
N
N/**
N  * @brief  Select the negitive input by the Comparision 1
N  * @rmtoll CP1CR           CP1NSEL        MS32_CMP1_SetNegitiveInput
N  * @param  NegInput This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_NEG_PIN
N  *         @arg @ref MS32_COMP_NEG_CRV
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP1_SetNegitiveInput(uint32_t NegInput) {
Xstatic __inline void MS32_CMP1_SetNegitiveInput(uint32_t NegInput) {
N  MODIFY_REG(CMP_OP->CP1CR, CMP_CPxCR_CPxNSEL, NegInput);
X  (((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR)) = ((((((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR))) & (~((0x1UL << (6U))))) | (NegInput))));
N}
N
N/**
N  * @brief  Get the negitive input by the Comparision 1
N  * @rmtoll CP1CR           CP1NSEL        MS32_CMP1_GetNegitiveInput
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_NEG_PIN
N  *         @arg @ref MS32_COMP_NEG_CRV
N  */
N__STATIC_INLINE uint32_t MS32_CMP1_GetNegitiveInput(void) {
Xstatic __inline uint32_t MS32_CMP1_GetNegitiveInput(void) {
N  return (CMP_OP->CP1CR & CMP_CPxCR_CPxNSEL);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR & (0x1UL << (6U)));
N}
N
N/**
N  * @brief  Select the negitive input by the Comparision 2
N  * @rmtoll CP2CR           CP2NSEL        MS32_CMP2_SetNegitiveInput
N  * @param  NegInput This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_NEG_PIN
N  *         @arg @ref MS32_COMP_NEG_CRV
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP2_SetNegitiveInput(uint32_t NegInput) {
Xstatic __inline void MS32_CMP2_SetNegitiveInput(uint32_t NegInput) {
N  MODIFY_REG(CMP_OP->CP2CR, CMP_CPxCR_CPxNSEL, NegInput);
X  (((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR)) = ((((((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR))) & (~((0x1UL << (6U))))) | (NegInput))));
N}
N
N/**
N  * @brief  Get the negitive input by the Comparision 2
N  * @rmtoll CP2CR           CP2NSEL        MS32_CMP2_GetPostiveInput
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_NEG_PIN
N  *         @arg @ref MS32_COMP_NEG_CRV
N  */
N__STATIC_INLINE uint32_t MS32_CMP2_GetNegitiveInput(void) {
Xstatic __inline uint32_t MS32_CMP2_GetNegitiveInput(void) {
N  return (CMP_OP->CP2CR & CMP_CPxCR_CPxNSEL);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR & (0x1UL << (6U)));
N}
N
N/**
N  * @brief  Select the VREF voltage by the Comparision 1
N  * @rmtoll CP1CR           CP1VERFSEL        MS32_CMP1_SetVrefVoltage
N  * @param  VrefVolt This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_CRV_1_DIV_8
N  *         @arg @ref MS32_COMP_CRV_2_DIV_8
N  *         @arg @ref MS32_COMP_CRV_3_DIV_8
N  *         @arg @ref MS32_COMP_CRV_4_DIV_8
N  *         @arg @ref MS32_COMP_CRV_5_DIV_8
N  *         @arg @ref MS32_COMP_CRV_6_DIV_8
N  *         @arg @ref MS32_COMP_CRV_7_DIV_8
N  *         @arg @ref MS32_COMP_CRV_8_DIV_8
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP1_SetVrefVoltage(uint32_t VrefVolt) {
Xstatic __inline void MS32_CMP1_SetVrefVoltage(uint32_t VrefVolt) {
N  MODIFY_REG(CMP_OP->CP1CR, CMP_CPxCR_CPxRVSEL, VrefVolt);
X  (((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR)) = ((((((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR))) & (~((0x7UL << (7U))))) | (VrefVolt))));
N}
N
N/**
N  * @brief  Get the VREF voltage by the Comparision 1
N  * @rmtoll CP1CR           CP1VERFSEL        MS32_CMP1_GetVrefVoltage
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_CRV_1_DIV_8
N  *         @arg @ref MS32_COMP_CRV_2_DIV_8
N  *         @arg @ref MS32_COMP_CRV_3_DIV_8
N  *         @arg @ref MS32_COMP_CRV_4_DIV_8
N  *         @arg @ref MS32_COMP_CRV_5_DIV_8
N  *         @arg @ref MS32_COMP_CRV_6_DIV_8
N  *         @arg @ref MS32_COMP_CRV_7_DIV_8
N  *         @arg @ref MS32_COMP_CRV_8_DIV_8
N  */
N__STATIC_INLINE uint32_t MS32_CMP1_GetVrefVoltage(void) {
Xstatic __inline uint32_t MS32_CMP1_GetVrefVoltage(void) {
N  return (CMP_OP->CP1CR & CMP_CPxCR_CPxRVSEL);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR & (0x7UL << (7U)));
N}
N
N/**
N  * @brief  Select the VREF voltage by the Comparision 2
N  * @rmtoll CP2CR           CP2VERFSEL        MS32_CMP2_SetVrefVoltage
N  * @param  VrefVolt This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_CRV_1_DIV_8
N  *         @arg @ref MS32_COMP_CRV_2_DIV_8
N  *         @arg @ref MS32_COMP_CRV_3_DIV_8
N  *         @arg @ref MS32_COMP_CRV_4_DIV_8
N  *         @arg @ref MS32_COMP_CRV_5_DIV_8
N  *         @arg @ref MS32_COMP_CRV_6_DIV_8
N  *         @arg @ref MS32_COMP_CRV_7_DIV_8
N  *         @arg @ref MS32_COMP_CRV_8_DIV_8
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP2_SetVrefVoltage(uint32_t VrefVolt) {
Xstatic __inline void MS32_CMP2_SetVrefVoltage(uint32_t VrefVolt) {
N  MODIFY_REG(CMP_OP->CP2CR, CMP_CPxCR_CPxRVSEL, VrefVolt);
X  (((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR)) = ((((((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR))) & (~((0x7UL << (7U))))) | (VrefVolt))));
N}
N
N/**
N  * @brief  Get the VREF voltage by the Comparision 2
N  * @rmtoll CP2CR           CP2VERFSEL        MS32_CMP2_GetVrefVoltage
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_CRV_1_DIV_8
N  *         @arg @ref MS32_COMP_CRV_2_DIV_8
N  *         @arg @ref MS32_COMP_CRV_3_DIV_8
N  *         @arg @ref MS32_COMP_CRV_4_DIV_8
N  *         @arg @ref MS32_COMP_CRV_5_DIV_8
N  *         @arg @ref MS32_COMP_CRV_6_DIV_8
N  *         @arg @ref MS32_COMP_CRV_7_DIV_8
N  *         @arg @ref MS32_COMP_CRV_8_DIV_8
N  */
N__STATIC_INLINE uint32_t MS32_CMP2_GetVrefVoltage(void) {
Xstatic __inline uint32_t MS32_CMP2_GetVrefVoltage(void) {
N  return (CMP_OP->CP2CR & CMP_CPxCR_CPxRVSEL);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR & (0x7UL << (7U)));
N}
N
N/**
N  * @brief  Select the output filter by the Comparision 1
N  * @rmtoll CP1CR           CP1OFLT        MS32_CMP1_SetOutputFilter
N  * @param  OutFilt This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK1  
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK4  
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK16 
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK32 
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK64 
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK128
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK256
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK512
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP1_SetOutputFilter(uint32_t OutFilt) {
Xstatic __inline void MS32_CMP1_SetOutputFilter(uint32_t OutFilt) {
N  MODIFY_REG(CMP_OP->CP1CR, CMP_CPxCR_CPxOFLT, OutFilt);
X  (((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR)) = ((((((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR))) & (~((0x7UL << (11U))))) | (OutFilt))));
N}
N
N/**
N  * @brief  Get the output filter by the Comparision 1
N  * @rmtoll CP1CR           CP1OFLT        MS32_CMP1_GetOutputFilter
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK1  
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK4  
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK16 
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK32 
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK64 
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK128
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK256
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK512
N  */
N__STATIC_INLINE uint32_t MS32_CMP1_GetOutputFilter(void) {
Xstatic __inline uint32_t MS32_CMP1_GetOutputFilter(void) {
N  return (CMP_OP->CP1CR & CMP_CPxCR_CPxOFLT);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR & (0x7UL << (11U)));
N}
N
N/**
N  * @brief  Select the output filter by the Comparision 2
N  * @rmtoll CP2CR           CP2OFLT        MS32_CMP2_SetOutputFilter
N  * @param  OutFilt This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK1  
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK4  
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK16 
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK32 
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK64 
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK128
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK256
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK512
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP2_SetOutputFilter(uint32_t OutFilt) {
Xstatic __inline void MS32_CMP2_SetOutputFilter(uint32_t OutFilt) {
N  MODIFY_REG(CMP_OP->CP2CR, CMP_CPxCR_CPxOFLT, OutFilt);
X  (((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR)) = ((((((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR))) & (~((0x7UL << (11U))))) | (OutFilt))));
N}
N
N/**
N  * @brief  Get the output filter by the Comparision 2
N  * @rmtoll CP2CR           CP2OFLT        MS32_CMP2_GetOutputFilter
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK1  
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK4  
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK16 
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK32 
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK64 
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK128
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK256
N  *         @arg @ref MS32_COMP_OUT_FILTER_CLK512
N  */
N__STATIC_INLINE uint32_t MS32_CMP2_GetOutputFilter(void) {
Xstatic __inline uint32_t MS32_CMP2_GetOutputFilter(void) {
N  return (CMP_OP->CP2CR & CMP_CPxCR_CPxOFLT);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR & (0x7UL << (11U)));
N}
N
N/**
N  * @brief  Select the output polarity by the Comparision 1
N  * @rmtoll CP1CR           CP1POL        MS32_CMP1_SetOutputPol
N  * @param  OutPol This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_OUT_POL_POS
N  *         @arg @ref MS32_COMP_OUT_POL_NEG
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP1_SetOutputPol(uint32_t OutPol) {
Xstatic __inline void MS32_CMP1_SetOutputPol(uint32_t OutPol) {
N  MODIFY_REG(CMP_OP->CP1CR, CMP_CPxCR_CPxPOL, OutPol);
X  (((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR)) = ((((((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR))) & (~((0x1UL << (15U))))) | (OutPol))));
N}
N
N/**
N  * @brief  Get the output polarity by the Comparision 1
N  * @rmtoll CP1CR           CP1POL        MS32_CMP1_GetOutputPol
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_OUT_POL_POS
N  *         @arg @ref MS32_COMP_OUT_POL_NEG
N  */
N__STATIC_INLINE uint32_t MS32_CMP1_GetOutputPol(void) {
Xstatic __inline uint32_t MS32_CMP1_GetOutputPol(void) {
N  return (CMP_OP->CP1CR & CMP_CPxCR_CPxPOL);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR & (0x1UL << (15U)));
N}
N
N/**
N  * @brief  Select the output polarity by the Comparision 2
N  * @rmtoll CP2CR           CP2POL        MS32_CMP2_SetOutputPol
N  * @param  OutPol This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_OUT_POL_POS
N  *         @arg @ref MS32_COMP_OUT_POL_NEG
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP2_SetOutputPol(uint32_t OutPol) {
Xstatic __inline void MS32_CMP2_SetOutputPol(uint32_t OutPol) {
N  MODIFY_REG(CMP_OP->CP2CR, CMP_CPxCR_CPxPOL, OutPol);
X  (((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR)) = ((((((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR))) & (~((0x1UL << (15U))))) | (OutPol))));
N}
N
N/**
N  * @brief  Get the output polarity by the Comparision 2
N  * @rmtoll CP2CR           CP2POL        MS32_CMP2_GetOutputPol
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_OUT_POL_POS
N  *         @arg @ref MS32_COMP_OUT_POL_NEG
N  */
N__STATIC_INLINE uint32_t MS32_CMP2_GetOutputPol(void) {
Xstatic __inline uint32_t MS32_CMP2_GetOutputPol(void) {
N  return (CMP_OP->CP2CR & CMP_CPxCR_CPxPOL);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR & (0x1UL << (15U)));
N}
N
N/**
N  * @brief  Select the inline output by the Comparision 1
N  * @rmtoll CP1CR           CP1OUTSEL        MS32_CMP1_SetInlineOutput
N  * @param  OutFilt This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_OUT_TIM1_BKIN     
N  *         @arg @ref MS32_COMP_OUT_TIM1_OCREF_CLR
N  *         @arg @ref MS32_COMP_OUT_TIM1_IC1      
N  *         @arg @ref MS32_COMP_OUT_TIM2_IC4      
N  *         @arg @ref MS32_COMP_OUT_TIM2_OCREF_CLR
N  *         @arg @ref MS32_COMP_OUT_TIM3_IC1      
N  *         @arg @ref MS32_COMP_OUT_TIM3_OCREF_CLR
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP1_SetInlineOutput(uint32_t OutFilt) {
Xstatic __inline void MS32_CMP1_SetInlineOutput(uint32_t OutFilt) {
N  MODIFY_REG(CMP_OP->CP1CR, CMP_CPxCR_CPxOUTSEL, OutFilt);
X  (((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR)) = ((((((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR))) & (~((0x7UL << (16U))))) | (OutFilt))));
N}
N
N/**
N  * @brief  Get the inline output by the Comparision 1
N  * @rmtoll CP1CR           CP1OUTSEL        MS32_CMP1_GetInlineOutput
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_OUT_TIM1_BKIN     
N  *         @arg @ref MS32_COMP_OUT_TIM1_OCREF_CLR
N  *         @arg @ref MS32_COMP_OUT_TIM1_IC1      
N  *         @arg @ref MS32_COMP_OUT_TIM2_IC4      
N  *         @arg @ref MS32_COMP_OUT_TIM2_OCREF_CLR
N  *         @arg @ref MS32_COMP_OUT_TIM3_IC1      
N  *         @arg @ref MS32_COMP_OUT_TIM3_OCREF_CLR
N  */
N__STATIC_INLINE uint32_t MS32_CMP1_GetInlineOutput(void) {
Xstatic __inline uint32_t MS32_CMP1_GetInlineOutput(void) {
N  return (CMP_OP->CP1CR & CMP_CPxCR_CPxOUTSEL);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR & (0x7UL << (16U)));
N}
N
N/**
N  * @brief  Select the inline output by the Comparision 2
N  * @rmtoll CP2CR           CP2OUTSEL        MS32_CMP2_SetInlineOutput
N  * @param  OutFilt This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_OUT_TIM1_BKIN     
N  *         @arg @ref MS32_COMP_OUT_TIM1_OCREF_CLR
N  *         @arg @ref MS32_COMP_OUT_TIM1_IC1      
N  *         @arg @ref MS32_COMP_OUT_TIM2_IC4      
N  *         @arg @ref MS32_COMP_OUT_TIM2_OCREF_CLR
N  *         @arg @ref MS32_COMP_OUT_TIM3_IC1      
N  *         @arg @ref MS32_COMP_OUT_TIM3_OCREF_CLR
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP2_SetInlineOutput(uint32_t OutFilt) {
Xstatic __inline void MS32_CMP2_SetInlineOutput(uint32_t OutFilt) {
N  MODIFY_REG(CMP_OP->CP2CR, CMP_CPxCR_CPxOUTSEL, OutFilt);
X  (((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR)) = ((((((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR))) & (~((0x7UL << (16U))))) | (OutFilt))));
N}
N
N/**
N  * @brief  Get the inline output by the Comparision 2
N  * @rmtoll CP2CR           CP2OUTSEL        MS32_CMP2_GetInlineOutput
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_OUT_TIM1_BKIN     
N  *         @arg @ref MS32_COMP_OUT_TIM1_OCREF_CLR
N  *         @arg @ref MS32_COMP_OUT_TIM1_IC1      
N  *         @arg @ref MS32_COMP_OUT_TIM2_IC4      
N  *         @arg @ref MS32_COMP_OUT_TIM2_OCREF_CLR
N  *         @arg @ref MS32_COMP_OUT_TIM3_IC1      
N  *         @arg @ref MS32_COMP_OUT_TIM3_OCREF_CLR
N  */
N__STATIC_INLINE uint32_t MS32_CMP2_GetInlineOutput(void) {
Xstatic __inline uint32_t MS32_CMP2_GetInlineOutput(void) {
N  return (CMP_OP->CP2CR & CMP_CPxCR_CPxOUTSEL);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR & (0x7UL << (16U)));
N}
N
N/**
N  * @brief  Get the output value by the Comparision 1
N  * @rmtoll CP1CR           CP1OUT        MS32_CMP1_GetOutputValue
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_OUTPUT_LOW  
N  *         @arg @ref MS32_COMP_OUTPUT_HIGH 
N  */
N__STATIC_INLINE uint32_t MS32_CMP1_GetOutputValue(void) {
Xstatic __inline uint32_t MS32_CMP1_GetOutputValue(void) {
N  return (CMP_OP->CP1CR & CMP_CPxCR_CPxOUT);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR & (0x1UL << (30U)));
N}
N
N/**
N  * @brief  Get the output value by the Comparision 2
N  * @rmtoll CP2CR           CP2OUT        MS32_CMP2_GetOutputValue
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_OUTPUT_LOW  
N  *         @arg @ref MS32_COMP_OUTPUT_HIGH 
N  */
N__STATIC_INLINE uint32_t MS32_CMP2_GetOutputValue(void) {
Xstatic __inline uint32_t MS32_CMP2_GetOutputValue(void) {
N  return (CMP_OP->CP2CR & CMP_CPxCR_CPxOUT);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR & (0x1UL << (30U)));
N}
N
N/**
N  * @brief  Lock the Comparision 1
N  * @rmtoll CP1CR           CP1LCK        MS32_CMP1_Lock
N  * @param  None
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP1_Lock(void) {
Xstatic __inline void MS32_CMP1_Lock(void) {
N  SET_BIT(CMP_OP->CP1CR, CMP_CPxCR_CPxLCK);
X  ((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR) |= ((0x1UL << (31U))));
N}
N
N/**
N  * @brief  Get the output value by the Comparision 1
N  * @rmtoll CP1CR           CP1LCK        MS32_CMP1_GetLock
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_UNLOCK 
N  *         @arg @ref MS32_COMP_LOCK   
N  */
N__STATIC_INLINE uint32_t MS32_CMP1_GetLock(void) {
Xstatic __inline uint32_t MS32_CMP1_GetLock(void) {
N  return (CMP_OP->CP1CR & CMP_CPxCR_CPxLCK);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP1CR & (0x1UL << (31U)));
N}
N
N/**
N  * @brief  Lock the Comparision 2
N  * @rmtoll CP2CR           CP2LCK        MS32_CMP2_Lock
N  * @param  None
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CMP2_Lock(void) {
Xstatic __inline void MS32_CMP2_Lock(void) {
N  SET_BIT(CMP_OP->CP2CR, CMP_CPxCR_CPxLCK);
X  ((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR) |= ((0x1UL << (31U))));
N}
N
N/**
N  * @brief  Get the output value by the Comparision 2
N  * @rmtoll CP2CR           CP2LCK        MS32_CMP2_GetLock
N  * @param  None
N  * @retval This parameter can be one of the following values:
N  *         @arg @ref MS32_COMP_UNLOCK
N  *         @arg @ref MS32_COMP_LOCK  
N  */
N__STATIC_INLINE uint32_t MS32_CMP2_GetLock(void) {
Xstatic __inline uint32_t MS32_CMP2_GetLock(void) {
N  return (CMP_OP->CP2CR & CMP_CPxCR_CPxLCK);
X  return (((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->CP2CR & (0x1UL << (31U)));
N}
N
N
N/** @defgroup COMP_EF_Init Initialization and de-initialization functions
N  * @{
N  */
NErrorStatus MS32_CMP_DeInit     (uint32_t CmpUnit);
Nvoid        MS32_CMP_StructInit (MS32_CMP_InitTypeDef *CmpInitStr);
NErrorStatus MS32_CMP_Init       (uint32_t CmpUnit, MS32_CMP_InitTypeDef *CmpInitStr);
Nvoid        MS32_CMP_ITConfig   (uint32_t InterruptFunc, uint32_t Priority);
N
N/** @defgroup COMP_EF_Application function
N  * @{
N  */
NFlagStatus  MS32_CMP_GetOutputStatus (uint32_t CmpUnit);
NErrorStatus MS32_CMP_GetCaliValue    (uint32_t CmpUnit, MS32_CMP_CaliTypeDef *CmpCaliStr);
NErrorStatus MS32_CMP_SetCaliValue    (uint32_t CmpUnit, MS32_CMP_CaliTypeDef *CmpCaliStr);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_COMP_H */
N
N/******************************** END OF FILE *********************************/
L 66 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_cortex.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_cortex.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_CORTEX_H
N#define __MS32F0XX_CORTEX_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup CORTEX_EC_CLKSOURCE_HCLK SYSTICK Clock Source
N  * @{
N  */
N#define MS32_SYSTICK_CLKSOURCE_HCLK_DIV8     0x00000000U                 /*!< AHB clock divided by 8 selected as SysTick clock source.*/
N#define MS32_SYSTICK_CLKSOURCE_HCLK          SysTick_CTRL_CLKSOURCE_Msk  /*!< AHB clock selected as SysTick clock source. */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup CORTEX_EF_SYSTICK SYSTICK
N  * @{
N  */
N
N/**
N  * @brief  Enable SysTick
N  * @rmtoll STK_CTRL     ENABLE       MS32_SYSTICK_Enable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SYSTICK_Enable(void) {
Xstatic __inline void MS32_SYSTICK_Enable(void) {
N  SET_BIT(SysTick->CTRL, SysTick_CTRL_ENABLE_Msk);
X  ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL) |= ((1UL )));
N}
N
N/**
N  * @brief  Disable SysTick
N  * @rmtoll STK_CTRL     ENABLE       MS32_SYSTICK_Disable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SYSTICK_Disable(void) {
Xstatic __inline void MS32_SYSTICK_Disable(void) {
N  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_ENABLE_Msk);
X  ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL) &= ~((1UL )));
N}
N
N/**
N  * @brief  Checks if the SYSTICK is enabled or disabled.
N  * @rmtoll STK_CTRL     ENABLE       MS32_SYSTICK_IsEnabled
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SYSTICK_IsEnabled(void) {
Xstatic __inline uint32_t MS32_SYSTICK_IsEnabled(void) {
N  return (READ_BIT(SysTick->CTRL, SysTick_CTRL_ENABLE_Msk) == (SysTick_CTRL_ENABLE_Msk));
X  return (((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL) & ((1UL ))) == ((1UL )));
N}
N
N/**
N  * @brief  This function checks if the Systick counter flag is active or not.
N  * @note   It can be used in timeout function on application side.
N  * @rmtoll STK_CTRL     COUNTFLAG     MS32_SYSTICK_IsActiveCounterFlag
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SYSTICK_IsActiveCounterFlag(void) {
Xstatic __inline uint32_t MS32_SYSTICK_IsActiveCounterFlag(void) {
N  return ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == (SysTick_CTRL_COUNTFLAG_Msk));
X  return ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL & (1UL << 16U)) == ((1UL << 16U)));
N}
N
N/**
N  * @brief  Configures the SysTick clock source
N  * @rmtoll STK_CTRL     CLKSOURCE     MS32_SYSTICK_SetClkSource
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref MS32_SYSTICK_CLKSOURCE_HCLK_DIV8
N  *         @arg @ref MS32_SYSTICK_CLKSOURCE_HCLK
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SYSTICK_SetClkSource(uint32_t Source) {
Xstatic __inline void MS32_SYSTICK_SetClkSource(uint32_t Source) {
N  if (Source == MS32_SYSTICK_CLKSOURCE_HCLK) {
X  if (Source == (1UL << 2U)) {
N    SET_BIT(SysTick->CTRL, MS32_SYSTICK_CLKSOURCE_HCLK);
X    ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL) |= ((1UL << 2U)));
N  } else {
N    CLEAR_BIT(SysTick->CTRL, MS32_SYSTICK_CLKSOURCE_HCLK);
X    ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL) &= ~((1UL << 2U)));
N  }
N}
N
N/**
N  * @brief  Get the SysTick clock source
N  * @rmtoll STK_CTRL     CLKSOURCE     MS32_SYSTICK_GetClkSource
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SYSTICK_CLKSOURCE_HCLK_DIV8
N  *         @arg @ref MS32_SYSTICK_CLKSOURCE_HCLK
N  */
N__STATIC_INLINE uint32_t MS32_SYSTICK_GetClkSource(void) {
Xstatic __inline uint32_t MS32_SYSTICK_GetClkSource(void) {
N  return READ_BIT(SysTick->CTRL, MS32_SYSTICK_CLKSOURCE_HCLK);
X  return ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL) & ((1UL << 2U)));
N}
N
N/**
N  * @brief  Set the SysTick reload-value
N  * @rmtoll STK_LOAD     LOAD     MS32_SYSTICK_SetReLoadVal
N  * @param  AutoReload between Min_Data=0 and Max_Data=0xFFFFFFUL
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SYSTICK_SetReloadVal(uint32_t AutoReload) {
Xstatic __inline void MS32_SYSTICK_SetReloadVal(uint32_t AutoReload) {
N  if (AutoReload <= SysTick_LOAD_RELOAD_Msk) {
X  if (AutoReload <= (0xFFFFFFUL )) {
N    WRITE_REG(SysTick->LOAD, AutoReload);
X    ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD) = (AutoReload));
N  }
N}
N
N/**
N  * @brief  Get the SysTick reload-value
N  * @rmtoll STK_LOAD     LOAD     MS32_SYSTICK_GetReLoadVal
N  * @retval Auto-reload value
N  */
N__STATIC_INLINE uint32_t MS32_SYSTICK_GetReLoadVal(void) {
Xstatic __inline uint32_t MS32_SYSTICK_GetReLoadVal(void) {
N  return READ_REG(SysTick->LOAD);
X  return ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD));
N}
N
N/**
N  * @brief  Set the SysTick value
N  * @rmtoll STK_VAL     VAL     MS32_SYSTICK_SetVal
N  * @param  Value between Min_Data=0 and Max_Data=0xFFFFFFUL
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SYSTICK_SetVal(uint32_t Value) {
Xstatic __inline void MS32_SYSTICK_SetVal(uint32_t Value) {
N  if (Value <= SysTick_VAL_CURRENT_Msk) {
X  if (Value <= (0xFFFFFFUL )) {
N    WRITE_REG(SysTick->VAL, Value);
X    ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL) = (Value));
N  }
N}
N
N/**
N  * @brief  Get the SysTick value
N  * @rmtoll STK_VAL     VAL     MS32_SYSTICK_GetVal
N  * @retval Value
N  */
N__STATIC_INLINE uint32_t MS32_SYSTICK_GetVal(void) {
Xstatic __inline uint32_t MS32_SYSTICK_GetVal(void) {
N  return READ_REG(SysTick->VAL);
X  return ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL));
N}
N
N/**
N  * @brief  Enable SysTick exception request
N  * @rmtoll STK_CTRL     TICKINT       MS32_SYSTICK_EnableIT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SYSTICK_EnableIT(void) {
Xstatic __inline void MS32_SYSTICK_EnableIT(void) {
N  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
X  ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL) |= ((1UL << 1U)));
N}
N
N/**
N  * @brief  Disable SysTick exception request
N  * @rmtoll STK_CTRL     TICKINT       MS32_SYSTICK_DisableIT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SYSTICK_DisableIT(void) {
Xstatic __inline void MS32_SYSTICK_DisableIT(void) {
N  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
X  ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL) &= ~((1UL << 1U)));
N}
N
N/**
N  * @brief  Checks if the SYSTICK interrupt is enabled or disabled.
N  * @rmtoll STK_CTRL     TICKINT       MS32_SYSTICK_IsEnabledIT
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SYSTICK_IsEnabledIT(void) {
Xstatic __inline uint32_t MS32_SYSTICK_IsEnabledIT(void) {
N  return (READ_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk) == (SysTick_CTRL_TICKINT_Msk));
X  return (((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL) & ((1UL << 1U))) == ((1UL << 1U)));
N}
N
N
N/** @defgroup CORTEX_EF_LOW_POWER_MODE LOW POWER MODE
N  * @{
N  */
N
N/**
N  * @brief  Processor uses sleep as its low power mode
N  * @rmtoll SCB_SCR      SLEEPDEEP     MS32_LPM_EnableSleep
N  * @retval None
N  */
N__STATIC_INLINE void MS32_LPM_EnableSleep(void) {
Xstatic __inline void MS32_LPM_EnableSleep(void) {
N  /* Clear SLEEPDEEP bit of Cortex System Control Register */
N  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
X  ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR) &= ~(((uint32_t)(1UL << 2U))));
N}
N
N/**
N  * @brief  Processor uses deep sleep as its low power mode
N  * @rmtoll SCB_SCR      SLEEPDEEP     MS32_LPM_EnableDeepSleep
N  * @retval None
N  */
N__STATIC_INLINE void MS32_LPM_EnableDeepSleep(void) {
Xstatic __inline void MS32_LPM_EnableDeepSleep(void) {
N  /* Set SLEEPDEEP bit of Cortex System Control Register */
N  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
X  ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR) |= (((uint32_t)(1UL << 2U))));
N}
N
N/**
N  * @brief  Configures sleep-on-exit when returning from Handler mode to Thread mode.
N  * @note   Setting this bit to 1 enables an interrupt-driven application to avoid returning to an
N  *         empty main application.
N  * @rmtoll SCB_SCR      SLEEPONEXIT   MS32_LPM_EnableSleepOnExit
N  * @retval None
N  */
N__STATIC_INLINE void MS32_LPM_EnableSleepOnExit(void) {
Xstatic __inline void MS32_LPM_EnableSleepOnExit(void) {
N  /* Set SLEEPONEXIT bit of Cortex System Control Register */
N  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
X  ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR) |= (((uint32_t)(1UL << 1U))));
N}
N
N/**
N  * @brief  Do not sleep when returning to Thread mode.
N  * @rmtoll SCB_SCR      SLEEPONEXIT   MS32_LPM_DisableSleepOnExit
N  * @retval None
N  */
N__STATIC_INLINE void MS32_LPM_DisableSleepOnExit(void) {
Xstatic __inline void MS32_LPM_DisableSleepOnExit(void) {
N  /* Clear SLEEPONEXIT bit of Cortex System Control Register */
N  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
X  ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR) &= ~(((uint32_t)(1UL << 1U))));
N}
N
N/**
N  * @brief  Enabled events and all interrupts, including disabled interrupts, can wakeup the
N  *         processor.
N  * @rmtoll SCB_SCR      SEVEONPEND    MS32_LPM_EnableEventOnPend
N  * @retval None
N  */
N__STATIC_INLINE void MS32_LPM_EnableEventOnPend(void) {
Xstatic __inline void MS32_LPM_EnableEventOnPend(void) {
N  /* Set SEVEONPEND bit of Cortex System Control Register */
N  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
X  ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR) |= (((uint32_t)(1UL << 4U))));
N}
N
N/**
N  * @brief  Only enabled interrupts or events can wakeup the processor, disabled interrupts are
N  *         excluded
N  * @rmtoll SCB_SCR      SEVEONPEND    MS32_LPM_DisableEventOnPend
N  * @retval None
N  */
N__STATIC_INLINE void MS32_LPM_DisableEventOnPend(void) {
Xstatic __inline void MS32_LPM_DisableEventOnPend(void) {
N  /* Clear SEVEONPEND bit of Cortex System Control Register */
N  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
X  ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR) &= ~(((uint32_t)(1UL << 4U))));
N}
N
N
N/** @defgroup CORTEX_EF_MCU_INFO MCU INFO
N  * @{
N  */
N
N/**
N  * @brief  Get Implementer code
N  * @rmtoll SCB_CPUID    IMPLEMENTER   MS32_CPUID_GetImplementer
N  * @retval Value should be equal to 0x41 for ARM
N  */
N__STATIC_INLINE uint32_t MS32_CPUID_GetImplementer(void) {
Xstatic __inline uint32_t MS32_CPUID_GetImplementer(void) {
N  return (uint32_t)(READ_BIT(SCB->CPUID, SCB_CPUID_IMPLEMENTER_Msk) >> SCB_CPUID_IMPLEMENTER_Pos);
X  return (uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CPUID) & ((0xFFUL << 24U))) >> 24U);
N}
N
N/**
N  * @brief  Get Variant number (The r value in the rnpn product revision identifier)
N  * @rmtoll SCB_CPUID    VARIANT       MS32_CPUID_GetVariant
N  * @retval Value between 0 and 255 (0x0: revision 0)
N  */
N__STATIC_INLINE uint32_t MS32_CPUID_GetVariant(void) {
Xstatic __inline uint32_t MS32_CPUID_GetVariant(void) {
N  return (uint32_t)(READ_BIT(SCB->CPUID, SCB_CPUID_VARIANT_Msk) >> SCB_CPUID_VARIANT_Pos);
X  return (uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CPUID) & ((0xFUL << 20U))) >> 20U);
N}
N
N/**
N  * @brief  Get Architecture number
N  * @rmtoll SCB_CPUID    ARCHITECTURE  MS32_CPUID_GetArchitecture
N  * @retval Value should be equal to 0xC for Cortex-M0 devices
N  */
N__STATIC_INLINE uint32_t MS32_CPUID_GetArchitecture(void) {
Xstatic __inline uint32_t MS32_CPUID_GetArchitecture(void) {
N  return (uint32_t)(READ_BIT(SCB->CPUID, SCB_CPUID_ARCHITECTURE_Msk) >> SCB_CPUID_ARCHITECTURE_Pos);
X  return (uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CPUID) & ((0xFUL << 16U))) >> 16U);
N}
N
N/**
N  * @brief  Get Part number
N  * @rmtoll SCB_CPUID    PARTNO        MS32_CPUID_GetParNo
N  * @retval Value should be equal to 0xC20 for Cortex-M0
N  */
N__STATIC_INLINE uint32_t MS32_CPUID_GetParNo(void) {
Xstatic __inline uint32_t MS32_CPUID_GetParNo(void) {
N  return (uint32_t)(READ_BIT(SCB->CPUID, SCB_CPUID_PARTNO_Msk) >> SCB_CPUID_PARTNO_Pos);
X  return (uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CPUID) & ((0xFFFUL << 4U))) >> 4U);
N}
N
N/**
N  * @brief  Get Revision number (The p value in the rnpn product revision identifier, indicates patch release)
N  * @rmtoll SCB_CPUID    REVISION      MS32_CPUID_GetRevision
N  * @retval Value between 0 and 255 (0x1: patch 1)
N  */
N__STATIC_INLINE uint32_t MS32_CPUID_GetRevision(void) {
Xstatic __inline uint32_t MS32_CPUID_GetRevision(void) {
N  return (uint32_t)(READ_BIT(SCB->CPUID, SCB_CPUID_REVISION_Msk) >> SCB_CPUID_REVISION_Pos);
X  return (uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CPUID) & ((0xFUL ))) >> 0U);
N}
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_CORTEX_H */
N
N/******************************** END OF FILE *********************************/
L 67 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_crc.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_crc.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_CRC_H
N#define __MS32F0XX_CRC_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup CRC_Exported_Types CRC Exported Types
N  * @{
N  */
N
N/**
N  * @brief CRC Init Structure definition
N  */
Ntypedef struct {
N  uint32_t InitValue;                 /*!< Init value to initiate CRC computation. No need to specify it if DefaultInitValueUse
N                                           is set to DEFAULT_INIT_VALUE_ENABLE.   */
N  uint32_t InputDataInversionMode;    /*!< This parameter is a value of @ref CRCEx_Input_Data_Inversion and specifies input data inversion mode.
N                                           Can be either one of the following values
N                                           @arg @ref CRC_INPUTDATA_INVERSION_NONE       no input data inversion
N                                           @arg @ref CRC_INPUTDATA_INVERSION_BYTE       byte-wise inversion, 0x1A2B3C4D becomes 0x58D43CB2
N                                           @arg @ref CRC_INPUTDATA_INVERSION_HALFWORD   halfword-wise inversion, 0x1A2B3C4D becomes 0xD458B23C
N                                           @arg @ref CRC_INPUTDATA_INVERSION_WORD       word-wise inversion, 0x1A2B3C4D becomes 0xB23CD458 */
N  uint32_t OutputDataInversionMode;   /*!< This parameter is a value of @ref CRCEx_Output_Data_Inversion and specifies output data (i.e. CRC) inversion mode.
N                                            Can be either
N                                            @arg @ref CRC_OUTPUTDATA_INVERSION_DISABLE   no CRC inversion,
N                                            @arg @ref CRC_OUTPUTDATA_INVERSION_ENABLE    CRC 0x11223344 is converted into 0x22CC4488 */
N} MS32_CRC_InitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup CRC_EC_Default_InitValue    Default CRC computation initialization value
N  * @{
N  */
N#define MS32_CRC_DEFAULT_CRC_INITVALUE       (0xFFFFFFFFU) /*!< Default CRC computation initialization value */
N
N
N/** @defgroup CRC_EC_INDATA_REVERSE Input Data Reverse
N  * @{
N  */
N#define MS32_CRC_INDATA_REVERSE_NONE         (0x00000000U)                       /*!< Input Data bit order not affected */
N#define MS32_CRC_INDATA_REVERSE_BYTE         CRC_CR_REV_IN_0                     /*!< Input Data bit reversal done by byte */
N#define MS32_CRC_INDATA_REVERSE_HALFWORD     CRC_CR_REV_IN_1                     /*!< Input Data bit reversal done by half-word */
N#define MS32_CRC_INDATA_REVERSE_WORD         (CRC_CR_REV_IN_1 | CRC_CR_REV_IN_0) /*!< Input Data bit reversal done by word */
N
N
N/** @defgroup CRC_EC_OUTDATA_REVERSE Output Data Reverse
N  * @{
N  */
N#define MS32_CRC_OUTDATA_REVERSE_NONE        (0x00000000U)  /*!< Output Data bit order not affected */
N#define MS32_CRC_OUTDATA_REVERSE_BIT         CRC_CR_REV_OUT /*!< Output Data bit reversal done by bit */
N
N
N/** @defgroup CRC_EC_Default_Polynomial_Value    Default CRC generating polynomial value
N  * @brief    Normal representation of this polynomial value is
N  *           X^32 + X^26 + X^23 + X^22 + X^16 + X^12 + X^11 + X^10 +X^8 + X^7 + X^5 + X^4 + X^2 + X + 1 .
N  * @{
N  */
N#define MS32_CRC_DEFAULT_CRC32_POLY          (0x04C11DB7U) /*!< Default CRC generating polynomial value */
N
N
N/** @defgroup CRC_Calculate_Method Calculate Method
N  * @{
N  */
N#define MS32_CRC_ACC_CALC                    (0x00000000U) /*!< Accumulate calculation */
N#define MS32_CRC_RECALC                      (0x00000001U) /*!< Recalculation */
N
N
N/** @defgroup CRC_Input_Buffer_Format Input Buffer Format
N  * @{
N  */
N#define MS32_CRC_INPUTDATA_FORMAT_UNDEFINED  (0x00000000U) /*!< Undefined input data format    */
N#define MS32_CRC_INPUTDATA_FORMAT_BYTES      (0x00000001U) /*!< Input data in byte format      */
N#define MS32_CRC_INPUTDATA_FORMAT_HALFWORDS  (0x00000002U) /*!< Input data in half-word format */
N#define MS32_CRC_INPUTDATA_FORMAT_WORDS      (0x00000003U) /*!< Input data in word format      */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/**
N  * @brief  Write a value in CRC register
N  * @param  __INSTANCE__ CRC Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_CRC_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, __VALUE__)
N
N/**
N  * @brief  Read a value in CRC register
N  * @param  __INSTANCE__ CRC Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_CRC_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup CRC_EF_Configuration CRC Configuration functions
N  * @{
N  */
N
N/**
N  * @brief  Reset the CRC calculation unit.
N  * @note   If Programmable Initial CRC value feature
N  *         is available, also set the Data Register to the value stored in the
N  *         CRC_INIT register, otherwise, reset Data Register to its default value.
N  * @rmtoll CR           RESET         MS32_CRC_ResetCRCCalculationUnit
N  * @param  CRCx CRC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CRC_ResetCRCCalculationUnit(CRC_TypeDef *CRCx) {
Xstatic __inline void MS32_CRC_ResetCRCCalculationUnit(CRC_TypeDef *CRCx) {
N  SET_BIT(CRCx->CR, CRC_CR_RESET);
X  ((CRCx->CR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Configure the reversal of the bit order of the input data
N  * @rmtoll CR           REV_IN        MS32_CRC_SetInputDataReverseMode
N  * @param  CRCx CRC Instance
N  * @param  ReverseMode This parameter can be one of the following values:
N  *         @arg @ref MS32_CRC_INDATA_REVERSE_NONE
N  *         @arg @ref MS32_CRC_INDATA_REVERSE_BYTE
N  *         @arg @ref MS32_CRC_INDATA_REVERSE_HALFWORD
N  *         @arg @ref MS32_CRC_INDATA_REVERSE_WORD
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CRC_SetInputDataReverseMode(CRC_TypeDef *CRCx, uint32_t ReverseMode) {
Xstatic __inline void MS32_CRC_SetInputDataReverseMode(CRC_TypeDef *CRCx, uint32_t ReverseMode) {
N  MODIFY_REG(CRCx->CR, CRC_CR_REV_IN, ReverseMode);
X  (((CRCx->CR)) = ((((((CRCx->CR))) & (~((0x3UL << (5U))))) | (ReverseMode))));
N}
N
N/**
N  * @brief  Return type of reversal for input data bit order
N  * @rmtoll CR           REV_IN        MS32_CRC_GetInputDataReverseMode
N  * @param  CRCx CRC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_CRC_INDATA_REVERSE_NONE
N  *         @arg @ref MS32_CRC_INDATA_REVERSE_BYTE
N  *         @arg @ref MS32_CRC_INDATA_REVERSE_HALFWORD
N  *         @arg @ref MS32_CRC_INDATA_REVERSE_WORD
N  */
N__STATIC_INLINE uint32_t MS32_CRC_GetInputDataReverseMode(CRC_TypeDef *CRCx) {
Xstatic __inline uint32_t MS32_CRC_GetInputDataReverseMode(CRC_TypeDef *CRCx) {
N  return (uint32_t)(READ_BIT(CRCx->CR, CRC_CR_REV_IN));
X  return (uint32_t)(((CRCx->CR) & ((0x3UL << (5U)))));
N}
N
N/**
N  * @brief  Configure the reversal of the bit order of the Output data
N  * @rmtoll CR           REV_OUT       MS32_CRC_SetOutputDataReverseMode
N  * @param  CRCx CRC Instance
N  * @param  ReverseMode This parameter can be one of the following values:
N  *         @arg @ref MS32_CRC_OUTDATA_REVERSE_NONE
N  *         @arg @ref MS32_CRC_OUTDATA_REVERSE_BIT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CRC_SetOutputDataReverseMode(CRC_TypeDef *CRCx, uint32_t ReverseMode) {
Xstatic __inline void MS32_CRC_SetOutputDataReverseMode(CRC_TypeDef *CRCx, uint32_t ReverseMode) {
N  MODIFY_REG(CRCx->CR, CRC_CR_REV_OUT, ReverseMode);
X  (((CRCx->CR)) = ((((((CRCx->CR))) & (~((0x1UL << (7U))))) | (ReverseMode))));
N}
N
N/**
N  * @brief  Configure the reversal of the bit order of the Output data
N  * @rmtoll CR           REV_OUT       MS32_CRC_GetOutputDataReverseMode
N  * @param  CRCx CRC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_CRC_OUTDATA_REVERSE_NONE
N  *         @arg @ref MS32_CRC_OUTDATA_REVERSE_BIT
N  */
N__STATIC_INLINE uint32_t MS32_CRC_GetOutputDataReverseMode(CRC_TypeDef *CRCx) {
Xstatic __inline uint32_t MS32_CRC_GetOutputDataReverseMode(CRC_TypeDef *CRCx) {
N  return (uint32_t)(READ_BIT(CRCx->CR, CRC_CR_REV_OUT));
X  return (uint32_t)(((CRCx->CR) & ((0x1UL << (7U)))));
N}
N
N/**
N  * @brief  Initialize the Programmable initial CRC value.
N  * @note   If the CRC size is less than 32 bits, the least significant bits
N  *         are used to write the correct value
N  * @note   MS32_CRC_DEFAULT_CRC_INITVALUE could be used as value for InitCrc parameter.
N  * @rmtoll INIT         INIT          MS32_CRC_SetInitialData
N  * @param  CRCx CRC Instance
N  * @param  InitCrc Value to be programmed in Programmable initial CRC value register
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CRC_SetInitialData(CRC_TypeDef *CRCx, uint32_t InitCrc) {
Xstatic __inline void MS32_CRC_SetInitialData(CRC_TypeDef *CRCx, uint32_t InitCrc) {
N  WRITE_REG(CRCx->INIT, InitCrc);
X  ((CRCx->INIT) = (InitCrc));
N}
N
N/**
N  * @brief  Return current Initial CRC value.
N  * @note   If the CRC size is less than 32 bits, the least significant bits
N  *         are used to read the correct value
N  * @rmtoll INIT         INIT          MS32_CRC_GetInitialData
N  * @param  CRCx CRC Instance
N  * @retval Value programmed in Programmable initial CRC value register
N  */
N__STATIC_INLINE uint32_t MS32_CRC_GetInitialData(CRC_TypeDef *CRCx) {
Xstatic __inline uint32_t MS32_CRC_GetInitialData(CRC_TypeDef *CRCx) {
N  return (uint32_t)(READ_REG(CRCx->INIT));
X  return (uint32_t)(((CRCx->INIT)));
N}
N
N
N/** @defgroup CRC_EF_Data_Management Data_Management
N  * @{
N  */
N
N/**
N  * @brief  Write given 32-bit data to the CRC calculator
N  * @rmtoll DR           DR            MS32_CRC_FeedData32
N  * @param  CRCx CRC Instance
N  * @param  InData value to be provided to CRC calculator between between Min_Data=0 and Max_Data=0xFFFFFFFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CRC_FeedData32(CRC_TypeDef *CRCx, uint32_t InData) {
Xstatic __inline void MS32_CRC_FeedData32(CRC_TypeDef *CRCx, uint32_t InData) {
N  WRITE_REG(CRCx->DR, InData);
X  ((CRCx->DR) = (InData));
N}
N
N/**
N  * @brief  Write given 16-bit data to the CRC calculator
N  * @rmtoll DR           DR            MS32_CRC_FeedData16
N  * @param  CRCx CRC Instance
N  * @param  InData 16 bit value to be provided to CRC calculator between between Min_Data=0 and Max_Data=0xFFFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CRC_FeedData16(CRC_TypeDef *CRCx, uint16_t InData) {
Xstatic __inline void MS32_CRC_FeedData16(CRC_TypeDef *CRCx, uint16_t InData) {
N  *(uint16_t __IO *)(&CRCx->DR) = (uint16_t) InData;                             /* Derogation MisraC2012 R.11.5 */
X  *(uint16_t volatile *)(&CRCx->DR) = (uint16_t) InData;                              
N}
N
N/**
N  * @brief  Write given 8-bit data to the CRC calculator
N  * @rmtoll DR           DR            MS32_CRC_FeedData8
N  * @param  CRCx CRC Instance
N  * @param  InData 8 bit value to be provided to CRC calculator between between Min_Data=0 and Max_Data=0xFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CRC_FeedData8(CRC_TypeDef *CRCx, uint8_t InData) {
Xstatic __inline void MS32_CRC_FeedData8(CRC_TypeDef *CRCx, uint8_t InData) {
N  *(uint8_t __IO *)(&CRCx->DR) = (uint8_t) InData;
X  *(uint8_t volatile *)(&CRCx->DR) = (uint8_t) InData;
N}
N
N/**
N  * @brief  Return current CRC calculation result. 32 bits value is returned.
N  * @rmtoll DR           DR            MS32_CRC_ReadData32
N  * @param  CRCx CRC Instance
N  * @retval Current CRC calculation result as stored in CRC_DR register (32 bits).
N  */
N__STATIC_INLINE uint32_t MS32_CRC_ReadData32(CRC_TypeDef *CRCx) {
Xstatic __inline uint32_t MS32_CRC_ReadData32(CRC_TypeDef *CRCx) {
N  return (uint32_t)(READ_REG(CRCx->DR));
X  return (uint32_t)(((CRCx->DR)));
N}
N
N/**
N  * @brief  Return data stored in the Independent Data(IDR) register.
N  * @note   This register can be used as a temporary storage location for one byte.
N  * @rmtoll IDR          IDR           MS32_CRC_Read_IDR
N  * @param  CRCx CRC Instance
N  * @retval Value stored in CRC_IDR register (General-purpose 8-bit data register).
N  */
N__STATIC_INLINE uint32_t MS32_CRC_Read_IDR(CRC_TypeDef *CRCx) {
Xstatic __inline uint32_t MS32_CRC_Read_IDR(CRC_TypeDef *CRCx) {
N  return (uint32_t)(READ_REG(CRCx->IDR));
X  return (uint32_t)(((CRCx->IDR)));
N}
N
N/**
N  * @brief  Store data in the Independent Data(IDR) register.
N  * @note   This register can be used as a temporary storage location for one byte.
N  * @rmtoll IDR          IDR           MS32_CRC_Write_IDR
N  * @param  CRCx CRC Instance
N  * @param  InData value to be stored in CRC_IDR register (8-bit) between Min_Data=0 and Max_Data=0xFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_CRC_Write_IDR(CRC_TypeDef *CRCx, uint32_t InData) {
Xstatic __inline void MS32_CRC_Write_IDR(CRC_TypeDef *CRCx, uint32_t InData) {
N  *((uint8_t __IO *)(&CRCx->IDR)) = (uint8_t) InData;
X  *((uint8_t volatile *)(&CRCx->IDR)) = (uint8_t) InData;
N}
N
N
N/** @defgroup CRC_EF_Init Initialization and de-initialization functions
N  * @{
N  */
NErrorStatus MS32_CRC_DeInit     (void);
Nvoid        MS32_CRC_StructInit (MS32_CRC_InitTypeDef *CrcInitStr);
NErrorStatus MS32_CRC_Init       (MS32_CRC_InitTypeDef *CrcInitStr);
N
N/** @defgroup CRC_EF_Application function
N  * @{
N  */
Nuint32_t MS32_CRC_Calculate(uint32_t CalcMethod, uint32_t InputDataFormat, uint32_t pBuffer[], uint32_t BufferLength);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_CRC_H */
N
N/******************************** END OF FILE *********************************/
L 68 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_dma.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_dma.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_DMA_H
N#define __MS32F0XX_DMA_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup DMA_MS32_Private_Variables DMA Private Variables
N  * @{
N  */
N
N/* Array used to get the DMA channel register offset versus channel index MS32_DMA_CHANNEL_x */
Nstatic const uint8_t CHANNEL_OFFSET_TAB[] = {
N  (uint8_t)(DMA1_Channel1_BASE - DMA1_BASE),
X  (uint8_t)((((0x40000000UL + 0x00020000UL) + 0x00000000UL) + 0x00000008UL) - ((0x40000000UL + 0x00020000UL) + 0x00000000UL)),
N  (uint8_t)(DMA1_Channel2_BASE - DMA1_BASE),
X  (uint8_t)((((0x40000000UL + 0x00020000UL) + 0x00000000UL) + 0x0000001CUL) - ((0x40000000UL + 0x00020000UL) + 0x00000000UL)),
N  (uint8_t)(DMA1_Channel3_BASE - DMA1_BASE),
X  (uint8_t)((((0x40000000UL + 0x00020000UL) + 0x00000000UL) + 0x00000030UL) - ((0x40000000UL + 0x00020000UL) + 0x00000000UL)),
N  (uint8_t)(DMA1_Channel4_BASE - DMA1_BASE),
X  (uint8_t)((((0x40000000UL + 0x00020000UL) + 0x00000000UL) + 0x00000044UL) - ((0x40000000UL + 0x00020000UL) + 0x00000000UL)),
N  (uint8_t)(DMA1_Channel5_BASE - DMA1_BASE),
X  (uint8_t)((((0x40000000UL + 0x00020000UL) + 0x00000000UL) + 0x00000058UL) - ((0x40000000UL + 0x00020000UL) + 0x00000000UL)),
N};
N
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup DMA_MS32_Private_Constants DMA Private Constants
N  * @{
N  */
N
N/* Define used to get CSELR register offset */
N#define DMA_CSELR_OFFSET                  (uint32_t)(DMA1_CSELR_BASE - DMA1_BASE)
N
N/* Defines used for the bit position in the register and perform offsets */
N#define DMA_POSITION_CSELR_CXS            ((Channel-1U)*4U)
N
N
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup DMA_MS32_ES_INIT DMA Exported Init structure
N  * @{
N  */
Ntypedef struct {
N  uint32_t PeriphOrM2MSrcAddress;  /*!< Specifies the peripheral base address for DMA transfer
N                                        or as Source base address in case of memory to memory transfer direction.
N                                        This parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF. */
N  uint32_t MemoryOrM2MDstAddress;  /*!< Specifies the memory base address for DMA transfer
N                                        or as Destination base address in case of memory to memory transfer direction.
N                                        This parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF. */
N  uint32_t Direction;              /*!< Specifies if the data will be transferred from memory to peripheral,
N                                        from memory to memory or from peripheral to memory.
N                                        This parameter can be a value of @ref DMA_EC_DIRECTION
N                                        This feature can be modified afterwards using unitary function @ref MS32_DMA_SetDataTransferDirection(). */
N  uint32_t Mode;                   /*!< Specifies the normal or circular operation mode.
N                                        This parameter can be a value of @ref DMA_EC_MODE
N                                        @note: The circular buffer mode cannot be used if the memory to memory
N                                               data transfer direction is configured on the selected Channel
N                                        This feature can be modified afterwards using unitary function @ref MS32_DMA_SetMode(). */
N  uint32_t PeriphOrM2MSrcIncMode;  /*!< Specifies whether the Peripheral address or Source address in case of memory to memory transfer direction
N                                        is incremented or not.
N                                        This parameter can be a value of @ref DMA_EC_PERIPH
N                                        This feature can be modified afterwards using unitary function @ref MS32_DMA_SetPeriphIncMode(). */
N  uint32_t MemoryOrM2MDstIncMode;  /*!< Specifies whether the Memory address or Destination address in case of memory to memory transfer direction
N                                        is incremented or not.
N                                        This parameter can be a value of @ref DMA_EC_MEMORY
N                                        This feature can be modified afterwards using unitary function @ref MS32_DMA_SetMemoryIncMode(). */
N  uint32_t PeriphOrM2MSrcDataSize; /*!< Specifies the Peripheral data size alignment or Source data size alignment (byte, half word, word)
N                                        in case of memory to memory transfer direction.
N                                        This parameter can be a value of @ref DMA_EC_PDATAALIGN
N                                        This feature can be modified afterwards using unitary function @ref MS32_DMA_SetPeriphSize(). */
N  uint32_t MemoryOrM2MDstDataSize; /*!< Specifies the Memory data size alignment or Destination data size alignment (byte, half word, word)
N                                        in case of memory to memory transfer direction.
N                                        This parameter can be a value of @ref DMA_EC_MDATAALIGN
N                                        This feature can be modified afterwards using unitary function @ref MS32_DMA_SetMemorySize(). */
N  uint32_t NbData;                 /*!< Specifies the number of data to transfer, in data unit.
N                                        The data unit is equal to the source buffer configuration set in PeripheralSize
N                                        or MemorySize parameters depending in the transfer direction.
N                                        This parameter must be a value between Min_Data = 0 and Max_Data = 0x0000FFFF
N                                        This feature can be modified afterwards using unitary function @ref MS32_DMA_SetDataLength(). */
N  uint32_t Priority;               /*!< Specifies the channel priority level.
N                                        This parameter can be a value of @ref DMA_EC_PRIORITY
N                                        This feature can be modified afterwards using unitary function @ref MS32_DMA_SetChannelPriorityLevel(). */
N} MS32_DMA_InitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup MS32_DMA_Exported_Constants DMA Exported Constants
N  * @{
N  */
N
N/** @defgroup DMA_EC_CLEAR_FLAG Clear Flags Defines
N  * @brief    Flags defines which can be used with MS32_DMA_WriteReg function
N  * @{
N  */
N#define MS32_DMA_IFCR_CGIF1                 DMA_IFCR_CGIF1        /*!< Channel 1 global flag            */
N#define MS32_DMA_IFCR_CTCIF1                DMA_IFCR_CTCIF1       /*!< Channel 1 transfer complete flag */
N#define MS32_DMA_IFCR_CHTIF1                DMA_IFCR_CHTIF1       /*!< Channel 1 half transfer flag     */
N#define MS32_DMA_IFCR_CTEIF1                DMA_IFCR_CTEIF1       /*!< Channel 1 transfer error flag    */
N#define MS32_DMA_IFCR_CGIF2                 DMA_IFCR_CGIF2        /*!< Channel 2 global flag            */
N#define MS32_DMA_IFCR_CTCIF2                DMA_IFCR_CTCIF2       /*!< Channel 2 transfer complete flag */
N#define MS32_DMA_IFCR_CHTIF2                DMA_IFCR_CHTIF2       /*!< Channel 2 half transfer flag     */
N#define MS32_DMA_IFCR_CTEIF2                DMA_IFCR_CTEIF2       /*!< Channel 2 transfer error flag    */
N#define MS32_DMA_IFCR_CGIF3                 DMA_IFCR_CGIF3        /*!< Channel 3 global flag            */
N#define MS32_DMA_IFCR_CTCIF3                DMA_IFCR_CTCIF3       /*!< Channel 3 transfer complete flag */
N#define MS32_DMA_IFCR_CHTIF3                DMA_IFCR_CHTIF3       /*!< Channel 3 half transfer flag     */
N#define MS32_DMA_IFCR_CTEIF3                DMA_IFCR_CTEIF3       /*!< Channel 3 transfer error flag    */
N#define MS32_DMA_IFCR_CGIF4                 DMA_IFCR_CGIF4        /*!< Channel 4 global flag            */
N#define MS32_DMA_IFCR_CTCIF4                DMA_IFCR_CTCIF4       /*!< Channel 4 transfer complete flag */
N#define MS32_DMA_IFCR_CHTIF4                DMA_IFCR_CHTIF4       /*!< Channel 4 half transfer flag     */
N#define MS32_DMA_IFCR_CTEIF4                DMA_IFCR_CTEIF4       /*!< Channel 4 transfer error flag    */
N#define MS32_DMA_IFCR_CGIF5                 DMA_IFCR_CGIF5        /*!< Channel 5 global flag            */
N#define MS32_DMA_IFCR_CTCIF5                DMA_IFCR_CTCIF5       /*!< Channel 5 transfer complete flag */
N#define MS32_DMA_IFCR_CHTIF5                DMA_IFCR_CHTIF5       /*!< Channel 5 half transfer flag     */
N#define MS32_DMA_IFCR_CTEIF5                DMA_IFCR_CTEIF5       /*!< Channel 5 transfer error flag    */
N#define MS32_DMA_IFCR_CALL                  (DMA_IFCR_CGIF1 | DMA_IFCR_CTCIF1 | DMA_IFCR_CHTIF1 | DMA_IFCR_CTEIF1 |\
N                                             DMA_IFCR_CGIF2 | DMA_IFCR_CTCIF2 | DMA_IFCR_CHTIF2 | DMA_IFCR_CTEIF2 |\
N                                             DMA_IFCR_CGIF3 | DMA_IFCR_CTCIF3 | DMA_IFCR_CHTIF3 | DMA_IFCR_CTEIF3 |\
N                                             DMA_IFCR_CGIF4 | DMA_IFCR_CTCIF4 | DMA_IFCR_CHTIF4 | DMA_IFCR_CTEIF4 |\
N                                             DMA_IFCR_CGIF5 | DMA_IFCR_CTCIF5 | DMA_IFCR_CHTIF5 | DMA_IFCR_CTEIF5)
X#define MS32_DMA_IFCR_CALL                  (DMA_IFCR_CGIF1 | DMA_IFCR_CTCIF1 | DMA_IFCR_CHTIF1 | DMA_IFCR_CTEIF1 |                                             DMA_IFCR_CGIF2 | DMA_IFCR_CTCIF2 | DMA_IFCR_CHTIF2 | DMA_IFCR_CTEIF2 |                                             DMA_IFCR_CGIF3 | DMA_IFCR_CTCIF3 | DMA_IFCR_CHTIF3 | DMA_IFCR_CTEIF3 |                                             DMA_IFCR_CGIF4 | DMA_IFCR_CTCIF4 | DMA_IFCR_CHTIF4 | DMA_IFCR_CTEIF4 |                                             DMA_IFCR_CGIF5 | DMA_IFCR_CTCIF5 | DMA_IFCR_CHTIF5 | DMA_IFCR_CTEIF5)
N
N
N/** @defgroup DMA_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with MS32_DMA_ReadReg function
N  * @{
N  */
N#define MS32_DMA_ISR_GIF1                   DMA_ISR_GIF1          /*!< Channel 1 global flag            */
N#define MS32_DMA_ISR_TCIF1                  DMA_ISR_TCIF1         /*!< Channel 1 transfer complete flag */
N#define MS32_DMA_ISR_HTIF1                  DMA_ISR_HTIF1         /*!< Channel 1 half transfer flag     */
N#define MS32_DMA_ISR_TEIF1                  DMA_ISR_TEIF1         /*!< Channel 1 transfer error flag    */
N#define MS32_DMA_ISR_GIF2                   DMA_ISR_GIF2          /*!< Channel 2 global flag            */
N#define MS32_DMA_ISR_TCIF2                  DMA_ISR_TCIF2         /*!< Channel 2 transfer complete flag */
N#define MS32_DMA_ISR_HTIF2                  DMA_ISR_HTIF2         /*!< Channel 2 half transfer flag     */
N#define MS32_DMA_ISR_TEIF2                  DMA_ISR_TEIF2         /*!< Channel 2 transfer error flag    */
N#define MS32_DMA_ISR_GIF3                   DMA_ISR_GIF3          /*!< Channel 3 global flag            */
N#define MS32_DMA_ISR_TCIF3                  DMA_ISR_TCIF3         /*!< Channel 3 transfer complete flag */
N#define MS32_DMA_ISR_HTIF3                  DMA_ISR_HTIF3         /*!< Channel 3 half transfer flag     */
N#define MS32_DMA_ISR_TEIF3                  DMA_ISR_TEIF3         /*!< Channel 3 transfer error flag    */
N#define MS32_DMA_ISR_GIF4                   DMA_ISR_GIF4          /*!< Channel 4 global flag            */
N#define MS32_DMA_ISR_TCIF4                  DMA_ISR_TCIF4         /*!< Channel 4 transfer complete flag */
N#define MS32_DMA_ISR_HTIF4                  DMA_ISR_HTIF4         /*!< Channel 4 half transfer flag     */
N#define MS32_DMA_ISR_TEIF4                  DMA_ISR_TEIF4         /*!< Channel 4 transfer error flag    */
N#define MS32_DMA_ISR_GIF5                   DMA_ISR_GIF5          /*!< Channel 5 global flag            */
N#define MS32_DMA_ISR_TCIF5                  DMA_ISR_TCIF5         /*!< Channel 5 transfer complete flag */
N#define MS32_DMA_ISR_HTIF5                  DMA_ISR_HTIF5         /*!< Channel 5 half transfer flag     */
N#define MS32_DMA_ISR_TEIF5                  DMA_ISR_TEIF5         /*!< Channel 5 transfer error flag    */
N
N
N/** @defgroup DMA_EC_IT IT Defines
N  * @brief    IT defines which can be used with MS32_DMA_ReadReg and  MS32_DMA_WriteReg functions
N  * @{
N  */
N#define MS32_DMA_CCR_TCIE                   DMA_CCR_TCIE          /*!< Transfer complete interrupt */
N#define MS32_DMA_CCR_HTIE                   DMA_CCR_HTIE          /*!< Half Transfer interrupt     */
N#define MS32_DMA_CCR_TEIE                   DMA_CCR_TEIE          /*!< Transfer error interrupt    */
N#define MS32_DMA_CCR_ALLIE                  (DMA_CCR_TCIE | DMA_CCR_HTIE | DMA_CCR_TEIE)
N
N
N/** @defgroup DMA_EC_CHANNEL CHANNEL
N  * @{
N  */
N#define MS32_DMA_CHANNEL_1                  0x00000001U /*!< DMA Channel 1 */
N#define MS32_DMA_CHANNEL_2                  0x00000002U /*!< DMA Channel 2 */
N#define MS32_DMA_CHANNEL_3                  0x00000003U /*!< DMA Channel 3 */
N#define MS32_DMA_CHANNEL_4                  0x00000004U /*!< DMA Channel 4 */
N#define MS32_DMA_CHANNEL_5                  0x00000005U /*!< DMA Channel 5 */
N#define MS32_DMA_CHANNEL_ALL                0xFFFF0000U /*!< DMA Channel all (used only for function @ref MS32_DMA_DeInit(). */
N
N
N/** @defgroup DMA_EC_DIRECTION Transfer Direction
N  * @{
N  */
N#define MS32_DMA_DIRECTION_PERIPH_TO_MEMORY 0x00000000U             /*!< Peripheral to memory direction */
N#define MS32_DMA_DIRECTION_MEMORY_TO_PERIPH DMA_CCR_DIR             /*!< Memory to peripheral direction */
N#define MS32_DMA_DIRECTION_MEMORY_TO_MEMORY DMA_CCR_MEM2MEM         /*!< Memory to memory direction     */
N
N
N/** @defgroup DMA_EC_MODE Transfer mode
N  * @{
N  */
N#define MS32_DMA_MODE_NORMAL                0x00000000U             /*!< Normal Mode                  */
N#define MS32_DMA_MODE_CIRCULAR              DMA_CCR_CIRC            /*!< Circular Mode                */
N
N
N/** @defgroup DMA_EC_PERIPH Peripheral increment mode
N  * @{
N  */
N#define MS32_DMA_PERIPH_INCREMENT           DMA_CCR_PINC            /*!< Peripheral increment mode Enable */
N#define MS32_DMA_PERIPH_NOINCREMENT         0x00000000U             /*!< Peripheral increment mode Disable */
N
N
N/** @defgroup DMA_EC_MEMORY Memory increment mode
N  * @{
N  */
N#define MS32_DMA_MEMORY_INCREMENT           DMA_CCR_MINC            /*!< Memory increment mode Enable  */
N#define MS32_DMA_MEMORY_NOINCREMENT         0x00000000U             /*!< Memory increment mode Disable */
N
N
N/** @defgroup DMA_EC_PDATAALIGN Peripheral data alignment
N  * @{
N  */
N#define MS32_DMA_PDATAALIGN_BYTE            0x00000000U             /*!< Peripheral data alignment : Byte     */
N#define MS32_DMA_PDATAALIGN_HALFWORD        DMA_CCR_PSIZE_0         /*!< Peripheral data alignment : HalfWord */
N#define MS32_DMA_PDATAALIGN_WORD            DMA_CCR_PSIZE_1         /*!< Peripheral data alignment : Word     */
N
N
N/** @defgroup DMA_EC_MDATAALIGN Memory data alignment
N  * @{
N  */
N#define MS32_DMA_MDATAALIGN_BYTE            0x00000000U             /*!< Memory data alignment : Byte     */
N#define MS32_DMA_MDATAALIGN_HALFWORD        DMA_CCR_MSIZE_0         /*!< Memory data alignment : HalfWord */
N#define MS32_DMA_MDATAALIGN_WORD            DMA_CCR_MSIZE_1         /*!< Memory data alignment : Word     */
N
N
N/** @defgroup DMA_EC_PRIORITY Transfer Priority level
N  * @{
N  */
N#define MS32_DMA_PRIORITY_LOW               0x00000000U             /*!< Priority level : Low       */
N#define MS32_DMA_PRIORITY_MEDIUM            DMA_CCR_PL_0            /*!< Priority level : Medium    */
N#define MS32_DMA_PRIORITY_HIGH              DMA_CCR_PL_1            /*!< Priority level : High      */
N#define MS32_DMA_PRIORITY_VERYHIGH          DMA_CCR_PL              /*!< Priority level : Very_High */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup DMA_EM_WRITE_READ Common Write and read registers macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in DMA register
N  * @param  __INSTANCE__ DMA Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_DMA_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in DMA register
N  * @param  __INSTANCE__ DMA Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_DMA_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N
N
N/** @defgroup DMA_EM_CONVERT_DMAxCHANNELy Convert DMAxChannely
N  * @{
N  */
N
N/**
N  * @brief  Convert DMAx_Channely into DMAx
N  * @param  __CHANNEL_INSTANCE__ DMAx_Channely
N  * @retval DMAx
N  */
N#define __MS32_DMA_GET_INSTANCE(__CHANNEL_INSTANCE__)  (DMA1)
N
N/**
N  * @brief  Convert DMAx_Channely into MS32_DMA_CHANNEL_y
N  * @param  __CHANNEL_INSTANCE__ DMAx_Channely
N  * @retval MS32_DMA_CHANNEL_y
N  */
N#define __MS32_DMA_GET_CHANNEL(__CHANNEL_INSTANCE__)   \
N(((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel1)) ? MS32_DMA_CHANNEL_1 : \
N ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel2)) ? MS32_DMA_CHANNEL_2 : \
N ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel3)) ? MS32_DMA_CHANNEL_3 : \
N ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel4)) ? MS32_DMA_CHANNEL_4 : \
N MS32_DMA_CHANNEL_5)
X#define __MS32_DMA_GET_CHANNEL(__CHANNEL_INSTANCE__)   (((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel1)) ? MS32_DMA_CHANNEL_1 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel2)) ? MS32_DMA_CHANNEL_2 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel3)) ? MS32_DMA_CHANNEL_3 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel4)) ? MS32_DMA_CHANNEL_4 :  MS32_DMA_CHANNEL_5)
N
N
N/**
N  * @brief  Convert DMA Instance DMAx and MS32_DMA_CHANNEL_y into DMAx_Channely
N  * @param  __DMA_INSTANCE__ DMAx
N  * @param  __CHANNEL__ MS32_DMA_CHANNEL_y
N  * @retval DMAx_Channely
N  */
N#define __MS32_DMA_GET_CHANNEL_INSTANCE(__DMA_INSTANCE__, __CHANNEL__)   \
N((((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)MS32_DMA_CHANNEL_1))) ? DMA1_Channel1 : \
N (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)MS32_DMA_CHANNEL_2))) ? DMA1_Channel2 : \
N (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)MS32_DMA_CHANNEL_3))) ? DMA1_Channel3 : \
N (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)MS32_DMA_CHANNEL_4))) ? DMA1_Channel4 : \
N DMA1_Channel5)
X#define __MS32_DMA_GET_CHANNEL_INSTANCE(__DMA_INSTANCE__, __CHANNEL__)   ((((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)MS32_DMA_CHANNEL_1))) ? DMA1_Channel1 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)MS32_DMA_CHANNEL_2))) ? DMA1_Channel2 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)MS32_DMA_CHANNEL_3))) ? DMA1_Channel3 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)MS32_DMA_CHANNEL_4))) ? DMA1_Channel4 :  DMA1_Channel5)
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup DMA_EF_Configuration Configuration
N  * @{
N  */
N
N/**
N  * @brief  Enable DMA channel.
N  * @rmtoll CCR          EN            MS32_DMA_EnableChannel
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_EnableChannel(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline void MS32_DMA_EnableChannel(DMA_TypeDef *DMAx, uint32_t Channel) {
N  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable DMA channel.
N  * @rmtoll CCR          EN            MS32_DMA_DisableChannel
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_DisableChannel(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline void MS32_DMA_DisableChannel(DMA_TypeDef *DMAx, uint32_t Channel) {
N  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if DMA channel is enabled or disabled.
N  * @rmtoll CCR          EN            MS32_DMA_IsEnabledChannel
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsEnabledChannel(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_IsEnabledChannel(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_EN) == (DMA_CCR_EN));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Configure all parameters link to DMA transfer.
N  * @rmtoll CCR          DIR           MS32_DMA_ConfigTransfer\n
N  *         CCR          MEM2MEM       MS32_DMA_ConfigTransfer\n
N  *         CCR          CIRC          MS32_DMA_ConfigTransfer\n
N  *         CCR          PINC          MS32_DMA_ConfigTransfer\n
N  *         CCR          MINC          MS32_DMA_ConfigTransfer\n
N  *         CCR          PSIZE         MS32_DMA_ConfigTransfer\n
N  *         CCR          MSIZE         MS32_DMA_ConfigTransfer\n
N  *         CCR          PL            MS32_DMA_ConfigTransfer
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @param  Configuration This parameter must be a combination of all the following values:
N  *         @arg @ref MS32_DMA_DIRECTION_PERIPH_TO_MEMORY or @ref MS32_DMA_DIRECTION_MEMORY_TO_PERIPH or @ref MS32_DMA_DIRECTION_MEMORY_TO_MEMORY
N  *         @arg @ref MS32_DMA_MODE_NORMAL or @ref MS32_DMA_MODE_CIRCULAR
N  *         @arg @ref MS32_DMA_PERIPH_INCREMENT or @ref MS32_DMA_PERIPH_NOINCREMENT
N  *         @arg @ref MS32_DMA_MEMORY_INCREMENT or @ref MS32_DMA_MEMORY_NOINCREMENT
N  *         @arg @ref MS32_DMA_PDATAALIGN_BYTE or @ref MS32_DMA_PDATAALIGN_HALFWORD or @ref MS32_DMA_PDATAALIGN_WORD
N  *         @arg @ref MS32_DMA_MDATAALIGN_BYTE or @ref MS32_DMA_MDATAALIGN_HALFWORD or @ref MS32_DMA_MDATAALIGN_WORD
N  *         @arg @ref MS32_DMA_PRIORITY_LOW or @ref MS32_DMA_PRIORITY_MEDIUM or @ref MS32_DMA_PRIORITY_HIGH or @ref MS32_DMA_PRIORITY_VERYHIGH
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ConfigTransfer(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Configuration) {
Xstatic __inline void MS32_DMA_ConfigTransfer(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Configuration) {
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N             DMA_CCR_DIR | DMA_CCR_MEM2MEM | DMA_CCR_CIRC | DMA_CCR_PINC | DMA_CCR_MINC | DMA_CCR_PSIZE | DMA_CCR_MSIZE | DMA_CCR_PL,
N             Configuration);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x1UL << (4U)) | (0x1UL << (14U)) | (0x1UL << (5U)) | (0x1UL << (6U)) | (0x1UL << (7U)) | (0x3UL << (8U)) | (0x3UL << (10U)) | (0x3UL << (12U))))) | (Configuration))));
N}
N
N/**
N  * @brief  Set Data transfer direction (read from peripheral or from memory).
N  * @rmtoll CCR          DIR           MS32_DMA_SetDataTransferDirection\n
N  *         CCR          MEM2MEM       MS32_DMA_SetDataTransferDirection
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @param  Direction This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_DIRECTION_PERIPH_TO_MEMORY
N  *         @arg @ref MS32_DMA_DIRECTION_MEMORY_TO_PERIPH
N  *         @arg @ref MS32_DMA_DIRECTION_MEMORY_TO_MEMORY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_SetDataTransferDirection(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Direction) {
Xstatic __inline void MS32_DMA_SetDataTransferDirection(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Direction) {
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N             DMA_CCR_DIR | DMA_CCR_MEM2MEM, Direction);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x1UL << (4U)) | (0x1UL << (14U))))) | (Direction))));
N}
N
N/**
N  * @brief  Get Data transfer direction (read from peripheral or from memory).
N  * @rmtoll CCR          DIR           MS32_DMA_GetDataTransferDirection\n
N  *         CCR          MEM2MEM       MS32_DMA_GetDataTransferDirection
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_DMA_DIRECTION_PERIPH_TO_MEMORY
N  *         @arg @ref MS32_DMA_DIRECTION_MEMORY_TO_PERIPH
N  *         @arg @ref MS32_DMA_DIRECTION_MEMORY_TO_MEMORY
N  */
N__STATIC_INLINE uint32_t MS32_DMA_GetDataTransferDirection(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_GetDataTransferDirection(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_DIR | DMA_CCR_MEM2MEM));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (4U)) | (0x1UL << (14U)))));
N}
N
N/**
N  * @brief  Set DMA mode circular or normal.
N  * @note The circular buffer mode cannot be used if the memory-to-memory
N  * data transfer is configured on the selected Channel.
N  * @rmtoll CCR          CIRC          MS32_DMA_SetMode
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @param  Mode This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_MODE_NORMAL
N  *         @arg @ref MS32_DMA_MODE_CIRCULAR
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_SetMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Mode) {
Xstatic __inline void MS32_DMA_SetMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Mode) {
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_CIRC,
N             Mode);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x1UL << (5U))))) | (Mode))));
N}
N
N/**
N  * @brief  Get DMA mode circular or normal.
N  * @rmtoll CCR          CIRC          MS32_DMA_GetMode
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_DMA_MODE_NORMAL
N  *         @arg @ref MS32_DMA_MODE_CIRCULAR
N  */
N__STATIC_INLINE uint32_t MS32_DMA_GetMode(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_GetMode(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_CIRC));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (5U)))));
N}
N
N/**
N  * @brief  Set Peripheral increment mode.
N  * @rmtoll CCR          PINC          MS32_DMA_SetPeriphIncMode
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @param  PeriphOrM2MSrcIncMode This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_PERIPH_INCREMENT
N  *         @arg @ref MS32_DMA_PERIPH_NOINCREMENT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_SetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcIncMode) {
Xstatic __inline void MS32_DMA_SetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcIncMode) {
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PINC,
N             PeriphOrM2MSrcIncMode);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x1UL << (6U))))) | (PeriphOrM2MSrcIncMode))));
N}
N
N/**
N  * @brief  Get Peripheral increment mode.
N  * @rmtoll CCR          PINC          MS32_DMA_GetPeriphIncMode
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_DMA_PERIPH_INCREMENT
N  *         @arg @ref MS32_DMA_PERIPH_NOINCREMENT
N  */
N__STATIC_INLINE uint32_t MS32_DMA_GetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_GetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_PINC));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (6U)))));
N}
N
N/**
N  * @brief  Set Memory increment mode.
N  * @rmtoll CCR          MINC          MS32_DMA_SetMemoryIncMode
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @param  MemoryOrM2MDstIncMode This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_MEMORY_INCREMENT
N  *         @arg @ref MS32_DMA_MEMORY_NOINCREMENT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_SetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstIncMode) {
Xstatic __inline void MS32_DMA_SetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstIncMode) {
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MINC,
N             MemoryOrM2MDstIncMode);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x1UL << (7U))))) | (MemoryOrM2MDstIncMode))));
N}
N
N/**
N  * @brief  Get Memory increment mode.
N  * @rmtoll CCR          MINC          MS32_DMA_GetMemoryIncMode
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_DMA_MEMORY_INCREMENT
N  *         @arg @ref MS32_DMA_MEMORY_NOINCREMENT
N  */
N__STATIC_INLINE uint32_t MS32_DMA_GetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_GetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_MINC));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (7U)))));
N}
N
N/**
N  * @brief  Set Peripheral size.
N  * @rmtoll CCR          PSIZE         MS32_DMA_SetPeriphSize
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @param  PeriphOrM2MSrcDataSize This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_PDATAALIGN_BYTE
N  *         @arg @ref MS32_DMA_PDATAALIGN_HALFWORD
N  *         @arg @ref MS32_DMA_PDATAALIGN_WORD
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_SetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcDataSize) {
Xstatic __inline void MS32_DMA_SetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcDataSize) {
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PSIZE,
N             PeriphOrM2MSrcDataSize);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x3UL << (8U))))) | (PeriphOrM2MSrcDataSize))));
N}
N
N/**
N  * @brief  Get Peripheral size.
N  * @rmtoll CCR          PSIZE         MS32_DMA_GetPeriphSize
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_DMA_PDATAALIGN_BYTE
N  *         @arg @ref MS32_DMA_PDATAALIGN_HALFWORD
N  *         @arg @ref MS32_DMA_PDATAALIGN_WORD
N  */
N__STATIC_INLINE uint32_t MS32_DMA_GetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_GetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_PSIZE));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x3UL << (8U)))));
N}
N
N/**
N  * @brief  Set Memory size.
N  * @rmtoll CCR          MSIZE         MS32_DMA_SetMemorySize
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @param  MemoryOrM2MDstDataSize This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_MDATAALIGN_BYTE
N  *         @arg @ref MS32_DMA_MDATAALIGN_HALFWORD
N  *         @arg @ref MS32_DMA_MDATAALIGN_WORD
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_SetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstDataSize) {
Xstatic __inline void MS32_DMA_SetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstDataSize) {
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MSIZE,
N             MemoryOrM2MDstDataSize);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x3UL << (10U))))) | (MemoryOrM2MDstDataSize))));
N}
N
N/**
N  * @brief  Get Memory size.
N  * @rmtoll CCR          MSIZE         MS32_DMA_GetMemorySize
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_DMA_MDATAALIGN_BYTE
N  *         @arg @ref MS32_DMA_MDATAALIGN_HALFWORD
N  *         @arg @ref MS32_DMA_MDATAALIGN_WORD
N  */
N__STATIC_INLINE uint32_t MS32_DMA_GetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_GetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_MSIZE));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x3UL << (10U)))));
N}
N
N/**
N  * @brief  Set Channel priority level.
N  * @rmtoll CCR          PL            MS32_DMA_SetChannelPriorityLevel
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @param  Priority This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_PRIORITY_LOW
N  *         @arg @ref MS32_DMA_PRIORITY_MEDIUM
N  *         @arg @ref MS32_DMA_PRIORITY_HIGH
N  *         @arg @ref MS32_DMA_PRIORITY_VERYHIGH
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_SetChannelPriorityLevel(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Priority) {
Xstatic __inline void MS32_DMA_SetChannelPriorityLevel(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Priority) {
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PL,
N             Priority);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x3UL << (12U))))) | (Priority))));
N}
N
N/**
N  * @brief  Get Channel priority level.
N  * @rmtoll CCR          PL            MS32_DMA_GetChannelPriorityLevel
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_DMA_PRIORITY_LOW
N  *         @arg @ref MS32_DMA_PRIORITY_MEDIUM
N  *         @arg @ref MS32_DMA_PRIORITY_HIGH
N  *         @arg @ref MS32_DMA_PRIORITY_VERYHIGH
N  */
N__STATIC_INLINE uint32_t MS32_DMA_GetChannelPriorityLevel(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_GetChannelPriorityLevel(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_PL));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x3UL << (12U)))));
N}
N
N/**
N  * @brief  Set Number of data to transfer.
N  * @note   This action has no effect if
N  *         channel is enabled.
N  * @rmtoll CNDTR        NDT           MS32_DMA_SetDataLength
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @param  NbData Between Min_Data = 0 and Max_Data = 0x0000FFFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_SetDataLength(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t NbData) {
Xstatic __inline void MS32_DMA_SetDataLength(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t NbData) {
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
N             DMA_CNDTR_NDT, NbData);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR))) & (~((0xFFFFUL << (0U))))) | (NbData))));
N}
N
N/**
N  * @brief  Get Number of data to transfer.
N  * @note   Once the channel is enabled, the return value indicate the
N  *         remaining bytes to be transmitted.
N  * @rmtoll CNDTR        NDT           MS32_DMA_GetDataLength
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  */
N__STATIC_INLINE uint32_t MS32_DMA_GetDataLength(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_GetDataLength(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
N                   DMA_CNDTR_NDT));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR) & ((0xFFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Configure the Source and Destination addresses.
N  * @note   This API must not be called when the DMA channel is enabled.
N  * @note   Each IP using DMA provides an API to get directly the register adress (MS32_PPP_DMA_GetRegAddr).
N  * @rmtoll CPAR         PA            MS32_DMA_ConfigAddresses\n
N  *         CMAR         MA            MS32_DMA_ConfigAddresses
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @param  SrcAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  * @param  DstAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  * @param  Direction This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_DIRECTION_PERIPH_TO_MEMORY
N  *         @arg @ref MS32_DMA_DIRECTION_MEMORY_TO_PERIPH
N  *         @arg @ref MS32_DMA_DIRECTION_MEMORY_TO_MEMORY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ConfigAddresses(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t SrcAddress,
Xstatic __inline void MS32_DMA_ConfigAddresses(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t SrcAddress,
N                                            uint32_t DstAddress, uint32_t Direction) {
N  /* Direction Memory to Periph */
N  if (Direction == MS32_DMA_DIRECTION_MEMORY_TO_PERIPH) {
X  if (Direction == (0x1UL << (4U))) {
N    WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, SrcAddress);
X    ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR) = (SrcAddress));
N    WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, DstAddress);
X    ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR) = (DstAddress));
N  } else {
N  /* Direction Periph to Memory and Memory to Memory */
N    WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, SrcAddress);
X    ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR) = (SrcAddress));
N    WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, DstAddress);
X    ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR) = (DstAddress));
N  }
N}
N
N/**
N  * @brief  Set the Memory address.
N  * @note   Interface used for direction MS32_DMA_DIRECTION_PERIPH_TO_MEMORY or MS32_DMA_DIRECTION_MEMORY_TO_PERIPH only.
N  * @note   This API must not be called when the DMA channel is enabled.
N  * @rmtoll CMAR         MA            MS32_DMA_SetMemoryAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @param  MemoryAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_SetMemoryAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryAddress) {
Xstatic __inline void MS32_DMA_SetMemoryAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryAddress) {
N  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, MemoryAddress);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR) = (MemoryAddress));
N}
N
N/**
N  * @brief  Set the Peripheral address.
N  * @note   Interface used for direction MS32_DMA_DIRECTION_PERIPH_TO_MEMORY or MS32_DMA_DIRECTION_MEMORY_TO_PERIPH only.
N  * @note   This API must not be called when the DMA channel is enabled.
N  * @rmtoll CPAR         PA            MS32_DMA_SetPeriphAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @param  PeriphAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_SetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphAddress) {
Xstatic __inline void MS32_DMA_SetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphAddress) {
N  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, PeriphAddress);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR) = (PeriphAddress));
N}
N
N/**
N  * @brief  Get Memory address.
N  * @note   Interface used for direction MS32_DMA_DIRECTION_PERIPH_TO_MEMORY or MS32_DMA_DIRECTION_MEMORY_TO_PERIPH only.
N  * @rmtoll CMAR         MA            MS32_DMA_GetMemoryAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  */
N__STATIC_INLINE uint32_t MS32_DMA_GetMemoryAddress(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_GetMemoryAddress(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR)));
N}
N
N/**
N  * @brief  Get Peripheral address.
N  * @note   Interface used for direction MS32_DMA_DIRECTION_PERIPH_TO_MEMORY or MS32_DMA_DIRECTION_MEMORY_TO_PERIPH only.
N  * @rmtoll CPAR         PA            MS32_DMA_GetPeriphAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  */
N__STATIC_INLINE uint32_t MS32_DMA_GetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_GetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR)));
N}
N
N/**
N  * @brief  Set the Memory to Memory Source address.
N  * @note   Interface used for direction MS32_DMA_DIRECTION_MEMORY_TO_MEMORY only.
N  * @note   This API must not be called when the DMA channel is enabled.
N  * @rmtoll CPAR         PA            MS32_DMA_SetM2MSrcAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @param  MemoryAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_SetM2MSrcAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryAddress) {
Xstatic __inline void MS32_DMA_SetM2MSrcAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryAddress) {
N  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, MemoryAddress);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR) = (MemoryAddress));
N}
N
N/**
N  * @brief  Set the Memory to Memory Destination address.
N  * @note   Interface used for direction MS32_DMA_DIRECTION_MEMORY_TO_MEMORY only.
N  * @note   This API must not be called when the DMA channel is enabled.
N  * @rmtoll CMAR         MA            MS32_DMA_SetM2MDstAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @param  MemoryAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_SetM2MDstAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryAddress) {
Xstatic __inline void MS32_DMA_SetM2MDstAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryAddress) {
N  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, MemoryAddress);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR) = (MemoryAddress));
N}
N
N/**
N  * @brief  Get the Memory to Memory Source address.
N  * @note   Interface used for direction MS32_DMA_DIRECTION_MEMORY_TO_MEMORY only.
N  * @rmtoll CPAR         PA            MS32_DMA_GetM2MSrcAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  */
N__STATIC_INLINE uint32_t MS32_DMA_GetM2MSrcAddress(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_GetM2MSrcAddress(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR)));
N}
N
N/**
N  * @brief  Get the Memory to Memory Destination address.
N  * @note   Interface used for direction MS32_DMA_DIRECTION_MEMORY_TO_MEMORY only.
N  * @rmtoll CMAR         MA            MS32_DMA_GetM2MDstAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  */
N__STATIC_INLINE uint32_t MS32_DMA_GetM2MDstAddress(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_GetM2MDstAddress(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR)));
N}
N
N
N/** @defgroup DMA_EF_FLAG_Management FLAG_Management
N  * @{
N  */
N
N/**
N  * @brief  Get Channel 1 global interrupt flag.
N  * @rmtoll ISR          GIF1          MS32_DMA_IsActiveFlag_GI1
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_GI1(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_GI1(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_GIF1) == (DMA_ISR_GIF1));
X  return (((DMAx->ISR) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Get Channel 2 global interrupt flag.
N  * @rmtoll ISR          GIF2          MS32_DMA_IsActiveFlag_GI2
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_GI2(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_GI2(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_GIF2) == (DMA_ISR_GIF2));
X  return (((DMAx->ISR) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Get Channel 3 global interrupt flag.
N  * @rmtoll ISR          GIF3          MS32_DMA_IsActiveFlag_GI3
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_GI3(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_GI3(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_GIF3) == (DMA_ISR_GIF3));
X  return (((DMAx->ISR) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Get Channel 4 global interrupt flag.
N  * @rmtoll ISR          GIF4          MS32_DMA_IsActiveFlag_GI4
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_GI4(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_GI4(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_GIF4) == (DMA_ISR_GIF4));
X  return (((DMAx->ISR) & ((0x1UL << (12U)))) == ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Get Channel 5 global interrupt flag.
N  * @rmtoll ISR          GIF5          MS32_DMA_IsActiveFlag_GI5
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_GI5(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_GI5(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_GIF5) == (DMA_ISR_GIF5));
X  return (((DMAx->ISR) & ((0x1UL << (16U)))) == ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Get Channel 1 transfer complete flag.
N  * @rmtoll ISR          TCIF1         MS32_DMA_IsActiveFlag_TC1
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_TC1(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_TC1(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF1) == (DMA_ISR_TCIF1));
X  return (((DMAx->ISR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Get Channel 2 transfer complete flag.
N  * @rmtoll ISR          TCIF2         MS32_DMA_IsActiveFlag_TC2
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_TC2(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_TC2(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF2) == (DMA_ISR_TCIF2));
X  return (((DMAx->ISR) & ((0x1UL << (5U)))) == ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Get Channel 3 transfer complete flag.
N  * @rmtoll ISR          TCIF3         MS32_DMA_IsActiveFlag_TC3
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_TC3(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_TC3(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF3) == (DMA_ISR_TCIF3));
X  return (((DMAx->ISR) & ((0x1UL << (9U)))) == ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Get Channel 4 transfer complete flag.
N  * @rmtoll ISR          TCIF4         MS32_DMA_IsActiveFlag_TC4
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_TC4(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_TC4(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF4) == (DMA_ISR_TCIF4));
X  return (((DMAx->ISR) & ((0x1UL << (13U)))) == ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Get Channel 5 transfer complete flag.
N  * @rmtoll ISR          TCIF5         MS32_DMA_IsActiveFlag_TC5
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_TC5(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_TC5(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF5) == (DMA_ISR_TCIF5));
X  return (((DMAx->ISR) & ((0x1UL << (17U)))) == ((0x1UL << (17U))));
N}
N
N/**
N  * @brief  Get Channel 1 half transfer flag.
N  * @rmtoll ISR          HTIF1         MS32_DMA_IsActiveFlag_HT1
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_HT1(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_HT1(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF1) == (DMA_ISR_HTIF1));
X  return (((DMAx->ISR) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Get Channel 2 half transfer flag.
N  * @rmtoll ISR          HTIF2         MS32_DMA_IsActiveFlag_HT2
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_HT2(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_HT2(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF2) == (DMA_ISR_HTIF2));
X  return (((DMAx->ISR) & ((0x1UL << (6U)))) == ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Get Channel 3 half transfer flag.
N  * @rmtoll ISR          HTIF3         MS32_DMA_IsActiveFlag_HT3
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_HT3(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_HT3(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF3) == (DMA_ISR_HTIF3));
X  return (((DMAx->ISR) & ((0x1UL << (10U)))) == ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Get Channel 4 half transfer flag.
N  * @rmtoll ISR          HTIF4         MS32_DMA_IsActiveFlag_HT4
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_HT4(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_HT4(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF4) == (DMA_ISR_HTIF4));
X  return (((DMAx->ISR) & ((0x1UL << (14U)))) == ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Get Channel 5 half transfer flag.
N  * @rmtoll ISR          HTIF5         MS32_DMA_IsActiveFlag_HT5
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_HT5(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_HT5(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF5) == (DMA_ISR_HTIF5));
X  return (((DMAx->ISR) & ((0x1UL << (18U)))) == ((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Get Channel 1 transfer error flag.
N  * @rmtoll ISR          TEIF1         MS32_DMA_IsActiveFlag_TE1
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_TE1(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_TE1(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF1) == (DMA_ISR_TEIF1));
X  return (((DMAx->ISR) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Get Channel 2 transfer error flag.
N  * @rmtoll ISR          TEIF2         MS32_DMA_IsActiveFlag_TE2
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_TE2(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_TE2(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF2) == (DMA_ISR_TEIF2));
X  return (((DMAx->ISR) & ((0x1UL << (7U)))) == ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Get Channel 3 transfer error flag.
N  * @rmtoll ISR          TEIF3         MS32_DMA_IsActiveFlag_TE3
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_TE3(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_TE3(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF3) == (DMA_ISR_TEIF3));
X  return (((DMAx->ISR) & ((0x1UL << (11U)))) == ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Get Channel 4 transfer error flag.
N  * @rmtoll ISR          TEIF4         MS32_DMA_IsActiveFlag_TE4
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_TE4(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_TE4(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF4) == (DMA_ISR_TEIF4));
X  return (((DMAx->ISR) & ((0x1UL << (15U)))) == ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Get Channel 5 transfer error flag.
N  * @rmtoll ISR          TEIF5         MS32_DMA_IsActiveFlag_TE5
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsActiveFlag_TE5(DMA_TypeDef *DMAx) {
Xstatic __inline uint32_t MS32_DMA_IsActiveFlag_TE5(DMA_TypeDef *DMAx) {
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF5) == (DMA_ISR_TEIF5));
X  return (((DMAx->ISR) & ((0x1UL << (19U)))) == ((0x1UL << (19U))));
N}
N
N/**
N  * @brief  Clear Channel 1 global interrupt flag.
N  * @rmtoll IFCR         CGIF1         MS32_DMA_ClearFlag_GI1
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_GI1(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_GI1(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF1);
X  ((DMAx->IFCR) = ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Clear Channel 2 global interrupt flag.
N  * @rmtoll IFCR         CGIF2         MS32_DMA_ClearFlag_GI2
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_GI2(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_GI2(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF2);
X  ((DMAx->IFCR) = ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Clear Channel 3 global interrupt flag.
N  * @rmtoll IFCR         CGIF3         MS32_DMA_ClearFlag_GI3
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_GI3(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_GI3(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF3);
X  ((DMAx->IFCR) = ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Clear Channel 4 global interrupt flag.
N  * @rmtoll IFCR         CGIF4         MS32_DMA_ClearFlag_GI4
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_GI4(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_GI4(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF4);
X  ((DMAx->IFCR) = ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Clear Channel 5 global interrupt flag.
N  * @rmtoll IFCR         CGIF5         MS32_DMA_ClearFlag_GI5
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_GI5(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_GI5(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF5);
X  ((DMAx->IFCR) = ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Clear Channel 1  transfer complete flag.
N  * @rmtoll IFCR         CTCIF1        MS32_DMA_ClearFlag_TC1
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_TC1(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_TC1(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF1);
X  ((DMAx->IFCR) = ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Clear Channel 2  transfer complete flag.
N  * @rmtoll IFCR         CTCIF2        MS32_DMA_ClearFlag_TC2
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_TC2(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_TC2(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF2);
X  ((DMAx->IFCR) = ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Clear Channel 3  transfer complete flag.
N  * @rmtoll IFCR         CTCIF3        MS32_DMA_ClearFlag_TC3
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_TC3(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_TC3(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF3);
X  ((DMAx->IFCR) = ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Clear Channel 4  transfer complete flag.
N  * @rmtoll IFCR         CTCIF4        MS32_DMA_ClearFlag_TC4
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_TC4(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_TC4(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF4);
X  ((DMAx->IFCR) = ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Clear Channel 5  transfer complete flag.
N  * @rmtoll IFCR         CTCIF5        MS32_DMA_ClearFlag_TC5
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_TC5(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_TC5(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF5);
X  ((DMAx->IFCR) = ((0x1UL << (17U))));
N}
N
N/**
N  * @brief  Clear Channel 1  half transfer flag.
N  * @rmtoll IFCR         CHTIF1        MS32_DMA_ClearFlag_HT1
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_HT1(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_HT1(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF1);
X  ((DMAx->IFCR) = ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Clear Channel 2  half transfer flag.
N  * @rmtoll IFCR         CHTIF2        MS32_DMA_ClearFlag_HT2
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_HT2(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_HT2(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF2);
X  ((DMAx->IFCR) = ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Clear Channel 3  half transfer flag.
N  * @rmtoll IFCR         CHTIF3        MS32_DMA_ClearFlag_HT3
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_HT3(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_HT3(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF3);
X  ((DMAx->IFCR) = ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Clear Channel 4  half transfer flag.
N  * @rmtoll IFCR         CHTIF4        MS32_DMA_ClearFlag_HT4
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_HT4(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_HT4(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF4);
X  ((DMAx->IFCR) = ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Clear Channel 5  half transfer flag.
N  * @rmtoll IFCR         CHTIF5        MS32_DMA_ClearFlag_HT5
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_HT5(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_HT5(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF5);
X  ((DMAx->IFCR) = ((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Clear Channel 1 transfer error flag.
N  * @rmtoll IFCR         CTEIF1        MS32_DMA_ClearFlag_TE1
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_TE1(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_TE1(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF1);
X  ((DMAx->IFCR) = ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Clear Channel 2 transfer error flag.
N  * @rmtoll IFCR         CTEIF2        MS32_DMA_ClearFlag_TE2
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_TE2(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_TE2(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF2);
X  ((DMAx->IFCR) = ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Clear Channel 3 transfer error flag.
N  * @rmtoll IFCR         CTEIF3        MS32_DMA_ClearFlag_TE3
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_TE3(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_TE3(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF3);
X  ((DMAx->IFCR) = ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Clear Channel 4 transfer error flag.
N  * @rmtoll IFCR         CTEIF4        MS32_DMA_ClearFlag_TE4
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_TE4(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_TE4(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF4);
X  ((DMAx->IFCR) = ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Clear Channel 5 transfer error flag.
N  * @rmtoll IFCR         CTEIF5        MS32_DMA_ClearFlag_TE5
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_ClearFlag_TE5(DMA_TypeDef *DMAx) {
Xstatic __inline void MS32_DMA_ClearFlag_TE5(DMA_TypeDef *DMAx) {
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF5);
X  ((DMAx->IFCR) = ((0x1UL << (19U))));
N}
N
N
N/** @defgroup DMA_EF_IT_Management IT_Management
N  * @{
N  */
N/**
N  * @brief  Enable Transfer complete interrupt.
N  * @rmtoll CCR          TCIE          MS32_DMA_EnableIT_TC
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_EnableIT_TC(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline void MS32_DMA_EnableIT_TC(DMA_TypeDef *DMAx, uint32_t Channel) {
N  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_TCIE);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Enable Half transfer interrupt.
N  * @rmtoll CCR          HTIE          MS32_DMA_EnableIT_HT
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_EnableIT_HT(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline void MS32_DMA_EnableIT_HT(DMA_TypeDef *DMAx, uint32_t Channel) {
N  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_HTIE);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Enable Transfer error interrupt.
N  * @rmtoll CCR          TEIE          MS32_DMA_EnableIT_TE
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_EnableIT_TE(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline void MS32_DMA_EnableIT_TE(DMA_TypeDef *DMAx, uint32_t Channel) {
N  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_TEIE);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Disable Transfer complete interrupt.
N  * @rmtoll CCR          TCIE          MS32_DMA_DisableIT_TC
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_DisableIT_TC(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline void MS32_DMA_DisableIT_TC(DMA_TypeDef *DMAx, uint32_t Channel) {
N  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_TCIE);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable Half transfer interrupt.
N  * @rmtoll CCR          HTIE          MS32_DMA_DisableIT_HT
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_DisableIT_HT(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline void MS32_DMA_DisableIT_HT(DMA_TypeDef *DMAx, uint32_t Channel) {
N  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_HTIE);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Disable Transfer error interrupt.
N  * @rmtoll CCR          TEIE          MS32_DMA_DisableIT_TE
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DMA_DisableIT_TE(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline void MS32_DMA_DisableIT_TE(DMA_TypeDef *DMAx, uint32_t Channel) {
N  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_TEIE);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) &= ~((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Check if Transfer complete Interrupt is enabled.
N  * @rmtoll CCR          TCIE          MS32_DMA_IsEnabledIT_TC
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsEnabledIT_TC(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_IsEnabledIT_TC(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_TCIE) == (DMA_CCR_TCIE));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Check if Half transfer Interrupt is enabled.
N  * @rmtoll CCR          HTIE          MS32_DMA_IsEnabledIT_HT
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsEnabledIT_HT(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_IsEnabledIT_HT(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_HTIE) == (DMA_CCR_HTIE));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Check if Transfer error Interrupt is enabled.
N  * @rmtoll CCR          TEIE          MS32_DMA_IsEnabledIT_TE
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_DMA_CHANNEL_1
N  *         @arg @ref MS32_DMA_CHANNEL_2
N  *         @arg @ref MS32_DMA_CHANNEL_3
N  *         @arg @ref MS32_DMA_CHANNEL_4
N  *         @arg @ref MS32_DMA_CHANNEL_5
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_DMA_IsEnabledIT_TE(DMA_TypeDef *DMAx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_DMA_IsEnabledIT_TE(DMA_TypeDef *DMAx, uint32_t Channel) {
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_TEIE) == (DMA_CCR_TEIE));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N
N/** @defgroup DMA_EF_Init Initialization and de-initialization functions
N  * @{
N  */
NErrorStatus MS32_DMA_DeInit     (DMA_TypeDef *DMAx, uint32_t Channel);
Nvoid        MS32_DMA_StructInit (MS32_DMA_InitTypeDef *DmaInitStr);
NErrorStatus MS32_DMA_Init       (DMA_TypeDef *DMAx, uint32_t Channel, MS32_DMA_InitTypeDef *DmaInitStr);
Nvoid        MS32_DMA_ITConfig   (DMA_TypeDef *DMAx, uint32_t Channel, uint32_t InterruptFunc, uint32_t Priority);
N
N/** @defgroup DMA_EF_Application function
N  * @{
N  */
NFlagStatus  MS32_DMA_GetStatusFlag (DMA_TypeDef *DMAx, uint32_t Flags);
Nvoid        MS32_DMA_Restart       (DMA_TypeDef *DMAx, uint32_t Channel, uint32_t NbData);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_DMA_H */
N
N/******************************** END OF FILE *********************************/
L 69 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_exti.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_exti.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_EXTI_H
N#define __MS32F0XX_EXTI_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private Macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup EXTI_ES_INIT EXTI Exported Init structure
N  * @{
N  */
Ntypedef struct {
N  uint32_t Line_0_31;           /*!< Specifies the EXTI lines to be enabled or disabled for Lines in range 0 to 31
N                                     This parameter can be any combination of @ref EXTI_EC_LINE */
N  FunctionalState LineCommand;  /*!< Specifies the new state of the selected EXTI lines.
N                                     This parameter can be set either to ENABLE or DISABLE */
N  uint8_t Mode;                 /*!< Specifies the mode for the EXTI lines.
N                                     This parameter can be a value of @ref EXTI_EC_MODE. */
N  uint8_t Trigger;              /*!< Specifies the trigger signal active edge for the EXTI lines.
N                                     This parameter can be a value of @ref EXTI_EC_TRIGGER. */
N} MS32_EXTI_InitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup EXTI_EC_LINE LINE
N  * @{
N  */
N#define MS32_EXTI_LINE_0                 EXTI_IMR_IM0  /*!< Extended line 0 */
N#define MS32_EXTI_LINE_1                 EXTI_IMR_IM1  /*!< Extended line 1 */
N#define MS32_EXTI_LINE_2                 EXTI_IMR_IM2  /*!< Extended line 2 */
N#define MS32_EXTI_LINE_3                 EXTI_IMR_IM3  /*!< Extended line 3 */
N#define MS32_EXTI_LINE_4                 EXTI_IMR_IM4  /*!< Extended line 4 */
N#define MS32_EXTI_LINE_5                 EXTI_IMR_IM5  /*!< Extended line 5 */
N#define MS32_EXTI_LINE_6                 EXTI_IMR_IM6  /*!< Extended line 6 */
N#define MS32_EXTI_LINE_7                 EXTI_IMR_IM7  /*!< Extended line 7 */
N#define MS32_EXTI_LINE_8                 EXTI_IMR_IM8  /*!< Extended line 8 */
N#define MS32_EXTI_LINE_9                 EXTI_IMR_IM9  /*!< Extended line 9 */
N#define MS32_EXTI_LINE_10                EXTI_IMR_IM10 /*!< Extended line 10 */
N#define MS32_EXTI_LINE_11                EXTI_IMR_IM11 /*!< Extended line 11 */
N#define MS32_EXTI_LINE_12                EXTI_IMR_IM12 /*!< Extended line 12 */
N#define MS32_EXTI_LINE_13                EXTI_IMR_IM13 /*!< Extended line 13 */
N#define MS32_EXTI_LINE_14                EXTI_IMR_IM14 /*!< Extended line 14 */
N#define MS32_EXTI_LINE_15                EXTI_IMR_IM15 /*!< Extended line 15 */
N#define MS32_EXTI_LINE_16                EXTI_IMR_IM16 /*!< Extended line 16 */
N#define MS32_EXTI_LINE_17                EXTI_IMR_IM17 /*!< Extended line 17 */
N#define MS32_EXTI_LINE_19                EXTI_IMR_IM19 /*!< Extended line 19 */
N#define MS32_EXTI_LINE_21                EXTI_IMR_IM21 /*!< Extended line 21 */
N#define MS32_EXTI_LINE_22                EXTI_IMR_IM22 /*!< Extended line 22 */
N#define MS32_EXTI_LINE_23                EXTI_IMR_IM23 /*!< Extended line 23 */
N#define MS32_EXTI_LINE_25                EXTI_IMR_IM25 /*!< Extended line 25 */
N#define MS32_EXTI_LINE_ALL_0_31          EXTI_IMR_IM   /*!< All Extended line not reserved*/
N
N#define MS32_EXTI_LINE_ALL               (0xFFFFFFFFU) /*!< All Extended line */
N#define MS32_EXTI_LINE_NONE              (0x00000000U) /*!< None Extended line */
N
N/** @defgroup EXTI_EC_MODE Mode
N  * @{
N  */
N#define MS32_EXTI_MODE_IT                 ((uint8_t)0x00U) /*!< Interrupt Mode */
N#define MS32_EXTI_MODE_EVENT              ((uint8_t)0x01U) /*!< Event Mode */
N#define MS32_EXTI_MODE_IT_EVENT           ((uint8_t)0x02U) /*!< Interrupt & Event Mode */
N
N/** @defgroup EXTI_EC_TRIGGER Edge Trigger
N  * @{
N  */
N#define MS32_EXTI_TRIGGER_NONE            ((uint8_t)0x00U) /*!< No Trigger Mode */
N#define MS32_EXTI_TRIGGER_RISING          ((uint8_t)0x01U) /*!< Trigger Rising Mode */
N#define MS32_EXTI_TRIGGER_FALLING         ((uint8_t)0x02U) /*!< Trigger Falling Mode */
N#define MS32_EXTI_TRIGGER_RISING_FALLING  ((uint8_t)0x03U) /*!< Trigger Rising & Falling Mode */
N
N/** @defgroup EXTI_EC_PORT Exti Trigger port
N  * @{
N  */
N#define MS32_EXTI_PORTA                   SYSCFG_EXTICR1_EXTI0_PA /*!< PA GPIO as EXTI */
N#define MS32_EXTI_PORTB                   SYSCFG_EXTICR1_EXTI0_PB /*!< PB GPIO as EXTI */
N#define MS32_EXTI_PORTC                   SYSCFG_EXTICR1_EXTI0_PC /*!< PC GPIO as EXTI */
N#define MS32_EXTI_PORTF                   SYSCFG_EXTICR1_EXTI0_PF /*!< PF GPIO as EXTI */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup EXTI_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in EXTI register
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_EXTI_WriteReg(__REG__, __VALUE__) WRITE_REG(EXTI->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in EXTI register
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_EXTI_ReadReg(__REG__) READ_REG(EXTI->__REG__)
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup EXTI_EF_IT_Management IT_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable ExtiLine Interrupt request for Lines in range 0 to 31
N  * @note The reset value for the direct or internal lines (see RM)
N  *       is set to 1 in order to enable the interrupt by default.
N  *       Bits are set automatically at Power on.
N  * @rmtoll IMR         IMx           MS32_EXTI_EnableIT_0_31
N  * @param  ExtiLine This parameter can be one of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  *         @arg @ref MS32_EXTI_LINE_23
N  *         @arg @ref MS32_EXTI_LINE_25
N  *         @arg @ref MS32_EXTI_LINE_ALL_0_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void MS32_EXTI_EnableIT_0_31(uint32_t ExtiLine) {
Xstatic __inline void MS32_EXTI_EnableIT_0_31(uint32_t ExtiLine) {
N  SET_BIT(EXTI->IMR, ExtiLine);
X  ((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->IMR) |= (ExtiLine));
N}
N
N/**
N  * @brief  Disable ExtiLine Interrupt request for Lines in range 0 to 31
N  * @note The reset value for the direct or internal lines (see RM)
N  *       is set to 1 in order to enable the interrupt by default.
N  *       Bits are set automatically at Power on.
N  * @rmtoll IMR         IMx           MS32_EXTI_DisableIT_0_31
N  * @param  ExtiLine This parameter can be one of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  *         @arg @ref MS32_EXTI_LINE_23
N  *         @arg @ref MS32_EXTI_LINE_25
N  *         @arg @ref MS32_EXTI_LINE_ALL_0_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void MS32_EXTI_DisableIT_0_31(uint32_t ExtiLine) {
Xstatic __inline void MS32_EXTI_DisableIT_0_31(uint32_t ExtiLine) {
N  CLEAR_BIT(EXTI->IMR, ExtiLine);
X  ((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->IMR) &= ~(ExtiLine));
N}
N
N
N/**
N  * @brief  Indicate if ExtiLine Interrupt request is enabled for Lines in range 0 to 31
N  * @note The reset value for the direct or internal lines (see RM)
N  *       is set to 1 in order to enable the interrupt by default.
N  *       Bits are set automatically at Power on.
N  * @rmtoll IMR         IMx           MS32_EXTI_IsEnabledIT_0_31
N  * @param  ExtiLine This parameter can be one of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  *         @arg @ref MS32_EXTI_LINE_23
N  *         @arg @ref MS32_EXTI_LINE_25
N  *         @arg @ref MS32_EXTI_LINE_ALL_0_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_EXTI_IsEnabledIT_0_31(uint32_t ExtiLine) {
Xstatic __inline uint32_t MS32_EXTI_IsEnabledIT_0_31(uint32_t ExtiLine) {
N  return (READ_BIT(EXTI->IMR, ExtiLine) == (ExtiLine));
X  return (((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->IMR) & (ExtiLine)) == (ExtiLine));
N}
N
N
N/** @defgroup EXTI_EF_Event_Management Event_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable ExtiLine Event request for Lines in range 0 to 31
N  * @rmtoll EMR         EMx           MS32_EXTI_EnableEvent_0_31
N  * @param  ExtiLine This parameter can be one of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  *         @arg @ref MS32_EXTI_LINE_23
N  *         @arg @ref MS32_EXTI_LINE_25
N  *         @arg @ref MS32_EXTI_LINE_ALL_0_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void MS32_EXTI_EnableEvent_0_31(uint32_t ExtiLine) {
Xstatic __inline void MS32_EXTI_EnableEvent_0_31(uint32_t ExtiLine) {
N  SET_BIT(EXTI->EMR, ExtiLine);
X  ((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->EMR) |= (ExtiLine));
N
N}
N
N
N/**
N  * @brief  Disable ExtiLine Event request for Lines in range 0 to 31
N  * @rmtoll EMR         EMx           MS32_EXTI_DisableEvent_0_31
N  * @param  ExtiLine This parameter can be one of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  *         @arg @ref MS32_EXTI_LINE_23
N  *         @arg @ref MS32_EXTI_LINE_25
N  *         @arg @ref MS32_EXTI_LINE_ALL_0_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void MS32_EXTI_DisableEvent_0_31(uint32_t ExtiLine) {
Xstatic __inline void MS32_EXTI_DisableEvent_0_31(uint32_t ExtiLine) {
N  CLEAR_BIT(EXTI->EMR, ExtiLine);
X  ((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->EMR) &= ~(ExtiLine));
N}
N
N
N/**
N  * @brief  Indicate if ExtiLine Event request is enabled for Lines in range 0 to 31
N  * @rmtoll EMR         EMx           MS32_EXTI_IsEnabledEvent_0_31
N  * @param  ExtiLine This parameter can be one of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  *         @arg @ref MS32_EXTI_LINE_23
N  *         @arg @ref MS32_EXTI_LINE_25
N  *         @arg @ref MS32_EXTI_LINE_ALL_0_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_EXTI_IsEnabledEvent_0_31(uint32_t ExtiLine) {
Xstatic __inline uint32_t MS32_EXTI_IsEnabledEvent_0_31(uint32_t ExtiLine) {
N  return (READ_BIT(EXTI->EMR, ExtiLine) == (ExtiLine));
X  return (((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->EMR) & (ExtiLine)) == (ExtiLine));
N
N}
N
N
N/** @defgroup EXTI_EF_Rising_Trigger_Management Rising_Trigger_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable ExtiLine Rising Edge Trigger for Lines in range 0 to 31
N  * @note The configurable wakeup lines are edge-triggered. No glitch must be
N  *       generated on these lines. If a rising edge on a configurable interrupt
N  *       line occurs during a write operation in the EXTI_RTSR register, the
N  *       pending bit is not set.
N  *       Rising and falling edge triggers can be set for
N  *       the same interrupt line. In this case, both generate a trigger
N  *       condition.
N  * @rmtoll RTSR        RTx           MS32_EXTI_EnableRisingTrig_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_20
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void MS32_EXTI_EnableRisingTrig_0_31(uint32_t ExtiLine) {
Xstatic __inline void MS32_EXTI_EnableRisingTrig_0_31(uint32_t ExtiLine) {
N  SET_BIT(EXTI->RTSR, ExtiLine);
X  ((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->RTSR) |= (ExtiLine));
N
N}
N
N
N/**
N  * @brief  Disable ExtiLine Rising Edge Trigger for Lines in range 0 to 31
N  * @note The configurable wakeup lines are edge-triggered. No glitch must be
N  *       generated on these lines. If a rising edge on a configurable interrupt
N  *       line occurs during a write operation in the EXTI_RTSR register, the
N  *       pending bit is not set.
N  *       Rising and falling edge triggers can be set for
N  *       the same interrupt line. In this case, both generate a trigger
N  *       condition.
N  * @rmtoll RTSR        RTx           MS32_EXTI_DisableRisingTrig_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_20
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void MS32_EXTI_DisableRisingTrig_0_31(uint32_t ExtiLine) {
Xstatic __inline void MS32_EXTI_DisableRisingTrig_0_31(uint32_t ExtiLine) {
N  CLEAR_BIT(EXTI->RTSR, ExtiLine);
X  ((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->RTSR) &= ~(ExtiLine));
N
N}
N
N
N/**
N  * @brief  Check if rising edge trigger is enabled for Lines in range 0 to 31
N  * @rmtoll RTSR        RTx           MS32_EXTI_IsEnabledRisingTrig_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_20
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_EXTI_IsEnabledRisingTrig_0_31(uint32_t ExtiLine) {
Xstatic __inline uint32_t MS32_EXTI_IsEnabledRisingTrig_0_31(uint32_t ExtiLine) {
N  return (READ_BIT(EXTI->RTSR, ExtiLine) == (ExtiLine));
X  return (((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->RTSR) & (ExtiLine)) == (ExtiLine));
N}
N
N
N/** @defgroup EXTI_EF_Falling_Trigger_Management Falling_Trigger_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable ExtiLine Falling Edge Trigger for Lines in range 0 to 31
N  * @note The configurable wakeup lines are edge-triggered. No glitch must be
N  *       generated on these lines. If a falling edge on a configurable interrupt
N  *       line occurs during a write operation in the EXTI_FTSR register, the
N  *       pending bit is not set.
N  *       Rising and falling edge triggers can be set for
N  *       the same interrupt line. In this case, both generate a trigger
N  *       condition.
N  * @rmtoll FTSR        FTx           MS32_EXTI_EnableFallingTrig_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_20
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void MS32_EXTI_EnableFallingTrig_0_31(uint32_t ExtiLine) {
Xstatic __inline void MS32_EXTI_EnableFallingTrig_0_31(uint32_t ExtiLine) {
N  SET_BIT(EXTI->FTSR, ExtiLine);
X  ((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->FTSR) |= (ExtiLine));
N}
N
N
N/**
N  * @brief  Disable ExtiLine Falling Edge Trigger for Lines in range 0 to 31
N  * @note The configurable wakeup lines are edge-triggered. No glitch must be
N  *       generated on these lines. If a Falling edge on a configurable interrupt
N  *       line occurs during a write operation in the EXTI_FTSR register, the
N  *       pending bit is not set.
N  *       Rising and falling edge triggers can be set for the same interrupt line.
N  *       In this case, both generate a trigger condition.
N  * @rmtoll FTSR        FTx           MS32_EXTI_DisableFallingTrig_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_20
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void MS32_EXTI_DisableFallingTrig_0_31(uint32_t ExtiLine) {
Xstatic __inline void MS32_EXTI_DisableFallingTrig_0_31(uint32_t ExtiLine) {
N  CLEAR_BIT(EXTI->FTSR, ExtiLine);
X  ((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->FTSR) &= ~(ExtiLine));
N}
N
N
N/**
N  * @brief  Check if falling edge trigger is enabled for Lines in range 0 to 31
N  * @rmtoll FTSR        FTx           MS32_EXTI_IsEnabledFallingTrig_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_20
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_EXTI_IsEnabledFallingTrig_0_31(uint32_t ExtiLine) {
Xstatic __inline uint32_t MS32_EXTI_IsEnabledFallingTrig_0_31(uint32_t ExtiLine) {
N  return (READ_BIT(EXTI->FTSR, ExtiLine) == (ExtiLine));
X  return (((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->FTSR) & (ExtiLine)) == (ExtiLine));
N}
N
N
N/** @defgroup EXTI_EF_Software_Interrupt_Management Software_Interrupt_Management
N  * @{
N  */
N
N/**
N  * @brief  Generate a software Interrupt Event for Lines in range 0 to 31
N  * @note If the interrupt is enabled on this line in the EXTI_IMR, writing a 1 to
N  *       this bit when it is at '0' sets the corresponding pending bit in EXTI_PR
N  *       resulting in an interrupt request generation.
N  *       This bit is cleared by clearing the corresponding bit in the EXTI_PR
N  *       register (by writing a 1 into the bit)
N  * @rmtoll SWIER       SWIx          MS32_EXTI_GenerateSWI_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_20
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void MS32_EXTI_GenerateSWI_0_31(uint32_t ExtiLine) {
Xstatic __inline void MS32_EXTI_GenerateSWI_0_31(uint32_t ExtiLine) {
N  SET_BIT(EXTI->SWIER, ExtiLine);
X  ((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->SWIER) |= (ExtiLine));
N}
N
N
N/** @defgroup EXTI_EF_Flag_Management Flag_Management
N  * @{
N  */
N
N/**
N  * @brief  Check if the ExtLine Flag is set or not for Lines in range 0 to 31
N  * @note This bit is set when the selected edge event arrives on the interrupt
N  *       line. This bit is cleared by writing a 1 to the bit.
N  * @rmtoll PR          PIFx           MS32_EXTI_IsActiveFlag_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_20
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_EXTI_IsActiveFlag_0_31(uint32_t ExtiLine) {
Xstatic __inline uint32_t MS32_EXTI_IsActiveFlag_0_31(uint32_t ExtiLine) {
N  return (READ_BIT(EXTI->PR, ExtiLine) == (ExtiLine));
X  return (((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->PR) & (ExtiLine)) == (ExtiLine));
N}
N
N
N/**
N  * @brief  Read ExtLine Combination Flag for Lines in range 0 to 31
N  * @note This bit is set when the selected edge event arrives on the interrupt
N  *       line. This bit is cleared by writing a 1 to the bit.
N  * @rmtoll PR          PIFx           MS32_EXTI_ReadFlag_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_20
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval @note This bit is set when the selected edge event arrives on the interrupt
N  */
N__STATIC_INLINE uint32_t MS32_EXTI_ReadFlag_0_31(uint32_t ExtiLine) {
Xstatic __inline uint32_t MS32_EXTI_ReadFlag_0_31(uint32_t ExtiLine) {
N  return (uint32_t)(READ_BIT(EXTI->PR, ExtiLine));
X  return (uint32_t)(((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->PR) & (ExtiLine)));
N}
N
N
N/**
N  * @brief  Clear ExtLine Flags  for Lines in range 0 to 31
N  * @note This bit is set when the selected edge event arrives on the interrupt
N  *       line. This bit is cleared by writing a 1 to the bit.
N  * @rmtoll PR          PIFx           MS32_EXTI_ClearFlag_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref MS32_EXTI_LINE_0
N  *         @arg @ref MS32_EXTI_LINE_1
N  *         @arg @ref MS32_EXTI_LINE_2
N  *         @arg @ref MS32_EXTI_LINE_3
N  *         @arg @ref MS32_EXTI_LINE_4
N  *         @arg @ref MS32_EXTI_LINE_5
N  *         @arg @ref MS32_EXTI_LINE_6
N  *         @arg @ref MS32_EXTI_LINE_7
N  *         @arg @ref MS32_EXTI_LINE_8
N  *         @arg @ref MS32_EXTI_LINE_9
N  *         @arg @ref MS32_EXTI_LINE_10
N  *         @arg @ref MS32_EXTI_LINE_11
N  *         @arg @ref MS32_EXTI_LINE_12
N  *         @arg @ref MS32_EXTI_LINE_13
N  *         @arg @ref MS32_EXTI_LINE_14
N  *         @arg @ref MS32_EXTI_LINE_15
N  *         @arg @ref MS32_EXTI_LINE_16
N  *         @arg @ref MS32_EXTI_LINE_17
N  *         @arg @ref MS32_EXTI_LINE_19
N  *         @arg @ref MS32_EXTI_LINE_20
N  *         @arg @ref MS32_EXTI_LINE_21
N  *         @arg @ref MS32_EXTI_LINE_22
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void MS32_EXTI_ClearFlag_0_31(uint32_t ExtiLine) {
Xstatic __inline void MS32_EXTI_ClearFlag_0_31(uint32_t ExtiLine) {
N  WRITE_REG(EXTI->PR, ExtiLine);
X  ((((EXTI_TypeDef *) (0x40000000UL + 0x00010400UL))->PR) = (ExtiLine));
N}
N
N
N/** @defgroup EXTI_EF_Init Initialization and de-initialization functions
N  * @{
N  */
NErrorStatus MS32_EXTI_DeInit      (void);
NErrorStatus MS32_EXTI_Init        (MS32_EXTI_InitTypeDef *EXTI_InitStruct);
Nvoid        MS32_EXTI_StructInit  (MS32_EXTI_InitTypeDef *EXTI_InitStruct);
Nvoid        MS32_EXTI_PinITConfig (uint32_t ExtiLine, uint32_t ExtiPort, uint32_t Priority, FunctionalState State);
N
N/** @defgroup EXTI_EF_Application function
N  * @{
N  */
Nvoid       MS32_EXTI_GenerateSWI   (uint32_t ExtiLine);
NFlagStatus MS32_EXTI_GetStatusFlag (uint32_t ExtiLine);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_EXTI_H */
N
N/******************************** END OF FILE *********************************/
L 70 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_flash.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_flash.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_FLASH_H
N#define __MS32F0XX_FLASH_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup MS32_FLASH_Exported_Constants FLASH Exported Constants
N  * @{
N  */
N
N/** @defgroup FLASH_IT  Flash Interrupt
N  * @{
N  */
N#define MS32_FLASH_IT_ERRIE            FLASH_CR_ERRIE /*!< FLASH Error Interrupt Enable            */
N#define MS32_FLASH_IT_EOPIE            FLASH_CR_EOPIE /*!< FLASH End of operation Interrupt Enable */
N#define MS32_FLASH_IT_ALLFSHIE         (FLASH_CR_ERRIE | FLASH_CR_EOPIE) /*!< All FLASH Interrupt Enable */
N
N/** @defgroup INT_ERR_Flags  Interrupt Error flags
N  * @{
N  */
N#define MS32_FLASH_FLAG_PGERR          FLASH_SR_PGERR    /*!< FLASH Programme Error Interrupt flag  */
N#define MS32_FLASH_FLAG_WRERR          FLASH_SR_WRPRTERR /*!< FLASH Write Error Interrupt flag      */
N#define MS32_FLASH_FLAG_EOP            FLASH_SR_EOP      /*!< FLASH End of Operation Interrupt flag */
N#define MS32_FLASH_FLAG_ALLFSH         (FLASH_SR_PGERR | FLASH_SR_WRPRTERR | FLASH_SR_EOP) /*!< ALL FLASH Interrupt flag */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup FLASH_EF_Init Initialization functions
N  * @{
N  */
Nvoid MS32_FLASH_ITConfig (uint32_t InterruptFunc, uint32_t Priority);
N
N/** @defgroup FLASH_EF_Application function
N  * @{
N  */
NFlagStatus  MS32_FLASH_GetStatusFlag (uint32_t Flags);
NErrorStatus MS32_FLASH_ChipErase     (void);
NErrorStatus MS32_FLASH_PageErase     (uint32_t page);
NErrorStatus MS32_FLASH_Write         (uint32_t addr, uint8_t *dat_buf, uint32_t len);
NErrorStatus MS32_FLASH_Read          (uint32_t addr, uint8_t *dat_buf, uint32_t len);
NErrorStatus MS32_FLASH_OptionErase   (void);
NErrorStatus MS32_FLASH_OptionWrite   (uint32_t addr, uint8_t *dat_buf, uint32_t len);
NErrorStatus MS32_FLASH_OptionRead    (uint32_t addr, uint8_t *dat_buf, uint32_t len);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_FLASH_H */
N
N/******************************** END OF FILE *********************************/
L 71 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_gpio.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_gpio.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_GPIO_H
N#define __MS32F0XX_GPIO_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup GPIO_Exported_Types GPIO Exported Types
N  * @{
N  */
N
N/**
N  * @brief GPIO_ES_INIT GPIO Exported Init structures
N  */
Ntypedef struct {
N  uint32_t Pin;          /*!< Specifies the GPIO pins to be configured.
N                              This parameter can be any value of @ref GPIO_EC_PIN */
N  uint32_t Mode;         /*!< Specifies the operating mode for the selected pins.
N                              This parameter can be a value of @ref GPIO_EC_MODE.
N                              GPIO HW configuration can be modified afterwards using unitary function @ref MS32_GPIO_SetPinMode().*/
N  uint32_t Speed;        /*!< Specifies the speed for the selected pins.
N                              This parameter can be a value of @ref GPIO_EC_SPEED.
N                              GPIO HW configuration can be modified afterwards using unitary function @ref MS32_GPIO_SetPinSpeed().*/
N  uint32_t OutputType;   /*!< Specifies the operating output type for the selected pins.
N                              This parameter can be a value of @ref GPIO_EC_OUTPUT.
N                              GPIO HW configuration can be modified afterwards using unitary function @ref MS32_GPIO_SetPinOutputType().*/
N  uint32_t Pull;         /*!< Specifies the operating Pull-up/Pull down for the selected pins.
N                              This parameter can be a value of @ref GPIO_EC_PULL.
N                              GPIO HW configuration can be modified afterwards using unitary function @ref MS32_GPIO_SetPinPull().*/
N  uint32_t Alternate;    /*!< Specifies the Peripheral to be connected to the selected pins.
N                              This parameter can be a value of @ref GPIO_EC_AF.
N                              GPIO HW configuration can be modified afterwards using unitary function @ref MS32_GPIO_SetAFPin_0_7() and MS32_GPIO_SetAFPin_8_15().*/
N} MS32_GPIO_InitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup MS32_GPIO_Exported_Constants GPIO Exported Constants
N  * @{
N  */
N
N/** @defgroup GPIO_EC_OUTPUT Output Type
N  * @{
N  */
N#define MS32_GPIO_OUTPUT_HIGH                (0x00000000U)
N#define MS32_GPIO_OUTPUT_LOW                 (0x00000001U)
N#define MS32_GPIO_OUTPUT_REV                 (0x00000002U)
N
N/** @defgroup GPIO_EC_PIN PIN
N  * @{
N  */
N#define MS32_GPIO_PIN_0                      GPIO_BSRR_BS_0 /*!< Select pin 0 */
N#define MS32_GPIO_PIN_1                      GPIO_BSRR_BS_1 /*!< Select pin 1 */
N#define MS32_GPIO_PIN_2                      GPIO_BSRR_BS_2 /*!< Select pin 2 */
N#define MS32_GPIO_PIN_3                      GPIO_BSRR_BS_3 /*!< Select pin 3 */
N#define MS32_GPIO_PIN_4                      GPIO_BSRR_BS_4 /*!< Select pin 4 */
N#define MS32_GPIO_PIN_5                      GPIO_BSRR_BS_5 /*!< Select pin 5 */
N#define MS32_GPIO_PIN_6                      GPIO_BSRR_BS_6 /*!< Select pin 6 */
N#define MS32_GPIO_PIN_7                      GPIO_BSRR_BS_7 /*!< Select pin 7 */
N#define MS32_GPIO_PIN_8                      GPIO_BSRR_BS_8 /*!< Select pin 8 */
N#define MS32_GPIO_PIN_9                      GPIO_BSRR_BS_9 /*!< Select pin 9 */
N#define MS32_GPIO_PIN_10                     GPIO_BSRR_BS_10 /*!< Select pin 10 */
N#define MS32_GPIO_PIN_11                     GPIO_BSRR_BS_11 /*!< Select pin 11 */
N#define MS32_GPIO_PIN_12                     GPIO_BSRR_BS_12 /*!< Select pin 12 */
N#define MS32_GPIO_PIN_13                     GPIO_BSRR_BS_13 /*!< Select pin 13 */
N#define MS32_GPIO_PIN_14                     GPIO_BSRR_BS_14 /*!< Select pin 14 */
N#define MS32_GPIO_PIN_15                     GPIO_BSRR_BS_15 /*!< Select pin 15 */
N#define MS32_GPIO_PIN_ALL                    (GPIO_BSRR_BS_0  | GPIO_BSRR_BS_1  | GPIO_BSRR_BS_2  | \
N                                              GPIO_BSRR_BS_3  | GPIO_BSRR_BS_4  | GPIO_BSRR_BS_5  | \
N                                              GPIO_BSRR_BS_6  | GPIO_BSRR_BS_7  | GPIO_BSRR_BS_8  | \
N                                              GPIO_BSRR_BS_9  | GPIO_BSRR_BS_10 | GPIO_BSRR_BS_11 | \
N                                              GPIO_BSRR_BS_12 | GPIO_BSRR_BS_13 | GPIO_BSRR_BS_14 | \
N                                              GPIO_BSRR_BS_15) /*!< Select all pins */
X#define MS32_GPIO_PIN_ALL                    (GPIO_BSRR_BS_0  | GPIO_BSRR_BS_1  | GPIO_BSRR_BS_2  |                                               GPIO_BSRR_BS_3  | GPIO_BSRR_BS_4  | GPIO_BSRR_BS_5  |                                               GPIO_BSRR_BS_6  | GPIO_BSRR_BS_7  | GPIO_BSRR_BS_8  |                                               GPIO_BSRR_BS_9  | GPIO_BSRR_BS_10 | GPIO_BSRR_BS_11 |                                               GPIO_BSRR_BS_12 | GPIO_BSRR_BS_13 | GPIO_BSRR_BS_14 |                                               GPIO_BSRR_BS_15)  
N
N/** @defgroup GPIO_EC_MODE Mode
N  * @{
N  */
N#define MS32_GPIO_MODE_INPUT                 (0x00000000U) /*!< Select input mode */
N#define MS32_GPIO_MODE_OUTPUT                GPIO_MODER_MODER0_0  /*!< Select output mode */
N#define MS32_GPIO_MODE_ALTERNATE             GPIO_MODER_MODER0_1  /*!< Select alternate function mode */
N#define MS32_GPIO_MODE_ANALOG                GPIO_MODER_MODER0    /*!< Select analog mode */
N
N/** @defgroup GPIO_EC_OUTPUT Output Type
N  * @{
N  */
N#define MS32_GPIO_OUTPUT_PUSHPULL            (0x00000000U) /*!< Select push-pull as output type */
N#define MS32_GPIO_OUTPUT_OPENDRAIN           GPIO_OTYPER_OT_0 /*!< Select open-drain as output type */
N
N/** @defgroup GPIO_EC_SPEED Output Speed
N  * @{
N  */
N#define MS32_GPIO_SPEED_FREQ_LOW             (0x00000000U) /*!< Select I/O low output speed    */
N#define MS32_GPIO_SPEED_FREQ_MEDIUM          GPIO_OSPEEDR_OSPEEDR0_0 /*!< Select I/O medium output speed */
N#define MS32_GPIO_SPEED_FREQ_HIGH            GPIO_OSPEEDR_OSPEEDR0   /*!< Select I/O high output speed   */
N#define MS32_GPIO_SPEED_LOW                  MS32_GPIO_SPEED_FREQ_LOW
N#define MS32_GPIO_SPEED_MEDIUM               MS32_GPIO_SPEED_FREQ_MEDIUM
N#define MS32_GPIO_SPEED_HIGH                 MS32_GPIO_SPEED_FREQ_HIGH
N
N/** @defgroup GPIO_EC_PULL Pull Up Pull Down
N  * @{
N  */
N#define MS32_GPIO_PULL_NO                    (0x00000000U) /*!< Select I/O no pull */
N#define MS32_GPIO_PULL_UP                    GPIO_PUPDR_PUPDR0_0 /*!< Select I/O pull up */
N#define MS32_GPIO_PULL_DOWN                  GPIO_PUPDR_PUPDR0_1 /*!< Select I/O pull down */
N
N/** @defgroup GPIO_EC_AF Alternate Function
N  * @{
N  */
N#define MS32_GPIO_AF_0                       (0x0000000U) /*!< Select alternate function 0 */
N#define MS32_GPIO_AF_1                       (0x0000001U) /*!< Select alternate function 1 */
N#define MS32_GPIO_AF_2                       (0x0000002U) /*!< Select alternate function 2 */
N#define MS32_GPIO_AF_3                       (0x0000003U) /*!< Select alternate function 3 */
N#define MS32_GPIO_AF_4                       (0x0000004U) /*!< Select alternate function 4 */
N#define MS32_GPIO_AF_5                       (0x0000005U) /*!< Select alternate function 5 */
N#define MS32_GPIO_AF_6                       (0x0000006U) /*!< Select alternate function 6 */
N#define MS32_GPIO_AF_7                       (0x0000007U) /*!< Select alternate function 7 */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup GPIO_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in GPIO register
N  * @param  __INSTANCE__ GPIO Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_GPIO_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in GPIO register
N  * @param  __INSTANCE__ GPIO Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_GPIO_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup GPIO_EF_Port_Configuration Port Configuration
N  * @{
N  */
N
N/**
N  * @brief  Configure gpio mode for a dedicated pin on dedicated port.
N  * @note   I/O mode can be Input mode, General purpose output, Alternate function mode or Analog.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @rmtoll MODER        MODEy         MS32_GPIO_SetPinMode
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  * @param  Mode This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_MODE_INPUT
N  *         @arg @ref MS32_GPIO_MODE_OUTPUT
N  *         @arg @ref MS32_GPIO_MODE_ALTERNATE
N  *         @arg @ref MS32_GPIO_MODE_ANALOG
N  * @retval None
N  */
N__STATIC_INLINE void MS32_GPIO_SetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Mode) {
Xstatic __inline void MS32_GPIO_SetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Mode) {
N  MODIFY_REG(GPIOx->MODER, ((Pin * Pin) * GPIO_MODER_MODER0), ((Pin * Pin) * Mode));
X  (((GPIOx->MODER)) = ((((((GPIOx->MODER))) & (~(((Pin * Pin) * (0x3UL << (0U)))))) | (((Pin * Pin) * Mode)))));
N}
N
N/**
N  * @brief  Return gpio mode for a dedicated pin on dedicated port.
N  * @note   I/O mode can be Input mode, General purpose output, Alternate function mode or Analog.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @rmtoll MODER        MODEy         MS32_GPIO_GetPinMode
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_GPIO_MODE_INPUT
N  *         @arg @ref MS32_GPIO_MODE_OUTPUT
N  *         @arg @ref MS32_GPIO_MODE_ALTERNATE
N  *         @arg @ref MS32_GPIO_MODE_ANALOG
N  */
N__STATIC_INLINE uint32_t MS32_GPIO_GetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin) {
Xstatic __inline uint32_t MS32_GPIO_GetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin) {
N  return (uint32_t)(READ_BIT(GPIOx->MODER, ((Pin * Pin) * GPIO_MODER_MODER0)) / (Pin * Pin));
X  return (uint32_t)(((GPIOx->MODER) & (((Pin * Pin) * (0x3UL << (0U))))) / (Pin * Pin));
N}
N
N/**
N  * @brief  Configure gpio output type for several pins on dedicated port.
N  * @note   Output type as to be set when gpio pin is in output or
N  *         alternate modes. Possible type are Push-pull or Open-drain.
N  * @rmtoll OTYPER       OTy           MS32_GPIO_SetPinOutputType
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  *         @arg @ref MS32_GPIO_PIN_ALL
N  * @param  OutputType This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_OUTPUT_PUSHPULL
N  *         @arg @ref MS32_GPIO_OUTPUT_OPENDRAIN
N  * @retval None
N  */
N__STATIC_INLINE void MS32_GPIO_SetPinOutputType(GPIO_TypeDef *GPIOx, uint32_t PinMask, uint32_t OutputType) {
Xstatic __inline void MS32_GPIO_SetPinOutputType(GPIO_TypeDef *GPIOx, uint32_t PinMask, uint32_t OutputType) {
N  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
X  (((GPIOx->OTYPER)) = ((((((GPIOx->OTYPER))) & (~(PinMask))) | ((PinMask * OutputType)))));
N}
N
N/**
N  * @brief  Return gpio output type for several pins on dedicated port.
N  * @note   Output type as to be set when gpio pin is in output or
N  *         alternate modes. Possible type are Push-pull or Open-drain.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @rmtoll OTYPER       OTy           MS32_GPIO_GetPinOutputType
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  *         @arg @ref MS32_GPIO_PIN_ALL
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_GPIO_OUTPUT_PUSHPULL
N  *         @arg @ref MS32_GPIO_OUTPUT_OPENDRAIN
N  */
N__STATIC_INLINE uint32_t MS32_GPIO_GetPinOutputType(GPIO_TypeDef *GPIOx, uint32_t Pin) {
Xstatic __inline uint32_t MS32_GPIO_GetPinOutputType(GPIO_TypeDef *GPIOx, uint32_t Pin) {
N  return (uint32_t)(READ_BIT(GPIOx->OTYPER, Pin) / Pin);
X  return (uint32_t)(((GPIOx->OTYPER) & (Pin)) / Pin);
N}
N
N/**
N  * @brief  Configure gpio speed for a dedicated pin on dedicated port.
N  * @note   I/O speed can be Low, Medium, Fast or High speed.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @note   Refer to datasheet for frequency specifications and the power
N  *         supply and load conditions for each speed.
N  * @rmtoll OSPEEDR      OSPEEDy       MS32_GPIO_SetPinSpeed
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  * @param  Speed This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_SPEED_FREQ_LOW
N  *         @arg @ref MS32_GPIO_SPEED_FREQ_MEDIUM
N  *         @arg @ref MS32_GPIO_SPEED_FREQ_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void MS32_GPIO_SetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t  Speed) {
Xstatic __inline void MS32_GPIO_SetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t  Speed) {
N  MODIFY_REG(GPIOx->OSPEEDR, ((Pin * Pin) * GPIO_OSPEEDR_OSPEEDR0), ((Pin * Pin) * Speed));
X  (((GPIOx->OSPEEDR)) = ((((((GPIOx->OSPEEDR))) & (~(((Pin * Pin) * (0x3UL << (0U)))))) | (((Pin * Pin) * Speed)))));
N}
N
N/**
N  * @brief  Return gpio speed for a dedicated pin on dedicated port.
N  * @note   I/O speed can be Low, Medium, Fast or High speed.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @note   Refer to datasheet for frequency specifications and the power
N  *         supply and load conditions for each speed.
N  * @rmtoll OSPEEDR      OSPEEDy       MS32_GPIO_GetPinSpeed
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_GPIO_SPEED_FREQ_LOW
N  *         @arg @ref MS32_GPIO_SPEED_FREQ_MEDIUM
N  *         @arg @ref MS32_GPIO_SPEED_FREQ_HIGH
N  */
N__STATIC_INLINE uint32_t MS32_GPIO_GetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin) {
Xstatic __inline uint32_t MS32_GPIO_GetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin) {
N  return (uint32_t)(READ_BIT(GPIOx->OSPEEDR, ((Pin * Pin) * GPIO_OSPEEDR_OSPEEDR0)) / (Pin * Pin));
X  return (uint32_t)(((GPIOx->OSPEEDR) & (((Pin * Pin) * (0x3UL << (0U))))) / (Pin * Pin));
N}
N
N/**
N  * @brief  Configure gpio pull-up or pull-down for a dedicated pin on a dedicated port.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @rmtoll PUPDR        PUPDy         MS32_GPIO_SetPinPull
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  * @param  Pull This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_PULL_NO
N  *         @arg @ref MS32_GPIO_PULL_UP
N  *         @arg @ref MS32_GPIO_PULL_DOWN
N  * @retval None
N  */
N__STATIC_INLINE void MS32_GPIO_SetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Pull) {
Xstatic __inline void MS32_GPIO_SetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Pull) {
N  MODIFY_REG(GPIOx->PUPDR, ((Pin * Pin) * GPIO_PUPDR_PUPDR0), ((Pin * Pin) * Pull));
X  (((GPIOx->PUPDR)) = ((((((GPIOx->PUPDR))) & (~(((Pin * Pin) * (0x3UL << (0U)))))) | (((Pin * Pin) * Pull)))));
N}
N
N/**
N  * @brief  Return gpio pull-up or pull-down for a dedicated pin on a dedicated port
N  * @note   Warning: only one pin can be passed as parameter.
N  * @rmtoll PUPDR        PUPDy         MS32_GPIO_GetPinPull
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_GPIO_PULL_NO
N  *         @arg @ref MS32_GPIO_PULL_UP
N  *         @arg @ref MS32_GPIO_PULL_DOWN
N  */
N__STATIC_INLINE uint32_t MS32_GPIO_GetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin) {
Xstatic __inline uint32_t MS32_GPIO_GetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin) {
N  return (uint32_t)(READ_BIT(GPIOx->PUPDR, ((Pin * Pin) * GPIO_PUPDR_PUPDR0)) / (Pin * Pin));
X  return (uint32_t)(((GPIOx->PUPDR) & (((Pin * Pin) * (0x3UL << (0U))))) / (Pin * Pin));
N}
N
N/**
N  * @brief  Configure gpio alternate function of a dedicated pin from 0 to 7 for a dedicated port.
N  * @note   Possible values are from AF0 to AF7 depending on target.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @rmtoll AFRL         AFSELy        MS32_GPIO_SetAFPin_0_7
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  * @param  Alternate This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_AF_0
N  *         @arg @ref MS32_GPIO_AF_1
N  *         @arg @ref MS32_GPIO_AF_2
N  *         @arg @ref MS32_GPIO_AF_3
N  *         @arg @ref MS32_GPIO_AF_4
N  *         @arg @ref MS32_GPIO_AF_5
N  *         @arg @ref MS32_GPIO_AF_6
N  *         @arg @ref MS32_GPIO_AF_7
N  * @retval None
N  */
N__STATIC_INLINE void MS32_GPIO_SetAFPin_0_7(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate) {
Xstatic __inline void MS32_GPIO_SetAFPin_0_7(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate) {
N  MODIFY_REG(GPIOx->AFRL, ((((Pin * Pin) * Pin) * Pin) * GPIO_AFRL_AFSEL0),
N             ((((Pin * Pin) * Pin) * Pin) * Alternate));
X  (((GPIOx->AFRL)) = ((((((GPIOx->AFRL))) & (~(((((Pin * Pin) * Pin) * Pin) * (0xFUL << (0U)))))) | (((((Pin * Pin) * Pin) * Pin) * Alternate)))));
N}
N
N/**
N  * @brief  Return gpio alternate function of a dedicated pin from 0 to 7 for a dedicated port.
N  * @rmtoll AFRL         AFSELy        MS32_GPIO_GetAFPin_0_7
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_GPIO_AF_0
N  *         @arg @ref MS32_GPIO_AF_1
N  *         @arg @ref MS32_GPIO_AF_2
N  *         @arg @ref MS32_GPIO_AF_3
N  *         @arg @ref MS32_GPIO_AF_4
N  *         @arg @ref MS32_GPIO_AF_5
N  *         @arg @ref MS32_GPIO_AF_6
N  *         @arg @ref MS32_GPIO_AF_7
N  */
N__STATIC_INLINE uint32_t MS32_GPIO_GetAFPin_0_7(GPIO_TypeDef *GPIOx, uint32_t Pin) {
Xstatic __inline uint32_t MS32_GPIO_GetAFPin_0_7(GPIO_TypeDef *GPIOx, uint32_t Pin) {
N  return (uint32_t)(READ_BIT(GPIOx->AFRL,
N                             ((((Pin * Pin) * Pin) * Pin) * GPIO_AFRL_AFSEL0)) / (((Pin * Pin) * Pin) * Pin));
X  return (uint32_t)(((GPIOx->AFRL) & (((((Pin * Pin) * Pin) * Pin) * (0xFUL << (0U))))) / (((Pin * Pin) * Pin) * Pin));
N}
N
N/**
N  * @brief  Configure gpio alternate function of a dedicated pin from 8 to 15 for a dedicated port.
N  * @note   Possible values are from AF0 to AF7 depending on target.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @rmtoll AFRH         AFSELy        MS32_GPIO_SetAFPin_8_15
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  * @param  Alternate This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_AF_0
N  *         @arg @ref MS32_GPIO_AF_1
N  *         @arg @ref MS32_GPIO_AF_2
N  *         @arg @ref MS32_GPIO_AF_3
N  *         @arg @ref MS32_GPIO_AF_4
N  *         @arg @ref MS32_GPIO_AF_5
N  *         @arg @ref MS32_GPIO_AF_6
N  *         @arg @ref MS32_GPIO_AF_7
N  * @retval None
N  */
N__STATIC_INLINE void MS32_GPIO_SetAFPin_8_15(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate) {
Xstatic __inline void MS32_GPIO_SetAFPin_8_15(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate) {
N  MODIFY_REG(GPIOx->AFRH, (((((Pin >> 8U) * (Pin >> 8U)) * (Pin >> 8U)) * (Pin >> 8U)) * GPIO_AFRH_AFSEL8),
N             (((((Pin >> 8U) * (Pin >> 8U)) * (Pin >> 8U)) * (Pin >> 8U)) * Alternate));
X  (((GPIOx->AFRH)) = ((((((GPIOx->AFRH))) & (~((((((Pin >> 8U) * (Pin >> 8U)) * (Pin >> 8U)) * (Pin >> 8U)) * (0xFUL << (0U)))))) | ((((((Pin >> 8U) * (Pin >> 8U)) * (Pin >> 8U)) * (Pin >> 8U)) * Alternate)))));
N}
N
N/**
N  * @brief  Return gpio alternate function of a dedicated pin from 8 to 15 for a dedicated port.
N  * @note   Possible values are from AF0 to AF7 depending on target.
N  * @rmtoll AFRH         AFSELy        MS32_GPIO_GetAFPin_8_15
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_GPIO_AF_0
N  *         @arg @ref MS32_GPIO_AF_1
N  *         @arg @ref MS32_GPIO_AF_2
N  *         @arg @ref MS32_GPIO_AF_3
N  *         @arg @ref MS32_GPIO_AF_4
N  *         @arg @ref MS32_GPIO_AF_5
N  *         @arg @ref MS32_GPIO_AF_6
N  *         @arg @ref MS32_GPIO_AF_7
N  */
N__STATIC_INLINE uint32_t MS32_GPIO_GetAFPin_8_15(GPIO_TypeDef *GPIOx, uint32_t Pin) {
Xstatic __inline uint32_t MS32_GPIO_GetAFPin_8_15(GPIO_TypeDef *GPIOx, uint32_t Pin) {
N  return (uint32_t)(READ_BIT(GPIOx->AFRH,
N                             (((((Pin >> 8U) * (Pin >> 8U)) * (Pin >> 8U)) * (Pin >> 8U)) * GPIO_AFRH_AFSEL8)) / ((((Pin >> 8U) *
X  return (uint32_t)(((GPIOx->AFRH) & ((((((Pin >> 8U) * (Pin >> 8U)) * (Pin >> 8U)) * (Pin >> 8U)) * (0xFUL << (0U))))) / ((((Pin >> 8U) *
N                                 (Pin >> 8U)) * (Pin >> 8U)) * (Pin >> 8U)));
N}
N
N
N/**
N  * @brief  Lock configuration of several pins for a dedicated port.
N  * @note   When the lock sequence has been applied on a port bit, the
N  *         value of this port bit can no longer be modified until the
N  *         next reset.
N  * @note   Each lock bit freezes a specific configuration register
N  *         (control and alternate function registers).
N  * @rmtoll LCKR         LCKK          MS32_GPIO_LockPin
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  *         @arg @ref MS32_GPIO_PIN_ALL
N  * @retval None
N  */
N__STATIC_INLINE void MS32_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint32_t PinMask) {
Xstatic __inline void MS32_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint32_t PinMask) {
N  __IO uint32_t temp;
X  volatile uint32_t temp;
N  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
X  ((GPIOx->LCKR) = ((0x1UL << (16U)) | PinMask));
N  WRITE_REG(GPIOx->LCKR, PinMask);
X  ((GPIOx->LCKR) = (PinMask));
N  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
X  ((GPIOx->LCKR) = ((0x1UL << (16U)) | PinMask));
N  temp = READ_REG(GPIOx->LCKR);
X  temp = ((GPIOx->LCKR));
N  (void) temp;
N}
N
N/**
N  * @brief  Return 1 if all pins passed as parameter, of a dedicated port, are locked. else Return 0.
N  * @rmtoll LCKR         LCKy          MS32_GPIO_IsPinLocked
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  *         @arg @ref MS32_GPIO_PIN_ALL
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_GPIO_IsPinLocked(GPIO_TypeDef *GPIOx, uint32_t PinMask) {
Xstatic __inline uint32_t MS32_GPIO_IsPinLocked(GPIO_TypeDef *GPIOx, uint32_t PinMask) {
N  return (READ_BIT(GPIOx->LCKR, PinMask) == (PinMask));
X  return (((GPIOx->LCKR) & (PinMask)) == (PinMask));
N}
N
N/**
N  * @brief  Return 1 if one of the pin of a dedicated port is locked. else return 0.
N  * @rmtoll LCKR         LCKK          MS32_GPIO_IsAnyPinLocked
N  * @param  GPIOx GPIO Port
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_GPIO_IsAnyPinLocked(GPIO_TypeDef *GPIOx) {
Xstatic __inline uint32_t MS32_GPIO_IsAnyPinLocked(GPIO_TypeDef *GPIOx) {
N  return (READ_BIT(GPIOx->LCKR, GPIO_LCKR_LCKK) == (GPIO_LCKR_LCKK));
X  return (((GPIOx->LCKR) & ((0x1UL << (16U)))) == ((0x1UL << (16U))));
N}
N
N
N/** @defgroup GPIO_EF_Data_Access Data Access
N  * @{
N  */
N
N/**
N  * @brief  Return full input data register value for a dedicated port.
N  * @rmtoll IDR          IDy           MS32_GPIO_ReadInputPort
N  * @param  GPIOx GPIO Port
N  * @retval Input data register value of port
N  */
N__STATIC_INLINE uint32_t MS32_GPIO_ReadInputPort(GPIO_TypeDef *GPIOx) {
Xstatic __inline uint32_t MS32_GPIO_ReadInputPort(GPIO_TypeDef *GPIOx) {
N  return (uint32_t)(READ_REG(GPIOx->IDR));
X  return (uint32_t)(((GPIOx->IDR)));
N}
N
N/**
N  * @brief  Return if input data level for several pins of dedicated port is high or low.
N  * @rmtoll IDR          IDy           MS32_GPIO_IsInputPinSet
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  *         @arg @ref MS32_GPIO_PIN_ALL
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_GPIO_IsInputPinSet(GPIO_TypeDef *GPIOx, uint32_t PinMask) {
Xstatic __inline uint32_t MS32_GPIO_IsInputPinSet(GPIO_TypeDef *GPIOx, uint32_t PinMask) {
N  return (READ_BIT(GPIOx->IDR, PinMask) == (PinMask));
X  return (((GPIOx->IDR) & (PinMask)) == (PinMask));
N}
N
N/**
N  * @brief  Write output data register for the port.
N  * @rmtoll ODR          ODy           MS32_GPIO_WriteOutputPort
N  * @param  GPIOx GPIO Port
N  * @param  PortValue Level value for each pin of the port
N  * @retval None
N  */
N__STATIC_INLINE void MS32_GPIO_WriteOutputPort(GPIO_TypeDef *GPIOx, uint32_t PortValue) {
Xstatic __inline void MS32_GPIO_WriteOutputPort(GPIO_TypeDef *GPIOx, uint32_t PortValue) {
N  WRITE_REG(GPIOx->ODR, PortValue);
X  ((GPIOx->ODR) = (PortValue));
N}
N
N/**
N  * @brief  Return full output data register value for a dedicated port.
N  * @rmtoll ODR          ODy           MS32_GPIO_ReadOutputPort
N  * @param  GPIOx GPIO Port
N  * @retval Output data register value of port
N  */
N__STATIC_INLINE uint32_t MS32_GPIO_ReadOutputPort(GPIO_TypeDef *GPIOx) {
Xstatic __inline uint32_t MS32_GPIO_ReadOutputPort(GPIO_TypeDef *GPIOx) {
N  return (uint32_t)(READ_REG(GPIOx->ODR));
X  return (uint32_t)(((GPIOx->ODR)));
N}
N
N/**
N  * @brief  Return if input data level for several pins of dedicated port is high or low.
N  * @rmtoll ODR          ODy           MS32_GPIO_IsOutputPinSet
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  *         @arg @ref MS32_GPIO_PIN_ALL
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_GPIO_IsOutputPinSet(GPIO_TypeDef *GPIOx, uint32_t PinMask) {
Xstatic __inline uint32_t MS32_GPIO_IsOutputPinSet(GPIO_TypeDef *GPIOx, uint32_t PinMask) {
N  return (READ_BIT(GPIOx->ODR, PinMask) == (PinMask));
X  return (((GPIOx->ODR) & (PinMask)) == (PinMask));
N}
N
N/**
N  * @brief  Set several pins to high level on dedicated gpio port.
N  * @rmtoll BSRR         BSy           MS32_GPIO_SetOutputPin
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  *         @arg @ref MS32_GPIO_PIN_ALL
N  * @retval None
N  */
N__STATIC_INLINE void MS32_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask) {
Xstatic __inline void MS32_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask) {
N  WRITE_REG(GPIOx->BSRR, PinMask);
X  ((GPIOx->BSRR) = (PinMask));
N}
N
N/**
N  * @brief  Set several pins to low level on dedicated gpio port.
N  * @rmtoll BRR          BRy           MS32_GPIO_ResetOutputPin
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  *         @arg @ref MS32_GPIO_PIN_ALL
N  * @retval None
N  */
N__STATIC_INLINE void MS32_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask) {
Xstatic __inline void MS32_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask) {
N  WRITE_REG(GPIOx->BRR, PinMask);
X  ((GPIOx->BRR) = (PinMask));
N}
N
N/**
N  * @brief  Toggle data value for several pin of dedicated port.
N  * @rmtoll ODR          ODy           MS32_GPIO_TogglePin
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref MS32_GPIO_PIN_0
N  *         @arg @ref MS32_GPIO_PIN_1
N  *         @arg @ref MS32_GPIO_PIN_2
N  *         @arg @ref MS32_GPIO_PIN_3
N  *         @arg @ref MS32_GPIO_PIN_4
N  *         @arg @ref MS32_GPIO_PIN_5
N  *         @arg @ref MS32_GPIO_PIN_6
N  *         @arg @ref MS32_GPIO_PIN_7
N  *         @arg @ref MS32_GPIO_PIN_8
N  *         @arg @ref MS32_GPIO_PIN_9
N  *         @arg @ref MS32_GPIO_PIN_10
N  *         @arg @ref MS32_GPIO_PIN_11
N  *         @arg @ref MS32_GPIO_PIN_12
N  *         @arg @ref MS32_GPIO_PIN_13
N  *         @arg @ref MS32_GPIO_PIN_14
N  *         @arg @ref MS32_GPIO_PIN_15
N  *         @arg @ref MS32_GPIO_PIN_ALL
N  * @retval None
N  */
N__STATIC_INLINE void MS32_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint32_t PinMask) {
Xstatic __inline void MS32_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint32_t PinMask) {
N  WRITE_REG(GPIOx->ODR, READ_REG(GPIOx->ODR) ^ PinMask);
X  ((GPIOx->ODR) = (((GPIOx->ODR)) ^ PinMask));
N}
N
N
N/** @defgroup GPIO_EF_Init Initialization and de-initialization functions
N  * @{
N  */
NErrorStatus MS32_GPIO_DeInit     (GPIO_TypeDef *GPIOx);
Nvoid        MS32_GPIO_StructInit (MS32_GPIO_InitTypeDef *GpioInitStr);
NErrorStatus MS32_GPIO_Init       (GPIO_TypeDef *GPIOx, MS32_GPIO_InitTypeDef *GpioInitStr);
N
N/** @defgroup GPIO_EF_Application function
N  * @{
N  */
Nvoid        MS32_GPIO_Output     (GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Output);
NLevelStatus MS32_GPIO_Input      (GPIO_TypeDef *GPIOx, uint32_t Pin);
NErrorStatus MS32_GPIO_Lock       (GPIO_TypeDef *GPIOx, uint32_t Pin);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_GPIO_H */
N
N/******************************** END OF FILE *********************************/
L 72 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_i2c.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_i2c.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_I2C_H
N#define __MS32F0XX_I2C_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup I2C_ES_INIT I2C Exported Init structure
N  * @{
N  */
Ntypedef struct {
N  uint32_t PeripheralMode;      /*!< Specifies the peripheral mode.
N                                     This parameter can be a value of @ref I2C_EC_PERIPHERAL_MODE
N                                     This feature can be modified afterwards using unitary function @ref MS32_I2C_SetMode(). */
N  uint32_t Timing;              /*!< Specifies the SDA setup, hold time and the SCL high, low period values.
N                                     This parameter must be set by referring to the macro @ref __MS32_I2C_CONVERT_TIMINGS()
N                                     This feature can be modified afterwards using unitary function @ref MS32_I2C_SetTiming(). */
N  uint32_t AnalogFilter;        /*!< Enables or disables analog noise filter.
N                                     This parameter can be a value of @ref I2C_EC_ANALOGFILTER_SELECTION
N                                     This feature can be modified afterwards using unitary functions @ref MS32_I2C_EnableAnalogFilter() or MS32_I2C_DisableAnalogFilter(). */
N  uint32_t DigitalFilter;       /*!< Configures the digital noise filter.
N                                     This parameter can be a number between Min_Data = 0x00 and Max_Data = 0x0F
N                                     This feature can be modified afterwards using unitary function @ref MS32_I2C_SetDigitalFilter(). */
N  uint32_t OwnAddress1;         /*!< Specifies the device own address 1.
N                                     This parameter must be a value between Min_Data = 0x00 and Max_Data = 0x3FF
N                                     This feature can be modified afterwards using unitary function @ref MS32_I2C_SetOwnAddress1(). */
N  uint32_t TypeAcknowledge;     /*!< Specifies the ACKnowledge or Non ACKnowledge condition after the address receive match code or next received byte.
N                                     This parameter can be a value of @ref I2C_EC_I2C_ACKNOWLEDGE
N                                     This feature can be modified afterwards using unitary function @ref MS32_I2C_AcknowledgeNextData(). */
N  uint32_t OwnAddrSize;         /*!< Specifies the device own address 1 size (7-bit or 10-bit).
N                                     This parameter can be a value of @ref I2C_EC_OWNADDRESS1
N                                     This feature can be modified afterwards using unitary function @ref MS32_I2C_SetOwnAddress1(). */
N} MS32_I2C_InitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup I2C_EC_CLEAR_FLAG Clear Flags Defines
N  * @brief    Flags defines which can be used with MS32_I2C_WriteReg function
N  * @{
N  */
N#define MS32_I2C_ICR_ADDRCF                   I2C_ICR_ADDRCF          /*!< Address Matched flag   */
N#define MS32_I2C_ICR_NACKCF                   I2C_ICR_NACKCF          /*!< Not Acknowledge flag   */
N#define MS32_I2C_ICR_STOPCF                   I2C_ICR_STOPCF          /*!< Stop detection flag    */
N#define MS32_I2C_ICR_BERRCF                   I2C_ICR_BERRCF          /*!< Bus error flag         */
N#define MS32_I2C_ICR_ARLOCF                   I2C_ICR_ARLOCF          /*!< Arbitration Lost flag  */
N#define MS32_I2C_ICR_OVRCF                    I2C_ICR_OVRCF           /*!< Overrun/Underrun flag  */
N#define MS32_I2C_ICR_PECCF                    I2C_ICR_PECCF           /*!< PEC error flag         */
N#define MS32_I2C_ICR_TIMOUTCF                 I2C_ICR_TIMOUTCF        /*!< Timeout detection flag */
N#define MS32_I2C_ICR_ALERTCF                  I2C_ICR_ALERTCF         /*!< Alert flag             */
N
N#define MS32_I2C_ICR_ALLCF                    (I2C_ICR_ADDRCF | I2C_ICR_NACKCF | I2C_ICR_STOPCF   | I2C_ICR_BERRCF | I2C_ICR_ARLOCF |\
N                                               I2C_ICR_OVRCF  | I2C_ICR_PECCF  | I2C_ICR_TIMOUTCF | I2C_ICR_ALERTCF)
X#define MS32_I2C_ICR_ALLCF                    (I2C_ICR_ADDRCF | I2C_ICR_NACKCF | I2C_ICR_STOPCF   | I2C_ICR_BERRCF | I2C_ICR_ARLOCF |                                               I2C_ICR_OVRCF  | I2C_ICR_PECCF  | I2C_ICR_TIMOUTCF | I2C_ICR_ALERTCF)
N
N
N/** @defgroup I2C_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with MS32_I2C_ReadReg function
N  * @{
N  */
N#define MS32_I2C_ISR_TXE                      I2C_ISR_TXE             /*!< Transmit data register empty        */
N#define MS32_I2C_ISR_TXIS                     I2C_ISR_TXIS            /*!< Transmit interrupt status           */
N#define MS32_I2C_ISR_RXNE                     I2C_ISR_RXNE            /*!< Receive data register not empty     */
N#define MS32_I2C_ISR_ADDR                     I2C_ISR_ADDR            /*!< Address matched (slave mode)        */
N#define MS32_I2C_ISR_NACKF                    I2C_ISR_NACKF           /*!< Not Acknowledge received flag       */
N#define MS32_I2C_ISR_STOPF                    I2C_ISR_STOPF           /*!< Stop detection flag                 */
N#define MS32_I2C_ISR_TC                       I2C_ISR_TC              /*!< Transfer Complete (master mode)     */
N#define MS32_I2C_ISR_TCR                      I2C_ISR_TCR             /*!< Transfer Complete Reload            */
N#define MS32_I2C_ISR_BERR                     I2C_ISR_BERR            /*!< Bus error                           */
N#define MS32_I2C_ISR_ARLO                     I2C_ISR_ARLO            /*!< Arbitration lost                    */
N#define MS32_I2C_ISR_OVR                      I2C_ISR_OVR             /*!< Overrun/Underrun (slave mode)       */
N#define MS32_I2C_ISR_PECERR                   I2C_ISR_PECERR          /*!< PEC Error in reception (SMBus mode) */
N#define MS32_I2C_ISR_TIMEOUT                  I2C_ISR_TIMEOUT         /*!< Timeout detection flag (SMBus mode) */
N#define MS32_I2C_ISR_ALERT                    I2C_ISR_ALERT           /*!< SMBus alert (SMBus mode)            */
N#define MS32_I2C_ISR_BUSY                     I2C_ISR_BUSY            /*!< Bus busy                            */
N
N#define MS32_I2C_ISR_ALLIF                    (I2C_ISR_TXIS | I2C_ISR_RXNE | I2C_ISR_ADDR | I2C_ISR_NACKF | I2C_ISR_STOPF  | I2C_ISR_TC      |\
N                                               I2C_ISR_TCR  | I2C_ISR_BERR | I2C_ISR_ARLO | I2C_ISR_OVR   | I2C_ISR_PECERR | I2C_ISR_TIMEOUT | I2C_ISR_ALERT)
X#define MS32_I2C_ISR_ALLIF                    (I2C_ISR_TXIS | I2C_ISR_RXNE | I2C_ISR_ADDR | I2C_ISR_NACKF | I2C_ISR_STOPF  | I2C_ISR_TC      |                                               I2C_ISR_TCR  | I2C_ISR_BERR | I2C_ISR_ARLO | I2C_ISR_OVR   | I2C_ISR_PECERR | I2C_ISR_TIMEOUT | I2C_ISR_ALERT)
N
N
N/** @defgroup I2C_EC_IT IT Defines
N  * @brief    IT defines which can be used with MS32_I2C_ReadReg and  MS32_I2C_WriteReg functions
N  * @{
N  */
N#define MS32_I2C_CR1_TXIE                     I2C_CR1_TXIE            /*!< TX Interrupt enable                         */
N#define MS32_I2C_CR1_RXIE                     I2C_CR1_RXIE            /*!< RX Interrupt enable                         */
N#define MS32_I2C_CR1_ADDRIE                   I2C_CR1_ADDRIE          /*!< Address match Interrupt enable (slave only) */
N#define MS32_I2C_CR1_NACKIE                   I2C_CR1_NACKIE          /*!< Not acknowledge received Interrupt enable   */
N#define MS32_I2C_CR1_STOPIE                   I2C_CR1_STOPIE          /*!< STOP detection Interrupt enable             */
N#define MS32_I2C_CR1_TCIE                     I2C_CR1_TCIE            /*!< Transfer Complete interrupt enable          */
N#define MS32_I2C_CR1_ERRIE                    I2C_CR1_ERRIE           /*!< Error interrupts enable                     */
N
N#define MS32_I2C_CR1_ALLIE                    (I2C_CR1_TXIE   | I2C_CR1_RXIE | I2C_CR1_ADDRIE | I2C_CR1_NACKIE |\
N                                               I2C_CR1_STOPIE | I2C_CR1_TCIE | I2C_CR1_ERRIE)
X#define MS32_I2C_CR1_ALLIE                    (I2C_CR1_TXIE   | I2C_CR1_RXIE | I2C_CR1_ADDRIE | I2C_CR1_NACKIE |                                               I2C_CR1_STOPIE | I2C_CR1_TCIE | I2C_CR1_ERRIE)
N
N
N/** @defgroup I2C_EC_PERIPHERAL_MODE Peripheral Mode
N  * @{
N  */
N#define MS32_I2C_MODE_I2C                    0x00000000U              /*!< I2C Master or Slave mode                                    */
N#define MS32_I2C_MODE_SMBUS_HOST             I2C_CR1_SMBHEN           /*!< SMBus Host address acknowledge                              */
N#define MS32_I2C_MODE_SMBUS_DEVICE           0x00000000U              /*!< SMBus Device default mode (Default address not acknowledge) */
N#define MS32_I2C_MODE_SMBUS_DEVICE_ARP       I2C_CR1_SMBDEN           /*!< SMBus Device Default address acknowledge                    */
N
N
N/** @defgroup I2C_EC_ANALOGFILTER_SELECTION Analog Filter Selection
N  * @{
N  */
N#define MS32_I2C_ANALOGFILTER_ENABLE          0x00000000U             /*!< Analog filter is enabled.  */
N#define MS32_I2C_ANALOGFILTER_DISABLE         I2C_CR1_ANFOFF          /*!< Analog filter is disabled. */
N
N
N/** @defgroup I2C_EC_ADDRESSING_MODE Master Addressing Mode
N  * @{
N  */
N#define MS32_I2C_ADDRESSING_MODE_7BIT         0x00000000U             /*!< Master operates in 7-bit addressing mode. */
N#define MS32_I2C_ADDRESSING_MODE_10BIT        I2C_CR2_ADD10           /*!< Master operates in 10-bit addressing mode.*/
N
N
N/** @defgroup I2C_EC_OWNADDRESS1 Own Address 1 Length
N  * @{
N  */
N#define MS32_I2C_OWNADDRESS1_7BIT             0x00000000U             /*!< Own address 1 is a 7-bit address. */
N#define MS32_I2C_OWNADDRESS1_10BIT            I2C_OAR1_OA1MODE        /*!< Own address 1 is a 10-bit address.*/
N
N
N/** @defgroup I2C_EC_OWNADDRESS2 Own Address 2 Masks
N  * @{
N  */
N#define MS32_I2C_OWNADDRESS2_NOMASK           I2C_OAR2_OA2NOMASK      /*!< Own Address2 No mask.                                */
N#define MS32_I2C_OWNADDRESS2_MASK01           I2C_OAR2_OA2MASK01      /*!< Only Address2 bits[7:2] are compared.                */
N#define MS32_I2C_OWNADDRESS2_MASK02           I2C_OAR2_OA2MASK02      /*!< Only Address2 bits[7:3] are compared.                */
N#define MS32_I2C_OWNADDRESS2_MASK03           I2C_OAR2_OA2MASK03      /*!< Only Address2 bits[7:4] are compared.                */
N#define MS32_I2C_OWNADDRESS2_MASK04           I2C_OAR2_OA2MASK04      /*!< Only Address2 bits[7:5] are compared.                */
N#define MS32_I2C_OWNADDRESS2_MASK05           I2C_OAR2_OA2MASK05      /*!< Only Address2 bits[7:6] are compared.                */
N#define MS32_I2C_OWNADDRESS2_MASK06           I2C_OAR2_OA2MASK06      /*!< Only Address2 bits[7] are compared.                  */
N#define MS32_I2C_OWNADDRESS2_MASK07           I2C_OAR2_OA2MASK07      /*!< No comparison is done. All Address2 are acknowledged.*/
N
N
N/** @defgroup I2C_EC_I2C_ACKNOWLEDGE Acknowledge Generation
N  * @{
N  */
N#define MS32_I2C_ACK                          0x00000000U              /*!< ACK is sent after current received byte. */
N#define MS32_I2C_NACK                         I2C_CR2_NACK             /*!< NACK is sent after current received byte.*/
N
N
N/** @defgroup I2C_EC_ADDRSLAVE Slave Address Length
N  * @{
N  */
N#define MS32_I2C_ADDRSLAVE_7BIT               0x00000000U              /*!< Slave Address in 7-bit. */
N#define MS32_I2C_ADDRSLAVE_10BIT              I2C_CR2_ADD10            /*!< Slave Address in 10-bit.*/
N
N
N/** @defgroup I2C_EC_REQUEST Transfer Request Direction
N  * @{
N  */
N#define MS32_I2C_REQUEST_WRITE                0x00000000U              /*!< Master request a write transfer. */
N#define MS32_I2C_REQUEST_READ                 I2C_CR2_RD_WRN           /*!< Master request a read transfer.  */
N
N
N/** @defgroup I2C_EC_MODE Transfer End Mode
N  * @{
N  */
N#define MS32_I2C_MODE_RELOAD                  I2C_CR2_RELOAD                                      /*!< Enable I2C Reload mode.                                   */
N#define MS32_I2C_MODE_AUTOEND                 I2C_CR2_AUTOEND                                     /*!< Enable I2C Automatic end mode with no HW PEC comparison.  */
N#define MS32_I2C_MODE_SOFTEND                 0x00000000U                                         /*!< Enable I2C Software end mode with no HW PEC comparison.   */
N#define MS32_I2C_MODE_SMBUS_RELOAD            MS32_I2C_MODE_RELOAD                                  /*!< Enable SMBUS Automatic end mode with HW PEC comparison.   */
N#define MS32_I2C_MODE_SMBUS_AUTOEND_NO_PEC    MS32_I2C_MODE_AUTOEND                                 /*!< Enable SMBUS Automatic end mode with HW PEC comparison.   */
N#define MS32_I2C_MODE_SMBUS_SOFTEND_NO_PEC    MS32_I2C_MODE_SOFTEND                                 /*!< Enable SMBUS Software end mode with HW PEC comparison.    */
N#define MS32_I2C_MODE_SMBUS_AUTOEND_WITH_PEC  (uint32_t)(MS32_I2C_MODE_AUTOEND | I2C_CR2_PECBYTE)   /*!< Enable SMBUS Automatic end mode with HW PEC comparison.   */
N#define MS32_I2C_MODE_SMBUS_SOFTEND_WITH_PEC  (uint32_t)(MS32_I2C_MODE_SOFTEND | I2C_CR2_PECBYTE)   /*!< Enable SMBUS Software end mode with HW PEC comparison.    */
N
N
N/** @defgroup I2C_EC_GENERATE Start And Stop Generation
N  * @{
N  */
N#define MS32_I2C_GENERATE_NOSTARTSTOP         0x00000000U                                                                /*!< Don't Generate Stop and Start condition.                */
N#define MS32_I2C_GENERATE_STOP                (uint32_t)(0x80000000U | I2C_CR2_STOP)                                     /*!< Generate Stop condition (Size should be set to 0).      */
N#define MS32_I2C_GENERATE_START_READ          (uint32_t)(0x80000000U | I2C_CR2_START | I2C_CR2_RD_WRN)                   /*!< Generate Start for read request.                        */
N#define MS32_I2C_GENERATE_START_WRITE         (uint32_t)(0x80000000U | I2C_CR2_START)                                    /*!< Generate Start for write request.                       */
N#define MS32_I2C_GENERATE_RESTART_7BIT_READ   (uint32_t)(0x80000000U | I2C_CR2_START | I2C_CR2_RD_WRN)                   /*!< Generate Restart for read request, slave 7Bit address.  */
N#define MS32_I2C_GENERATE_RESTART_7BIT_WRITE  (uint32_t)(0x80000000U | I2C_CR2_START)                                    /*!< Generate Restart for write request, slave 7Bit address. */
N#define MS32_I2C_GENERATE_RESTART_10BIT_READ  (uint32_t)(0x80000000U | I2C_CR2_START | I2C_CR2_RD_WRN | I2C_CR2_HEAD10R) /*!< Generate Restart for read request, slave 10Bit address. */
N#define MS32_I2C_GENERATE_RESTART_10BIT_WRITE (uint32_t)(0x80000000U | I2C_CR2_START)                                    /*!< Generate Restart for write request, slave 10Bit address.*/
N
N
N/** @defgroup I2C_EC_DIRECTION Read Write Direction
N  * @{
N  */
N#define MS32_I2C_DIRECTION_WRITE              0x00000000U              /*!< Write transfer request by master, slave enters receiver mode.  */
N#define MS32_I2C_DIRECTION_READ               I2C_ISR_DIR              /*!< Read transfer request by master, slave enters transmitter mode.*/
N
N
N/** @defgroup I2C_EC_DMA_REG_DATA DMA Register Data
N  * @{
N  */
N#define MS32_I2C_DMA_REG_DATA_TRANSMIT        0x00000000U              /*!< Get address of data register used for transmission */
N#define MS32_I2C_DMA_REG_DATA_RECEIVE         0x00000001U              /*!< Get address of data register used for reception */
N
N
N/** @defgroup I2C_EC_SMBUS_TIMEOUTA_MODE SMBus TimeoutA Mode SCL SDA Timeout
N  * @{
N  */
N#define MS32_I2C_SMBUS_TIMEOUTA_MODE_SCL_LOW      0x00000000U          /*!< TimeoutA is used to detect SCL low level timeout.              */
N#define MS32_I2C_SMBUS_TIMEOUTA_MODE_SDA_SCL_HIGH I2C_TIMEOUTR_TIDLE   /*!< TimeoutA is used to detect both SCL and SDA high level timeout.*/
N
N
N/** @defgroup I2C_EC_SMBUS_TIMEOUT_SELECTION SMBus Timeout Selection
N  * @{
N  */
N#define MS32_I2C_SMBUS_TIMEOUTA               I2C_TIMEOUTR_TIMOUTEN                                   /*!< TimeoutA enable bit                                */
N#define MS32_I2C_SMBUS_TIMEOUTB               I2C_TIMEOUTR_TEXTEN                                     /*!< TimeoutB (extended clock) enable bit               */
N#define MS32_I2C_SMBUS_AMS32_TIMEOUT            (uint32_t)(I2C_TIMEOUTR_TIMOUTEN | I2C_TIMEOUTR_TEXTEN) /*!< TimeoutA and TimeoutB (extended clock) enable bits */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup I2C_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in I2C register
N  * @param  __INSTANCE__ I2C Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_I2C_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in I2C register
N  * @param  __INSTANCE__ I2C Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_I2C_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N
N
N/** @defgroup I2C_EM_CONVERT_TIMINGS Convert SDA SCL timings
N  * @{
N  */
N
N/**
N  * @brief  Configure the SDA setup, hold time and the SCL high, low period.
N  * @param  __PRESCALER__ This parameter must be a value between  Min_Data=0 and Max_Data=0xF.
N  * @param  __DATA_SETUP_TIME__ This parameter must be a value between Min_Data=0 and Max_Data=0xF. (tscldel = (SCLDEL+1)xtpresc)
N  * @param  __DATA_HOLD_TIME__ This parameter must be a value between Min_Data=0 and Max_Data=0xF. (tsdadel = SDADELxtpresc)
N  * @param  __CLOCK_HIGH_PERIOD__ This parameter must be a value between Min_Data=0 and Max_Data=0xFF. (tsclh = (SCLH+1)xtpresc)
N  * @param  __CLOCK_LOW_PERIOD__ This parameter must be a value between  Min_Data=0 and Max_Data=0xFF. (tscll = (SCLL+1)xtpresc)
N  * @retval Value between Min_Data=0 and Max_Data=0xFFFFFFFF
N  */
N#define __MS32_I2C_CONVERT_TIMINGS(__PRESCALER__, __DATA_SETUP_TIME__, __DATA_HOLD_TIME__, __CLOCK_HIGH_PERIOD__, __CLOCK_LOW_PERIOD__)   \
N        ((((uint32_t)(__PRESCALER__)         << I2C_TIMINGR_PRESC_Pos)  & I2C_TIMINGR_PRESC)   | \
N         (((uint32_t)(__DATA_SETUP_TIME__)   << I2C_TIMINGR_SCLDEL_Pos) & I2C_TIMINGR_SCLDEL)  | \
N         (((uint32_t)(__DATA_HOLD_TIME__)    << I2C_TIMINGR_SDADEL_Pos) & I2C_TIMINGR_SDADEL)  | \
N         (((uint32_t)(__CLOCK_HIGH_PERIOD__) << I2C_TIMINGR_SCLH_Pos)   & I2C_TIMINGR_SCLH)    | \
N         (((uint32_t)(__CLOCK_LOW_PERIOD__)  << I2C_TIMINGR_SCMS32_Pos)   & I2C_TIMINGR_SCLL))
X#define __MS32_I2C_CONVERT_TIMINGS(__PRESCALER__, __DATA_SETUP_TIME__, __DATA_HOLD_TIME__, __CLOCK_HIGH_PERIOD__, __CLOCK_LOW_PERIOD__)           ((((uint32_t)(__PRESCALER__)         << I2C_TIMINGR_PRESC_Pos)  & I2C_TIMINGR_PRESC)   |          (((uint32_t)(__DATA_SETUP_TIME__)   << I2C_TIMINGR_SCLDEL_Pos) & I2C_TIMINGR_SCLDEL)  |          (((uint32_t)(__DATA_HOLD_TIME__)    << I2C_TIMINGR_SDADEL_Pos) & I2C_TIMINGR_SDADEL)  |          (((uint32_t)(__CLOCK_HIGH_PERIOD__) << I2C_TIMINGR_SCLH_Pos)   & I2C_TIMINGR_SCLH)    |          (((uint32_t)(__CLOCK_LOW_PERIOD__)  << I2C_TIMINGR_SCMS32_Pos)   & I2C_TIMINGR_SCLL))
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup I2C_EF_Configuration Configuration
N  * @{
N  */
N
N/**
N  * @brief  Enable I2C peripheral (PE = 1).
N  * @rmtoll CR1          PE            MS32_I2C_Enable
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_Enable(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_Enable(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_PE);
X  ((I2Cx->CR1) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable I2C peripheral (PE = 0).
N  * @note   When PE = 0, the I2C SCL and SDA lines are released.
N  *         Internal state machines and status bits are put back to their reset value.
N  *         When cleared, PE must be kept low for at least 3 APB clock cycles.
N  * @rmtoll CR1          PE            MS32_I2C_Disable
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_Disable(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_Disable(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_PE);
X  ((I2Cx->CR1) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if the I2C peripheral is enabled or disabled.
N  * @rmtoll CR1          PE            MS32_I2C_IsEnabled
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabled(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabled(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_PE) == (I2C_CR1_PE)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Configure Noise Filters (Analog and Digital).
N  * @note   If the analog filter is also enabled, the digital filter is added to analog filter.
N  *         The filters can only be programmed when the I2C is disabled (PE = 0).
N  * @rmtoll CR1          ANFOFF        MS32_I2C_ConfigFilters\n
N  *         CR1          DNF           MS32_I2C_ConfigFilters
N  * @param  I2Cx I2C Instance.
N  * @param  AnalogFilter This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_ANALOGFILTER_ENABLE
N  *         @arg @ref MS32_I2C_ANALOGFILTER_DISABLE
N  * @param  DigitalFilter This parameter must be a value between Min_Data=0x00 (Digital filter disabled) and Max_Data=0x0F (Digital filter enabled and filtering capability up to 15*ti2cclk).
N  *         This parameter is used to configure the digital noise filter on SDA and SCL input.
N  *         The digital filter will filter spikes with a length of up to DNF[3:0]*ti2cclk.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_ConfigFilters(I2C_TypeDef *I2Cx, uint32_t AnalogFilter, uint32_t DigitalFilter) {
Xstatic __inline void MS32_I2C_ConfigFilters(I2C_TypeDef *I2Cx, uint32_t AnalogFilter, uint32_t DigitalFilter) {
N  MODIFY_REG(I2Cx->CR1, I2C_CR1_ANFOFF | I2C_CR1_DNF, AnalogFilter | (DigitalFilter << I2C_CR1_DNF_Pos));
X  (((I2Cx->CR1)) = ((((((I2Cx->CR1))) & (~((0x1UL << (12U)) | (0xFUL << (8U))))) | (AnalogFilter | (DigitalFilter << (8U))))));
N}
N
N/**
N  * @brief  Configure Digital Noise Filter.
N  * @note   If the analog filter is also enabled, the digital filter is added to analog filter.
N  *         This filter can only be programmed when the I2C is disabled (PE = 0).
N  * @rmtoll CR1          DNF           MS32_I2C_SetDigitalFilter
N  * @param  I2Cx I2C Instance.
N  * @param  DigitalFilter This parameter must be a value between Min_Data=0x00 (Digital filter disabled) and Max_Data=0x0F (Digital filter enabled and filtering capability up to 15*ti2cclk).
N  *         This parameter is used to configure the digital noise filter on SDA and SCL input.
N  *         The digital filter will filter spikes with a length of up to DNF[3:0]*ti2cclk.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_SetDigitalFilter(I2C_TypeDef *I2Cx, uint32_t DigitalFilter) {
Xstatic __inline void MS32_I2C_SetDigitalFilter(I2C_TypeDef *I2Cx, uint32_t DigitalFilter) {
N  MODIFY_REG(I2Cx->CR1, I2C_CR1_DNF, DigitalFilter << I2C_CR1_DNF_Pos);
X  (((I2Cx->CR1)) = ((((((I2Cx->CR1))) & (~((0xFUL << (8U))))) | (DigitalFilter << (8U)))));
N}
N
N/**
N  * @brief  Get the current Digital Noise Filter configuration.
N  * @rmtoll CR1          DNF           MS32_I2C_GetDigitalFilter
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x0 and Max_Data=0xF
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetDigitalFilter(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetDigitalFilter(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->CR1, I2C_CR1_DNF) >> I2C_CR1_DNF_Pos);
X  return (uint32_t)(((I2Cx->CR1) & ((0xFUL << (8U)))) >> (8U));
N}
N
N/**
N  * @brief  Enable Analog Noise Filter.
N  * @note   This filter can only be programmed when the I2C is disabled (PE = 0).
N  * @rmtoll CR1          ANFOFF        MS32_I2C_EnableAnalogFilter
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableAnalogFilter(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableAnalogFilter(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_ANFOFF);
X  ((I2Cx->CR1) &= ~((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Disable Analog Noise Filter.
N  * @note   This filter can only be programmed when the I2C is disabled (PE = 0).
N  * @rmtoll CR1          ANFOFF        MS32_I2C_DisableAnalogFilter
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableAnalogFilter(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableAnalogFilter(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_ANFOFF);
X  ((I2Cx->CR1) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Check if Analog Noise Filter is enabled or disabled.
N  * @rmtoll CR1          ANFOFF        MS32_I2C_IsEnabledAnalogFilter
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledAnalogFilter(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledAnalogFilter(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_ANFOFF) != (I2C_CR1_ANFOFF)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (12U)))) != ((0x1UL << (12U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable DMA transmission requests.
N  * @rmtoll CR1          TXDMAEN       MS32_I2C_EnableDMAReq_TX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableDMAReq_TX(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableDMAReq_TX(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_TXDMAEN);
X  ((I2Cx->CR1) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Disable DMA transmission requests.
N  * @rmtoll CR1          TXDMAEN       MS32_I2C_DisableDMAReq_TX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableDMAReq_TX(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableDMAReq_TX(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_TXDMAEN);
X  ((I2Cx->CR1) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Check if DMA transmission requests are enabled or disabled.
N  * @rmtoll CR1          TXDMAEN       MS32_I2C_IsEnabledDMAReq_TX
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledDMAReq_TX(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledDMAReq_TX(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_TXDMAEN) == (I2C_CR1_TXDMAEN)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (14U)))) == ((0x1UL << (14U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable DMA reception requests.
N  * @rmtoll CR1          RXDMAEN       MS32_I2C_EnableDMAReq_RX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableDMAReq_RX(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableDMAReq_RX(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_RXDMAEN);
X  ((I2Cx->CR1) |= ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Disable DMA reception requests.
N  * @rmtoll CR1          RXDMAEN       MS32_I2C_DisableDMAReq_RX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableDMAReq_RX(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableDMAReq_RX(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_RXDMAEN);
X  ((I2Cx->CR1) &= ~((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Check if DMA reception requests are enabled or disabled.
N  * @rmtoll CR1          RXDMAEN       MS32_I2C_IsEnabledDMAReq_RX
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledDMAReq_RX(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledDMAReq_RX(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_RXDMAEN) == (I2C_CR1_RXDMAEN)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (15U)))) == ((0x1UL << (15U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get the data register address used for DMA transfer
N  * @rmtoll TXDR         TXDATA        MS32_I2C_DMA_GetRegAddr\n
N  *         RXDR         RXDATA        MS32_I2C_DMA_GetRegAddr
N  * @param  I2Cx I2C Instance
N  * @param  Direction This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_DMA_REG_DATA_TRANSMIT
N  *         @arg @ref MS32_I2C_DMA_REG_DATA_RECEIVE
N  * @retval Address of data register
N  */
N__STATIC_INLINE uint32_t MS32_I2C_DMA_GetRegAddr(I2C_TypeDef *I2Cx, uint32_t Direction) {
Xstatic __inline uint32_t MS32_I2C_DMA_GetRegAddr(I2C_TypeDef *I2Cx, uint32_t Direction) {
N  register uint32_t data_reg_addr;
N
N  if (Direction == MS32_I2C_DMA_REG_DATA_TRANSMIT) {
X  if (Direction == 0x00000000U) {
N    /* return address of TXDR register */
N    data_reg_addr = (uint32_t) & (I2Cx->TXDR);
N  } else {
N    /* return address of RXDR register */
N    data_reg_addr = (uint32_t) & (I2Cx->RXDR);
N  }
N
N  return data_reg_addr;
N}
N
N/**
N  * @brief  Enable Clock stretching.
N  * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
N  * @rmtoll CR1          NOSTRETCH     MS32_I2C_EnableClockStretching
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableClockStretching(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableClockStretching(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH);
X  ((I2Cx->CR1) &= ~((0x1UL << (17U))));
N}
N
N/**
N  * @brief  Disable Clock stretching.
N  * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
N  * @rmtoll CR1          NOSTRETCH     MS32_I2C_DisableClockStretching
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableClockStretching(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableClockStretching(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH);
X  ((I2Cx->CR1) |= ((0x1UL << (17U))));
N}
N
N/**
N  * @brief  Check if Clock stretching is enabled or disabled.
N  * @rmtoll CR1          NOSTRETCH     MS32_I2C_IsEnabledClockStretching
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledClockStretching(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledClockStretching(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH) != (I2C_CR1_NOSTRETCH)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (17U)))) != ((0x1UL << (17U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable hardware byte control in slave mode.
N  * @rmtoll CR1          SBC           MS32_I2C_EnableSlaveByteControl
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableSlaveByteControl(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableSlaveByteControl(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_SBC);
X  ((I2Cx->CR1) |= ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Disable hardware byte control in slave mode.
N  * @rmtoll CR1          SBC           MS32_I2C_DisableSlaveByteControl
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableSlaveByteControl(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableSlaveByteControl(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_SBC);
X  ((I2Cx->CR1) &= ~((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Check if hardware byte control in slave mode is enabled or disabled.
N  * @rmtoll CR1          SBC           MS32_I2C_IsEnabledSlaveByteControl
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledSlaveByteControl(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledSlaveByteControl(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_SBC) == (I2C_CR1_SBC)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (16U)))) == ((0x1UL << (16U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable Wakeup from STOP.
N  * @note   Macro @ref IS_I2C_WAKEUP_FROMSTOP_INSTANCE(I2Cx) can be used to check whether or not
N  *         WakeUpFromStop feature is supported by the I2Cx Instance.
N  * @note   This bit can only be programmed when Digital Filter is disabled.
N  * @rmtoll CR1          WUPEN         MS32_I2C_EnableWakeUpFromStop
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableWakeUpFromStop(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableWakeUpFromStop(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_WUPEN);
X  ((I2Cx->CR1) |= ((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Disable Wakeup from STOP.
N  * @note   Macro @ref IS_I2C_WAKEUP_FROMSTOP_INSTANCE(I2Cx) can be used to check whether or not
N  *         WakeUpFromStop feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          WUPEN         MS32_I2C_DisableWakeUpFromStop
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableWakeUpFromStop(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableWakeUpFromStop(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_WUPEN);
X  ((I2Cx->CR1) &= ~((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Check if Wakeup from STOP is enabled or disabled.
N  * @note   Macro @ref IS_I2C_WAKEUP_FROMSTOP_INSTANCE(I2Cx) can be used to check whether or not
N  *         WakeUpFromStop feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          WUPEN         MS32_I2C_IsEnabledWakeUpFromStop
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledWakeUpFromStop(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledWakeUpFromStop(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_WUPEN) == (I2C_CR1_WUPEN)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (18U)))) == ((0x1UL << (18U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable General Call.
N  * @note   When enabled the Address 0x00 is ACKed.
N  * @rmtoll CR1          GCEN          MS32_I2C_EnableGeneralCall
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableGeneralCall(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableGeneralCall(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_GCEN);
X  ((I2Cx->CR1) |= ((0x1UL << (19U))));
N}
N
N/**
N  * @brief  Disable General Call.
N  * @note   When disabled the Address 0x00 is NACKed.
N  * @rmtoll CR1          GCEN          MS32_I2C_DisableGeneralCall
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableGeneralCall(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableGeneralCall(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_GCEN);
X  ((I2Cx->CR1) &= ~((0x1UL << (19U))));
N}
N
N/**
N  * @brief  Check if General Call is enabled or disabled.
N  * @rmtoll CR1          GCEN          MS32_I2C_IsEnabledGeneralCall
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledGeneralCall(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledGeneralCall(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_GCEN) == (I2C_CR1_GCEN)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (19U)))) == ((0x1UL << (19U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Configure the Master to operate in 7-bit or 10-bit addressing mode.
N  * @note   Changing this bit is not allowed, when the START bit is set.
N  * @rmtoll CR2          ADD10         MS32_I2C_SetMasterAddressingMode
N  * @param  I2Cx I2C Instance.
N  * @param  AddressingMode This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_ADDRESSING_MODE_7BIT
N  *         @arg @ref MS32_I2C_ADDRESSING_MODE_10BIT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_SetMasterAddressingMode(I2C_TypeDef *I2Cx, uint32_t AddressingMode) {
Xstatic __inline void MS32_I2C_SetMasterAddressingMode(I2C_TypeDef *I2Cx, uint32_t AddressingMode) {
N  MODIFY_REG(I2Cx->CR2, I2C_CR2_ADD10, AddressingMode);
X  (((I2Cx->CR2)) = ((((((I2Cx->CR2))) & (~((0x1UL << (11U))))) | (AddressingMode))));
N}
N
N/**
N  * @brief  Get the Master addressing mode.
N  * @rmtoll CR2          ADD10         MS32_I2C_GetMasterAddressingMode
N  * @param  I2Cx I2C Instance.
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_I2C_ADDRESSING_MODE_7BIT
N  *         @arg @ref MS32_I2C_ADDRESSING_MODE_10BIT
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetMasterAddressingMode(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetMasterAddressingMode(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->CR2, I2C_CR2_ADD10));
X  return (uint32_t)(((I2Cx->CR2) & ((0x1UL << (11U)))));
N}
N
N/**
N  * @brief  Set the Own Address1.
N  * @rmtoll OAR1         OA1           MS32_I2C_SetOwnAddress1\n
N  *         OAR1         OA1MODE       MS32_I2C_SetOwnAddress1
N  * @param  I2Cx I2C Instance.
N  * @param  OwnAddress1 This parameter must be a value between Min_Data=0 and Max_Data=0x3FF.
N  * @param  OwnAddrSize This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_OWNADDRESS1_7BIT
N  *         @arg @ref MS32_I2C_OWNADDRESS1_10BIT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_SetOwnAddress1(I2C_TypeDef *I2Cx, uint32_t OwnAddress1, uint32_t OwnAddrSize) {
Xstatic __inline void MS32_I2C_SetOwnAddress1(I2C_TypeDef *I2Cx, uint32_t OwnAddress1, uint32_t OwnAddrSize) {
N  MODIFY_REG(I2Cx->OAR1, I2C_OAR1_OA1 | I2C_OAR1_OA1MODE, OwnAddress1 | OwnAddrSize);
X  (((I2Cx->OAR1)) = ((((((I2Cx->OAR1))) & (~((0x3FFUL << (0U)) | (0x1UL << (10U))))) | (OwnAddress1 | OwnAddrSize))));
N}
N
N/**
N  * @brief  Enable acknowledge on Own Address1 match address.
N  * @rmtoll OAR1         OA1EN         MS32_I2C_EnableOwnAddress1
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableOwnAddress1(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableOwnAddress1(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->OAR1, I2C_OAR1_OA1EN);
X  ((I2Cx->OAR1) |= ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Disable acknowledge on Own Address1 match address.
N  * @rmtoll OAR1         OA1EN         MS32_I2C_DisableOwnAddress1
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableOwnAddress1(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableOwnAddress1(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->OAR1, I2C_OAR1_OA1EN);
X  ((I2Cx->OAR1) &= ~((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Check if Own Address1 acknowledge is enabled or disabled.
N  * @rmtoll OAR1         OA1EN         MS32_I2C_IsEnabledOwnAddress1
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledOwnAddress1(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledOwnAddress1(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->OAR1, I2C_OAR1_OA1EN) == (I2C_OAR1_OA1EN)) ? 1UL : 0UL);
X  return ((((I2Cx->OAR1) & ((0x1UL << (15U)))) == ((0x1UL << (15U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set the 7bits Own Address2.
N  * @note   This action has no effect if own address2 is enabled.
N  * @rmtoll OAR2         OA2           MS32_I2C_SetOwnAddress2\n
N  *         OAR2         OA2MSK        MS32_I2C_SetOwnAddress2
N  * @param  I2Cx I2C Instance.
N  * @param  OwnAddress2 Value between Min_Data=0 and Max_Data=0x7F.
N  * @param  OwnAddrMask This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_OWNADDRESS2_NOMASK
N  *         @arg @ref MS32_I2C_OWNADDRESS2_MASK01
N  *         @arg @ref MS32_I2C_OWNADDRESS2_MASK02
N  *         @arg @ref MS32_I2C_OWNADDRESS2_MASK03
N  *         @arg @ref MS32_I2C_OWNADDRESS2_MASK04
N  *         @arg @ref MS32_I2C_OWNADDRESS2_MASK05
N  *         @arg @ref MS32_I2C_OWNADDRESS2_MASK06
N  *         @arg @ref MS32_I2C_OWNADDRESS2_MASK07
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_SetOwnAddress2(I2C_TypeDef *I2Cx, uint32_t OwnAddress2, uint32_t OwnAddrMask) {
Xstatic __inline void MS32_I2C_SetOwnAddress2(I2C_TypeDef *I2Cx, uint32_t OwnAddress2, uint32_t OwnAddrMask) {
N  MODIFY_REG(I2Cx->OAR2, I2C_OAR2_OA2 | I2C_OAR2_OA2MSK, OwnAddress2 | OwnAddrMask);
X  (((I2Cx->OAR2)) = ((((((I2Cx->OAR2))) & (~((0x7FUL << (1U)) | (0x7UL << (8U))))) | (OwnAddress2 | OwnAddrMask))));
N}
N
N/**
N  * @brief  Enable acknowledge on Own Address2 match address.
N  * @rmtoll OAR2         OA2EN         MS32_I2C_EnableOwnAddress2
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableOwnAddress2(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableOwnAddress2(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->OAR2, I2C_OAR2_OA2EN);
X  ((I2Cx->OAR2) |= ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Disable  acknowledge on Own Address2 match address.
N  * @rmtoll OAR2         OA2EN         MS32_I2C_DisableOwnAddress2
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableOwnAddress2(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableOwnAddress2(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->OAR2, I2C_OAR2_OA2EN);
X  ((I2Cx->OAR2) &= ~((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Check if Own Address1 acknowledge is enabled or disabled.
N  * @rmtoll OAR2         OA2EN         MS32_I2C_IsEnabledOwnAddress2
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledOwnAddress2(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledOwnAddress2(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->OAR2, I2C_OAR2_OA2EN) == (I2C_OAR2_OA2EN)) ? 1UL : 0UL);
X  return ((((I2Cx->OAR2) & ((0x1UL << (15U)))) == ((0x1UL << (15U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Configure the SDA setup, hold time and the SCL high, low period.
N  * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
N  * @rmtoll TIMINGR      TIMINGR       MS32_I2C_SetTiming
N  * @param  I2Cx I2C Instance.
N  * @param  Timing This parameter must be a value between Min_Data=0 and Max_Data=0xFFFFFFFF.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_SetTiming(I2C_TypeDef *I2Cx, uint32_t Timing) {
Xstatic __inline void MS32_I2C_SetTiming(I2C_TypeDef *I2Cx, uint32_t Timing) {
N  WRITE_REG(I2Cx->TIMINGR, Timing);
X  ((I2Cx->TIMINGR) = (Timing));
N}
N
N/**
N  * @brief  Get the Timing Prescaler setting.
N  * @rmtoll TIMINGR      PRESC         MS32_I2C_GetTimingPrescaler
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x0 and Max_Data=0xF
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetTimingPrescaler(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetTimingPrescaler(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->TIMINGR, I2C_TIMINGR_PRESC) >> I2C_TIMINGR_PRESC_Pos);
X  return (uint32_t)(((I2Cx->TIMINGR) & ((0xFUL << (28U)))) >> (28U));
N}
N
N/**
N  * @brief  Get the SCL low period setting.
N  * @rmtoll TIMINGR      SCLL          MS32_I2C_GetClockLowPeriod
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetClockLowPeriod(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetClockLowPeriod(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->TIMINGR, I2C_TIMINGR_SCLL) >> I2C_TIMINGR_SCLL_Pos);
X  return (uint32_t)(((I2Cx->TIMINGR) & ((0xFFUL << (0U)))) >> (0U));
N}
N
N/**
N  * @brief  Get the SCL high period setting.
N  * @rmtoll TIMINGR      SCLH          MS32_I2C_GetClockHighPeriod
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetClockHighPeriod(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetClockHighPeriod(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->TIMINGR, I2C_TIMINGR_SCLH) >> I2C_TIMINGR_SCLH_Pos);
X  return (uint32_t)(((I2Cx->TIMINGR) & ((0xFFUL << (8U)))) >> (8U));
N}
N
N/**
N  * @brief  Get the SDA hold time.
N  * @rmtoll TIMINGR      SDADEL        MS32_I2C_GetDataHoldTime
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x0 and Max_Data=0xF
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetDataHoldTime(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetDataHoldTime(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->TIMINGR, I2C_TIMINGR_SDADEL) >> I2C_TIMINGR_SDADEL_Pos);
X  return (uint32_t)(((I2Cx->TIMINGR) & ((0xFUL << (16U)))) >> (16U));
N}
N
N/**
N  * @brief  Get the SDA setup time.
N  * @rmtoll TIMINGR      SCLDEL        MS32_I2C_GetDataSetupTime
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x0 and Max_Data=0xF
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetDataSetupTime(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetDataSetupTime(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->TIMINGR, I2C_TIMINGR_SCLDEL) >> I2C_TIMINGR_SCLDEL_Pos);
X  return (uint32_t)(((I2Cx->TIMINGR) & ((0xFUL << (20U)))) >> (20U));
N}
N
N/**
N  * @brief  Configure peripheral mode.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          SMBHEN        MS32_I2C_SetMode\n
N  *         CR1          SMBDEN        MS32_I2C_SetMode
N  * @param  I2Cx I2C Instance.
N  * @param  PeripheralMode This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_MODE_I2C
N  *         @arg @ref MS32_I2C_MODE_SMBUS_HOST
N  *         @arg @ref MS32_I2C_MODE_SMBUS_DEVICE
N  *         @arg @ref MS32_I2C_MODE_SMBUS_DEVICE_ARP
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_SetMode(I2C_TypeDef *I2Cx, uint32_t PeripheralMode) {
Xstatic __inline void MS32_I2C_SetMode(I2C_TypeDef *I2Cx, uint32_t PeripheralMode) {
N  MODIFY_REG(I2Cx->CR1, I2C_CR1_SMBHEN | I2C_CR1_SMBDEN, PeripheralMode);
X  (((I2Cx->CR1)) = ((((((I2Cx->CR1))) & (~((0x1UL << (20U)) | (0x1UL << (21U))))) | (PeripheralMode))));
N}
N
N/**
N  * @brief  Get peripheral mode.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          SMBHEN        MS32_I2C_GetMode\n
N  *         CR1          SMBDEN        MS32_I2C_GetMode
N  * @param  I2Cx I2C Instance.
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_I2C_MODE_I2C
N  *         @arg @ref MS32_I2C_MODE_SMBUS_HOST
N  *         @arg @ref MS32_I2C_MODE_SMBUS_DEVICE
N  *         @arg @ref MS32_I2C_MODE_SMBUS_DEVICE_ARP
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetMode(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetMode(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->CR1, I2C_CR1_SMBHEN | I2C_CR1_SMBDEN));
X  return (uint32_t)(((I2Cx->CR1) & ((0x1UL << (20U)) | (0x1UL << (21U)))));
N}
N
N/**
N  * @brief  Enable SMBus alert (Host or Device mode)
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   SMBus Device mode:
N  *         - SMBus Alert pin is drived low and
N  *           Alert Response Address Header acknowledge is enabled.
N  *         SMBus Host mode:
N  *         - SMBus Alert pin management is supported.
N  * @rmtoll CR1          ALERTEN       MS32_I2C_EnableSMBusAlert
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableSMBusAlert(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableSMBusAlert(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_ALERTEN);
X  ((I2Cx->CR1) |= ((0x1UL << (22U))));
N}
N
N/**
N  * @brief  Disable SMBus alert (Host or Device mode)
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   SMBus Device mode:
N  *         - SMBus Alert pin is not drived (can be used as a standard GPIO) and
N  *           Alert Response Address Header acknowledge is disabled.
N  *         SMBus Host mode:
N  *         - SMBus Alert pin management is not supported.
N  * @rmtoll CR1          ALERTEN       MS32_I2C_DisableSMBusAlert
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableSMBusAlert(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableSMBusAlert(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_ALERTEN);
X  ((I2Cx->CR1) &= ~((0x1UL << (22U))));
N}
N
N/**
N  * @brief  Check if SMBus alert (Host or Device mode) is enabled or disabled.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          ALERTEN       MS32_I2C_IsEnabledSMBusAlert
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledSMBusAlert(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledSMBusAlert(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_ALERTEN) == (I2C_CR1_ALERTEN)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (22U)))) == ((0x1UL << (22U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable SMBus Packet Error Calculation (PEC).
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          PECEN         MS32_I2C_EnableSMBusPEC
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableSMBusPEC(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableSMBusPEC(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_PECEN);
X  ((I2Cx->CR1) |= ((0x1UL << (23U))));
N}
N
N/**
N  * @brief  Disable SMBus Packet Error Calculation (PEC).
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          PECEN         MS32_I2C_DisableSMBusPEC
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableSMBusPEC(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableSMBusPEC(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_PECEN);
X  ((I2Cx->CR1) &= ~((0x1UL << (23U))));
N}
N
N/**
N  * @brief  Check if SMBus Packet Error Calculation (PEC) is enabled or disabled.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          PECEN         MS32_I2C_IsEnabledSMBusPEC
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledSMBusPEC(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledSMBusPEC(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_PECEN) == (I2C_CR1_PECEN)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (23U)))) == ((0x1UL << (23U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Configure the SMBus Clock Timeout.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   This configuration can only be programmed when associated Timeout is disabled (TimeoutA and/orTimeoutB).
N  * @rmtoll TIMEOUTR     TIMEOUTA      MS32_I2C_ConfigSMBusTimeout\n
N  *         TIMEOUTR     TIDLE         MS32_I2C_ConfigSMBusTimeout\n
N  *         TIMEOUTR     TIMEOUTB      MS32_I2C_ConfigSMBusTimeout
N  * @param  I2Cx I2C Instance.
N  * @param  TimeoutA This parameter must be a value between  Min_Data=0 and Max_Data=0xFFF.
N  * @param  TimeoutAMode This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_SMBUS_TIMEOUTA_MODE_SCL_LOW
N  *         @arg @ref MS32_I2C_SMBUS_TIMEOUTA_MODE_SDA_SCL_HIGH
N  * @param  TimeoutB
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_ConfigSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t TimeoutA, uint32_t TimeoutAMode,
Xstatic __inline void MS32_I2C_ConfigSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t TimeoutA, uint32_t TimeoutAMode,
N                                               uint32_t TimeoutB) {
N  MODIFY_REG(I2Cx->TIMEOUTR, I2C_TIMEOUTR_TIMEOUTA | I2C_TIMEOUTR_TIDLE | I2C_TIMEOUTR_TIMEOUTB,
N             TimeoutA | TimeoutAMode | (TimeoutB << I2C_TIMEOUTR_TIMEOUTB_Pos));
X  (((I2Cx->TIMEOUTR)) = ((((((I2Cx->TIMEOUTR))) & (~((0xFFFUL << (0U)) | (0x1UL << (12U)) | (0xFFFUL << (16U))))) | (TimeoutA | TimeoutAMode | (TimeoutB << (16U))))));
N}
N
N/**
N  * @brief  Configure the SMBus Clock TimeoutA (SCL low timeout or SCL and SDA high timeout depends on TimeoutA mode).
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   These bits can only be programmed when TimeoutA is disabled.
N  * @rmtoll TIMEOUTR     TIMEOUTA      MS32_I2C_SetSMBusTimeoutA
N  * @param  I2Cx I2C Instance.
N  * @param  TimeoutA This parameter must be a value between  Min_Data=0 and Max_Data=0xFFF.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_SetSMBusTimeoutA(I2C_TypeDef *I2Cx, uint32_t TimeoutA) {
Xstatic __inline void MS32_I2C_SetSMBusTimeoutA(I2C_TypeDef *I2Cx, uint32_t TimeoutA) {
N  WRITE_REG(I2Cx->TIMEOUTR, TimeoutA);
X  ((I2Cx->TIMEOUTR) = (TimeoutA));
N}
N
N/**
N  * @brief  Get the SMBus Clock TimeoutA setting.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll TIMEOUTR     TIMEOUTA      MS32_I2C_GetSMBusTimeoutA
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0 and Max_Data=0xFFF
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetSMBusTimeoutA(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetSMBusTimeoutA(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->TIMEOUTR, I2C_TIMEOUTR_TIMEOUTA));
X  return (uint32_t)(((I2Cx->TIMEOUTR) & ((0xFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Set the SMBus Clock TimeoutA mode.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   This bit can only be programmed when TimeoutA is disabled.
N  * @rmtoll TIMEOUTR     TIDLE         MS32_I2C_SetSMBusTimeoutAMode
N  * @param  I2Cx I2C Instance.
N  * @param  TimeoutAMode This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_SMBUS_TIMEOUTA_MODE_SCL_LOW
N  *         @arg @ref MS32_I2C_SMBUS_TIMEOUTA_MODE_SDA_SCL_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_SetSMBusTimeoutAMode(I2C_TypeDef *I2Cx, uint32_t TimeoutAMode) {
Xstatic __inline void MS32_I2C_SetSMBusTimeoutAMode(I2C_TypeDef *I2Cx, uint32_t TimeoutAMode) {
N  WRITE_REG(I2Cx->TIMEOUTR, TimeoutAMode);
X  ((I2Cx->TIMEOUTR) = (TimeoutAMode));
N}
N
N/**
N  * @brief  Get the SMBus Clock TimeoutA mode.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll TIMEOUTR     TIDLE         MS32_I2C_GetSMBusTimeoutAMode
N  * @param  I2Cx I2C Instance.
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_I2C_SMBUS_TIMEOUTA_MODE_SCL_LOW
N  *         @arg @ref MS32_I2C_SMBUS_TIMEOUTA_MODE_SDA_SCL_HIGH
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetSMBusTimeoutAMode(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetSMBusTimeoutAMode(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->TIMEOUTR, I2C_TIMEOUTR_TIDLE));
X  return (uint32_t)(((I2Cx->TIMEOUTR) & ((0x1UL << (12U)))));
N}
N
N/**
N  * @brief  Configure the SMBus Extended Cumulative Clock TimeoutB (Master or Slave mode).
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   These bits can only be programmed when TimeoutB is disabled.
N  * @rmtoll TIMEOUTR     TIMEOUTB      MS32_I2C_SetSMBusTimeoutB
N  * @param  I2Cx I2C Instance.
N  * @param  TimeoutB This parameter must be a value between  Min_Data=0 and Max_Data=0xFFF.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_SetSMBusTimeoutB(I2C_TypeDef *I2Cx, uint32_t TimeoutB) {
Xstatic __inline void MS32_I2C_SetSMBusTimeoutB(I2C_TypeDef *I2Cx, uint32_t TimeoutB) {
N  WRITE_REG(I2Cx->TIMEOUTR, TimeoutB << I2C_TIMEOUTR_TIMEOUTB_Pos);
X  ((I2Cx->TIMEOUTR) = (TimeoutB << (16U)));
N}
N
N/**
N  * @brief  Get the SMBus Extented Cumulative Clock TimeoutB setting.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll TIMEOUTR     TIMEOUTB      MS32_I2C_GetSMBusTimeoutB
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0 and Max_Data=0xFFF
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetSMBusTimeoutB(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetSMBusTimeoutB(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->TIMEOUTR, I2C_TIMEOUTR_TIMEOUTB) >> I2C_TIMEOUTR_TIMEOUTB_Pos);
X  return (uint32_t)(((I2Cx->TIMEOUTR) & ((0xFFFUL << (16U)))) >> (16U));
N}
N
N/**
N  * @brief  Enable the SMBus Clock Timeout.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll TIMEOUTR     TIMOUTEN      MS32_I2C_EnableSMBusTimeout\n
N  *         TIMEOUTR     TEXTEN        MS32_I2C_EnableSMBusTimeout
N  * @param  I2Cx I2C Instance.
N  * @param  ClockTimeout This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_SMBUS_TIMEOUTA
N  *         @arg @ref MS32_I2C_SMBUS_TIMEOUTB
N  *         @arg @ref MS32_I2C_SMBUS_AMS32_TIMEOUT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t ClockTimeout) {
Xstatic __inline void MS32_I2C_EnableSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t ClockTimeout) {
N  SET_BIT(I2Cx->TIMEOUTR, ClockTimeout);
X  ((I2Cx->TIMEOUTR) |= (ClockTimeout));
N}
N
N/**
N  * @brief  Disable the SMBus Clock Timeout.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll TIMEOUTR     TIMOUTEN      MS32_I2C_DisableSMBusTimeout\n
N  *         TIMEOUTR     TEXTEN        MS32_I2C_DisableSMBusTimeout
N  * @param  I2Cx I2C Instance.
N  * @param  ClockTimeout This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_SMBUS_TIMEOUTA
N  *         @arg @ref MS32_I2C_SMBUS_TIMEOUTB
N  *         @arg @ref MS32_I2C_SMBUS_AMS32_TIMEOUT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t ClockTimeout) {
Xstatic __inline void MS32_I2C_DisableSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t ClockTimeout) {
N  CLEAR_BIT(I2Cx->TIMEOUTR, ClockTimeout);
X  ((I2Cx->TIMEOUTR) &= ~(ClockTimeout));
N}
N
N/**
N  * @brief  Check if the SMBus Clock Timeout is enabled or disabled.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll TIMEOUTR     TIMOUTEN      MS32_I2C_IsEnabledSMBusTimeout\n
N  *         TIMEOUTR     TEXTEN        MS32_I2C_IsEnabledSMBusTimeout
N  * @param  I2Cx I2C Instance.
N  * @param  ClockTimeout This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_SMBUS_TIMEOUTA
N  *         @arg @ref MS32_I2C_SMBUS_TIMEOUTB
N  *         @arg @ref MS32_I2C_SMBUS_AMS32_TIMEOUT
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t ClockTimeout) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t ClockTimeout) {
N  return ((READ_BIT(I2Cx->TIMEOUTR, (I2C_TIMEOUTR_TIMOUTEN | I2C_TIMEOUTR_TEXTEN)) == (ClockTimeout)) ? 1UL : 0UL);
X  return ((((I2Cx->TIMEOUTR) & (((0x1UL << (15U)) | (0x1UL << (31U))))) == (ClockTimeout)) ? 1UL : 0UL);
N}
N
N
N/** @defgroup I2C_EF_IT_Management IT_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable TXIS interrupt.
N  * @rmtoll CR1          TXIE          MS32_I2C_EnableIT_TX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableIT_TX(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableIT_TX(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_TXIE);
X  ((I2Cx->CR1) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable TXIS interrupt.
N  * @rmtoll CR1          TXIE          MS32_I2C_DisableIT_TX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableIT_TX(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableIT_TX(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_TXIE);
X  ((I2Cx->CR1) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Check if the TXIS Interrupt is enabled or disabled.
N  * @rmtoll CR1          TXIE          MS32_I2C_IsEnabledIT_TX
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledIT_TX(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledIT_TX(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_TXIE) == (I2C_CR1_TXIE)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (1U)))) == ((0x1UL << (1U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable RXNE interrupt.
N  * @rmtoll CR1          RXIE          MS32_I2C_EnableIT_RX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableIT_RX(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableIT_RX(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_RXIE);
X  ((I2Cx->CR1) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Disable RXNE interrupt.
N  * @rmtoll CR1          RXIE          MS32_I2C_DisableIT_RX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableIT_RX(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableIT_RX(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_RXIE);
X  ((I2Cx->CR1) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Check if the RXNE Interrupt is enabled or disabled.
N  * @rmtoll CR1          RXIE          MS32_I2C_IsEnabledIT_RX
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledIT_RX(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledIT_RX(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_RXIE) == (I2C_CR1_RXIE)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (2U)))) == ((0x1UL << (2U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable Address match interrupt (slave mode only).
N  * @rmtoll CR1          ADDRIE        MS32_I2C_EnableIT_ADDR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableIT_ADDR(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableIT_ADDR(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_ADDRIE);
X  ((I2Cx->CR1) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Disable Address match interrupt (slave mode only).
N  * @rmtoll CR1          ADDRIE        MS32_I2C_DisableIT_ADDR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableIT_ADDR(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableIT_ADDR(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_ADDRIE);
X  ((I2Cx->CR1) &= ~((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Check if Address match interrupt is enabled or disabled.
N  * @rmtoll CR1          ADDRIE        MS32_I2C_IsEnabledIT_ADDR
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledIT_ADDR(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledIT_ADDR(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_ADDRIE) == (I2C_CR1_ADDRIE)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (3U)))) == ((0x1UL << (3U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable Not acknowledge received interrupt.
N  * @rmtoll CR1          NACKIE        MS32_I2C_EnableIT_NACK
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableIT_NACK(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableIT_NACK(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_NACKIE);
X  ((I2Cx->CR1) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Disable Not acknowledge received interrupt.
N  * @rmtoll CR1          NACKIE        MS32_I2C_DisableIT_NACK
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableIT_NACK(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableIT_NACK(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_NACKIE);
X  ((I2Cx->CR1) &= ~((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Check if Not acknowledge received interrupt is enabled or disabled.
N  * @rmtoll CR1          NACKIE        MS32_I2C_IsEnabledIT_NACK
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledIT_NACK(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledIT_NACK(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_NACKIE) == (I2C_CR1_NACKIE)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (4U)))) == ((0x1UL << (4U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable STOP detection interrupt.
N  * @rmtoll CR1          STOPIE        MS32_I2C_EnableIT_STOP
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableIT_STOP(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableIT_STOP(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_STOPIE);
X  ((I2Cx->CR1) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Disable STOP detection interrupt.
N  * @rmtoll CR1          STOPIE        MS32_I2C_DisableIT_STOP
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableIT_STOP(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableIT_STOP(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_STOPIE);
X  ((I2Cx->CR1) &= ~((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Check if STOP detection interrupt is enabled or disabled.
N  * @rmtoll CR1          STOPIE        MS32_I2C_IsEnabledIT_STOP
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledIT_STOP(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledIT_STOP(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_STOPIE) == (I2C_CR1_STOPIE)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (5U)))) == ((0x1UL << (5U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable Transfer Complete interrupt.
N  * @note   Any of these events will generate interrupt :
N  *         Transfer Complete (TC)
N  *         Transfer Complete Reload (TCR)
N  * @rmtoll CR1          TCIE          MS32_I2C_EnableIT_TC
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableIT_TC(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableIT_TC(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_TCIE);
X  ((I2Cx->CR1) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Disable Transfer Complete interrupt.
N  * @note   Any of these events will generate interrupt :
N  *         Transfer Complete (TC)
N  *         Transfer Complete Reload (TCR)
N  * @rmtoll CR1          TCIE          MS32_I2C_DisableIT_TC
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableIT_TC(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableIT_TC(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_TCIE);
X  ((I2Cx->CR1) &= ~((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Check if Transfer Complete interrupt is enabled or disabled.
N  * @rmtoll CR1          TCIE          MS32_I2C_IsEnabledIT_TC
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledIT_TC(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledIT_TC(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_TCIE) == (I2C_CR1_TCIE)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable Error interrupts.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   Any of these errors will generate interrupt :
N  *         Arbitration Loss (ARLO)
N  *         Bus Error detection (BERR)
N  *         Overrun/Underrun (OVR)
N  *         SMBus Timeout detection (TIMEOUT)
N  *         SMBus PEC error detection (PECERR)
N  *         SMBus Alert pin event detection (ALERT)
N  * @rmtoll CR1          ERRIE         MS32_I2C_EnableIT_ERR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableIT_ERR(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableIT_ERR(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR1, I2C_CR1_ERRIE);
X  ((I2Cx->CR1) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable Error interrupts.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   Any of these errors will generate interrupt :
N  *         Arbitration Loss (ARLO)
N  *         Bus Error detection (BERR)
N  *         Overrun/Underrun (OVR)
N  *         SMBus Timeout detection (TIMEOUT)
N  *         SMBus PEC error detection (PECERR)
N  *         SMBus Alert pin event detection (ALERT)
N  * @rmtoll CR1          ERRIE         MS32_I2C_DisableIT_ERR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableIT_ERR(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableIT_ERR(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_ERRIE);
X  ((I2Cx->CR1) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Check if Error interrupts are enabled or disabled.
N  * @rmtoll CR1          ERRIE         MS32_I2C_IsEnabledIT_ERR
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledIT_ERR(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledIT_ERR(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR1, I2C_CR1_ERRIE) == (I2C_CR1_ERRIE)) ? 1UL : 0UL);
X  return ((((I2Cx->CR1) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N
N/** @defgroup I2C_EF_FLAG_management FLAG_management
N  * @{
N  */
N
N/**
N  * @brief  Indicate the status of Transmit data register empty flag.
N  * @note   RESET: When next data is written in Transmit data register.
N  *         SET: When Transmit data register is empty.
N  * @rmtoll ISR          TXE           MS32_I2C_IsActiveFlag_TXE
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsActiveFlag_TXE(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsActiveFlag_TXE(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->ISR, I2C_ISR_TXE) == (I2C_ISR_TXE)) ? 1UL : 0UL);
X  return ((((I2Cx->ISR) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Indicate the status of Transmit interrupt flag.
N  * @note   RESET: When next data is written in Transmit data register.
N  *         SET: When Transmit data register is empty.
N  * @rmtoll ISR          TXIS          MS32_I2C_IsActiveFlag_TXIS
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsActiveFlag_TXIS(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsActiveFlag_TXIS(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->ISR, I2C_ISR_TXIS) == (I2C_ISR_TXIS)) ? 1UL : 0UL);
X  return ((((I2Cx->ISR) & ((0x1UL << (1U)))) == ((0x1UL << (1U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Indicate the status of Receive data register not empty flag.
N  * @note   RESET: When Receive data register is read.
N  *         SET: When the received data is copied in Receive data register.
N  * @rmtoll ISR          RXNE          MS32_I2C_IsActiveFlag_RXNE
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsActiveFlag_RXNE(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsActiveFlag_RXNE(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->ISR, I2C_ISR_RXNE) == (I2C_ISR_RXNE)) ? 1UL : 0UL);
X  return ((((I2Cx->ISR) & ((0x1UL << (2U)))) == ((0x1UL << (2U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Indicate the status of Address matched flag (slave mode).
N  * @note   RESET: Clear default value.
N  *         SET: When the received slave address matched with one of the enabled slave address.
N  * @rmtoll ISR          ADDR          MS32_I2C_IsActiveFlag_ADDR
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsActiveFlag_ADDR(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsActiveFlag_ADDR(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->ISR, I2C_ISR_ADDR) == (I2C_ISR_ADDR)) ? 1UL : 0UL);
X  return ((((I2Cx->ISR) & ((0x1UL << (3U)))) == ((0x1UL << (3U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Indicate the status of Not Acknowledge received flag.
N  * @note   RESET: Clear default value.
N  *         SET: When a NACK is received after a byte transmission.
N  * @rmtoll ISR          NACKF         MS32_I2C_IsActiveFlag_NACK
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsActiveFlag_NACK(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsActiveFlag_NACK(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->ISR, I2C_ISR_NACKF) == (I2C_ISR_NACKF)) ? 1UL : 0UL);
X  return ((((I2Cx->ISR) & ((0x1UL << (4U)))) == ((0x1UL << (4U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Indicate the status of Stop detection flag.
N  * @note   RESET: Clear default value.
N  *         SET: When a Stop condition is detected.
N  * @rmtoll ISR          STOPF         MS32_I2C_IsActiveFlag_STOP
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsActiveFlag_STOP(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsActiveFlag_STOP(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->ISR, I2C_ISR_STOPF) == (I2C_ISR_STOPF)) ? 1UL : 0UL);
X  return ((((I2Cx->ISR) & ((0x1UL << (5U)))) == ((0x1UL << (5U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Indicate the status of Transfer complete flag (master mode).
N  * @note   RESET: Clear default value.
N  *         SET: When RELOAD=0, AUTOEND=0 and NBYTES date have been transferred.
N  * @rmtoll ISR          TC            MS32_I2C_IsActiveFlag_TC
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsActiveFlag_TC(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsActiveFlag_TC(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->ISR, I2C_ISR_TC) == (I2C_ISR_TC)) ? 1UL : 0UL);
X  return ((((I2Cx->ISR) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Indicate the status of Transfer complete flag (master mode).
N  * @note   RESET: Clear default value.
N  *         SET: When RELOAD=1 and NBYTES date have been transferred.
N  * @rmtoll ISR          TCR           MS32_I2C_IsActiveFlag_TCR
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsActiveFlag_TCR(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsActiveFlag_TCR(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->ISR, I2C_ISR_TCR) == (I2C_ISR_TCR)) ? 1UL : 0UL);
X  return ((((I2Cx->ISR) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Indicate the status of Bus error flag.
N  * @note   RESET: Clear default value.
N  *         SET: When a misplaced Start or Stop condition is detected.
N  * @rmtoll ISR          BERR          MS32_I2C_IsActiveFlag_BERR
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsActiveFlag_BERR(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsActiveFlag_BERR(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->ISR, I2C_ISR_BERR) == (I2C_ISR_BERR)) ? 1UL : 0UL);
X  return ((((I2Cx->ISR) & ((0x1UL << (8U)))) == ((0x1UL << (8U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Indicate the status of Arbitration lost flag.
N  * @note   RESET: Clear default value.
N  *         SET: When arbitration lost.
N  * @rmtoll ISR          ARLO          MS32_I2C_IsActiveFlag_ARLO
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsActiveFlag_ARLO(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsActiveFlag_ARLO(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->ISR, I2C_ISR_ARLO) == (I2C_ISR_ARLO)) ? 1UL : 0UL);
X  return ((((I2Cx->ISR) & ((0x1UL << (9U)))) == ((0x1UL << (9U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Indicate the status of Overrun/Underrun flag (slave mode).
N  * @note   RESET: Clear default value.
N  *         SET: When an overrun/underrun error occurs (Clock Stretching Disabled).
N  * @rmtoll ISR          OVR           MS32_I2C_IsActiveFlag_OVR
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsActiveFlag_OVR(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsActiveFlag_OVR(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->ISR, I2C_ISR_OVR) == (I2C_ISR_OVR)) ? 1UL : 0UL);
X  return ((((I2Cx->ISR) & ((0x1UL << (10U)))) == ((0x1UL << (10U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Indicate the status of SMBus PEC error flag in reception.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   RESET: Clear default value.
N  *         SET: When the received PEC does not match with the PEC register content.
N  * @rmtoll ISR          PECERR        MS32_I2C_IsActiveSMBusFlag_PECERR
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsActiveSMBusFlag_PECERR(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsActiveSMBusFlag_PECERR(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->ISR, I2C_ISR_PECERR) == (I2C_ISR_PECERR)) ? 1UL : 0UL);
X  return ((((I2Cx->ISR) & ((0x1UL << (11U)))) == ((0x1UL << (11U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Indicate the status of SMBus Timeout detection flag.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   RESET: Clear default value.
N  *         SET: When a timeout or extended clock timeout occurs.
N  * @rmtoll ISR          TIMEOUT       MS32_I2C_IsActiveSMBusFlag_TIMEOUT
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsActiveSMBusFlag_TIMEOUT(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsActiveSMBusFlag_TIMEOUT(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->ISR, I2C_ISR_TIMEOUT) == (I2C_ISR_TIMEOUT)) ? 1UL : 0UL);
X  return ((((I2Cx->ISR) & ((0x1UL << (12U)))) == ((0x1UL << (12U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Indicate the status of SMBus alert flag.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   RESET: Clear default value.
N  *         SET: When SMBus host configuration, SMBus alert enabled and
N  *              a falling edge event occurs on SMBA pin.
N  * @rmtoll ISR          ALERT         MS32_I2C_IsActiveSMBusFlag_ALERT
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsActiveSMBusFlag_ALERT(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsActiveSMBusFlag_ALERT(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->ISR, I2C_ISR_ALERT) == (I2C_ISR_ALERT)) ? 1UL : 0UL);
X  return ((((I2Cx->ISR) & ((0x1UL << (13U)))) == ((0x1UL << (13U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Indicate the status of Bus Busy flag.
N  * @note   RESET: Clear default value.
N  *         SET: When a Start condition is detected.
N  * @rmtoll ISR          BUSY          MS32_I2C_IsActiveFlag_BUSY
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsActiveFlag_BUSY(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsActiveFlag_BUSY(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->ISR, I2C_ISR_BUSY) == (I2C_ISR_BUSY)) ? 1UL : 0UL);
X  return ((((I2Cx->ISR) & ((0x1UL << (15U)))) == ((0x1UL << (15U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear Address Matched flag.
N  * @rmtoll ICR          ADDRCF        MS32_I2C_ClearFlag_ADDR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_ClearFlag_ADDR(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_ClearFlag_ADDR(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->ICR, I2C_ICR_ADDRCF);
X  ((I2Cx->ICR) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Clear Not Acknowledge flag.
N  * @rmtoll ICR          NACKCF        MS32_I2C_ClearFlag_NACK
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_ClearFlag_NACK(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_ClearFlag_NACK(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->ICR, I2C_ICR_NACKCF);
X  ((I2Cx->ICR) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Clear Stop detection flag.
N  * @rmtoll ICR          STOPCF        MS32_I2C_ClearFlag_STOP
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_ClearFlag_STOP(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_ClearFlag_STOP(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->ICR, I2C_ICR_STOPCF);
X  ((I2Cx->ICR) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Clear Transmit data register empty flag (TXE).
N  * @note   This bit can be clear by software in order to flush the transmit data register (TXDR).
N  * @rmtoll ISR          TXE           MS32_I2C_ClearFlag_TXE
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_ClearFlag_TXE(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_ClearFlag_TXE(I2C_TypeDef *I2Cx) {
N  WRITE_REG(I2Cx->ISR, I2C_ISR_TXE);
X  ((I2Cx->ISR) = ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Clear Bus error flag.
N  * @rmtoll ICR          BERRCF        MS32_I2C_ClearFlag_BERR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_ClearFlag_BERR(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_ClearFlag_BERR(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->ICR, I2C_ICR_BERRCF);
X  ((I2Cx->ICR) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Clear Arbitration lost flag.
N  * @rmtoll ICR          ARLOCF        MS32_I2C_ClearFlag_ARLO
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_ClearFlag_ARLO(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_ClearFlag_ARLO(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->ICR, I2C_ICR_ARLOCF);
X  ((I2Cx->ICR) |= ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Clear Overrun/Underrun flag.
N  * @rmtoll ICR          OVRCF         MS32_I2C_ClearFlag_OVR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_ClearFlag_OVR(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_ClearFlag_OVR(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->ICR, I2C_ICR_OVRCF);
X  ((I2Cx->ICR) |= ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Clear SMBus PEC error flag.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll ICR          PECCF         MS32_I2C_ClearSMBusFlag_PECERR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_ClearSMBusFlag_PECERR(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_ClearSMBusFlag_PECERR(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->ICR, I2C_ICR_PECCF);
X  ((I2Cx->ICR) |= ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Clear SMBus Timeout detection flag.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll ICR          TIMOUTCF      MS32_I2C_ClearSMBusFlag_TIMEOUT
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_ClearSMBusFlag_TIMEOUT(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_ClearSMBusFlag_TIMEOUT(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->ICR, I2C_ICR_TIMOUTCF);
X  ((I2Cx->ICR) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Clear SMBus Alert flag.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll ICR          ALERTCF       MS32_I2C_ClearSMBusFlag_ALERT
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_ClearSMBusFlag_ALERT(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_ClearSMBusFlag_ALERT(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->ICR, I2C_ICR_ALERTCF);
X  ((I2Cx->ICR) |= ((0x1UL << (13U))));
N}
N
N
N/** @defgroup I2C_EF_Data_Management Data_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable automatic STOP condition generation (master mode).
N  * @note   Automatic end mode : a STOP condition is automatically sent when NBYTES data are transferred.
N  *         This bit has no effect in slave mode or when RELOAD bit is set.
N  * @rmtoll CR2          AUTOEND       MS32_I2C_EnableAutoEndMode
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableAutoEndMode(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableAutoEndMode(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR2, I2C_CR2_AUTOEND);
X  ((I2Cx->CR2) |= ((0x1UL << (25U))));
N}
N
N/**
N  * @brief  Disable automatic STOP condition generation (master mode).
N  * @note   Software end mode : TC flag is set when NBYTES data are transferre, stretching SCL low.
N  * @rmtoll CR2          AUTOEND       MS32_I2C_DisableAutoEndMode
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableAutoEndMode(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableAutoEndMode(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR2, I2C_CR2_AUTOEND);
X  ((I2Cx->CR2) &= ~((0x1UL << (25U))));
N}
N
N/**
N  * @brief  Check if automatic STOP condition is enabled or disabled.
N  * @rmtoll CR2          AUTOEND       MS32_I2C_IsEnabledAutoEndMode
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledAutoEndMode(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledAutoEndMode(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR2, I2C_CR2_AUTOEND) == (I2C_CR2_AUTOEND)) ? 1UL : 0UL);
X  return ((((I2Cx->CR2) & ((0x1UL << (25U)))) == ((0x1UL << (25U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable reload mode (master mode).
N  * @note   The transfer is not completed after the NBYTES data transfer, NBYTES will be reloaded when TCR flag is set.
N  * @rmtoll CR2          RELOAD       MS32_I2C_EnableReloadMode
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableReloadMode(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableReloadMode(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR2, I2C_CR2_RELOAD);
X  ((I2Cx->CR2) |= ((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Disable reload mode (master mode).
N  * @note   The transfer is completed after the NBYTES data transfer(STOP or RESTART will follow).
N  * @rmtoll CR2          RELOAD       MS32_I2C_DisableReloadMode
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableReloadMode(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableReloadMode(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR2, I2C_CR2_RELOAD);
X  ((I2Cx->CR2) &= ~((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Check if reload mode is enabled or disabled.
N  * @rmtoll CR2          RELOAD       MS32_I2C_IsEnabledReloadMode
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledReloadMode(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledReloadMode(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR2, I2C_CR2_RELOAD) == (I2C_CR2_RELOAD)) ? 1UL : 0UL);
X  return ((((I2Cx->CR2) & ((0x1UL << (24U)))) == ((0x1UL << (24U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Configure the number of bytes for transfer.
N  * @note   Changing these bits when START bit is set is not allowed.
N  * @rmtoll CR2          NBYTES           MS32_I2C_SetTransferSize
N  * @param  I2Cx I2C Instance.
N  * @param  TransferSize This parameter must be a value between Min_Data=0x00 and Max_Data=0xFF.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_SetTransferSize(I2C_TypeDef *I2Cx, uint32_t TransferSize) {
Xstatic __inline void MS32_I2C_SetTransferSize(I2C_TypeDef *I2Cx, uint32_t TransferSize) {
N  MODIFY_REG(I2Cx->CR2, I2C_CR2_NBYTES, TransferSize << I2C_CR2_NBYTES_Pos);
X  (((I2Cx->CR2)) = ((((((I2Cx->CR2))) & (~((0xFFUL << (16U))))) | (TransferSize << (16U)))));
N}
N
N/**
N  * @brief  Get the number of bytes configured for transfer.
N  * @rmtoll CR2          NBYTES           MS32_I2C_GetTransferSize
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x0 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetTransferSize(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetTransferSize(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->CR2, I2C_CR2_NBYTES) >> I2C_CR2_NBYTES_Pos);
X  return (uint32_t)(((I2Cx->CR2) & ((0xFFUL << (16U)))) >> (16U));
N}
N
N/**
N  * @brief  Prepare the generation of a ACKnowledge or Non ACKnowledge condition after the address receive match code or next received byte.
N  * @note   Usage in Slave mode only.
N  * @rmtoll CR2          NACK          MS32_I2C_AcknowledgeNextData
N  * @param  I2Cx I2C Instance.
N  * @param  TypeAcknowledge This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_ACK
N  *         @arg @ref MS32_I2C_NACK
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_AcknowledgeNextData(I2C_TypeDef *I2Cx, uint32_t TypeAcknowledge) {
Xstatic __inline void MS32_I2C_AcknowledgeNextData(I2C_TypeDef *I2Cx, uint32_t TypeAcknowledge) {
N  MODIFY_REG(I2Cx->CR2, I2C_CR2_NACK, TypeAcknowledge);
X  (((I2Cx->CR2)) = ((((((I2Cx->CR2))) & (~((0x1UL << (15U))))) | (TypeAcknowledge))));
N}
N
N/**
N  * @brief  Generate a START or RESTART condition
N  * @note   The START bit can be set even if bus is BUSY or I2C is in slave mode.
N  *         This action has no effect when RELOAD is set.
N  * @rmtoll CR2          START           MS32_I2C_GenerateStartCondition
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_GenerateStartCondition(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_GenerateStartCondition(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR2, I2C_CR2_START);
X  ((I2Cx->CR2) |= ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Generate a STOP condition after the current byte transfer (master mode).
N  * @rmtoll CR2          STOP          MS32_I2C_GenerateStopCondition
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_GenerateStopCondition(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_GenerateStopCondition(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR2, I2C_CR2_STOP);
X  ((I2Cx->CR2) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Enable automatic RESTART Read request condition for 10bit address header (master mode).
N  * @note   The master sends the complete 10bit slave address read sequence :
N  *         Start + 2 bytes 10bit address in Write direction + Restart + first 7 bits of 10bit address in Read direction.
N  * @rmtoll CR2          HEAD10R       MS32_I2C_EnableAuto10BitRead
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableAuto10BitRead(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableAuto10BitRead(I2C_TypeDef *I2Cx) {
N  CLEAR_BIT(I2Cx->CR2, I2C_CR2_HEAD10R);
X  ((I2Cx->CR2) &= ~((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Disable automatic RESTART Read request condition for 10bit address header (master mode).
N  * @note   The master only sends the first 7 bits of 10bit address in Read direction.
N  * @rmtoll CR2          HEAD10R       MS32_I2C_DisableAuto10BitRead
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_DisableAuto10BitRead(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_DisableAuto10BitRead(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR2, I2C_CR2_HEAD10R);
X  ((I2Cx->CR2) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Check if automatic RESTART Read request condition for 10bit address header is enabled or disabled.
N  * @rmtoll CR2          HEAD10R       MS32_I2C_IsEnabledAuto10BitRead
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledAuto10BitRead(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledAuto10BitRead(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR2, I2C_CR2_HEAD10R) != (I2C_CR2_HEAD10R)) ? 1UL : 0UL);
X  return ((((I2Cx->CR2) & ((0x1UL << (12U)))) != ((0x1UL << (12U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Configure the transfer direction (master mode).
N  * @note   Changing these bits when START bit is set is not allowed.
N  * @rmtoll CR2          RD_WRN           MS32_I2C_SetTransferRequest
N  * @param  I2Cx I2C Instance.
N  * @param  TransferRequest This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_REQUEST_WRITE
N  *         @arg @ref MS32_I2C_REQUEST_READ
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_SetTransferRequest(I2C_TypeDef *I2Cx, uint32_t TransferRequest) {
Xstatic __inline void MS32_I2C_SetTransferRequest(I2C_TypeDef *I2Cx, uint32_t TransferRequest) {
N  MODIFY_REG(I2Cx->CR2, I2C_CR2_RD_WRN, TransferRequest);
X  (((I2Cx->CR2)) = ((((((I2Cx->CR2))) & (~((0x1UL << (10U))))) | (TransferRequest))));
N}
N
N/**
N  * @brief  Get the transfer direction requested (master mode).
N  * @rmtoll CR2          RD_WRN           MS32_I2C_GetTransferRequest
N  * @param  I2Cx I2C Instance.
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_I2C_REQUEST_WRITE
N  *         @arg @ref MS32_I2C_REQUEST_READ
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetTransferRequest(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetTransferRequest(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->CR2, I2C_CR2_RD_WRN));
X  return (uint32_t)(((I2Cx->CR2) & ((0x1UL << (10U)))));
N}
N
N/**
N  * @brief  Configure the slave address for transfer (master mode).
N  * @note   Changing these bits when START bit is set is not allowed.
N  * @rmtoll CR2          SADD           MS32_I2C_SetSlaveAddr
N  * @param  I2Cx I2C Instance.
N  * @param  SlaveAddr This parameter must be a value between Min_Data=0x00 and Max_Data=0x3F.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_SetSlaveAddr(I2C_TypeDef *I2Cx, uint32_t SlaveAddr) {
Xstatic __inline void MS32_I2C_SetSlaveAddr(I2C_TypeDef *I2Cx, uint32_t SlaveAddr) {
N  MODIFY_REG(I2Cx->CR2, I2C_CR2_SADD, SlaveAddr);
X  (((I2Cx->CR2)) = ((((((I2Cx->CR2))) & (~((0x3FFUL << (0U))))) | (SlaveAddr))));
N}
N
N/**
N  * @brief  Get the slave address programmed for transfer.
N  * @rmtoll CR2          SADD           MS32_I2C_GetSlaveAddr
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x0 and Max_Data=0x3F
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetSlaveAddr(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetSlaveAddr(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->CR2, I2C_CR2_SADD));
X  return (uint32_t)(((I2Cx->CR2) & ((0x3FFUL << (0U)))));
N}
N
N/**
N  * @brief  Handles I2Cx communication when starting transfer or during transfer (TC or TCR flag are set).
N  * @rmtoll CR2          SADD          MS32_I2C_HandleTransfer\n
N  *         CR2          ADD10         MS32_I2C_HandleTransfer\n
N  *         CR2          RD_WRN        MS32_I2C_HandleTransfer\n
N  *         CR2          START         MS32_I2C_HandleTransfer\n
N  *         CR2          STOP          MS32_I2C_HandleTransfer\n
N  *         CR2          RELOAD        MS32_I2C_HandleTransfer\n
N  *         CR2          NBYTES        MS32_I2C_HandleTransfer\n
N  *         CR2          AUTOEND       MS32_I2C_HandleTransfer\n
N  *         CR2          HEAD10R       MS32_I2C_HandleTransfer
N  * @param  I2Cx I2C Instance.
N  * @param  SlaveAddr Specifies the slave address to be programmed.
N  * @param  SlaveAddrSize This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_ADDRSLAVE_7BIT
N  *         @arg @ref MS32_I2C_ADDRSLAVE_10BIT
N  * @param  TransferSize Specifies the number of bytes to be programmed.
N  *                       This parameter must be a value between Min_Data=0 and Max_Data=255.
N  * @param  EndMode This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_MODE_RELOAD
N  *         @arg @ref MS32_I2C_MODE_AUTOEND
N  *         @arg @ref MS32_I2C_MODE_SOFTEND
N  *         @arg @ref MS32_I2C_MODE_SMBUS_RELOAD
N  *         @arg @ref MS32_I2C_MODE_SMBUS_AUTOEND_NO_PEC
N  *         @arg @ref MS32_I2C_MODE_SMBUS_SOFTEND_NO_PEC
N  *         @arg @ref MS32_I2C_MODE_SMBUS_AUTOEND_WITH_PEC
N  *         @arg @ref MS32_I2C_MODE_SMBUS_SOFTEND_WITH_PEC
N  * @param  Request This parameter can be one of the following values:
N  *         @arg @ref MS32_I2C_GENERATE_NOSTARTSTOP
N  *         @arg @ref MS32_I2C_GENERATE_STOP
N  *         @arg @ref MS32_I2C_GENERATE_START_READ
N  *         @arg @ref MS32_I2C_GENERATE_START_WRITE
N  *         @arg @ref MS32_I2C_GENERATE_RESTART_7BIT_READ
N  *         @arg @ref MS32_I2C_GENERATE_RESTART_7BIT_WRITE
N  *         @arg @ref MS32_I2C_GENERATE_RESTART_10BIT_READ
N  *         @arg @ref MS32_I2C_GENERATE_RESTART_10BIT_WRITE
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_HandleTransfer(I2C_TypeDef *I2Cx, uint32_t SlaveAddr, uint32_t SlaveAddrSize,
Xstatic __inline void MS32_I2C_HandleTransfer(I2C_TypeDef *I2Cx, uint32_t SlaveAddr, uint32_t SlaveAddrSize,
N                                           uint32_t TransferSize, uint32_t EndMode, uint32_t Request) {
N  MODIFY_REG(I2Cx->CR2, I2C_CR2_SADD | I2C_CR2_ADD10 | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP | I2C_CR2_RELOAD |
N             I2C_CR2_NBYTES | I2C_CR2_AUTOEND | I2C_CR2_HEAD10R,
N             SlaveAddr | SlaveAddrSize | (TransferSize << I2C_CR2_NBYTES_Pos) | EndMode | Request);
X  (((I2Cx->CR2)) = ((((((I2Cx->CR2))) & (~((0x3FFUL << (0U)) | (0x1UL << (11U)) | ((0x1UL << (10U)) & (uint32_t)(Request >> (31U - (10U)))) | (0x1UL << (13U)) | (0x1UL << (14U)) | (0x1UL << (24U)) | (0xFFUL << (16U)) | (0x1UL << (25U)) | (0x1UL << (12U))))) | (SlaveAddr | SlaveAddrSize | (TransferSize << (16U)) | EndMode | Request))));
N}
N
N/**
N  * @brief  Indicate the value of transfer direction (slave mode).
N  * @note   RESET: Write transfer, Slave enters in receiver mode.
N  *         SET: Read transfer, Slave enters in transmitter mode.
N  * @rmtoll ISR          DIR           MS32_I2C_GetTransferDirection
N  * @param  I2Cx I2C Instance.
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_I2C_DIRECTION_WRITE
N  *         @arg @ref MS32_I2C_DIRECTION_READ
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetTransferDirection(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetTransferDirection(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->ISR, I2C_ISR_DIR));
X  return (uint32_t)(((I2Cx->ISR) & ((0x1UL << (16U)))));
N}
N
N/**
N  * @brief  Return the slave matched address.
N  * @rmtoll ISR          ADDCODE       MS32_I2C_GetAddressMatchCode
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x00 and Max_Data=0x3F
N  */
N__STATIC_INLINE uint32_t MS32_I2C_GetAddressMatchCode(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetAddressMatchCode(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->ISR, I2C_ISR_ADDCODE) >> I2C_ISR_ADDCODE_Pos << 1);
X  return (uint32_t)(((I2Cx->ISR) & ((0x7FUL << (17U)))) >> (17U) << 1);
N}
N
N/**
N  * @brief  Enable internal comparison of the SMBus Packet Error byte (transmission or reception mode).
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   This feature is cleared by hardware when the PEC byte is transferred, or when a STOP condition or an Address Matched is received.
N  *         This bit has no effect when RELOAD bit is set.
N  *         This bit has no effect in device mode when SBC bit is not set.
N  * @rmtoll CR2          PECBYTE       MS32_I2C_EnableSMBusPECCompare
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_EnableSMBusPECCompare(I2C_TypeDef *I2Cx) {
Xstatic __inline void MS32_I2C_EnableSMBusPECCompare(I2C_TypeDef *I2Cx) {
N  SET_BIT(I2Cx->CR2, I2C_CR2_PECBYTE);
X  ((I2Cx->CR2) |= ((0x1UL << (26U))));
N}
N
N/**
N  * @brief  Check if the SMBus Packet Error byte internal comparison is requested or not.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll CR2          PECBYTE       MS32_I2C_IsEnabledSMBusPECCompare
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2C_IsEnabledSMBusPECCompare(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_IsEnabledSMBusPECCompare(I2C_TypeDef *I2Cx) {
N  return ((READ_BIT(I2Cx->CR2, I2C_CR2_PECBYTE) == (I2C_CR2_PECBYTE)) ? 1UL : 0UL);
X  return ((((I2Cx->CR2) & ((0x1UL << (26U)))) == ((0x1UL << (26U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get the SMBus Packet Error byte calculated.
N  * @note   Macro @ref IS_SMBUS_AMS32_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll PECR         PEC           MS32_I2C_GetSMBusPEC
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
N*/
N__STATIC_INLINE uint32_t MS32_I2C_GetSMBusPEC(I2C_TypeDef *I2Cx) {
Xstatic __inline uint32_t MS32_I2C_GetSMBusPEC(I2C_TypeDef *I2Cx) {
N  return (uint32_t)(READ_BIT(I2Cx->PECR, I2C_PECR_PEC));
X  return (uint32_t)(((I2Cx->PECR) & ((0xFFUL << (0U)))));
N}
N
N/**
N  * @brief  Read Receive Data register.
N  * @rmtoll RXDR         RXDATA        MS32_I2C_ReceiveData8
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint8_t MS32_I2C_ReceiveData8(I2C_TypeDef *I2Cx) {
Xstatic __inline uint8_t MS32_I2C_ReceiveData8(I2C_TypeDef *I2Cx) {
N  return (uint8_t)(READ_BIT(I2Cx->RXDR, I2C_RXDR_RXDATA));
X  return (uint8_t)(((I2Cx->RXDR) & ((0xFFUL << (0U)))));
N}
N
N/**
N  * @brief  Write in Transmit Data Register .
N  * @rmtoll TXDR         TXDATA        MS32_I2C_TransmitData8
N  * @param  I2Cx I2C Instance.
N  * @param  Data Value between Min_Data=0x00 and Max_Data=0xFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2C_TransmitData8(I2C_TypeDef *I2Cx, uint8_t Data) {
Xstatic __inline void MS32_I2C_TransmitData8(I2C_TypeDef *I2Cx, uint8_t Data) {
N  WRITE_REG(I2Cx->TXDR, Data);
X  ((I2Cx->TXDR) = (Data));
N}
N
N
N/** @defgroup I2C_EF_Init Initialization and de-initialization functions
N  * @{
N  */
NErrorStatus MS32_I2C_Init       (I2C_TypeDef *I2Cx, MS32_I2C_InitTypeDef *I2cInitStr);
NErrorStatus MS32_I2C_DeInit     (I2C_TypeDef *I2Cx);
Nvoid        MS32_I2C_StructInit (MS32_I2C_InitTypeDef *I2cInitStr);
N
N/** @defgroup I2C_EF_Application function
N  * @{
N  */
NFlagStatus MS32_I2C_GetStatusFlag(I2C_TypeDef *I2Cx, uint32_t Flags);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_I2C_H */
N
N/******************************** END OF FILE *********************************/
L 73 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_iwdg.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_iwdg.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_IWDG_H
N#define __MS32F0XX_IWDG_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup IWDG_Private_Constants IWDG Private Constants
N  * @{
N  */
N#define MS32_IWDG_KEY_RELOAD                 0x0000AAAAU                   /*!< IWDG Reload Counter Enable   */
N#define MS32_IWDG_KEY_ENABLE                 0x0000CCCCU                   /*!< IWDG Peripheral Enable       */
N#define MS32_IWDG_KEY_WR_ACCESS_ENABLE       0x00005555U                   /*!< IWDG KR Write Access Enable  */
N#define MS32_IWDG_KEY_WR_ACCESS_DISABLE      0x00000000U                   /*!< IWDG KR Write Access Disable */
N
N
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup IWDG_Exported_Types IWDG Exported Types
N  * @{
N  */
N
N/**
N  * @brief  IWDG Init structure definition
N  */
Ntypedef struct {
N  uint32_t Prescaler;  /*!< Select the prescaler of the IWDG.
N                            This parameter can be a value of @ref IWDG_Prescaler */
N  uint32_t Reload;     /*!< Specifies the IWDG down-counter reload value.
N                            This parameter must be a number between Min_Data = 0 and Max_Data = 0x0FFF */
N  uint32_t Window;     /*!< Specifies the window value to be compared to the down-counter.
N                            This parameter must be a number between Min_Data = 0 and Max_Data = 0x0FFF */
N} MS32_IWDG_InitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup IWDG_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with MS32_IWDG_ReadReg function
N  * @{
N  */
N#define MS32_IWDG_FLAG_PVU                   IWDG_SR_PVU /*!< Watchdog prescaler value update */
N#define MS32_IWDG_FLAG_RVU                   IWDG_SR_RVU /*!< Watchdog counter reload value update */
N#define MS32_IWDG_FLAG_WVU                   IWDG_SR_WVU /*!< Watchdog counter window value update */
N
N
N/** @defgroup IWDG_EC_PRESCALER  Prescaler Divider
N  * @{
N  */
N#define MS32_IWDG_PRESCALER_4                0x00000000U                    /*!< Divider by 4   */
N#define MS32_IWDG_PRESCALER_8                (IWDG_PR_PR_0)                 /*!< Divider by 8   */
N#define MS32_IWDG_PRESCALER_16               (IWDG_PR_PR_1)                 /*!< Divider by 16  */
N#define MS32_IWDG_PRESCALER_32               (IWDG_PR_PR_1 | IWDG_PR_PR_0)  /*!< Divider by 32  */
N#define MS32_IWDG_PRESCALER_64               (IWDG_PR_PR_2)                 /*!< Divider by 64  */
N#define MS32_IWDG_PRESCALER_128              (IWDG_PR_PR_2 | IWDG_PR_PR_0)  /*!< Divider by 128 */
N#define MS32_IWDG_PRESCALER_256              (IWDG_PR_PR_2 | IWDG_PR_PR_1)  /*!< Divider by 256 */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup IWDG_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in IWDG register
N  * @param  __INSTANCE__ IWDG Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_IWDG_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in IWDG register
N  * @param  __INSTANCE__ IWDG Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_IWDG_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup IWDG_EF_Configuration Configuration
N  * @{
N  */
N
N/**
N  * @brief  Start the Independent Watchdog
N  * @note   Except if the hardware watchdog option is selected
N  * @rmtoll KR           KEY           MS32_IWDG_Enable
N  * @param  IWDGx IWDG Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_IWDG_Enable(IWDG_TypeDef *IWDGx) {
Xstatic __inline void MS32_IWDG_Enable(IWDG_TypeDef *IWDGx) {
N  WRITE_REG(IWDGx->KR, MS32_IWDG_KEY_ENABLE);
X  ((IWDGx->KR) = (0x0000CCCCU));
N}
N
N/**
N  * @brief  Reloads IWDG counter with value defined in the reload register
N  * @rmtoll KR           KEY           MS32_IWDG_ReloadCounter
N  * @param  IWDGx IWDG Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_IWDG_ReloadCounter(IWDG_TypeDef *IWDGx) {
Xstatic __inline void MS32_IWDG_ReloadCounter(IWDG_TypeDef *IWDGx) {
N  WRITE_REG(IWDGx->KR, MS32_IWDG_KEY_RELOAD);
X  ((IWDGx->KR) = (0x0000AAAAU));
N}
N
N/**
N  * @brief  Enable write access to IWDG_PR, IWDG_RLR and IWDG_WINR registers
N  * @rmtoll KR           KEY           MS32_IWDG_EnableWriteAccess
N  * @param  IWDGx IWDG Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_IWDG_EnableWriteAccess(IWDG_TypeDef *IWDGx) {
Xstatic __inline void MS32_IWDG_EnableWriteAccess(IWDG_TypeDef *IWDGx) {
N  WRITE_REG(IWDGx->KR, MS32_IWDG_KEY_WR_ACCESS_ENABLE);
X  ((IWDGx->KR) = (0x00005555U));
N}
N
N/**
N  * @brief  Disable write access to IWDG_PR, IWDG_RLR and IWDG_WINR registers
N  * @rmtoll KR           KEY           MS32_IWDG_DisableWriteAccess
N  * @param  IWDGx IWDG Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_IWDG_DisableWriteAccess(IWDG_TypeDef *IWDGx) {
Xstatic __inline void MS32_IWDG_DisableWriteAccess(IWDG_TypeDef *IWDGx) {
N  WRITE_REG(IWDGx->KR, MS32_IWDG_KEY_WR_ACCESS_DISABLE);
X  ((IWDGx->KR) = (0x00000000U));
N}
N
N/**
N  * @brief  Select the prescaler of the IWDG
N  * @rmtoll PR           PR            MS32_IWDG_SetPrescaler
N  * @param  IWDGx IWDG Instance
N  * @param  Prescaler This parameter can be one of the following values:
N  *         @arg @ref MS32_IWDG_PRESCALER_4
N  *         @arg @ref MS32_IWDG_PRESCALER_8
N  *         @arg @ref MS32_IWDG_PRESCALER_16
N  *         @arg @ref MS32_IWDG_PRESCALER_32
N  *         @arg @ref MS32_IWDG_PRESCALER_64
N  *         @arg @ref MS32_IWDG_PRESCALER_128
N  *         @arg @ref MS32_IWDG_PRESCALER_256
N  * @retval None
N  */
N__STATIC_INLINE void MS32_IWDG_SetPrescaler(IWDG_TypeDef *IWDGx, uint32_t Prescaler) {
Xstatic __inline void MS32_IWDG_SetPrescaler(IWDG_TypeDef *IWDGx, uint32_t Prescaler) {
N  WRITE_REG(IWDGx->PR, IWDG_PR_PR & Prescaler);
X  ((IWDGx->PR) = ((0x7UL << (0U)) & Prescaler));
N}
N
N/**
N  * @brief  Get the selected prescaler of the IWDG
N  * @rmtoll PR           PR            MS32_IWDG_GetPrescaler
N  * @param  IWDGx IWDG Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_IWDG_PRESCALER_4
N  *         @arg @ref MS32_IWDG_PRESCALER_8
N  *         @arg @ref MS32_IWDG_PRESCALER_16
N  *         @arg @ref MS32_IWDG_PRESCALER_32
N  *         @arg @ref MS32_IWDG_PRESCALER_64
N  *         @arg @ref MS32_IWDG_PRESCALER_128
N  *         @arg @ref MS32_IWDG_PRESCALER_256
N  */
N__STATIC_INLINE uint32_t MS32_IWDG_GetPrescaler(IWDG_TypeDef *IWDGx) {
Xstatic __inline uint32_t MS32_IWDG_GetPrescaler(IWDG_TypeDef *IWDGx) {
N  return (READ_REG(IWDGx->PR));
X  return (((IWDGx->PR)));
N}
N
N/**
N  * @brief  Specify the IWDG down-counter reload value
N  * @rmtoll RLR          RL            MS32_IWDG_SetReloadCounter
N  * @param  IWDGx IWDG Instance
N  * @param  Counter Value between Min_Data=0 and Max_Data=0x0FFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_IWDG_SetReloadCounter(IWDG_TypeDef *IWDGx, uint32_t Counter) {
Xstatic __inline void MS32_IWDG_SetReloadCounter(IWDG_TypeDef *IWDGx, uint32_t Counter) {
N  WRITE_REG(IWDGx->RLR, IWDG_RLR_RL & Counter);
X  ((IWDGx->RLR) = ((0xFFFUL << (0U)) & Counter));
N}
N
N/**
N  * @brief  Get the specified IWDG down-counter reload value
N  * @rmtoll RLR          RL            MS32_IWDG_GetReloadCounter
N  * @param  IWDGx IWDG Instance
N  * @retval Value between Min_Data=0 and Max_Data=0x0FFF
N  */
N__STATIC_INLINE uint32_t MS32_IWDG_GetReloadCounter(IWDG_TypeDef *IWDGx) {
Xstatic __inline uint32_t MS32_IWDG_GetReloadCounter(IWDG_TypeDef *IWDGx) {
N  return (READ_REG(IWDGx->RLR));
X  return (((IWDGx->RLR)));
N}
N
N/**
N  * @brief  Specify high limit of the window value to be compared to the down-counter.
N  * @rmtoll WINR         WIN           MS32_IWDG_SetWindow
N  * @param  IWDGx IWDG Instance
N  * @param  Window Value between Min_Data=0 and Max_Data=0x0FFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_IWDG_SetWindow(IWDG_TypeDef *IWDGx, uint32_t Window) {
Xstatic __inline void MS32_IWDG_SetWindow(IWDG_TypeDef *IWDGx, uint32_t Window) {
N  WRITE_REG(IWDGx->WINR, IWDG_WINR_WIN & Window);
X  ((IWDGx->WINR) = ((0xFFFUL << (0U)) & Window));
N}
N
N/**
N  * @brief  Get the high limit of the window value specified.
N  * @rmtoll WINR         WIN           MS32_IWDG_GetWindow
N  * @param  IWDGx IWDG Instance
N  * @retval Value between Min_Data=0 and Max_Data=0x0FFF
N  */
N__STATIC_INLINE uint32_t MS32_IWDG_GetWindow(IWDG_TypeDef *IWDGx) {
Xstatic __inline uint32_t MS32_IWDG_GetWindow(IWDG_TypeDef *IWDGx) {
N  return (READ_REG(IWDGx->WINR));
X  return (((IWDGx->WINR)));
N}
N
N
N/** @defgroup IWDG_EF_FLAG_Management FLAG_Management
N  * @{
N  */
N
N/**
N  * @brief  Check if flag Prescaler Value Update is set or not
N  * @rmtoll SR           PVU           MS32_IWDG_IsActiveFlag_PVU
N  * @param  IWDGx IWDG Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_IWDG_IsActiveFlag_PVU(IWDG_TypeDef *IWDGx) {
Xstatic __inline uint32_t MS32_IWDG_IsActiveFlag_PVU(IWDG_TypeDef *IWDGx) {
N  return ((READ_BIT(IWDGx->SR, IWDG_SR_PVU) == (IWDG_SR_PVU)) ? 1UL : 0UL);
X  return ((((IWDGx->SR) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if flag Reload Value Update is set or not
N  * @rmtoll SR           RVU           MS32_IWDG_IsActiveFlag_RVU
N  * @param  IWDGx IWDG Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_IWDG_IsActiveFlag_RVU(IWDG_TypeDef *IWDGx) {
Xstatic __inline uint32_t MS32_IWDG_IsActiveFlag_RVU(IWDG_TypeDef *IWDGx) {
N  return ((READ_BIT(IWDGx->SR, IWDG_SR_RVU) == (IWDG_SR_RVU)) ? 1UL : 0UL);
X  return ((((IWDGx->SR) & ((0x1UL << (1U)))) == ((0x1UL << (1U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if flag Window Value Update is set or not
N  * @rmtoll SR           WVU           MS32_IWDG_IsActiveFlag_WVU
N  * @param  IWDGx IWDG Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_IWDG_IsActiveFlag_WVU(IWDG_TypeDef *IWDGx) {
Xstatic __inline uint32_t MS32_IWDG_IsActiveFlag_WVU(IWDG_TypeDef *IWDGx) {
N  return ((READ_BIT(IWDGx->SR, IWDG_SR_WVU) == (IWDG_SR_WVU)) ? 1UL : 0UL);
X  return ((((IWDGx->SR) & ((0x1UL << (2U)))) == ((0x1UL << (2U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if all flags Prescaler, Reload & Window Value Update are reset or not
N  * @rmtoll SR           PVU           MS32_IWDG_IsReady\n
N  *         SR           WVU           MS32_IWDG_IsReady\n
N  *         SR           RVU           MS32_IWDG_IsReady
N  * @param  IWDGx IWDG Instance
N  * @retval State of bits (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_IWDG_IsReady(IWDG_TypeDef *IWDGx) {
Xstatic __inline uint32_t MS32_IWDG_IsReady(IWDG_TypeDef *IWDGx) {
N  return ((READ_BIT(IWDGx->SR, IWDG_SR_PVU | IWDG_SR_RVU | IWDG_SR_WVU) == 0U) ? 1UL : 0UL);
X  return ((((IWDGx->SR) & ((0x1UL << (0U)) | (0x1UL << (1U)) | (0x1UL << (2U)))) == 0U) ? 1UL : 0UL);
N}
N
N
N/** @defgroup WWDG_EF_Init Initialization functions
N  * @{
N  */
Nvoid        MS32_IWDG_StructInit (MS32_IWDG_InitTypeDef *IwdgInitStr);
NErrorStatus MS32_IWDG_Init       (MS32_IWDG_InitTypeDef *IwdgInitStr);
N
N/** @defgroup WWDG_EF_Application function
N  * @{
N  */
Nvoid       MS32_IWDG_Refresh       (void);
NFlagStatus MS32_IWDG_GetStatusFlag (uint32_t Flags);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_IWDG_H */
N
N/******************************** END OF FILE *********************************/
L 74 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_opamp.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_opamp.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_OPAMP_H
N#define __MS32F0XX_OPAMP_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/**
N  * @brief OP Init Structure definition
N  */
Ntypedef struct {
N  uint32_t OutputEn;          /*!< The new state of the operation output polarity.
N                                   This parameter can be a value of @ref OP_OUT_EN */
N  uint32_t GAIN;              /*!< The new state of the operation gaom selection.
N                                   This parameter can be a value of @ref OP_GAIN_SEL */
N  uint32_t NegitiveInputSel;  /*!< The new state of the operation negitive input selection.
N                                   This parameter can be a value of @ref OP_OUTPUT_FILTER */
N} MS32_OP_InitTypeDef;
N
N/**
N  * @brief OP calibration Structure definition
N  */
Ntypedef struct {
N  uint8_t OpPosCaliData;      /*!< The value of the operation position calibration register. */
N  uint8_t OpNegCaliData;      /*!< The value of the operation negative calibration register. */
N} MS32_OP_CaliTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup OP_UNIT Operation unit
N  * @{
N  */
N#define MS32_OP1                     (0x00000001U)
N#define MS32_OP2                     (0x00000002U)
N#define MS32_OP3                     (0x00000004U)
N
N
N/** @defgroup OP_LOCK Operation lock
N  * @{
N  */
N#define MS32_OP_UNLOCK               (0x00000000U)
N#define MS32_OP_LOCK                 OPAMP_OPCR_OPAMPLCK
N
N
N/** @defgroup OP_OUT_EN Operation output enable
N  * @{
N  */
N#define MS32_OP_OUT_DIS              (0x00000000U)
N#define MS32_OP_OUT_EN               OPAMP_OPCR_OPAMP1OUTEN
N
N
N/** @defgroup OP_GAIN_SEL Operation gain selection
N  * @{
N  */
N#define MS32_OP_GAIN2               (0x00000000U)
N#define MS32_OP_GAIN4               OPAMP_OPCR_OPAMP1GAIN_0
N#define MS32_OP_GAIN8               OPAMP_OPCR_OPAMP1GAIN_1
N#define MS32_OP_GAIN16              (OPAMP_OPCR_OPAMP1GAIN_1 | OPAMP_OPCR_OPAMP1GAIN_0)
N
N
N/** @defgroup OP_NEG_INPUT_SEL Operation negative input selection
N  * @{
N  */
N#define MS32_OP_NEGINPUT_PIN        (0x00000000U)
N#define MS32_OP_NEGINPUT_OPOUT      OPAMP_OPCR_OPAMP1NSEL_0
N#define MS32_OP_NEGINPUT_GAIN       OPAMP_OPCR_OPAMP1NSEL_1
N#define MS32_OP_NEGINPUT_GAIN_PIN   (OPAMP_OPCR_OPAMP1NSEL_1 | OPAMP_OPCR_OPAMP1NSEL_0)
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup OP_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in OP register
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_OP_WriteReg(__REG__, __VALUE__) WRITE_REG(CMP_OP->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in OP register
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_OP_ReadReg(__REG__) READ_REG(CMP_OP->__REG__)
N
N
N/* Exported functions --------------------------------------------------------*/
N/**
N  * @brief  Enable operation 1
N  * @rmtoll OPCR           OP1ON         MS32_OP1_Enable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_OP1_Enable(void) {
Xstatic __inline void MS32_OP1_Enable(void) {
N  SET_BIT(CMP_OP->OPCR, OPAMP_OPCR_OPAMP1EN);
X  ((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->OPCR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable operation 1
N  * @rmtoll OPCR           OP1ON         MS32_OP1_Disable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_OP1_Disable(void) {
Xstatic __inline void MS32_OP1_Disable(void) {
N  CLEAR_BIT(CMP_OP->OPCR, OPAMP_OPCR_OPAMP1EN);
X  ((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->OPCR) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Enable operation 2
N  * @rmtoll OPCR           OP2ON         MS32_OP2_Enable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_OP2_Enable(void) {
Xstatic __inline void MS32_OP2_Enable(void) {
N  SET_BIT(CMP_OP->OPCR, OPAMP_OPCR_OPAMP2EN);
X  ((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->OPCR) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable operation 2
N  * @rmtoll OPCR           OP2ON         MS32_OP2_Disable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_OP2_Disable(void) {
Xstatic __inline void MS32_OP2_Disable(void) {
N  CLEAR_BIT(CMP_OP->OPCR, OPAMP_OPCR_OPAMP2EN);
X  ((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->OPCR) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Enable operation 3
N  * @rmtoll OPCR           OP3ON         MS32_OP3_Enable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_OP3_Enable(void) {
Xstatic __inline void MS32_OP3_Enable(void) {
N  SET_BIT(CMP_OP->OPCR, OPAMP_OPCR_OPAMP3EN);
X  ((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->OPCR) |= ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Disable operation 3
N  * @rmtoll OPCR           OP3ON         MS32_OP3_Disable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_OP3_Disable(void) {
Xstatic __inline void MS32_OP3_Disable(void) {
N  CLEAR_BIT(CMP_OP->OPCR, OPAMP_OPCR_OPAMP3EN);
X  ((((CMP_OP_TypeDef *) (0x40000000UL + 0x00013C00UL))->OPCR) &= ~((0x1UL << (16U))));
N}
N
N
N/** @defgroup OP_EF_Init Initialization and de-initialization functions
N  * @{
N  */
NErrorStatus MS32_OP_DeInit     (uint32_t OpUnit);
Nvoid        MS32_OP_StructInit (MS32_OP_InitTypeDef *OpInitStr);
NErrorStatus MS32_OP_Init       (uint32_t OpUnit, MS32_OP_InitTypeDef *OpInitStr);
N
N/** @defgroup OP_EF_Application function
N  * @{
N  */
NErrorStatus MS32_OP_GetCaliValue (uint32_t OpUnit, MS32_OP_CaliTypeDef *OpCaliStr);
NErrorStatus MS32_OP_SetCaliValue (uint32_t OpUnit, MS32_OP_CaliTypeDef *OpCaliStr);
Nvoid        MS32_OP_LockEn       (void);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_OPAMP_H */
N
N/******************************** END OF FILE *********************************/
L 75 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_pwr.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_pwr.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_PWR_H
N#define __MS32F0XX_PWR_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup MS32_PWR_Exported_Types PWR Exported Types
N  * @{
N  */
N
N/**
N  * @brief PWR Init Structure definition
N  */
Ntypedef struct {
N  uint32_t BackupAccessStatus;     /*!< The new state of the backup access write protection.
N                                        This parameter can be a value of @ref PWR_EC_BKUP_ACCESS */
N  uint32_t WakeupPin;              /*!< The new state of the wakeup pin.
N                                        This parameter can be a value of @ref PWR_EC_WAKEUP_PIN */
N  uint32_t PowerVoltDetectSel;     /*!< The new state of the power voltage detector and selection.
N                                        This parameter can be a value of @ref PWR_EC_PVDLEVEL */
N  uint32_t PowerVoltDetectLock;    /*!< The new state of the power voltage detector and selection.
N                                        This parameter can be a value of @ref SYSCFG_EC_PVD_LOCK */          
N} MS32_PWR_InitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup MS32_PWR_Exported_Constants PWR Exported Constants
N  * @{
N  */
N
N/** @defgroup PWR_EC_BKUP_ACCESS  Access to RTC and Backup
N  * @{
N  */
N#define MS32_PWR_BKUPACC_DIS                 (0x00000000U) /*!< Access to RTC and Backup registers disabled */
N#define MS32_PWR_BKUPACC_EN                  PWR_CR_DBP    /*!< Access to RTC and Backup registers enabled  */
N
N
N/** @defgroup PWR_EC_PVDLEVEL Power Voltage Detector Level
N  * @{
N  */
N#define MS32_PWR_PVDOFF                      (0x00000000U)                   /*!< Voltage threshold off */
N#define MS32_PWR_PVDON_LEVEL0                (PWR_CR_PLS_LEV0 | PWR_CR_PVDE) /*!< Voltage threshold 0   */
N#define MS32_PWR_PVDON_LEVEL1                (PWR_CR_PLS_LEV1 | PWR_CR_PVDE) /*!< Voltage threshold 1   */
N#define MS32_PWR_PVDON_LEVEL2                (PWR_CR_PLS_LEV2 | PWR_CR_PVDE) /*!< Voltage threshold 2   */
N#define MS32_PWR_PVDON_LEVEL3                (PWR_CR_PLS_LEV3 | PWR_CR_PVDE) /*!< Voltage threshold 3   */
N#define MS32_PWR_PVDON_LEVEL4                (PWR_CR_PLS_LEV4 | PWR_CR_PVDE) /*!< Voltage threshold 4   */
N#define MS32_PWR_PVDON_LEVEL5                (PWR_CR_PLS_LEV5 | PWR_CR_PVDE) /*!< Voltage threshold 5   */
N#define MS32_PWR_PVDON_LEVEL6                (PWR_CR_PLS_LEV6 | PWR_CR_PVDE) /*!< Voltage threshold 6   */
N#define MS32_PWR_PVDON_LEVEL7                (PWR_CR_PLS_LEV7 | PWR_CR_PVDE) /*!< Voltage threshold 7   */
N
N
N/** @defgroup PWR_EC_WAKEUP_PIN  Wakeup Pins
N  * @{
N  */
N#define MS32_PWR_WAKEUP_NONE                 (0x00000000U)          /*!< No WKUP pin */
N#define MS32_PWR_WAKEUP_PIN1                 PWR_CSR_EWUP1          /*!< WKUP pin 1 : PA0 */
N#define MS32_PWR_WAKEUP_PIN2                 PWR_CSR_EWUP2          /*!< WKUP pin 2 : PC13 */
N
N
N/** @defgroup PWR_EC_STATE_STOP_mode PWR Regulator state in STOP mode
N  * @{
N  */
N#define PWR_MAINREGULATOR_ON                 (0x00000000U)
N#define PWR_LOWPOWERREGULATOR_ON             PWR_CR_LPDS
N
N
N/** @defgroup SYSCFG_EC_PVD_LOCK Sysclk PVD lock
N  * @{
N  */
N#define MS32_SYSCFG_PVD_UNLOCK               (0x00000000U)          /*!< PVD unlock without time break */
N#define MS32_SYSCFG_PVD_LOCK                 SYSCFG_CFGR2_PVD_LOCK  /*!< PVD lock with time break   */
N
N
N/** @defgroup PWR_SLEEP_mode_entry PWR SLEEP mode entry
N  * @{
N  */
N#define PWR_SLEEPENTRY_WFI                   (0x00000001U)
N#define PWR_SLEEPENTRY_WFE                   (0x00000002U)
N
N
N/** @defgroup PWR_STOP_mode_entry PWR STOP mode entry
N  * @{
N  */
N#define PWR_STOPENTRY_WFI                    (0x00000001U)
N#define PWR_STOPENTRY_WFE                    (0x00000002U)
N
N
N/** @defgroup PWR_EC_MODE_PWR Mode Power
N  * @{
N  */
N#define MS32_PWR_MODE_STOP_MAINREGU          (0x00000000U)          /*!< Enter Stop mode when the CPU enters deepsleep */
N#define MS32_PWR_MODE_STOP_LPREGU            PWR_CR_LPDS            /*!< Enter Stop mode (with low power Regulator ON) when the CPU enters deepsleep */
N#define MS32_PWR_MODE_STANDBY                PWR_CR_PDDS            /*!< Enter Standby mode when the CPU enters deepsleep */
N
N#define MS32_PWR_REGU_DSMODE_MAIN            (0x00000000U)          /*!< Voltage Regulator in main mode during deepsleep mode */
N#define MS32_PWR_REGU_DSMODE_LOW_POWER       PWR_CR_LPDS            /*!< Voltage Regulator in low-power mode during deepsleep mode */
N
N
N/** @defgroup PWR_EC_CLEAR_FLAG Clear Flags Defines
N  * @{
N  */
N#define MS32_PWR_CR_CWUF                     PWR_CR_CWUF            /*!< Clear wakeup flag  */
N#define MS32_PWR_CR_CSBF                     PWR_CR_CSBF            /*!< Clear standby flag */
N
N
N/** @defgroup PWR_EC_GET_FLAG Get Flags Defines
N  * @{
N  */
N#define MS32_PWR_CSR_WUF                     PWR_CSR_WUF            /*!< Wakeup flag */
N#define MS32_PWR_CSR_SBF                     PWR_CSR_SBF            /*!< Standby flag */
N#define MS32_PWR_CSR_PVDO                    PWR_CSR_PVDO           /*!< Power voltage detector output flag */
N
N
N/** @defgroup PWR_PVDI_Mode PWR power voltage detector interrupt Mode
N  * @{
N  */
N#define MS32_PWR_PVDIT_DISABLE               (0x00000000U)          /*!< PVD interrupt disable */
N#define MS32_PWR_PVDIT_ENABLE                (0x00000001U)          /*!< PVD interrupt enable */
N
N/** @defgroup PWR_EC_PVDLEVEL Power Voltage Detector Level
N  * @{
N  */
N#define MS32_PWR_PVDLEVEL_0                (PWR_CR_PLS_LEV0)      /*!< Voltage threshold 0   */
N#define MS32_PWR_PVDLEVEL_1                (PWR_CR_PLS_LEV1)      /*!< Voltage threshold 1   */
N#define MS32_PWR_PVDLEVEL_2                (PWR_CR_PLS_LEV2)      /*!< Voltage threshold 2   */
N#define MS32_PWR_PVDLEVEL_3                (PWR_CR_PLS_LEV3)      /*!< Voltage threshold 3   */
N#define MS32_PWR_PVDLEVEL_4                (PWR_CR_PLS_LEV4)      /*!< Voltage threshold 4   */
N#define MS32_PWR_PVDLEVEL_5                (PWR_CR_PLS_LEV5)      /*!< Voltage threshold 5   */
N#define MS32_PWR_PVDLEVEL_6                (PWR_CR_PLS_LEV6)      /*!< Voltage threshold 6   */
N#define MS32_PWR_PVDLEVEL_7                (PWR_CR_PLS_LEV7)      /*!< Voltage threshold 7   */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup PWR_EM_WRITE_READ Common write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in PWR register
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_PWR_WriteReg(__REG__, __VALUE__) WRITE_REG(PWR->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in PWR register
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_PWR_ReadReg(__REG__) READ_REG(PWR->__REG__)
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup PWR_EF_Configuration Configuration
N  * @{
N  */
N
N/**
N  * @brief  Enable access to the backup domain
N  * @rmtoll CR    DBP       MS32_PWR_EnableBkUpAccess
N  * @retval None
N  */
N__STATIC_INLINE void MS32_PWR_EnableBkUpAccess(void) {
Xstatic __inline void MS32_PWR_EnableBkUpAccess(void) {
N  SET_BIT(PWR->CR, PWR_CR_DBP);
X  ((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable access to the backup domain
N  * @rmtoll CR    DBP       MS32_PWR_DisableBkUpAccess
N  * @retval None
N  */
N__STATIC_INLINE void MS32_PWR_DisableBkUpAccess(void) {
Xstatic __inline void MS32_PWR_DisableBkUpAccess(void) {
N  CLEAR_BIT(PWR->CR, PWR_CR_DBP);
X  ((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Check if the backup domain is enabled
N  * @rmtoll CR    DBP       MS32_PWR_IsEnabledBkUpAccess
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_PWR_IsEnabledBkUpAccess(void) {
Xstatic __inline uint32_t MS32_PWR_IsEnabledBkUpAccess(void) {
N  return (READ_BIT(PWR->CR, PWR_CR_DBP) == (PWR_CR_DBP));
X  return (((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Set voltage Regulator mode during deep sleep mode
N  * @rmtoll CR    LPDS         MS32_PWR_SetRegulModeDS
N  * @param  RegulMode This parameter can be one of the following values:
N  *         @arg @ref MS32_PWR_REGU_DSMODE_MAIN
N  *         @arg @ref MS32_PWR_REGU_DSMODE_LOW_POWER
N  * @retval None
N  */
N__STATIC_INLINE void MS32_PWR_SetRegulModeDS(uint32_t RegulMode) {
Xstatic __inline void MS32_PWR_SetRegulModeDS(uint32_t RegulMode) {
N  MODIFY_REG(PWR->CR, PWR_CR_LPDS, RegulMode);
X  (((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR)) = ((((((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR))) & (~((0x1UL << (0U))))) | (RegulMode))));
N}
N
N/**
N  * @brief  Get voltage Regulator mode during deep sleep mode
N  * @rmtoll CR    LPDS         MS32_PWR_GetRegulModeDS
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_PWR_REGU_DSMODE_MAIN
N  *         @arg @ref MS32_PWR_REGU_DSMODE_LOW_POWER
N  */
N__STATIC_INLINE uint32_t MS32_PWR_GetRegulModeDS(void) {
Xstatic __inline uint32_t MS32_PWR_GetRegulModeDS(void) {
N  return (uint32_t)(READ_BIT(PWR->CR, PWR_CR_LPDS));
X  return (uint32_t)(((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR) & ((0x1UL << (0U)))));
N}
N
N/**
N  * @brief  Set Power Down mode when CPU enters deepsleep
N  * @rmtoll CR    PDDS         MS32_PWR_SetPowerMode\n
N  * @rmtoll CR    LPDS         MS32_PWR_SetPowerMode
N  * @param  PDMode This parameter can be one of the following values:
N  *         @arg @ref MS32_PWR_MODE_STOP_MAINREGU
N  *         @arg @ref MS32_PWR_MODE_STOP_LPREGU
N  *         @arg @ref MS32_PWR_MODE_STANDBY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_PWR_SetPowerMode(uint32_t PDMode) {
Xstatic __inline void MS32_PWR_SetPowerMode(uint32_t PDMode) {
N  MODIFY_REG(PWR->CR, (PWR_CR_PDDS | PWR_CR_LPDS), PDMode);
X  (((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR)) = ((((((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR))) & (~(((0x1UL << (1U)) | (0x1UL << (0U)))))) | (PDMode))));
N}
N
N/**
N  * @brief  Get Power Down mode when CPU enters deepsleep
N  * @rmtoll CR    PDDS         MS32_PWR_GetPowerMode\n
N  * @rmtoll CR    LPDS         MS32_PWR_GetPowerMode
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_PWR_MODE_STOP_MAINREGU
N  *         @arg @ref MS32_PWR_MODE_STOP_LPREGU
N  *         @arg @ref MS32_PWR_MODE_STANDBY
N  */
N__STATIC_INLINE uint32_t MS32_PWR_GetPowerMode(void) {
Xstatic __inline uint32_t MS32_PWR_GetPowerMode(void) {
N  return (uint32_t)(READ_BIT(PWR->CR, (PWR_CR_PDDS | PWR_CR_LPDS)));
X  return (uint32_t)(((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR) & (((0x1UL << (1U)) | (0x1UL << (0U))))));
N}
N
N/**
N  * @brief  Configure the voltage threshold detected by the Power Voltage Detector
N  * @rmtoll CR    PLS       MS32_PWR_SetPVDLevel
N  * @param  PVDLevel This parameter can be one of the following values:
N  *         @arg @ref MS32_PWR_PVDLEVEL_0
N  *         @arg @ref MS32_PWR_PVDLEVEL_1
N  *         @arg @ref MS32_PWR_PVDLEVEL_2
N  *         @arg @ref MS32_PWR_PVDLEVEL_3
N  *         @arg @ref MS32_PWR_PVDLEVEL_4
N  *         @arg @ref MS32_PWR_PVDLEVEL_5
N  *         @arg @ref MS32_PWR_PVDLEVEL_6
N  *         @arg @ref MS32_PWR_PVDLEVEL_7
N  * @retval None
N  */
N__STATIC_INLINE void MS32_PWR_SetPVDLevel(uint32_t PVDLevel) {
Xstatic __inline void MS32_PWR_SetPVDLevel(uint32_t PVDLevel) {
N  MODIFY_REG(PWR->CR, PWR_CR_PLS, PVDLevel);
X  (((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR)) = ((((((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR))) & (~((0x7UL << (5U))))) | (PVDLevel))));
N}
N
N/**
N  * @brief  Get the voltage threshold detection
N  * @rmtoll CR    PLS       MS32_PWR_GetPVDLevel
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_PWR_PVDLEVEL_0
N  *         @arg @ref MS32_PWR_PVDLEVEL_1
N  *         @arg @ref MS32_PWR_PVDLEVEL_2
N  *         @arg @ref MS32_PWR_PVDLEVEL_3
N  *         @arg @ref MS32_PWR_PVDLEVEL_4
N  *         @arg @ref MS32_PWR_PVDLEVEL_5
N  *         @arg @ref MS32_PWR_PVDLEVEL_6
N  *         @arg @ref MS32_PWR_PVDLEVEL_7
N  */
N__STATIC_INLINE uint32_t MS32_PWR_GetPVDLevel(void) {
Xstatic __inline uint32_t MS32_PWR_GetPVDLevel(void) {
N  return (uint32_t)(READ_BIT(PWR->CR, PWR_CR_PLS));
X  return (uint32_t)(((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR) & ((0x7UL << (5U)))));
N}
N
N/**
N  * @brief  Enable Power Voltage Detector
N  * @rmtoll CR    PVDE       MS32_PWR_EnablePVD
N  * @retval None
N  */
N__STATIC_INLINE void MS32_PWR_EnablePVD(void) {
Xstatic __inline void MS32_PWR_EnablePVD(void) {
N  SET_BIT(PWR->CR, PWR_CR_PVDE);
X  ((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Disable Power Voltage Detector
N  * @rmtoll CR    PVDE       MS32_PWR_DisablePVD
N  * @retval None
N  */
N__STATIC_INLINE void MS32_PWR_DisablePVD(void) {
Xstatic __inline void MS32_PWR_DisablePVD(void) {
N  CLEAR_BIT(PWR->CR, PWR_CR_PVDE);
X  ((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR) &= ~((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Check if Power Voltage Detector is enabled
N  * @rmtoll CR    PVDE       MS32_PWR_IsEnabledPVD
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_PWR_IsEnabledPVD(void) {
Xstatic __inline uint32_t MS32_PWR_IsEnabledPVD(void) {
N  return (READ_BIT(PWR->CR, PWR_CR_PVDE) == (PWR_CR_PVDE));
X  return (((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Enable the WakeUp PINx functionality
N  * @rmtoll CSR   EWUP1       MS32_PWR_EnableWakeUpPin\n
N  * @rmtoll CSR   EWUP2       MS32_PWR_EnableWakeUpPin
N  * @param  WakeUpPin This parameter can be one of the following values:
N  *         @arg @ref MS32_PWR_WAKEUP_PIN1
N  *         @arg @ref MS32_PWR_WAKEUP_PIN2
N  * @retval None
N  */
N__STATIC_INLINE void MS32_PWR_EnableWakeUpPin(uint32_t WakeUpPin) {
Xstatic __inline void MS32_PWR_EnableWakeUpPin(uint32_t WakeUpPin) {
N  SET_BIT(PWR->CSR, WakeUpPin);
X  ((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CSR) |= (WakeUpPin));
N}
N
N/**
N  * @brief  Disable the WakeUp PINx functionality
N  * @rmtoll CSR   EWUP1       MS32_PWR_DisableWakeUpPin\n
N  * @rmtoll CSR   EWUP2       MS32_PWR_DisableWakeUpPin
N  * @param  WakeUpPin This parameter can be one of the following values:
N  *         @arg @ref MS32_PWR_WAKEUP_PIN1
N  *         @arg @ref MS32_PWR_WAKEUP_PIN2
N  * @retval None
N  */
N__STATIC_INLINE void MS32_PWR_DisableWakeUpPin(uint32_t WakeUpPin) {
Xstatic __inline void MS32_PWR_DisableWakeUpPin(uint32_t WakeUpPin) {
N  CLEAR_BIT(PWR->CSR, WakeUpPin);
X  ((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CSR) &= ~(WakeUpPin));
N}
N
N/**
N  * @brief  Check if the WakeUp PINx functionality is enabled
N  * @rmtoll CSR   EWUP1       MS32_PWR_IsEnabledWakeUpPin\n
N  * @rmtoll CSR   EWUP2       MS32_PWR_IsEnabledWakeUpPin
N  * @param  WakeUpPin This parameter can be one of the following values:
N  *         @arg @ref MS32_PWR_WAKEUP_PIN1
N  *         @arg @ref MS32_PWR_WAKEUP_PIN2
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_PWR_IsEnabledWakeUpPin(uint32_t WakeUpPin) {
Xstatic __inline uint32_t MS32_PWR_IsEnabledWakeUpPin(uint32_t WakeUpPin) {
N  return (READ_BIT(PWR->CSR, WakeUpPin) == (WakeUpPin));
X  return (((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CSR) & (WakeUpPin)) == (WakeUpPin));
N}
N
N
N/** @defgroup PWR_EF_FLAG_Management FLAG_Management
N  * @{
N  */
N
N/**
N  * @brief  Get Wake-up Flag
N  * @rmtoll CSR   WUF       MS32_PWR_IsActiveFlag_WU
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_PWR_IsActiveFlag_WU(void) {
Xstatic __inline uint32_t MS32_PWR_IsActiveFlag_WU(void) {
N  return (READ_BIT(PWR->CSR, PWR_CSR_WUF) == (PWR_CSR_WUF));
X  return (((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CSR) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Get Standby Flag
N  * @rmtoll CSR   SBF       MS32_PWR_IsActiveFlag_SB
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_PWR_IsActiveFlag_SB(void) {
Xstatic __inline uint32_t MS32_PWR_IsActiveFlag_SB(void) {
N  return (READ_BIT(PWR->CSR, PWR_CSR_SBF) == (PWR_CSR_SBF));
X  return (((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CSR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Indicate whether VDD voltage is below the selected PVD threshold
N  * @rmtoll CSR   PVDO       MS32_PWR_IsActiveFlag_PVDO
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_PWR_IsActiveFlag_PVDO(void) {
Xstatic __inline uint32_t MS32_PWR_IsActiveFlag_PVDO(void) {
N  return (READ_BIT(PWR->CSR, PWR_CSR_PVDO) == (PWR_CSR_PVDO));
X  return (((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CSR) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Clear Standby Flag
N  * @rmtoll CR   CSBF       MS32_PWR_ClearFlag_SB
N  * @retval None
N  */
N__STATIC_INLINE void MS32_PWR_ClearFlag_SB(void) {
Xstatic __inline void MS32_PWR_ClearFlag_SB(void) {
N  SET_BIT(PWR->CR, PWR_CR_CSBF);
X  ((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Clear Wake-up Flags
N  * @rmtoll CR   CWUF       MS32_PWR_ClearFlag_WU
N  * @retval None
N  */
N__STATIC_INLINE void MS32_PWR_ClearFlag_WU(void) {
Xstatic __inline void MS32_PWR_ClearFlag_WU(void) {
N  SET_BIT(PWR->CR, PWR_CR_CWUF);
X  ((((PWR_TypeDef *) (0x40000000UL + 0x00007000UL))->CR) |= ((0x1UL << (2U))));
N}
N
N
N/** @defgroup PWR_EF_Init Initialization and de-initialization functions
N  * @{
N  */
NErrorStatus MS32_PWR_DeInit     (void);
Nvoid        MS32_PWR_StructInit (MS32_PWR_InitTypeDef *PwrInitStr);
NErrorStatus MS32_PWR_Init       (MS32_PWR_InitTypeDef *PwrInitStr);
Nvoid        MS32_PWR_ITConfig   (uint32_t InterruptFunc, uint32_t Priority);
N
N/** @defgroup PWR_EF_Application function
N  * @{
N  */
NFlagStatus MS32_PWR_GetStatusFlag    (uint32_t Flags);
Nvoid       MS32_PWR_EnterSLEEPMode   (uint32_t SLEEPEntry);
Nvoid       MS32_PWR_EnterSTOPMode    (uint32_t Regulator, uint8_t STOPEntry);
Nvoid       MS32_PWR_EnterSTANDBYMode (void);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_PWR_H */
N
N/******************************** END OF FILE *********************************/
L 76 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_rcc.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_rcc.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_RCC_H
N#define __MS32F0XX_RCC_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Defines used for the bit position in the register and perform offsets*/
N#define RCC_POSITION_HPRE       (uint32_t)4U  /*!< field position in register RCC_CFGR */
N#define RCC_POSITION_PPRE1      (uint32_t)8U  /*!< field position in register RCC_CFGR */
N#define RCC_POSITION_PLLMUL     (uint32_t)18U /*!< field position in register RCC_CFGR */
N#define RCC_POSITION_HSICAL     (uint32_t)8U  /*!< field position in register RCC_CR */
N#define RCC_POSITION_HSITRIM    (uint32_t)3U  /*!< field position in register RCC_CR */
N#define RCC_POSITION_USART1SW   (uint32_t)0U  /*!< field position in register RCC_CFGR3 */
N
N
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup RCC_Exported_Types RCC Exported Types
N  * @{
N  */
N
N/**
N  * @brief  RCC Clocks Frequency Structure
N  */
Ntypedef struct {
N  uint32_t SYSCLK_Frequency;      /*!< SYSCLK clock frequency */
N  uint32_t HCLK_Frequency;        /*!< HCLK clock frequency */
N  uint32_t PCLK1_Frequency;       /*!< PCLK1 clock frequency */
N} MS32_RCC_ClocksTypeDef;
N
N/**
N  * @brief  RCC Internal/External Oscillator (HSE, HSI, LSE and LSI) configuration structure definition  
N  */
Ntypedef struct {
N  uint32_t HSIState;              /*!< The new state of the HSI.
N                                       This parameter can be a value of @ref HSI_Config */
N  uint32_t HSEState;              /*!< The new state of the HSE.
N                                       This parameter can be a value of @ref HSE_Config */
N  uint32_t LSIState;              /*!< The new state of the LSI.
N                                       This parameter can be a value of @ref LSI_Config */ 
N  uint32_t LSEState;              /*!< The new state of the LSE.
N                                       This parameter can be a value of @ref LSE_Config */
N} MS32_RCC_OscInitTypeDef;
N
N/** 
N  * @brief  RCC PLL configuration structure definition  
N  */
Ntypedef struct {
N  uint32_t PLLState;              /*!< PLLState: The new state of the PLL.
N                                       This parameter can be a value of @ref PLL_Config */
N  uint32_t PLLSource;             /*!< PLLSource: PLL entry clock source.
N                                       This parameter must be a value of @ref PLL_Clock_Source */          
N  uint32_t PLLMUL;                /*!< PLLMUL: Multiplication factor for PLL VCO input clock
N                                       This parameter must be a value of @ref PLL_Multiplication_Factor*/
N  uint32_t PREDIV;                /*!< PREDIV: Predivision factor for PLL VCO input clock
N                                       This parameter must be a value of @ref PLL_Prediv_Factor */
N} MS32_RCC_PllInitTypeDef;
N
N/**
N  * @brief  RCC System, AHB and APB busses clock configuration structure definition  
N  */
Ntypedef struct {
N  uint32_t SYSCLKSource;          /*!< The clock source (SYSCLKS) used as system clock.
N                                       This parameter can be a value of @ref System_Clock_Source */
N  uint32_t AHBCLKDivider;         /*!< The AHB clock (HCLK) divider. This clock is derived from the system clock (SYSCLK).
N                                       This parameter can be a value of @ref AHB_Clock_Source */
N  uint32_t APB1CLKDivider;        /*!< The APB1 clock (PCLK1) divider. This clock is derived from the AHB clock (HCLK).
N                                       This parameter can be a value of @ref APB1_Clock_Source */
N} MS32_RCC_ClkInitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RCC_EC_OSC_VALUES Oscillator Values adaptation
N  * @brief    Defines used to adapt values of different oscillators
N  * @note     These values could be modified in the user environment according to
N  *           HW set-up.
N  * @{
N  */
N#if !defined  (HSE_VALUE)
X#if !0L
N#define HSE_VALUE    8000000U  /*!< Value of the HSE oscillator in Hz */
N#endif /* HSE_VALUE */
N
N#if !defined  (HSI_VALUE)
X#if !0L
N#define HSI_VALUE    8000000U  /*!< Value of the HSI oscillator in Hz */
N#endif /* HSI_VALUE */
N
N#if !defined  (LSE_VALUE)
X#if !0L
N#define LSE_VALUE    32768U    /*!< Value of the LSE oscillator in Hz */
N#endif /* LSE_VALUE */
N
N#if !defined  (LSI_VALUE)
X#if !0L
N#define LSI_VALUE    40000U    /*!< Value of the LSI oscillator in Hz */
N#endif /* LSI_VALUE */
N
N
N/** @defgroup MS32_RCC_Exported_Constants RCC Exported Constants(APP)
N  * @{
N  */
N 
N/** @defgroup HSI_Config HSI Config
N  * @{
N  */
N#define MS32_RCC_HSI_OFF                (0x00000000U) /*!< HSI clock deactivation */
N#define MS32_RCC_HSI_ON                 RCC_CR_HSION  /*!< HSI clock activation */
N
N
N/** @defgroup HSE_Config HSE Config
N  * @{
N  */
N#define MS32_RCC_HSE_OFF                (0x00000000U)                  /*!< HSE clock deactivation */
N#define MS32_RCC_HSE_ON                 RCC_CR_HSEON                   /*!< HSE clock activation */
N#define MS32_RCC_HSE_BYPASS             (RCC_CR_HSEON | RCC_CR_HSEBYP) /*!< External clock source for HSE clock */
N
N
N/** @defgroup LSI_Config LSI Config
N  * @{
N  */
N#define MS32_RCC_LSI_OFF                (0x00000000U) /*!< LSI clock deactivation */
N#define MS32_RCC_LSI_ON                 RCC_CSR_LSION /*!< LSI clock activation */
N
N
N/** @defgroup LSE_Config LSE Config
N  * @{
N  */
N#define MS32_RCC_LSE_OFF                (0x00000000U)                                   /*!< LSE clock deactivation */
N#define MS32_RCC_LSE_ON_DRV_L           (RCC_BDCR_LSEON | MS32_RCC_LSEDRIVE_LOW)        /*!< LSE clock activation and Xtal mode lower driving capability */
N#define MS32_RCC_LSE_ON_DRV_ML          (RCC_BDCR_LSEON | MS32_RCC_LSEDRIVE_MEDIUMLOW)  /*!< LSE clock activation and Xtal mode medium low driving capability */
N#define MS32_RCC_LSE_ON_DRV_MH          (RCC_BDCR_LSEON | MS32_RCC_LSEDRIVE_MEDIUMHIGH) /*!< LSE clock activation and Xtal mode medium high driving capability */
N#define MS32_RCC_LSE_ON_DRV_H           (RCC_BDCR_LSEON | MS32_RCC_LSEDRIVE_HIGH)       /*!< LSE clock activation and Xtal mode higher driving capability */
N#define MS32_RCC_LSE_BYPASS             (RCC_BDCR_LSEON | RCC_BDCR_LSEBYP)              /*!< External clock source for LSE clock */
N
N
N/** @defgroup PLL_Config PLL Config
N  * @{
N  */
N#define MS32_RCC_PLL_OFF                (0x00000000U) /*!< PLL deactivation */
N#define MS32_RCC_PLL_ON                 RCC_CR_PLLON  /*!< PLL activation */
N
N
N/** @defgroup PLL_Clock_Source PLL Clock Source
N  * @{
N  */
N#define MS32_RCC_PLL_SOURCE_HSI_DIV_2   MS32_RCC_PLLSOURCE_HSI_DIV_2 /*!< HSI/2 clock selected as PLL entry clock source */
N#define MS32_RCC_PLL_SOURCE_HSE         MS32_RCC_PLLSOURCE_HSE       /*!< HSE clock selected as PLL entry clock source */
N
N
N/** @defgroup PLL_Multiplication_Factor RCC PLL Multiplication Factor
N  * @{
N  */
N#define MS32_RCC_PLL_MUL2               MS32_RCC_PLL_MUL_2 
N#define MS32_RCC_PLL_MUL3               MS32_RCC_PLL_MUL_3 
N#define MS32_RCC_PLL_MUL4               MS32_RCC_PLL_MUL_4 
N#define MS32_RCC_PLL_MUL5               MS32_RCC_PLL_MUL_5 
N#define MS32_RCC_PLL_MUL6               MS32_RCC_PLL_MUL_6 
N#define MS32_RCC_PLL_MUL7               MS32_RCC_PLL_MUL_7 
N#define MS32_RCC_PLL_MUL8               MS32_RCC_PLL_MUL_8 
N#define MS32_RCC_PLL_MUL9               MS32_RCC_PLL_MUL_9 
N#define MS32_RCC_PLL_MUL10              MS32_RCC_PLL_MUL_10
N#define MS32_RCC_PLL_MUL11              MS32_RCC_PLL_MUL_11
N#define MS32_RCC_PLL_MUL12              MS32_RCC_PLL_MUL_12
N#define MS32_RCC_PLL_MUL13              MS32_RCC_PLL_MUL_13
N#define MS32_RCC_PLL_MUL14              MS32_RCC_PLL_MUL_14
N#define MS32_RCC_PLL_MUL15              MS32_RCC_PLL_MUL_15
N#define MS32_RCC_PLL_MUL16              MS32_RCC_PLL_MUL_16
N
N
N/** @defgroup PLL_Prediv_Factor RCC PLL Prediv Factor
N  * @{
N  */
N#define MS32_RCC_PLL_PREDIV_DIV1        MS32_RCC_PREDIV_DIV_1 
N#define MS32_RCC_PLL_PREDIV_DIV2        MS32_RCC_PREDIV_DIV_2 
N#define MS32_RCC_PLL_PREDIV_DIV3        MS32_RCC_PREDIV_DIV_3 
N#define MS32_RCC_PLL_PREDIV_DIV4        MS32_RCC_PREDIV_DIV_4 
N#define MS32_RCC_PLL_PREDIV_DIV5        MS32_RCC_PREDIV_DIV_5 
N#define MS32_RCC_PLL_PREDIV_DIV6        MS32_RCC_PREDIV_DIV_6 
N#define MS32_RCC_PLL_PREDIV_DIV7        MS32_RCC_PREDIV_DIV_7 
N#define MS32_RCC_PLL_PREDIV_DIV8        MS32_RCC_PREDIV_DIV_8 
N#define MS32_RCC_PLL_PREDIV_DIV9        MS32_RCC_PREDIV_DIV_9 
N#define MS32_RCC_PLL_PREDIV_DIV10       MS32_RCC_PREDIV_DIV_10
N#define MS32_RCC_PLL_PREDIV_DIV11       MS32_RCC_PREDIV_DIV_11
N#define MS32_RCC_PLL_PREDIV_DIV12       MS32_RCC_PREDIV_DIV_12
N#define MS32_RCC_PLL_PREDIV_DIV13       MS32_RCC_PREDIV_DIV_13
N#define MS32_RCC_PLL_PREDIV_DIV14       MS32_RCC_PREDIV_DIV_14
N#define MS32_RCC_PLL_PREDIV_DIV15       MS32_RCC_PREDIV_DIV_15
N#define MS32_RCC_PLL_PREDIV_DIV16       MS32_RCC_PREDIV_DIV_16
N
N
N/** @defgroup System_Clock_Source System Clock Source
N  * @{
N  */
N#define MS32_RCC_SYSCLK_SOURCE_HSI      MS32_RCC_SYS_CLKSOURCE_HSI /*!< HSI selected as system clock */
N#define MS32_RCC_SYSCLK_SOURCE_HSE      MS32_RCC_SYS_CLKSOURCE_HSE /*!< HSE selected as system clock */
N#define MS32_RCC_SYSCLK_SOURCE_PLL      MS32_RCC_SYS_CLKSOURCE_PLL /*!< PLL selected as system clock */
N
N
N/** @defgroup AHB_Clock_Source AHB Clock Source
N  * @{
N  */
N#define MS32_RCC_SYSCLK_DIV1            MS32_RCC_SYSCLK_DIV_1   /*!< SYSCLK not divided */
N#define MS32_RCC_SYSCLK_DIV2            MS32_RCC_SYSCLK_DIV_2   /*!< SYSCLK divided by 2 */
N#define MS32_RCC_SYSCLK_DIV4            MS32_RCC_SYSCLK_DIV_4   /*!< SYSCLK divided by 4 */
N#define MS32_RCC_SYSCLK_DIV8            MS32_RCC_SYSCLK_DIV_8   /*!< SYSCLK divided by 8 */
N#define MS32_RCC_SYSCLK_DIV16           MS32_RCC_SYSCLK_DIV_16  /*!< SYSCLK divided by 16 */
N#define MS32_RCC_SYSCLK_DIV64           MS32_RCC_SYSCLK_DIV_64  /*!< SYSCLK divided by 64 */
N#define MS32_RCC_SYSCLK_DIV128          MS32_RCC_SYSCLK_DIV_128 /*!< SYSCLK divided by 128 */
N#define MS32_RCC_SYSCLK_DIV256          MS32_RCC_SYSCLK_DIV_256 /*!< SYSCLK divided by 256 */
N#define MS32_RCC_SYSCLK_DIV512          MS32_RCC_SYSCLK_DIV_512 /*!< SYSCLK divided by 512 */
N
N
N/** @defgroup APB1_Clock_Source RCC APB1 Clock Source
N  * @{
N  */
N#define MS32_RCC_HCLK_DIV1              MS32_RCC_APB1_DIV_1  /*!< HCLK not divided */
N#define MS32_RCC_HCLK_DIV2              MS32_RCC_APB1_DIV_2  /*!< HCLK divided by 2 */
N#define MS32_RCC_HCLK_DIV4              MS32_RCC_APB1_DIV_4  /*!< HCLK divided by 4 */
N#define MS32_RCC_HCLK_DIV8              MS32_RCC_APB1_DIV_8  /*!< HCLK divided by 8 */
N#define MS32_RCC_HCLK_DIV16             MS32_RCC_APB1_DIV_16 /*!< HCLK divided by 16 */
N
N
N/** @defgroup MCO_Source  MCO SOURCE selection
N  * @{
N  */
N#define MS32_RCC_MCO_SOURCE_NOCLOCK     MS32_RCC_MCO1SOURCE_NOCLOCK   /*!< MCO output disabled, no clock on MCO */
N#define MS32_RCC_MCO_SOURCE_HSI16       MS32_RCC_MCO1SOURCE_HSI16     /*!< HSI16 oscillator clock selected */
N#define MS32_RCC_MCO_SOURCE_LSI         MS32_RCC_MCO1SOURCE_LSI       /*!< LSI selection as MCO source */
N#define MS32_RCC_MCO_SOURCE_LSE         MS32_RCC_MCO1SOURCE_LSE       /*!< LSE selection as MCO source */
N#define MS32_RCC_MCO_SOURCE_SYSCLK      MS32_RCC_MCO1SOURCE_SYSCLK    /*!< SYSCLK selection as MCO source */
N#define MS32_RCC_MCO_SOURCE_HSI         MS32_RCC_MCO1SOURCE_HSI       /*!< HSI selection as MCO source */
N#define MS32_RCC_MCO_SOURCE_HSE         MS32_RCC_MCO1SOURCE_HSE       /*!< HSE selection as MCO source */
N#define MS32_RCC_MCO_SOURCE_PLL_DIV2    MS32_RCC_MCO1SOURCE_PLL_DIV_2 /*!< PLL/2 selection as MCO source */
N#define MS32_RCC_MCO_SOURCE_PLL         MS32_RCC_MCO1SOURCE_PLL       /*!< PLL selection as MCO source */
N
N
N/** @defgroup MCO_Prescaler  MCO prescaler
N  * @{
N  */
N#define MS32_RCC_MCO_DIV1               MS32_RCC_MCO1_DIV_1   /*!< MCO Clock divided by 1 */
N#define MS32_RCC_MCO_DIV2               MS32_RCC_MCO1_DIV_2   /*!< MCO Clock divided by 2 */
N#define MS32_RCC_MCO_DIV4               MS32_RCC_MCO1_DIV_4   /*!< MCO Clock divided by 4 */
N#define MS32_RCC_MCO_DIV8               MS32_RCC_MCO1_DIV_8   /*!< MCO Clock divided by 8 */
N#define MS32_RCC_MCO_DIV16              MS32_RCC_MCO1_DIV_16  /*!< MCO Clock divided by 16 */
N#define MS32_RCC_MCO_DIV32              MS32_RCC_MCO1_DIV_32  /*!< MCO Clock divided by 32 */
N#define MS32_RCC_MCO_DIV64              MS32_RCC_MCO1_DIV_64  /*!< MCO Clock divided by 64 */
N#define MS32_RCC_MCO_DIV128             MS32_RCC_MCO1_DIV_128 /*!< MCO Clock divided by 128 */
N
N
N/** @defgroup CLK_IT  Clock Interrupt
N  * @{
N  */
N#define MS32_RCC_IT_LSIRDYIE            RCC_CIR_LSIRDYIE /*!< LSI Ready Interrupt Enable */
N#define MS32_RCC_IT_LSERDYIE            RCC_CIR_LSERDYIE /*!< LSE Ready Interrupt Enable */
N#define MS32_RCC_IT_HSIRDYIE            RCC_CIR_HSIRDYIE /*!< HSI Ready Interrupt Enable */
N#define MS32_RCC_IT_HSERDYIE            RCC_CIR_HSERDYIE /*!< HSE Ready Interrupt Enable */
N#define MS32_RCC_IT_PLLRDYIE            RCC_CIR_PLLRDYIE /*!< PLL Ready Interrupt Enable */
N#define MS32_RCC_IT_ALLRDYIE            (RCC_CIR_LSIRDYIE | RCC_CIR_LSERDYIE | RCC_CIR_HSIRDYIE | RCC_CIR_HSERDYIE | RCC_CIR_PLLRDYIE) /*!< All clock Ready Interrupt Enable */
N
N
N/** @defgroup INT_ERR_Flags  Interrupt Error flags
N  * @{
N  */
N#define MS32_RCC_FLAG_LSIRDY            MS32_RCC_CIR_LSIRDYF /*!< LSI Ready Interrupt flag */
N#define MS32_RCC_FLAG_LSERDY            MS32_RCC_CIR_LSERDYF /*!< LSE Ready Interrupt flag */
N#define MS32_RCC_FLAG_HSIRDY            MS32_RCC_CIR_HSIRDYF /*!< HSI Ready Interrupt flag */
N#define MS32_RCC_FLAG_HSERDY            MS32_RCC_CIR_HSERDYF /*!< HSE Ready Interrupt flag */
N#define MS32_RCC_FLAG_PLLRDY            MS32_RCC_CIR_PLLRDYF /*!< PLL Ready Interrupt flag */
N#define MS32_RCC_FLAG_ALLRDY            (MS32_RCC_CIR_LSIRDYF | MS32_RCC_CIR_LSERDYF | MS32_RCC_CIR_HSIRDYF | MS32_RCC_CIR_HSERDYF | MS32_RCC_CIR_PLLRDYF) /*!< ALL Ready Interrupt flag */
N#define MS32_RCC_FLAG_CSS               MS32_RCC_CIR_CSSF    /*!< Clock Security System Interrupt flag */
N
N
N/** @defgroup RESET_Flags  Reset flags
N  * @{
N  */
N#define MS32_RCC_FLAG_OBLRSTF           MS32_RCC_CSR_OBLRSTF    /*!< OBL reset flag */
N#define MS32_RCC_FLAG_PINRSTF           MS32_RCC_CSR_PINRSTF    /*!< PIN reset flag */
N#define MS32_RCC_FLAG_PORRSTF           MS32_RCC_CSR_PORRSTF    /*!< POR/PDR reset flag */
N#define MS32_RCC_FLAG_SFTRSTF           MS32_RCC_CSR_SFTRSTF    /*!< Software Reset flag */
N#define MS32_RCC_FLAG_IWDGRSTF          MS32_RCC_CSR_IWDGRSTF   /*!< Independent Watchdog reset flag */
N#define MS32_RCC_FLAG_WWDGRSTF          MS32_RCC_CSR_WWDGRSTF   /*!< Window watchdog reset flag */
N#define MS32_RCC_FLAG_LPWRRSTF          MS32_RCC_CSR_LPWRRSTF   /*!< Low-Power reset flag */
N#define MS32_RCC_FLAG_V15PWRRSTF        MS32_RCC_CSR_V15PWRRSTF /*!< Reset flag of the 1.5 V domain. */
N#define MS32_RCC_FLAG_ALLRSTF           (MS32_RCC_CSR_OBLRSTF | MS32_RCC_CSR_PINRSTF | MS32_RCC_CSR_PORRSTF | MS32_RCC_CSR_SFTRSTF | MS32_RCC_CSR_IWDGRSTF | MS32_RCC_CSR_WWDGRSTF | MS32_RCC_CSR_LPWRRSTF | MS32_RCC_CSR_V15PWRRSTF) /*!< ALL Reset Interrupt flag */
N
N
N/** @defgroup RCC_Exported_Constants RCC Exported Constants(BASE)
N  * @{
N  */
N/** @defgroup RCC_EC_CLEAR_FLAG Clear Flags Defines
N  * @brief    Flags defines which can be used with RCC_WriteReg function
N  * @{
N  */
N#define MS32_RCC_CIR_LSIRDYC                RCC_CIR_LSIRDYC /*!< LSI Ready Interrupt Clear */
N#define MS32_RCC_CIR_LSERDYC                RCC_CIR_LSERDYC /*!< LSE Ready Interrupt Clear */
N#define MS32_RCC_CIR_HSIRDYC                RCC_CIR_HSIRDYC /*!< HSI Ready Interrupt Clear */
N#define MS32_RCC_CIR_HSERDYC                RCC_CIR_HSERDYC /*!< HSE Ready Interrupt Clear */
N#define MS32_RCC_CIR_PLLRDYC                RCC_CIR_PLLRDYC /*!< PLL Ready Interrupt Clear */
N#define MS32_RCC_CIR_CSSC                   RCC_CIR_CSSC    /*!< Clock Security System Interrupt Clear */
N
N
N/** @defgroup RCC_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with RCC_ReadReg function
N  * @{
N  */
N#define MS32_RCC_CIR_LSIRDYF                RCC_CIR_LSIRDYF    /*!< LSI Ready Interrupt flag */
N#define MS32_RCC_CIR_LSERDYF                RCC_CIR_LSERDYF    /*!< LSE Ready Interrupt flag */
N#define MS32_RCC_CIR_HSIRDYF                RCC_CIR_HSIRDYF    /*!< HSI Ready Interrupt flag */
N#define MS32_RCC_CIR_HSERDYF                RCC_CIR_HSERDYF    /*!< HSE Ready Interrupt flag */
N#define MS32_RCC_CIR_PLLRDYF                RCC_CIR_PLLRDYF    /*!< PLL Ready Interrupt flag */
N#define MS32_RCC_CIR_CSSF                   RCC_CIR_CSSF       /*!< Clock Security System Interrupt flag */
N#define MS32_RCC_CSR_OBLRSTF                RCC_CSR_OBLRSTF    /*!< OBL reset flag */
N#define MS32_RCC_CSR_PINRSTF                RCC_CSR_PINRSTF    /*!< PIN reset flag */
N#define MS32_RCC_CSR_PORRSTF                RCC_CSR_PORRSTF    /*!< POR/PDR reset flag */
N#define MS32_RCC_CSR_SFTRSTF                RCC_CSR_SFTRSTF    /*!< Software Reset flag */
N#define MS32_RCC_CSR_IWDGRSTF               RCC_CSR_IWDGRSTF   /*!< Independent Watchdog reset flag */
N#define MS32_RCC_CSR_WWDGRSTF               RCC_CSR_WWDGRSTF   /*!< Window watchdog reset flag */
N#define MS32_RCC_CSR_LPWRRSTF               RCC_CSR_LPWRRSTF   /*!< Low-Power reset flag */
N#define MS32_RCC_CSR_V15PWRRSTF             RCC_CSR_V15PWRRSTF /*!< Reset flag of the 1.5 V domain. */
N
N
N/** @defgroup RCC_EC_IT IT Defines
N  * @brief    IT defines which can be used with RCC_ReadReg and  RCC_WriteReg functions
N  * @{
N  */
N#define MS32_RCC_CIR_LSIRDYIE               RCC_CIR_LSIRDYIE /*!< LSI Ready Interrupt Enable */
N#define MS32_RCC_CIR_LSERDYIE               RCC_CIR_LSERDYIE /*!< LSE Ready Interrupt Enable */
N#define MS32_RCC_CIR_HSIRDYIE               RCC_CIR_HSIRDYIE /*!< HSI Ready Interrupt Enable */
N#define MS32_RCC_CIR_HSERDYIE               RCC_CIR_HSERDYIE /*!< HSE Ready Interrupt Enable */
N#define MS32_RCC_CIR_PLLRDYIE               RCC_CIR_PLLRDYIE /*!< PLL Ready Interrupt Enable */
N
N
N/** @defgroup RCC_EC_LSEDRIVE  LSE oscillator drive capability
N  * @{
N  */
N#define MS32_RCC_LSEDRIVE_LOW               (0x00000000U)     /*!< Xtal mode lower driving capability */
N#define MS32_RCC_LSEDRIVE_MEDIUMLOW         RCC_BDCR_LSEDRV_1 /*!< Xtal mode medium low driving capability */
N#define MS32_RCC_LSEDRIVE_MEDIUMHIGH        RCC_BDCR_LSEDRV_0 /*!< Xtal mode medium high driving capability */
N#define MS32_RCC_LSEDRIVE_HIGH              RCC_BDCR_LSEDRV   /*!< Xtal mode higher driving capability */
N
N
N/** @defgroup RCC_EC_SYS_CLKSOURCE  System clock switch
N  * @{
N  */
N#define MS32_RCC_SYS_CLKSOURCE_HSI          RCC_CFGR_SW_HSI /*!< HSI selection as system clock */
N#define MS32_RCC_SYS_CLKSOURCE_HSE          RCC_CFGR_SW_HSE /*!< HSE selection as system clock */
N#define MS32_RCC_SYS_CLKSOURCE_PLL          RCC_CFGR_SW_PLL /*!< PLL selection as system clock */
N
N
N/** @defgroup RCC_EC_SYS_CLKSOURCE_STATUS  System clock switch status
N  * @{
N  */
N#define MS32_RCC_SYS_CLKSOURCE_STATUS_HSI   RCC_CFGR_SWS_HSI /*!< HSI used as system clock */
N#define MS32_RCC_SYS_CLKSOURCE_STATUS_HSE   RCC_CFGR_SWS_HSE /*!< HSE used as system clock */
N#define MS32_RCC_SYS_CLKSOURCE_STATUS_PLL   RCC_CFGR_SWS_PLL /*!< PLL used as system clock */
N
N
N/** @defgroup RCC_EC_SYSCLK_DIV  AHB prescaler
N  * @{
N  */
N#define MS32_RCC_SYSCLK_DIV_1               RCC_CFGR_HPRE_DIV1   /*!< SYSCLK not divided */
N#define MS32_RCC_SYSCLK_DIV_2               RCC_CFGR_HPRE_DIV2   /*!< SYSCLK divided by 2 */
N#define MS32_RCC_SYSCLK_DIV_4               RCC_CFGR_HPRE_DIV4   /*!< SYSCLK divided by 4 */
N#define MS32_RCC_SYSCLK_DIV_8               RCC_CFGR_HPRE_DIV8   /*!< SYSCLK divided by 8 */
N#define MS32_RCC_SYSCLK_DIV_16              RCC_CFGR_HPRE_DIV16  /*!< SYSCLK divided by 16 */
N#define MS32_RCC_SYSCLK_DIV_64              RCC_CFGR_HPRE_DIV64  /*!< SYSCLK divided by 64 */
N#define MS32_RCC_SYSCLK_DIV_128             RCC_CFGR_HPRE_DIV128 /*!< SYSCLK divided by 128 */
N#define MS32_RCC_SYSCLK_DIV_256             RCC_CFGR_HPRE_DIV256 /*!< SYSCLK divided by 256 */
N#define MS32_RCC_SYSCLK_DIV_512             RCC_CFGR_HPRE_DIV512 /*!< SYSCLK divided by 512 */
N
N
N/** @defgroup RCC_EC_APB1_DIV  APB low-speed prescaler (APB1)
N  * @{
N  */
N#define MS32_RCC_APB1_DIV_1                 RCC_CFGR_PPRE_DIV1  /*!< HCLK not divided */
N#define MS32_RCC_APB1_DIV_2                 RCC_CFGR_PPRE_DIV2  /*!< HCLK divided by 2 */
N#define MS32_RCC_APB1_DIV_4                 RCC_CFGR_PPRE_DIV4  /*!< HCLK divided by 4 */
N#define MS32_RCC_APB1_DIV_8                 RCC_CFGR_PPRE_DIV8  /*!< HCLK divided by 8 */
N#define MS32_RCC_APB1_DIV_16                RCC_CFGR_PPRE_DIV16 /*!< HCLK divided by 16 */
N
N
N/** @defgroup RCC_EC_MCO1SOURCE  MCO1 SOURCE selection
N  * @{
N  */
N#define MS32_RCC_MCO1SOURCE_NOCLOCK         RCC_CFGR_MCO_NOCLOCK                   /*!< MCO output disabled, no clock on MCO */
N#define MS32_RCC_MCO1SOURCE_HSI16           RCC_CFGR_MCO_HSI16                     /*!< HSI16 oscillator clock selected */
N#define MS32_RCC_MCO1SOURCE_LSI             RCC_CFGR_MCO_LSI                       /*!< LSI selection as MCO source */
N#define MS32_RCC_MCO1SOURCE_LSE             RCC_CFGR_MCO_LSE                       /*!< LSE selection as MCO source */
N#define MS32_RCC_MCO1SOURCE_SYSCLK          RCC_CFGR_MCO_SYSCLK                    /*!< SYSCLK selection as MCO source */
N#define MS32_RCC_MCO1SOURCE_HSI             RCC_CFGR_MCO_HSI                       /*!< HSI selection as MCO source */
N#define MS32_RCC_MCO1SOURCE_HSE             RCC_CFGR_MCO_HSE                       /*!< HSE selection as MCO source */
N#define MS32_RCC_MCO1SOURCE_PLL_DIV_2       RCC_CFGR_MCO_PLL                       /*!< PLL/2 selection as MCO source */
N#define MS32_RCC_MCO1SOURCE_PLL             (RCC_CFGR_MCO_PLL | RCC_CFGR_PLLNODIV) /*!< PLL selection as MCO source */
N
N
N/** @defgroup RCC_EC_MCO1_DIV  MCO1 prescaler
N  * @{
N  */
N#define MS32_RCC_MCO1_DIV_1                  RCC_CFGR_MCOPRE_DIV1    /*!< MCO Clock divided by 1 */
N#define MS32_RCC_MCO1_DIV_2                  RCC_CFGR_MCOPRE_DIV2    /*!< MCO Clock divided by 2 */
N#define MS32_RCC_MCO1_DIV_4                  RCC_CFGR_MCOPRE_DIV4    /*!< MCO Clock divided by 4 */
N#define MS32_RCC_MCO1_DIV_8                  RCC_CFGR_MCOPRE_DIV8    /*!< MCO Clock divided by 8 */
N#define MS32_RCC_MCO1_DIV_16                 RCC_CFGR_MCOPRE_DIV16   /*!< MCO Clock divided by 16 */
N#define MS32_RCC_MCO1_DIV_32                 RCC_CFGR_MCOPRE_DIV32   /*!< MCO Clock divided by 32 */
N#define MS32_RCC_MCO1_DIV_64                 RCC_CFGR_MCOPRE_DIV64   /*!< MCO Clock divided by 64 */
N#define MS32_RCC_MCO1_DIV_128                RCC_CFGR_MCOPRE_DIV128  /*!< MCO Clock divided by 128 */
N
N
N/** @defgroup RCC_EC_PERIPH_FREQUENCY Peripheral clock frequency
N  * @{
N  */
N#define MS32_RCC_PERIPH_FREQUENCY_NO         0x00000000U /*!< No clock enabled for the peripheral            */
N#define MS32_RCC_PERIPH_FREQUENCY_NA         0xFFFFFFFFU /*!< Frequency cannot be provided as external clock */
N
N
N/** @defgroup RCC_EC_USART1_CLKSOURCE Peripheral USART clock source selection
N  * @{
N  */
N#define MS32_RCC_USART1_CLKSOURCE_PCLK1      (uint32_t)((RCC_POSITION_USART1SW << 24) | RCC_CFGR3_USART1SW_PCLK)   /*!< PCLK1 clock used as USART1 clock source */
N#define MS32_RCC_USART1_CLKSOURCE_SYSCLK     (uint32_t)((RCC_POSITION_USART1SW << 24) | RCC_CFGR3_USART1SW_SYSCLK) /*!< System clock selected as USART1 clock source */
N#define MS32_RCC_USART1_CLKSOURCE_LSE        (uint32_t)((RCC_POSITION_USART1SW << 24) | RCC_CFGR3_USART1SW_LSE)    /*!< LSE oscillator clock used as USART1 clock source */
N#define MS32_RCC_USART1_CLKSOURCE_HSI        (uint32_t)((RCC_POSITION_USART1SW << 24) | RCC_CFGR3_USART1SW_HSI)    /*!< HSI oscillator clock used as USART1 clock source */
N
N
N/** @defgroup RCC_EC_I2C1_CLKSOURCE Peripheral I2C clock source selection
N  * @{
N  */
N#define MS32_RCC_I2C1_CLKSOURCE_HSI          RCC_CFGR3_I2C1SW_HSI    /*!< HSI oscillator clock used as I2C1 clock source */
N#define MS32_RCC_I2C1_CLKSOURCE_SYSCLK       RCC_CFGR3_I2C1SW_SYSCLK /*!< System clock selected as I2C1 clock source */
N
N
N/** @defgroup RCC_EC_USART1 Peripheral USART get clock source
N  * @{
N  */
N#define MS32_RCC_USART1_CLKSOURCE            RCC_POSITION_USART1SW /*!< USART1 Clock source selection */
N
N
N/** @defgroup RCC_EC_I2C1 Peripheral I2C get clock source
N  * @{
N  */
N#define MS32_RCC_I2C1_CLKSOURCE              RCC_CFGR3_I2C1SW /*!< I2C1 Clock source selection */
N
N
N/** @defgroup RCC_EC_RTC_CLKSOURCE  RTC clock source selection
N  * @{
N  */
N#define MS32_RCC_RTC_CLKSOURCE_NONE          0x00000000U       /*!< No clock used as RTC clock */
N#define MS32_RCC_RTC_CLKSOURCE_LSE           RCC_BDCR_RTCSEL_0 /*!< LSE oscillator clock used as RTC clock */
N#define MS32_RCC_RTC_CLKSOURCE_LSI           RCC_BDCR_RTCSEL_1 /*!< LSI oscillator clock used as RTC clock */
N#define MS32_RCC_RTC_CLKSOURCE_HSE_DIV32     RCC_BDCR_RTCSEL   /*!< HSE oscillator clock divided by 32 used as RTC clock */
N
N
N/** @defgroup RCC_EC_PLL_MUL PLL Multiplicator factor
N  * @{
N  */
N#define MS32_RCC_PLL_MUL_2                   RCC_CFGR_PLLMUL2  /*!< PLL input clock*2 */
N#define MS32_RCC_PLL_MUL_3                   RCC_CFGR_PLLMUL3  /*!< PLL input clock*3 */
N#define MS32_RCC_PLL_MUL_4                   RCC_CFGR_PLLMUL4  /*!< PLL input clock*4 */
N#define MS32_RCC_PLL_MUL_5                   RCC_CFGR_PLLMUL5  /*!< PLL input clock*5 */
N#define MS32_RCC_PLL_MUL_6                   RCC_CFGR_PLLMUL6  /*!< PLL input clock*6 */
N#define MS32_RCC_PLL_MUL_7                   RCC_CFGR_PLLMUL7  /*!< PLL input clock*7 */
N#define MS32_RCC_PLL_MUL_8                   RCC_CFGR_PLLMUL8  /*!< PLL input clock*8 */
N#define MS32_RCC_PLL_MUL_9                   RCC_CFGR_PLLMUL9  /*!< PLL input clock*9 */
N#define MS32_RCC_PLL_MUL_10                  RCC_CFGR_PLLMUL10 /*!< PLL input clock*10 */
N#define MS32_RCC_PLL_MUL_11                  RCC_CFGR_PLLMUL11 /*!< PLL input clock*11 */
N#define MS32_RCC_PLL_MUL_12                  RCC_CFGR_PLLMUL12 /*!< PLL input clock*12 */
N#define MS32_RCC_PLL_MUL_13                  RCC_CFGR_PLLMUL13 /*!< PLL input clock*13 */
N#define MS32_RCC_PLL_MUL_14                  RCC_CFGR_PLLMUL14 /*!< PLL input clock*14 */
N#define MS32_RCC_PLL_MUL_15                  RCC_CFGR_PLLMUL15 /*!< PLL input clock*15 */
N#define MS32_RCC_PLL_MUL_16                  RCC_CFGR_PLLMUL16 /*!< PLL input clock*16 */
N
N
N/** @defgroup RCC_EC_PLLSOURCE PLL SOURCE
N  * @{
N  */
N#define MS32_RCC_PLLSOURCE_HSE               RCC_CFGR_PLLSRC_HSE_PREDIV                            /*!< HSE/PREDIV clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSI_DIV_2         RCC_CFGR_PLLSRC_HSI_DIV2                              /*!< HSI clock divided by 2 selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_1         (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV1)  /*!< HSE clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_2         (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV2)  /*!< HSE/2 clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_3         (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV3)  /*!< HSE/3 clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_4         (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV4)  /*!< HSE/4 clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_5         (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV5)  /*!< HSE/5 clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_6         (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV6)  /*!< HSE/6 clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_7         (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV7)  /*!< HSE/7 clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_8         (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV8)  /*!< HSE/8 clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_9         (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV9)  /*!< HSE/9 clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_10        (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV10) /*!< HSE/10 clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_11        (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV11) /*!< HSE/11 clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_12        (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV12) /*!< HSE/12 clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_13        (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV13) /*!< HSE/13 clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_14        (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV14) /*!< HSE/14 clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_15        (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV15) /*!< HSE/15 clock selected as PLL entry clock source */
N#define MS32_RCC_PLLSOURCE_HSE_DIV_16        (RCC_CFGR_PLLSRC_HSE_PREDIV | RCC_CFGR2_PREDIV_DIV16) /*!< HSE/16 clock selected as PLL entry clock source */
N
N
N/** @defgroup RCC_EC_PREDIV_DIV PREDIV Division factor
N  * @{
N  */
N#define MS32_RCC_PREDIV_DIV_1                RCC_CFGR2_PREDIV_DIV1  /*!< PREDIV input clock not divided */
N#define MS32_RCC_PREDIV_DIV_2                RCC_CFGR2_PREDIV_DIV2  /*!< PREDIV input clock divided by 2 */
N#define MS32_RCC_PREDIV_DIV_3                RCC_CFGR2_PREDIV_DIV3  /*!< PREDIV input clock divided by 3 */
N#define MS32_RCC_PREDIV_DIV_4                RCC_CFGR2_PREDIV_DIV4  /*!< PREDIV input clock divided by 4 */
N#define MS32_RCC_PREDIV_DIV_5                RCC_CFGR2_PREDIV_DIV5  /*!< PREDIV input clock divided by 5 */
N#define MS32_RCC_PREDIV_DIV_6                RCC_CFGR2_PREDIV_DIV6  /*!< PREDIV input clock divided by 6 */
N#define MS32_RCC_PREDIV_DIV_7                RCC_CFGR2_PREDIV_DIV7  /*!< PREDIV input clock divided by 7 */
N#define MS32_RCC_PREDIV_DIV_8                RCC_CFGR2_PREDIV_DIV8  /*!< PREDIV input clock divided by 8 */
N#define MS32_RCC_PREDIV_DIV_9                RCC_CFGR2_PREDIV_DIV9  /*!< PREDIV input clock divided by 9 */
N#define MS32_RCC_PREDIV_DIV_10               RCC_CFGR2_PREDIV_DIV10 /*!< PREDIV input clock divided by 10 */
N#define MS32_RCC_PREDIV_DIV_11               RCC_CFGR2_PREDIV_DIV11 /*!< PREDIV input clock divided by 11 */
N#define MS32_RCC_PREDIV_DIV_12               RCC_CFGR2_PREDIV_DIV12 /*!< PREDIV input clock divided by 12 */
N#define MS32_RCC_PREDIV_DIV_13               RCC_CFGR2_PREDIV_DIV13 /*!< PREDIV input clock divided by 13 */
N#define MS32_RCC_PREDIV_DIV_14               RCC_CFGR2_PREDIV_DIV14 /*!< PREDIV input clock divided by 14 */
N#define MS32_RCC_PREDIV_DIV_15               RCC_CFGR2_PREDIV_DIV15 /*!< PREDIV input clock divided by 15 */
N#define MS32_RCC_PREDIV_DIV_16               RCC_CFGR2_PREDIV_DIV16 /*!< PREDIV input clock divided by 16 */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/**
N  * @brief  Write a value in RCC register
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_RCC_WriteReg(__REG__, __VALUE__) WRITE_REG(RCC->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in RCC register
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_RCC_ReadReg(__REG__) READ_REG(RCC->__REG__)
N
N
N/** @defgroup RCC_MS32_EM_CALC_FREQ Calculate frequencies
N  * @{
N  */
N
N/**
N  * @brief  Helper macro to calculate the PLLCLK frequency
N  * @note ex: @ref __MS32_RCC_CALC_PLLCLK_FREQ (HSE_VALUE / (@ref MS32_RCC_PLL_GetPrediv () + 1), @ref MS32_RCC_PLL_GetMultiplicator());
N  * @param  __INPUTFREQ__ PLL Input frequency (based on HSE div Prediv / HSI div 2)
N  * @param  __PLLMUL__ This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_PLL_MUL_2
N  *         @arg @ref MS32_RCC_PLL_MUL_3
N  *         @arg @ref MS32_RCC_PLL_MUL_4
N  *         @arg @ref MS32_RCC_PLL_MUL_5
N  *         @arg @ref MS32_RCC_PLL_MUL_6
N  *         @arg @ref MS32_RCC_PLL_MUL_7
N  *         @arg @ref MS32_RCC_PLL_MUL_8
N  *         @arg @ref MS32_RCC_PLL_MUL_9
N  *         @arg @ref MS32_RCC_PLL_MUL_10
N  *         @arg @ref MS32_RCC_PLL_MUL_11
N  *         @arg @ref MS32_RCC_PLL_MUL_12
N  *         @arg @ref MS32_RCC_PLL_MUL_13
N  *         @arg @ref MS32_RCC_PLL_MUL_14
N  *         @arg @ref MS32_RCC_PLL_MUL_15
N  *         @arg @ref MS32_RCC_PLL_MUL_16
N  * @retval PLL clock frequency (in Hz)
N  */
N#define __MS32_RCC_CALC_PLLCLK_FREQ(__INPUTFREQ__, __PLLMUL__) \
N          ((__INPUTFREQ__) * ((((__PLLMUL__) & RCC_CFGR_PLLMUL) >> RCC_POSITION_PLLMUL) + 2U))
X#define __MS32_RCC_CALC_PLLCLK_FREQ(__INPUTFREQ__, __PLLMUL__)           ((__INPUTFREQ__) * ((((__PLLMUL__) & RCC_CFGR_PLLMUL) >> RCC_POSITION_PLLMUL) + 2U))
N
N/**
N  * @brief  Helper macro to calculate the HCLK frequency
N  * @note: __AHBPRESCALER__ be retrieved by @ref MS32_RCC_GetAHBPrescaler
N  *        ex: __MS32_RCC_CALC_HCLK_FREQ(MS32_RCC_GetAHBPrescaler())
N  * @param  __SYSCLKFREQ__ SYSCLK frequency (based on HSE/HSI/PLLCLK)
N  * @param  __AHBPRESCALER__ This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_1
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_2
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_4
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_8
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_16
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_64
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_128
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_256
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_512
N  * @retval HCLK clock frequency (in Hz)
N  */
N#define __MS32_RCC_CALC_HCLK_FREQ(__SYSCLKFREQ__, __AHBPRESCALER__) ((__SYSCLKFREQ__) >> AHBPrescTable[((__AHBPRESCALER__) & RCC_CFGR_HPRE) >>  RCC_CFGR_HPRE_Pos])
N
N/**
N  * @brief  Helper macro to calculate the PCLK1 frequency (ABP1)
N  * @note: __APB1PRESCALER__ be retrieved by @ref MS32_RCC_GetAPB1Prescaler
N  *        ex: __MS32_RCC_CALC_PCLK1_FREQ(MS32_RCC_GetAPB1Prescaler())
N  * @param  __HCLKFREQ__ HCLK frequency
N  * @param  __APB1PRESCALER__ This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_APB1_DIV_1
N  *         @arg @ref MS32_RCC_APB1_DIV_2
N  *         @arg @ref MS32_RCC_APB1_DIV_4
N  *         @arg @ref MS32_RCC_APB1_DIV_8
N  *         @arg @ref MS32_RCC_APB1_DIV_16
N  * @retval PCLK1 clock frequency (in Hz)
N  */
N#define __MS32_RCC_CALC_PCLK1_FREQ(__HCLKFREQ__, __APB1PRESCALER__) ((__HCLKFREQ__) >> APBPrescTable[(__APB1PRESCALER__) >>  RCC_CFGR_PPRE_Pos])
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup RCC_EF_HSE HSE
N  * @{
N  */
N
N/**
N  * @brief  Enable the Clock Security System.
N  * @rmtoll CR           CSSON         MS32_RCC_HSE_EnableCSS
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_HSE_EnableCSS(void) {
Xstatic __inline void MS32_RCC_HSE_EnableCSS(void) {
N  SET_BIT(RCC->CR, RCC_CR_CSSON);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) |= ((0x1UL << (19U))));
N}
N
N/**
N  * @brief  Disable the Clock Security System.
N  * @note Cannot be disabled in HSE is ready (only by hardware)
N  * @rmtoll CR           CSSON         MS32_RCC_HSE_DisableCSS
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_HSE_DisableCSS(void) {
Xstatic __inline void MS32_RCC_HSE_DisableCSS(void) {
N  CLEAR_BIT(RCC->CR, RCC_CR_CSSON);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) &= ~((0x1UL << (19U))));
N}
N
N/**
N  * @brief  Enable HSE external oscillator (HSE Bypass)
N  * @rmtoll CR           HSEBYP        MS32_RCC_HSE_EnableBypass
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_HSE_EnableBypass(void) {
Xstatic __inline void MS32_RCC_HSE_EnableBypass(void) {
N  SET_BIT(RCC->CR, RCC_CR_HSEBYP);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) |= ((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Disable HSE external oscillator (HSE Bypass)
N  * @rmtoll CR           HSEBYP        MS32_RCC_HSE_DisableBypass
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_HSE_DisableBypass(void) {
Xstatic __inline void MS32_RCC_HSE_DisableBypass(void) {
N  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) &= ~((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Check if HSE external oscillator (HSE Bypass)
N  * @rmtoll CR           HSEBYP        MS32_RCC_HSE_IsBypass
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_HSE_IsBypass(void) {
Xstatic __inline uint32_t MS32_RCC_HSE_IsBypass(void) {
N  return (READ_BIT(RCC->CR, RCC_CR_HSEBYP) == (RCC_CR_HSEBYP));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) & ((0x1UL << (18U)))) == ((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Enable HSE crystal oscillator (HSE ON)
N  * @rmtoll CR           HSEON         MS32_RCC_HSE_Enable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_HSE_Enable(void) {
Xstatic __inline void MS32_RCC_HSE_Enable(void) {
N  SET_BIT(RCC->CR, RCC_CR_HSEON);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) |= ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Disable HSE crystal oscillator (HSE ON)
N  * @rmtoll CR           HSEON         MS32_RCC_HSE_Disable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_HSE_Disable(void) {
Xstatic __inline void MS32_RCC_HSE_Disable(void) {
N  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) &= ~((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Check if HSE oscillator Ready
N  * @rmtoll CR           HSERDY        MS32_RCC_HSE_IsReady
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_HSE_IsReady(void) {
Xstatic __inline uint32_t MS32_RCC_HSE_IsReady(void) {
N  return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) & ((0x1UL << (17U)))) == ((0x1UL << (17U))));
N}
N
N
N/** @defgroup RCC_EF_HSI HSI
N  * @{
N  */
N
N/**
N  * @brief  Enable HSI oscillator
N  * @rmtoll CR           HSION         MS32_RCC_HSI_Enable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_HSI_Enable(void) {
Xstatic __inline void MS32_RCC_HSI_Enable(void) {
N  SET_BIT(RCC->CR, RCC_CR_HSION);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable HSI oscillator
N  * @rmtoll CR           HSION         MS32_RCC_HSI_Disable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_HSI_Disable(void) {
Xstatic __inline void MS32_RCC_HSI_Disable(void) {
N  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if HSI clock is ready
N  * @rmtoll CR           HSIRDY        MS32_RCC_HSI_IsReady
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_HSI_IsReady(void) {
Xstatic __inline uint32_t MS32_RCC_HSI_IsReady(void) {
N  return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Get HSI Calibration value
N  * @note When HSITRIM is written, HSICAL is updated with the sum of
N  *       HSITRIM and the factory trim value
N  * @rmtoll CR        HSICAL        MS32_RCC_HSI_GetCalibration
N  * @retval Between Min_Data = 0x00 and Max_Data = 0xFF
N  */
N__STATIC_INLINE uint32_t MS32_RCC_HSI_GetCalibration(void) {
Xstatic __inline uint32_t MS32_RCC_HSI_GetCalibration(void) {
N  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_HSICAL) >> RCC_CR_HSICAL_Pos);
X  return (uint32_t)(((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) & ((0xFFUL << (8U)))) >> (8U));
N}
N
N
N/** @defgroup RCC_EF_LSE LSE
N  * @{
N  */
N
N/**
N  * @brief  Enable  Low Speed External (LSE) crystal.
N  * @rmtoll BDCR         LSEON         MS32_RCC_LSE_Enable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_LSE_Enable(void) {
Xstatic __inline void MS32_RCC_LSE_Enable(void) {
N  SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable  Low Speed External (LSE) crystal.
N  * @rmtoll BDCR         LSEON         MS32_RCC_LSE_Disable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_LSE_Disable(void) {
Xstatic __inline void MS32_RCC_LSE_Disable(void) {
N  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Enable external clock source (LSE bypass).
N  * @rmtoll BDCR         LSEBYP        MS32_RCC_LSE_EnableBypass
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_LSE_EnableBypass(void) {
Xstatic __inline void MS32_RCC_LSE_EnableBypass(void) {
N  SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Disable external clock source (LSE bypass).
N  * @rmtoll BDCR         LSEBYP        MS32_RCC_LSE_DisableBypass
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_LSE_DisableBypass(void) {
Xstatic __inline void MS32_RCC_LSE_DisableBypass(void) {
N  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Check if external clock source (LSE bypass).
N  * @rmtoll BDCR         LSERDY        MS32_RCC_LSE_IsReady
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_LSE_IsBypass(void) {
Xstatic __inline uint32_t MS32_RCC_LSE_IsBypass(void) {
N  return (READ_BIT(RCC->BDCR, RCC_BDCR_LSEBYP) == (RCC_BDCR_LSEBYP));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Set LSE oscillator drive capability
N  * @note The oscillator is in Xtal mode when it is not in bypass mode.
N  * @rmtoll BDCR         LSEDRV        MS32_RCC_LSE_SetDriveCapability
N  * @param  LSEDrive This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_LSEDRIVE_LOW
N  *         @arg @ref MS32_RCC_LSEDRIVE_MEDIUMLOW
N  *         @arg @ref MS32_RCC_LSEDRIVE_MEDIUMHIGH
N  *         @arg @ref MS32_RCC_LSEDRIVE_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_LSE_SetDriveCapability(uint32_t LSEDrive) {
Xstatic __inline void MS32_RCC_LSE_SetDriveCapability(uint32_t LSEDrive) {
N  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, LSEDrive);
X  (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR)) = ((((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR))) & (~((0x3UL << (3U))))) | (LSEDrive))));
N}
N
N/**
N  * @brief  Get LSE oscillator drive capability
N  * @rmtoll BDCR         LSEDRV        MS32_RCC_LSE_GetDriveCapability
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RCC_LSEDRIVE_LOW
N  *         @arg @ref MS32_RCC_LSEDRIVE_MEDIUMLOW
N  *         @arg @ref MS32_RCC_LSEDRIVE_MEDIUMHIGH
N  *         @arg @ref MS32_RCC_LSEDRIVE_HIGH
N  */
N__STATIC_INLINE uint32_t MS32_RCC_LSE_GetDriveCapability(void) {
Xstatic __inline uint32_t MS32_RCC_LSE_GetDriveCapability(void) {
N  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_LSEDRV));
X  return (uint32_t)(((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR) & ((0x3UL << (3U)))));
N}
N
N/**
N  * @brief  Check if LSE oscillator Ready
N  * @rmtoll BDCR         LSERDY        MS32_RCC_LSE_IsReady
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_LSE_IsReady(void) {
Xstatic __inline uint32_t MS32_RCC_LSE_IsReady(void) {
N  return (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N
N/** @defgroup RCC_EF_LSI LSI
N  * @{
N  */
N
N/**
N  * @brief  Enable LSI Oscillator
N  * @rmtoll CSR          LSION         MS32_RCC_LSI_Enable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_LSI_Enable(void) {
Xstatic __inline void MS32_RCC_LSI_Enable(void) {
N  SET_BIT(RCC->CSR, RCC_CSR_LSION);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CSR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable LSI Oscillator
N  * @rmtoll CSR          LSION         MS32_RCC_LSI_Disable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_LSI_Disable(void) {
Xstatic __inline void MS32_RCC_LSI_Disable(void) {
N  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CSR) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if LSI is Ready
N  * @rmtoll CSR          LSIRDY        MS32_RCC_LSI_IsReady
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_LSI_IsReady(void) {
Xstatic __inline uint32_t MS32_RCC_LSI_IsReady(void) {
N  return (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CSR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N
N/** @defgroup RCC_EF_System System
N  * @{
N  */
N
N/**
N  * @brief  Configure the system clock source
N  * @rmtoll CFGR         SW            MS32_RCC_SetSysClkSource
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_SYS_CLKSOURCE_HSI
N  *         @arg @ref MS32_RCC_SYS_CLKSOURCE_HSE
N  *         @arg @ref MS32_RCC_SYS_CLKSOURCE_PLL
N  *
N  *         (*) value not defined in all devices
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_SetSysClkSource(uint32_t Source) {
Xstatic __inline void MS32_RCC_SetSysClkSource(uint32_t Source) {
N  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
X  (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR)) = ((((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR))) & (~((0x3UL << (0U))))) | (Source))));
N}
N
N/**
N  * @brief  Get the system clock source
N  * @rmtoll CFGR         SWS           MS32_RCC_GetSysClkSource
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RCC_SYS_CLKSOURCE_STATUS_HSI
N  *         @arg @ref MS32_RCC_SYS_CLKSOURCE_STATUS_HSE
N  *         @arg @ref MS32_RCC_SYS_CLKSOURCE_STATUS_PLL
N  *
N  *         (*) value not defined in all devices
N  */
N__STATIC_INLINE uint32_t MS32_RCC_GetSysClkSource(void) {
Xstatic __inline uint32_t MS32_RCC_GetSysClkSource(void) {
N  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
X  return (uint32_t)(((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR) & ((0x3UL << (2U)))));
N}
N
N/**
N  * @brief  Set AHB prescaler
N  * @rmtoll CFGR         HPRE          MS32_RCC_SetAHBPrescaler
N  * @param  Prescaler This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_1
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_2
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_4
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_8
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_16
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_64
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_128
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_256
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_512
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_SetAHBPrescaler(uint32_t Prescaler) {
Xstatic __inline void MS32_RCC_SetAHBPrescaler(uint32_t Prescaler) {
N  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
X  (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR)) = ((((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR))) & (~((0xFUL << (4U))))) | (Prescaler))));
N}
N
N/**
N  * @brief  Set APB1 prescaler
N  * @rmtoll CFGR         PPRE         MS32_RCC_SetAPB1Prescaler
N  * @param  Prescaler This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_APB1_DIV_1
N  *         @arg @ref MS32_RCC_APB1_DIV_2
N  *         @arg @ref MS32_RCC_APB1_DIV_4
N  *         @arg @ref MS32_RCC_APB1_DIV_8
N  *         @arg @ref MS32_RCC_APB1_DIV_16
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_SetAPB1Prescaler(uint32_t Prescaler) {
Xstatic __inline void MS32_RCC_SetAPB1Prescaler(uint32_t Prescaler) {
N  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, Prescaler);
X  (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR)) = ((((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR))) & (~((0x7UL << (8U))))) | (Prescaler))));
N}
N
N/**
N  * @brief  Get AHB prescaler
N  * @rmtoll CFGR         HPRE          MS32_RCC_GetAHBPrescaler
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_1
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_2
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_4
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_8
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_16
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_64
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_128
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_256
N  *         @arg @ref MS32_RCC_SYSCLK_DIV_512
N  */
N__STATIC_INLINE uint32_t MS32_RCC_GetAHBPrescaler(void) {
Xstatic __inline uint32_t MS32_RCC_GetAHBPrescaler(void) {
N  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
X  return (uint32_t)(((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR) & ((0xFUL << (4U)))));
N}
N
N/**
N  * @brief  Get APB1 prescaler
N  * @rmtoll CFGR         PPRE         MS32_RCC_GetAPB1Prescaler
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RCC_APB1_DIV_1
N  *         @arg @ref MS32_RCC_APB1_DIV_2
N  *         @arg @ref MS32_RCC_APB1_DIV_4
N  *         @arg @ref MS32_RCC_APB1_DIV_8
N  *         @arg @ref MS32_RCC_APB1_DIV_16
N  */
N__STATIC_INLINE uint32_t MS32_RCC_GetAPB1Prescaler(void) {
Xstatic __inline uint32_t MS32_RCC_GetAPB1Prescaler(void) {
N  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE));
X  return (uint32_t)(((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR) & ((0x7UL << (8U)))));
N}
N
N
N/** @defgroup RCC_EF_MCO MCO
N  * @{
N  */
N
N/**
N  * @brief  Configure MCOx
N  * @rmtoll CFGR         MCO           MS32_RCC_ConfigMCO\n
N  *         CFGR         MCOPRE        MS32_RCC_ConfigMCO\n
N  *         CFGR         PLLNODIV      MS32_RCC_ConfigMCO
N  * @param  MCOxSource This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_MCO1SOURCE_NOCLOCK  
N  *         @arg @ref MS32_RCC_MCO1SOURCE_HSI16    
N  *         @arg @ref MS32_RCC_MCO1SOURCE_LSI      
N  *         @arg @ref MS32_RCC_MCO1SOURCE_LSE      
N  *         @arg @ref MS32_RCC_MCO1SOURCE_SYSCLK   
N  *         @arg @ref MS32_RCC_MCO1SOURCE_HSI      
N  *         @arg @ref MS32_RCC_MCO1SOURCE_HSE      
N  *         @arg @ref MS32_RCC_MCO1SOURCE_PLL_DIV_2
N  *         @arg @ref MS32_RCC_MCO1SOURCE_PLL
N  * @param  MCOxPrescaler This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_MCO1_DIV_1
N  *         @arg @ref MS32_RCC_MCO1_DIV_2
N  *         @arg @ref MS32_RCC_MCO1_DIV_4
N  *         @arg @ref MS32_RCC_MCO1_DIV_8
N  *         @arg @ref MS32_RCC_MCO1_DIV_16
N  *         @arg @ref MS32_RCC_MCO1_DIV_32
N  *         @arg @ref MS32_RCC_MCO1_DIV_64
N  *         @arg @ref MS32_RCC_MCO1_DIV_128
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_ConfigMCO(uint32_t MCOxSource, uint32_t MCOxPrescaler) {
Xstatic __inline void MS32_RCC_ConfigMCO(uint32_t MCOxSource, uint32_t MCOxPrescaler) {
N  MODIFY_REG(RCC->CFGR, RCC_CFGR_MCO | RCC_CFGR_MCOPRE | RCC_CFGR_PLLNODIV, MCOxSource | MCOxPrescaler);
X  (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR)) = ((((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR))) & (~((0xFUL << (24U)) | (0x7UL << (28U)) | (0x1UL << (31U))))) | (MCOxSource | MCOxPrescaler))));
N}
N
N
N/** @defgroup RCC_EF_Peripheral_Clock_Source Peripheral Clock Source
N  * @{
N  */
N
N/**
N  * @brief  Configure USARTx clock source
N  * @rmtoll CFGR3        USART1SW      MS32_RCC_SetUSARTClockSource
N  * @param  USARTxSource This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_USART1_CLKSOURCE_PCLK1
N  *         @arg @ref MS32_RCC_USART1_CLKSOURCE_SYSCLK
N  *         @arg @ref MS32_RCC_USART1_CLKSOURCE_LSE
N  *         @arg @ref MS32_RCC_USART1_CLKSOURCE_HSI
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_SetUSARTClockSource(uint32_t USARTxSource) {
Xstatic __inline void MS32_RCC_SetUSARTClockSource(uint32_t USARTxSource) {
N  MODIFY_REG(RCC->CFGR3, (RCC_CFGR3_USART1SW << ((USARTxSource  & 0xFF000000U) >> 24U)), (USARTxSource & 0x00FFFFFFU));
X  (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR3)) = ((((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR3))) & (~(((0x3UL << (0U)) << ((USARTxSource & 0xFF000000U) >> 24U))))) | ((USARTxSource & 0x00FFFFFFU)))));
N}
N
N/**
N  * @brief  Configure I2Cx clock source
N  * @rmtoll CFGR3        I2C1SW        MS32_RCC_SetI2CClockSource
N  * @param  I2CxSource This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_I2C1_CLKSOURCE_HSI
N  *         @arg @ref MS32_RCC_I2C1_CLKSOURCE_SYSCLK
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_SetI2CClockSource(uint32_t I2CxSource) {
Xstatic __inline void MS32_RCC_SetI2CClockSource(uint32_t I2CxSource) {
N  MODIFY_REG(RCC->CFGR3, RCC_CFGR3_I2C1SW, I2CxSource);
X  (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR3)) = ((((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR3))) & (~((0x1UL << (4U))))) | (I2CxSource))));
N}
N
N/**
N  * @brief  Get USARTx clock source
N  * @rmtoll CFGR3        USART1SW      MS32_RCC_GetUSARTClockSource
N  * @param  USARTx This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_USART1_CLKSOURCE
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RCC_USART1_CLKSOURCE_PCLK1
N  *         @arg @ref MS32_RCC_USART1_CLKSOURCE_SYSCLK
N  *         @arg @ref MS32_RCC_USART1_CLKSOURCE_LSE
N  *         @arg @ref MS32_RCC_USART1_CLKSOURCE_HSI
N  */
N__STATIC_INLINE uint32_t MS32_RCC_GetUSARTClockSource(uint32_t USARTx) {
Xstatic __inline uint32_t MS32_RCC_GetUSARTClockSource(uint32_t USARTx) {
N  return (uint32_t)(READ_BIT(RCC->CFGR3, (RCC_CFGR3_USART1SW << USARTx)) | (USARTx << 24U));
X  return (uint32_t)(((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR3) & (((0x3UL << (0U)) << USARTx))) | (USARTx << 24U));
N}
N
N/**
N  * @brief  Get I2Cx clock source
N  * @rmtoll CFGR3        I2C1SW        MS32_RCC_GetI2CClockSource
N  * @param  I2Cx This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_I2C1_CLKSOURCE
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RCC_I2C1_CLKSOURCE_HSI
N  *         @arg @ref MS32_RCC_I2C1_CLKSOURCE_SYSCLK
N  */
N__STATIC_INLINE uint32_t MS32_RCC_GetI2CClockSource(uint32_t I2Cx) {
Xstatic __inline uint32_t MS32_RCC_GetI2CClockSource(uint32_t I2Cx) {
N  return (uint32_t)(READ_BIT(RCC->CFGR3, I2Cx));
X  return (uint32_t)(((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR3) & (I2Cx)));
N}
N
N
N/** @defgroup RCC_EF_RTC RTC
N  * @{
N  */
N
N/**
N  * @brief  Set RTC Clock Source
N  * @note Once the RTC clock source has been selected, it cannot be changed any more unless
N  *       the Backup domain is reset. The BDRST bit can be used to reset them.
N  * @rmtoll BDCR         RTCSEL        MS32_RCC_SetRTCClockSource
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_RTC_CLKSOURCE_NONE
N  *         @arg @ref MS32_RCC_RTC_CLKSOURCE_LSE
N  *         @arg @ref MS32_RCC_RTC_CLKSOURCE_LSI
N  *         @arg @ref MS32_RCC_RTC_CLKSOURCE_HSE_DIV32
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_SetRTCClockSource(uint32_t Source) {
Xstatic __inline void MS32_RCC_SetRTCClockSource(uint32_t Source) {
N  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
X  (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR)) = ((((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR))) & (~((0x3UL << (8U))))) | (Source))));
N}
N
N/**
N  * @brief  Get RTC Clock Source
N  * @rmtoll BDCR         RTCSEL        MS32_RCC_GetRTCClockSource
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RCC_RTC_CLKSOURCE_NONE
N  *         @arg @ref MS32_RCC_RTC_CLKSOURCE_LSE
N  *         @arg @ref MS32_RCC_RTC_CLKSOURCE_LSI
N  *         @arg @ref MS32_RCC_RTC_CLKSOURCE_HSE_DIV32
N  */
N__STATIC_INLINE uint32_t MS32_RCC_GetRTCClockSource(void) {
Xstatic __inline uint32_t MS32_RCC_GetRTCClockSource(void) {
N  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
X  return (uint32_t)(((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR) & ((0x3UL << (8U)))));
N}
N
N/**
N  * @brief  Enable RTC
N  * @rmtoll BDCR         RTCEN         MS32_RCC_EnableRTC
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_EnableRTC(void) {
Xstatic __inline void MS32_RCC_EnableRTC(void) {
N  SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR) |= ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Disable RTC
N  * @rmtoll BDCR         RTCEN         MS32_RCC_DisableRTC
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_DisableRTC(void) {
Xstatic __inline void MS32_RCC_DisableRTC(void) {
N  CLEAR_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR) &= ~((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Check if RTC has been enabled or not
N  * @rmtoll BDCR         RTCEN         MS32_RCC_IsEnabledRTC
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsEnabledRTC(void) {
Xstatic __inline uint32_t MS32_RCC_IsEnabledRTC(void) {
N  return (READ_BIT(RCC->BDCR, RCC_BDCR_RTCEN) == (RCC_BDCR_RTCEN));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR) & ((0x1UL << (15U)))) == ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Force the Backup domain reset
N  * @rmtoll BDCR         BDRST         MS32_RCC_ForceBackupDomainReset
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_ForceBackupDomainReset(void) {
Xstatic __inline void MS32_RCC_ForceBackupDomainReset(void) {
N  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR) |= ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Release the Backup domain reset
N  * @rmtoll BDCR         BDRST         MS32_RCC_ReleaseBackupDomainReset
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_ReleaseBackupDomainReset(void) {
Xstatic __inline void MS32_RCC_ReleaseBackupDomainReset(void) {
N  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->BDCR) &= ~((0x1UL << (16U))));
N}
N
N
N/** @defgroup RCC_EF_PLL PLL
N  * @{
N  */
N
N/**
N  * @brief  Enable PLL
N  * @rmtoll CR           PLLON         MS32_RCC_PLL_Enable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_PLL_Enable(void) {
Xstatic __inline void MS32_RCC_PLL_Enable(void) {
N  SET_BIT(RCC->CR, RCC_CR_PLLON);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) |= ((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Disable PLL
N  * @note Cannot be disabled if the PLL clock is used as the system clock
N  * @rmtoll CR           PLLON         MS32_RCC_PLL_Disable
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_PLL_Disable(void) {
Xstatic __inline void MS32_RCC_PLL_Disable(void) {
N  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) &= ~((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Check if PLL Ready
N  * @rmtoll CR           PLLRDY        MS32_RCC_PLL_IsReady
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_PLL_IsReady(void) {
Xstatic __inline uint32_t MS32_RCC_PLL_IsReady(void) {
N  return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) & ((0x1UL << (25U)))) == ((0x1UL << (25U))));
N}
N
N/**
N  * @brief  Configure PLL used for SYSCLK Domain
N  * @rmtoll CFGR         PLLSRC        MS32_RCC_PLL_ConfigDomain_SYS\n
N  *         CFGR         PLLMUL        MS32_RCC_PLL_ConfigDomain_SYS\n
N  *         CFGR2        PREDIV        MS32_RCC_PLL_ConfigDomain_SYS
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSI_DIV_2
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_1
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_2
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_3
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_4
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_5
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_6
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_7
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_8
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_9
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_10
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_11
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_12
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_13
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_14
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_15
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE_DIV_16
N  * @param  PLLMul This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_PLL_MUL_2
N  *         @arg @ref MS32_RCC_PLL_MUL_3
N  *         @arg @ref MS32_RCC_PLL_MUL_4
N  *         @arg @ref MS32_RCC_PLL_MUL_5
N  *         @arg @ref MS32_RCC_PLL_MUL_6
N  *         @arg @ref MS32_RCC_PLL_MUL_7
N  *         @arg @ref MS32_RCC_PLL_MUL_8
N  *         @arg @ref MS32_RCC_PLL_MUL_9
N  *         @arg @ref MS32_RCC_PLL_MUL_10
N  *         @arg @ref MS32_RCC_PLL_MUL_11
N  *         @arg @ref MS32_RCC_PLL_MUL_12
N  *         @arg @ref MS32_RCC_PLL_MUL_13
N  *         @arg @ref MS32_RCC_PLL_MUL_14
N  *         @arg @ref MS32_RCC_PLL_MUL_15
N  *         @arg @ref MS32_RCC_PLL_MUL_16
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_PLL_ConfigDomain_SYS(uint32_t Source, uint32_t PLLMul)
Xstatic __inline void MS32_RCC_PLL_ConfigDomain_SYS(uint32_t Source, uint32_t PLLMul)
N{
N  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL, (Source & RCC_CFGR_PLLSRC) | PLLMul);
X  (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR)) = ((((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR))) & (~((0x1UL << (16U)) | (0xFUL << (18U))))) | ((Source & (0x1UL << (16U))) | PLLMul))));
N  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, (Source & RCC_CFGR2_PREDIV));
X  (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR2)) = ((((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR2))) & (~((0xFUL << (0U))))) | ((Source & (0xFUL << (0U)))))));
N}
N
N/**
N  * @brief  Configure PLL clock source
N  * @note They can be written only when the PLL is disabled
N  * @rmtoll CFGR      PLLSRC        MS32_RCC_PLL_SetMainSource
N  * @param PLLSource This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_PLLSOURCE_NONE
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSI_DIV_2 (*)
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE
N  *
N  *         (*) value not defined in all devices
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_PLL_SetMainSource(uint32_t PLLSource) {
Xstatic __inline void MS32_RCC_PLL_SetMainSource(uint32_t PLLSource) {
N  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC, PLLSource);
X  (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR)) = ((((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR))) & (~((0x1UL << (16U))))) | (PLLSource))));
N}
N
N/**
N  * @brief  Get the oscillator used as PLL clock source.
N  * @rmtoll CFGR         PLLSRC        MS32_RCC_PLL_GetMainSource
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RCC_PLLSOURCE_NONE
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSI_DIV_2 (*)
N  *         @arg @ref MS32_RCC_PLLSOURCE_HSE
N  *
N  *         (*) value not defined in all devices
N  */
N__STATIC_INLINE uint32_t MS32_RCC_PLL_GetMainSource(void) {
Xstatic __inline uint32_t MS32_RCC_PLL_GetMainSource(void) {
N  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLSRC));
X  return (uint32_t)(((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR) & ((0x1UL << (16U)))));
N}
N
N/**
N  * @brief  Set PLL multiplication Factor
N  * @note They can be written only when the PLL is disabled
N  * @rmtoll CFGR         PLLMUL        MS32_RCC_PLL_SetMultiplicator
N  * @param PLLSource This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_PLL_MUL_2
N  *         @arg @ref MS32_RCC_PLL_MUL_3
N  *         @arg @ref MS32_RCC_PLL_MUL_4
N  *         @arg @ref MS32_RCC_PLL_MUL_5
N  *         @arg @ref MS32_RCC_PLL_MUL_6
N  *         @arg @ref MS32_RCC_PLL_MUL_7
N  *         @arg @ref MS32_RCC_PLL_MUL_8
N  *         @arg @ref MS32_RCC_PLL_MUL_9
N  *         @arg @ref MS32_RCC_PLL_MUL_10
N  *         @arg @ref MS32_RCC_PLL_MUL_11
N  *         @arg @ref MS32_RCC_PLL_MUL_12
N  *         @arg @ref MS32_RCC_PLL_MUL_13
N  *         @arg @ref MS32_RCC_PLL_MUL_14
N  *         @arg @ref MS32_RCC_PLL_MUL_15
N  *         @arg @ref MS32_RCC_PLL_MUL_16
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_PLL_SetMultiplicator(uint32_t PLLMul) {
Xstatic __inline void MS32_RCC_PLL_SetMultiplicator(uint32_t PLLMul) {
N  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLMUL, PLLMul);
X  (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR)) = ((((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR))) & (~((0xFUL << (18U))))) | (PLLMul))));
N}
N
N/**
N  * @brief  Get PLL multiplication Factor
N  * @rmtoll CFGR         PLLMUL        MS32_RCC_PLL_GetMultiplicator
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RCC_PLL_MUL_2
N  *         @arg @ref MS32_RCC_PLL_MUL_3
N  *         @arg @ref MS32_RCC_PLL_MUL_4
N  *         @arg @ref MS32_RCC_PLL_MUL_5
N  *         @arg @ref MS32_RCC_PLL_MUL_6
N  *         @arg @ref MS32_RCC_PLL_MUL_7
N  *         @arg @ref MS32_RCC_PLL_MUL_8
N  *         @arg @ref MS32_RCC_PLL_MUL_9
N  *         @arg @ref MS32_RCC_PLL_MUL_10
N  *         @arg @ref MS32_RCC_PLL_MUL_11
N  *         @arg @ref MS32_RCC_PLL_MUL_12
N  *         @arg @ref MS32_RCC_PLL_MUL_13
N  *         @arg @ref MS32_RCC_PLL_MUL_14
N  *         @arg @ref MS32_RCC_PLL_MUL_15
N  *         @arg @ref MS32_RCC_PLL_MUL_16
N  */
N__STATIC_INLINE uint32_t MS32_RCC_PLL_GetMultiplicator(void) {
Xstatic __inline uint32_t MS32_RCC_PLL_GetMultiplicator(void) {
N  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLMUL));
X  return (uint32_t)(((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR) & ((0xFUL << (18U)))));
N}
N
N/**
N  * @brief  Set PREDIV division factor for the main PLL
N  * @note They can be written only when the PLL is disabled
N  * @rmtoll CFGR2        PREDIV        MS32_RCC_PLL_SetPrediv
N  * @param PLLPrediv value can be one of the following values:
N  *         @arg @ref MS32_RCC_PREDIV_DIV_1
N  *         @arg @ref MS32_RCC_PREDIV_DIV_2
N  *         @arg @ref MS32_RCC_PREDIV_DIV_3
N  *         @arg @ref MS32_RCC_PREDIV_DIV_4
N  *         @arg @ref MS32_RCC_PREDIV_DIV_5
N  *         @arg @ref MS32_RCC_PREDIV_DIV_6
N  *         @arg @ref MS32_RCC_PREDIV_DIV_7
N  *         @arg @ref MS32_RCC_PREDIV_DIV_8
N  *         @arg @ref MS32_RCC_PREDIV_DIV_9
N  *         @arg @ref MS32_RCC_PREDIV_DIV_10
N  *         @arg @ref MS32_RCC_PREDIV_DIV_11
N  *         @arg @ref MS32_RCC_PREDIV_DIV_12
N  *         @arg @ref MS32_RCC_PREDIV_DIV_13
N  *         @arg @ref MS32_RCC_PREDIV_DIV_14
N  *         @arg @ref MS32_RCC_PREDIV_DIV_15
N  *         @arg @ref MS32_RCC_PREDIV_DIV_16
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_PLL_SetPrediv(uint32_t PLLPrediv) {
Xstatic __inline void MS32_RCC_PLL_SetPrediv(uint32_t PLLPrediv) {
N  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, PLLPrediv);
X  (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR2)) = ((((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR2))) & (~((0xFUL << (0U))))) | (PLLPrediv))));
N}
N
N/**
N  * @brief  Get PREDIV division factor for the main PLL
N  * @rmtoll CFGR2        PREDIV        MS32_RCC_PLL_GetPrediv
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RCC_PREDIV_DIV_1
N  *         @arg @ref MS32_RCC_PREDIV_DIV_2
N  *         @arg @ref MS32_RCC_PREDIV_DIV_3
N  *         @arg @ref MS32_RCC_PREDIV_DIV_4
N  *         @arg @ref MS32_RCC_PREDIV_DIV_5
N  *         @arg @ref MS32_RCC_PREDIV_DIV_6
N  *         @arg @ref MS32_RCC_PREDIV_DIV_7
N  *         @arg @ref MS32_RCC_PREDIV_DIV_8
N  *         @arg @ref MS32_RCC_PREDIV_DIV_9
N  *         @arg @ref MS32_RCC_PREDIV_DIV_10
N  *         @arg @ref MS32_RCC_PREDIV_DIV_11
N  *         @arg @ref MS32_RCC_PREDIV_DIV_12
N  *         @arg @ref MS32_RCC_PREDIV_DIV_13
N  *         @arg @ref MS32_RCC_PREDIV_DIV_14
N  *         @arg @ref MS32_RCC_PREDIV_DIV_15
N  *         @arg @ref MS32_RCC_PREDIV_DIV_16
N  */
N__STATIC_INLINE uint32_t MS32_RCC_PLL_GetPrediv(void) {
Xstatic __inline uint32_t MS32_RCC_PLL_GetPrediv(void) {
N  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PREDIV));
X  return (uint32_t)(((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR2) & ((0xFUL << (0U)))));
N}
N
N
N/** @defgroup RCC_EF_FLAG_Management FLAG Management
N  * @{
N  */
N
N/**
N  * @brief  Clear LSI ready interrupt flag
N  * @rmtoll CIR         LSIRDYC       MS32_RCC_ClearFlag_LSIRDY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_ClearFlag_LSIRDY(void) {
Xstatic __inline void MS32_RCC_ClearFlag_LSIRDY(void) {
N  SET_BIT(RCC->CIR, RCC_CIR_LSIRDYC);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) |= ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Clear LSE ready interrupt flag
N  * @rmtoll CIR         LSERDYC       MS32_RCC_ClearFlag_LSERDY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_ClearFlag_LSERDY(void) {
Xstatic __inline void MS32_RCC_ClearFlag_LSERDY(void) {
N  SET_BIT(RCC->CIR, RCC_CIR_LSERDYC);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) |= ((0x1UL << (17U))));
N}
N
N/**
N  * @brief  Clear HSI ready interrupt flag
N  * @rmtoll CIR         HSIRDYC       MS32_RCC_ClearFlag_HSIRDY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_ClearFlag_HSIRDY(void) {
Xstatic __inline void MS32_RCC_ClearFlag_HSIRDY(void) {
N  SET_BIT(RCC->CIR, RCC_CIR_HSIRDYC);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) |= ((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Clear HSE ready interrupt flag
N  * @rmtoll CIR         HSERDYC       MS32_RCC_ClearFlag_HSERDY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_ClearFlag_HSERDY(void) {
Xstatic __inline void MS32_RCC_ClearFlag_HSERDY(void) {
N  SET_BIT(RCC->CIR, RCC_CIR_HSERDYC);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) |= ((0x1UL << (19U))));
N}
N
N/**
N  * @brief  Clear PLL ready interrupt flag
N  * @rmtoll CIR         PLLRDYC       MS32_RCC_ClearFlag_PLLRDY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_ClearFlag_PLLRDY(void) {
Xstatic __inline void MS32_RCC_ClearFlag_PLLRDY(void) {
N  SET_BIT(RCC->CIR, RCC_CIR_PLLRDYC);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) |= ((0x1UL << (20U))));
N}
N
N/**
N  * @brief  Clear Clock security system interrupt flag
N  * @rmtoll CIR         CSSC          MS32_RCC_ClearFlag_HSECSS
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_ClearFlag_HSECSS(void) {
Xstatic __inline void MS32_RCC_ClearFlag_HSECSS(void) {
N  SET_BIT(RCC->CIR, RCC_CIR_CSSC);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) |= ((0x1UL << (23U))));
N}
N
N/**
N  * @brief  Check if LSI ready interrupt occurred or not
N  * @rmtoll CIR         LSIRDYF       MS32_RCC_IsActiveFlag_LSIRDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsActiveFlag_LSIRDY(void) {
Xstatic __inline uint32_t MS32_RCC_IsActiveFlag_LSIRDY(void) {
N  return (READ_BIT(RCC->CIR, RCC_CIR_LSIRDYF) == (RCC_CIR_LSIRDYF));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if LSE ready interrupt occurred or not
N  * @rmtoll CIR         LSERDYF       MS32_RCC_IsActiveFlag_LSERDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsActiveFlag_LSERDY(void) {
Xstatic __inline uint32_t MS32_RCC_IsActiveFlag_LSERDY(void) {
N  return (READ_BIT(RCC->CIR, RCC_CIR_LSERDYF) == (RCC_CIR_LSERDYF));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Check if HSI ready interrupt occurred or not
N  * @rmtoll CIR         HSIRDYF       MS32_RCC_IsActiveFlag_HSIRDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsActiveFlag_HSIRDY(void) {
Xstatic __inline uint32_t MS32_RCC_IsActiveFlag_HSIRDY(void) {
N  return (READ_BIT(RCC->CIR, RCC_CIR_HSIRDYF) == (RCC_CIR_HSIRDYF));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Check if HSE ready interrupt occurred or not
N  * @rmtoll CIR         HSERDYF       MS32_RCC_IsActiveFlag_HSERDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsActiveFlag_HSERDY(void) {
Xstatic __inline uint32_t MS32_RCC_IsActiveFlag_HSERDY(void) {
N  return (READ_BIT(RCC->CIR, RCC_CIR_HSERDYF) == (RCC_CIR_HSERDYF));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Check if PLL ready interrupt occurred or not
N  * @rmtoll CIR         PLLRDYF       MS32_RCC_IsActiveFlag_PLLRDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsActiveFlag_PLLRDY(void) {
Xstatic __inline uint32_t MS32_RCC_IsActiveFlag_PLLRDY(void) {
N  return (READ_BIT(RCC->CIR, RCC_CIR_PLLRDYF) == (RCC_CIR_PLLRDYF));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Check if Clock security system interrupt occurred or not
N  * @rmtoll CIR         CSSF          MS32_RCC_IsActiveFlag_HSECSS
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsActiveFlag_HSECSS(void) {
Xstatic __inline uint32_t MS32_RCC_IsActiveFlag_HSECSS(void) {
N  return (READ_BIT(RCC->CIR, RCC_CIR_CSSF) == (RCC_CIR_CSSF));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) & ((0x1UL << (7U)))) == ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Check if RCC flag Independent Watchdog reset is set or not.
N  * @rmtoll CSR          IWDGRSTF      MS32_RCC_IsActiveFlag_IWDGRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsActiveFlag_IWDGRST(void) {
Xstatic __inline uint32_t MS32_RCC_IsActiveFlag_IWDGRST(void) {
N  return (READ_BIT(RCC->CSR, RCC_CSR_IWDGRSTF) == (RCC_CSR_IWDGRSTF));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CSR) & ((0x1UL << (29U)))) == ((0x1UL << (29U))));
N}
N
N/**
N  * @brief  Check if RCC flag Low Power reset is set or not.
N  * @rmtoll CSR          LPWRRSTF      MS32_RCC_IsActiveFlag_LPWRRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsActiveFlag_LPWRRST(void) {
Xstatic __inline uint32_t MS32_RCC_IsActiveFlag_LPWRRST(void) {
N  return (READ_BIT(RCC->CSR, RCC_CSR_LPWRRSTF) == (RCC_CSR_LPWRRSTF));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CSR) & ((0x1UL << (31U)))) == ((0x1UL << (31U))));
N}
N
N/**
N  * @brief  Check if RCC flag is set or not.
N  * @rmtoll CSR          OBLRSTF       MS32_RCC_IsActiveFlag_OBLRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsActiveFlag_OBLRST(void) {
Xstatic __inline uint32_t MS32_RCC_IsActiveFlag_OBLRST(void) {
N  return (READ_BIT(RCC->CSR, RCC_CSR_OBLRSTF) == (RCC_CSR_OBLRSTF));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CSR) & ((0x1UL << (25U)))) == ((0x1UL << (25U))));
N}
N
N/**
N  * @brief  Check if RCC flag Pin reset is set or not.
N  * @rmtoll CSR          PINRSTF       MS32_RCC_IsActiveFlag_PINRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsActiveFlag_PINRST(void) {
Xstatic __inline uint32_t MS32_RCC_IsActiveFlag_PINRST(void) {
N  return (READ_BIT(RCC->CSR, RCC_CSR_PINRSTF) == (RCC_CSR_PINRSTF));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CSR) & ((0x1UL << (26U)))) == ((0x1UL << (26U))));
N}
N
N/**
N  * @brief  Check if RCC flag POR/PDR reset is set or not.
N  * @rmtoll CSR          PORRSTF       MS32_RCC_IsActiveFlag_PORRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsActiveFlag_PORRST(void) {
Xstatic __inline uint32_t MS32_RCC_IsActiveFlag_PORRST(void) {
N  return (READ_BIT(RCC->CSR, RCC_CSR_PORRSTF) == (RCC_CSR_PORRSTF));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CSR) & ((0x1UL << (27U)))) == ((0x1UL << (27U))));
N}
N
N/**
N  * @brief  Check if RCC flag Software reset is set or not.
N  * @rmtoll CSR          SFTRSTF       MS32_RCC_IsActiveFlag_SFTRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsActiveFlag_SFTRST(void) {
Xstatic __inline uint32_t MS32_RCC_IsActiveFlag_SFTRST(void) {
N  return (READ_BIT(RCC->CSR, RCC_CSR_SFTRSTF) == (RCC_CSR_SFTRSTF));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CSR) & ((0x1UL << (28U)))) == ((0x1UL << (28U))));
N}
N
N/**
N  * @brief  Check if RCC flag Window Watchdog reset is set or not.
N  * @rmtoll CSR          WWDGRSTF      MS32_RCC_IsActiveFlag_WWDGRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsActiveFlag_WWDGRST(void) {
Xstatic __inline uint32_t MS32_RCC_IsActiveFlag_WWDGRST(void) {
N  return (READ_BIT(RCC->CSR, RCC_CSR_WWDGRSTF) == (RCC_CSR_WWDGRSTF));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CSR) & ((0x1UL << (30U)))) == ((0x1UL << (30U))));
N}
N
N/**
N  * @brief  Check if RCC Reset flag of the 1.5 V domain is set or not.
N  * @rmtoll CSR          V18PWRRSTF    MS32_RCC_IsActiveFlag_V18PWRRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsActiveFlag_V15PWRRST(void) {
Xstatic __inline uint32_t MS32_RCC_IsActiveFlag_V15PWRRST(void) {
N  return (READ_BIT(RCC->CSR, RCC_CSR_V15PWRRSTF) == (RCC_CSR_V15PWRRSTF));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CSR) & ((0x1UL << (23U)))) == ((0x1UL << (23U))));
N}
N
N/**
N  * @brief  Set RMVF bit to clear the reset flags.
N  * @rmtoll CSR          RMVF          MS32_RCC_ClearResetFlags
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_ClearResetFlags(void) {
Xstatic __inline void MS32_RCC_ClearResetFlags(void) {
N  SET_BIT(RCC->CSR, RCC_CSR_RMVF);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CSR) |= ((0x1UL << (24U))));
N}
N
N
N/** @defgroup RCC_EF_IT_Management IT Management
N  * @{
N  */
N
N/**
N  * @brief  Enable LSI ready interrupt
N  * @rmtoll CIR         LSIRDYIE      MS32_RCC_EnableIT_LSIRDY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_EnableIT_LSIRDY(void) {
Xstatic __inline void MS32_RCC_EnableIT_LSIRDY(void) {
N  SET_BIT(RCC->CIR, RCC_CIR_LSIRDYIE);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Enable LSE ready interrupt
N  * @rmtoll CIR         LSERDYIE      MS32_RCC_EnableIT_LSERDY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_EnableIT_LSERDY(void) {
Xstatic __inline void MS32_RCC_EnableIT_LSERDY(void) {
N  SET_BIT(RCC->CIR, RCC_CIR_LSERDYIE);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) |= ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Enable HSI ready interrupt
N  * @rmtoll CIR         HSIRDYIE      MS32_RCC_EnableIT_HSIRDY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_EnableIT_HSIRDY(void) {
Xstatic __inline void MS32_RCC_EnableIT_HSIRDY(void) {
N  SET_BIT(RCC->CIR, RCC_CIR_HSIRDYIE);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) |= ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Enable HSE ready interrupt
N  * @rmtoll CIR         HSERDYIE      MS32_RCC_EnableIT_HSERDY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_EnableIT_HSERDY(void) {
Xstatic __inline void MS32_RCC_EnableIT_HSERDY(void) {
N  SET_BIT(RCC->CIR, RCC_CIR_HSERDYIE);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) |= ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Enable PLL ready interrupt
N  * @rmtoll CIR         PLLRDYIE      MS32_RCC_EnableIT_PLLRDY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_EnableIT_PLLRDY(void) {
Xstatic __inline void MS32_RCC_EnableIT_PLLRDY(void) {
N  SET_BIT(RCC->CIR, RCC_CIR_PLLRDYIE);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Disable LSI ready interrupt
N  * @rmtoll CIR         LSIRDYIE      MS32_RCC_DisableIT_LSIRDY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_DisableIT_LSIRDY(void) {
Xstatic __inline void MS32_RCC_DisableIT_LSIRDY(void) {
N  CLEAR_BIT(RCC->CIR, RCC_CIR_LSIRDYIE);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable LSE ready interrupt
N  * @rmtoll CIR         LSERDYIE      MS32_RCC_DisableIT_LSERDY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_DisableIT_LSERDY(void) {
Xstatic __inline void MS32_RCC_DisableIT_LSERDY(void) {
N  CLEAR_BIT(RCC->CIR, RCC_CIR_LSERDYIE);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) &= ~((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Disable HSI ready interrupt
N  * @rmtoll CIR         HSIRDYIE      MS32_RCC_DisableIT_HSIRDY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_DisableIT_HSIRDY(void) {
Xstatic __inline void MS32_RCC_DisableIT_HSIRDY(void) {
N  CLEAR_BIT(RCC->CIR, RCC_CIR_HSIRDYIE);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) &= ~((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Disable HSE ready interrupt
N  * @rmtoll CIR         HSERDYIE      MS32_RCC_DisableIT_HSERDY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_DisableIT_HSERDY(void) {
Xstatic __inline void MS32_RCC_DisableIT_HSERDY(void) {
N  CLEAR_BIT(RCC->CIR, RCC_CIR_HSERDYIE);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) &= ~((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Disable PLL ready interrupt
N  * @rmtoll CIR         PLLRDYIE      MS32_RCC_DisableIT_PLLRDY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RCC_DisableIT_PLLRDY(void) {
Xstatic __inline void MS32_RCC_DisableIT_PLLRDY(void) {
N  CLEAR_BIT(RCC->CIR, RCC_CIR_PLLRDYIE);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) &= ~((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Checks if LSI ready interrupt source is enabled or disabled.
N  * @rmtoll CIR         LSIRDYIE      MS32_RCC_IsEnabledIT_LSIRDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsEnabledIT_LSIRDY(void) {
Xstatic __inline uint32_t MS32_RCC_IsEnabledIT_LSIRDY(void) {
N  return (READ_BIT(RCC->CIR, RCC_CIR_LSIRDYIE) == (RCC_CIR_LSIRDYIE));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Checks if LSE ready interrupt source is enabled or disabled.
N  * @rmtoll CIR         LSERDYIE      MS32_RCC_IsEnabledIT_LSERDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsEnabledIT_LSERDY(void) {
Xstatic __inline uint32_t MS32_RCC_IsEnabledIT_LSERDY(void) {
N  return (READ_BIT(RCC->CIR, RCC_CIR_LSERDYIE) == (RCC_CIR_LSERDYIE));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) & ((0x1UL << (9U)))) == ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Checks if HSI ready interrupt source is enabled or disabled.
N  * @rmtoll CIR         HSIRDYIE      MS32_RCC_IsEnabledIT_HSIRDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsEnabledIT_HSIRDY(void) {
Xstatic __inline uint32_t MS32_RCC_IsEnabledIT_HSIRDY(void) {
N  return (READ_BIT(RCC->CIR, RCC_CIR_HSIRDYIE) == (RCC_CIR_HSIRDYIE));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) & ((0x1UL << (10U)))) == ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Checks if HSE ready interrupt source is enabled or disabled.
N  * @rmtoll CIR         HSERDYIE      MS32_RCC_IsEnabledIT_HSERDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsEnabledIT_HSERDY(void) {
Xstatic __inline uint32_t MS32_RCC_IsEnabledIT_HSERDY(void) {
N  return (READ_BIT(RCC->CIR, RCC_CIR_HSERDYIE) == (RCC_CIR_HSERDYIE));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) & ((0x1UL << (11U)))) == ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Checks if PLL ready interrupt source is enabled or disabled.
N  * @rmtoll CIR         PLLRDYIE      MS32_RCC_IsEnabledIT_PLLRDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RCC_IsEnabledIT_PLLRDY(void) {
Xstatic __inline uint32_t MS32_RCC_IsEnabledIT_PLLRDY(void) {
N  return (READ_BIT(RCC->CIR, RCC_CIR_PLLRDYIE) == (RCC_CIR_PLLRDYIE));
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) & ((0x1UL << (12U)))) == ((0x1UL << (12U))));
N}
N
N
N/** @defgroup RCC_EF_Init De-initialization function
N  * @{
N  */
NErrorStatus MS32_RCC_DeInit      (void);
NErrorStatus MS32_RCC_OscConfig   (MS32_RCC_OscInitTypeDef *OscInitStr);
NErrorStatus MS32_RCC_PllConfig   (MS32_RCC_PllInitTypeDef *PllInitStr);
NErrorStatus MS32_RCC_ClockConfig (MS32_RCC_ClkInitTypeDef *ClkInitStr);
Nvoid        MS32_RCC_ITConfig    (uint32_t InterruptFunc, uint32_t Priority);
N
N/** @defgroup WWDG_EF_Application function
N  * @{
N  */
Nvoid        MS32_RCC_GetOscConfig   (MS32_RCC_OscInitTypeDef *OscInitStr);
Nvoid        MS32_RCC_GetPllConfig   (MS32_RCC_PllInitTypeDef *PllInitStr);
Nvoid        MS32_RCC_GetClockConfig (MS32_RCC_ClkInitTypeDef *ClkInitStr);
Nvoid        MS32_RCC_MCOConfig      (uint32_t McoSource, uint32_t McoDiv);
Nvoid        MS32_RCC_CSS            (FunctionalState CssState);
NFlagStatus  MS32_RCC_GetStatusFlag  (uint32_t Flags);
Nuint32_t    MS32_RCC_GetResetFlag   (FunctionalState FlagClrCtrl);
N
N/** @defgroup RCC_EF_Get_Freq Get system and peripherals clocks frequency functions
N  * @{
N  */
Nvoid     MS32_RCC_GetSystemClocksFreq (MS32_RCC_ClocksTypeDef *RccClocks);
Nuint32_t MS32_RCC_GetUSARTClockFreq   (uint32_t UsartxSource);
Nuint32_t MS32_RCC_GetI2CClockFreq     (uint32_t I2cxSource);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_RCC_H */
N
N/******************************** END OF FILE *********************************/
L 77 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_rtc.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_rtc.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_RTC_H
N#define __MS32F0XX_RTC_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RTC_Private_Constants RTC Private Constants
N  * @{
N  */
N/* Masks Definition */
N#define RTC_INIT_MASK                 0xFFFFFFFFU
N#define RTC_RSF_MASK                  0xFFFFFF5FU
N
N/* Write protection defines */
N#define RTC_WRITE_PROTECTION_DISABLE  ((uint8_t)0xFFU)
N#define RTC_WRITE_PROTECTION_ENABLE_1 ((uint8_t)0xCAU)
N#define RTC_WRITE_PROTECTION_ENABLE_2 ((uint8_t)0x53U)
N
N/* Defines used to combine date & time */
N#define RTC_OFFSET_WEEKDAY            24U
N#define RTC_OFFSET_DAY                16U
N#define RTC_OFFSET_MONTH              8U
N#define RTC_OFFSET_HOUR               16U
N#define RTC_OFFSET_MINUTE             8U
N
N
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/**
N  * @brief  RTC Init structures definition
N  */
Ntypedef struct {
N  uint32_t HourFormat;   /*!< Specifies the RTC Hours Format.
N                              This parameter can be a value of @ref RTC_EC_HOURFORMAT
N                              This feature can be modified afterwards using unitary function
N                              @ref MS32_RTC_SetHourFormat(). */
N  uint32_t AsynchPrescaler; /*!< Specifies the RTC Asynchronous Predivider value.
N                              This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7F
N                              This feature can be modified afterwards using unitary function
N                              @ref MS32_RTC_SetAsynchPrescaler(). */
N  uint32_t SynchPrescaler;  /*!< Specifies the RTC Synchronous Predivider value.
N                              This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7FFF
N                              This feature can be modified afterwards using unitary function
N                              @ref MS32_RTC_SetSynchPrescaler(). */
N} MS32_RTC_InitTypeDef;
N
N/**
N  * @brief  RTC Time structure definition
N  */
Ntypedef struct {
N  uint32_t TimeFormat; /*!< Specifies the RTC AM/PM Time.
N                            This parameter can be a value of @ref RTC_EC_TIME_FORMAT
N                            This feature can be modified afterwards using unitary function @ref MS32_RTC_TIME_SetFormat(). */
N  uint8_t Hours;       /*!< Specifies the RTC Time Hours.
N                            This parameter must be a number between Min_Data = 0 and Max_Data = 12 if the @ref MS32_RTC_TIME_FORMAT_PM is selected.
N                            This parameter must be a number between Min_Data = 0 and Max_Data = 23 if the @ref MS32_RTC_TIME_FORMAT_AM_OR_24 is selected.
N                            This feature can be modified afterwards using unitary function @ref MS32_RTC_TIME_SetHour(). */
N  uint8_t Minutes;     /*!< Specifies the RTC Time Minutes.
N                            This parameter must be a number between Min_Data = 0 and Max_Data = 59
N                            This feature can be modified afterwards using unitary function @ref MS32_RTC_TIME_SetMinute(). */
N  uint8_t Seconds;     /*!< Specifies the RTC Time Seconds.
N                            This parameter must be a number between Min_Data = 0 and Max_Data = 59
N                            This feature can be modified afterwards using unitary function @ref MS32_RTC_TIME_SetSecond(). */
N} MS32_RTC_TimeTypeDef;
N
N/**
N  * @brief  RTC Date structure definition
N  */
Ntypedef struct {
N  uint8_t WeekDay;  /*!< Specifies the RTC Date WeekDay.
N                         This parameter can be a value of @ref RTC_EC_WEEKDAY
N                         This feature can be modified afterwards using unitary function @ref MS32_RTC_DATE_SetWeekDay(). */
N  uint8_t Month;    /*!< Specifies the RTC Date Month.
N                         This parameter can be a value of @ref RTC_EC_MONTH
N                         This feature can be modified afterwards using unitary function @ref MS32_RTC_DATE_SetMonth(). */
N  uint8_t Day;      /*!< Specifies the RTC Date Day.
N                         This parameter must be a number between Min_Data = 1 and Max_Data = 31
N                         This feature can be modified afterwards using unitary function @ref MS32_RTC_DATE_SetDay(). */
N  uint8_t Year;     /*!< Specifies the RTC Date Year.
N                         This parameter must be a number between Min_Data = 0 and Max_Data = 99
N                         This feature can be modified afterwards using unitary function @ref MS32_RTC_DATE_SetYear(). */
N} MS32_RTC_DateTypeDef;
N
N/**
N  * @brief  RTC Alarm structure definition
N  */
Ntypedef struct {
N  MS32_RTC_TimeTypeDef AlarmTime;  /*!< Specifies the RTC Alarm Time members. */
N  uint32_t AlarmMask;              /*!< Specifies the RTC Alarm Masks.
N                                        This parameter can be a value of @ref RTC_EC_ALARM_MASK
N                                        This feature can be modified afterwards using unitary function @ref MS32_RTC_ALARM_SetMask() for ALARM A. */
N  uint32_t AlarmDateWeekDaySel;    /*!< Specifies the RTC Alarm is on day or WeekDay.
N                                        This parameter can be a value of @ref RTC_EC_ALARM_WEEKDAY_SELECTION
N                                        This feature can be modified afterwards using unitary function @ref MS32_RTC_ALARM_EnableWeekday() or @ref MS32_RTC_ALARM_DisableWeekday() */
N  uint8_t AlarmDateWeekDay;        /*!< Specifies the RTC Alarm Day/WeekDay.
N                                        If AlarmDateWeekDaySel set to day, this parameter  must be a number between Min_Data = 1 and Max_Data = 31.
N                                        This feature can be modified afterwards using unitary function @ref MS32_RTC_ALARM_SetDay()
N                                        If AlarmDateWeekDaySel set to Weekday, this parameter can be a value of @ref RTC_EC_WEEKDAY.
N                                        This feature can be modified afterwards using unitary function @ref MS32_RTC_ALARM_SetWeekDay() */
N} MS32_RTC_AlarmTypeDef;
N
N/**
N  * @brief  RTC time stamp structure definition
N  */
Ntypedef struct {
N  MS32_RTC_TimeTypeDef TimeStamp;  /*!< Specifies the RTC Time Stamp members. */
N  uint8_t WeekDay;                 /*!< Specifies the RTC time stamp WeekDay.
N                                        This parameter can be a value of @ref RTC_EC_WEEKDAY
N                                        This feature can be modified afterwards using unitary function @ref MS32_RTC_TS_GetWeekDay(). */
N  uint8_t Month;                   /*!< Specifies the RTC time stamp Month.
N                                        This parameter can be a value of @ref RTC_EC_MONTH
N                                        This feature can be modified afterwards using unitary function @ref MS32_RTC_TS_GetMonth(). */
N  uint8_t Day;                     /*!< Specifies the RTC time stamp Day.
N                                        This parameter must be a number between Min_Data = 1 and Max_Data = 31
N                                        This feature can be modified afterwards using unitary function @ref MS32_RTC_TS_GetMonth(). */
N
N} MS32_RTC_TimStampTypeDef;
N
N/**
N  * @brief  RTC tamper structure definition
N  */
Ntypedef struct {
N  uint32_t Pullup;                 /*!< Specifies the RTC tamper pullup.
N                                        This parameter can be a value of @ref RTC_EC_TAMPER_PULLUP */
N  uint32_t Duration;               /*!< Specifies the RTC tamper duration.
N                                        This parameter can be a value of @ref RTC_EC_TAMPER_DURATION */
N  uint32_t Filter;                 /*!< Specifies the RTC tamper filter.
N                                        This parameter must be a value of @ref RTC_EC_TAMPER_FILTER . */
N  uint32_t Freq;                   /*!< Specifies the RTC tamper filter.
N                                        This parameter must be a value of @ref RTC_EC_TAMPER_SAMPLFREQDIV . */
N  uint32_t TampTs;                 /*!< Specifies the RTC tamper with timestamp.
N                                        This parameter must be a value of @ref RTC_EC_TAMPER_TS . */
N  uint32_t Tamp1En;                /*!< Specifies the RTC tamper1 ennable.
N                                        This parameter must be a value of @ref RTC_EC_TAMPER1 . */
N  uint32_t Tamp1Trg;                /*!< Specifies the RTC tamper1 trgger.
N                                        This parameter must be a value of @ref RTC_EC_TAMPER1_ACTIVELEVEL . */
N  uint32_t Tamp2En;                /*!< Specifies the RTC tamper2 ennable.
N                                        This parameter must be a value of @ref RTC_EC_TAMPER2 . */
N  uint32_t Tamp2Trg;                /*!< Specifies the RTC tamper2 trgger.
N                                        This parameter must be a value of @ref RTC_EC_TAMPER2_ACTIVELEVEL . */
N} MS32_RTC_TampTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RTC_CLKSOURCE  RTC clock source selection
N  * @{
N  */
N#define MS32_RTC_CLKSOURCE_NONE              0x00000000U       /*!< No clock used as RTC clock */
N#define MS32_RTC_CLKSOURCE_LSE               RCC_BDCR_RTCSEL_0 /*!< LSE oscillator clock used as RTC clock */
N#define MS32_RTC_CLKSOURCE_LSI               RCC_BDCR_RTCSEL_1 /*!< LSI oscillator clock used as RTC clock */
N#define MS32_RTC_CLKSOURCE_HSE_DIV32         RCC_BDCR_RTCSEL   /*!< HSE oscillator clock divided by 32 used as RTC clock */
N
N
N/** @defgroup RTC_Exported_Constants RTC Exported Constants
N  * @{
N  */
N#define MS32_RTC_FORMAT_BIN                  0x000000000U /*!< Binary data format */
N#define MS32_RTC_FORMAT_BCD                  0x000000001U /*!< BCD data format */
N
N
N/** @defgroup RTC_EC_ALARM_WEEKDAY_SELECTION RTC Alarm A Date WeekDay
N  * @{
N  */
N#define MS32_RTC_ALARM_DATEWEEKDAYSEL_DATE    0x00000000U             /*!< Alarm A Date is selected */
N#define MS32_RTC_ALARM_DATEWEEKDAYSEL_WEEKDAY RTC_ALRMAR_WDSEL        /*!< Alarm A WeekDay is selected */
N
N
N/** @defgroup RTC_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with MS32_RTC_ReadReg function
N  * @{
N  */
N#define MS32_RTC_ISR_RECALPF                 RTC_ISR_RECALPF
N#define MS32_RTC_ISR_TAMP2F                  RTC_ISR_TAMP2F
N#define MS32_RTC_ISR_TAMP1F                  RTC_ISR_TAMP1F
N#define MS32_RTC_ISR_TSOVF                   RTC_ISR_TSOVF
N#define MS32_RTC_ISR_TSF                     RTC_ISR_TSF
N#define MS32_RTC_ISR_ALRAF                   RTC_ISR_ALRAF
N#define MS32_RTC_ISR_INITF                   RTC_ISR_INITF
N#define MS32_RTC_ISR_RSF                     RTC_ISR_RSF
N#define MS32_RTC_ISR_INITS                   RTC_ISR_INITS
N#define MS32_RTC_ISR_SHPF                    RTC_ISR_SHPF
N#define MS32_RTC_ISR_ALRAWF                  RTC_ISR_ALRAWF
N
N#define MS32_RTC_ISR_ALLINTF                 (RTC_ISR_TAMP2F | RTC_ISR_TAMP1F | RTC_ISR_TSF | RTC_ISR_ALRAF)
N
N
N/** @defgroup RTC_EC_IT IT Defines
N  * @brief    IT defines which can be used with MS32_RTC_ReadReg and  MS32_RTC_WriteReg functions
N  * @{
N  */
N#define MS32_RTC_CR_TSIE                     RTC_CR_TSIE
N#define MS32_RTC_CR_WUTIE                    RTC_CR_WUTIE
N#define MS32_RTC_CR_ALRAIE                   RTC_CR_ALRAIE
N#define MS32_RTC_TAFCR_TAMPIE                RTC_TAFCR_TAMPIE
N
N
N/** @defgroup RTC_EC_WEEKDAY  WEEK DAY
N  * @{
N  */
N#define MS32_RTC_WEEKDAY_MONDAY              ((uint8_t)0x01U) /*!< Monday    */
N#define MS32_RTC_WEEKDAY_TUESDAY             ((uint8_t)0x02U) /*!< Tuesday   */
N#define MS32_RTC_WEEKDAY_WEDNESDAY           ((uint8_t)0x03U) /*!< Wednesday */
N#define MS32_RTC_WEEKDAY_THURSDAY            ((uint8_t)0x04U) /*!< Thrusday  */
N#define MS32_RTC_WEEKDAY_FRIDAY              ((uint8_t)0x05U) /*!< Friday    */
N#define MS32_RTC_WEEKDAY_SATURDAY            ((uint8_t)0x06U) /*!< Saturday  */
N#define MS32_RTC_WEEKDAY_SUNDAY              ((uint8_t)0x07U) /*!< Sunday    */
N
N
N/** @defgroup RTC_EC_MONTH  MONTH
N  * @{
N  */
N#define MS32_RTC_MONTH_JANUARY               ((uint8_t)0x01U)  /*!< January   */
N#define MS32_RTC_MONTH_FEBRUARY              ((uint8_t)0x02U)  /*!< February  */
N#define MS32_RTC_MONTH_MARCH                 ((uint8_t)0x03U)  /*!< March     */
N#define MS32_RTC_MONTH_APRIL                 ((uint8_t)0x04U)  /*!< April     */
N#define MS32_RTC_MONTH_MAY                   ((uint8_t)0x05U)  /*!< May       */
N#define MS32_RTC_MONTH_JUNE                  ((uint8_t)0x06U)  /*!< June      */
N#define MS32_RTC_MONTH_JULY                  ((uint8_t)0x07U)  /*!< July      */
N#define MS32_RTC_MONTH_AUGUST                ((uint8_t)0x08U)  /*!< August    */
N#define MS32_RTC_MONTH_SEPTEMBER             ((uint8_t)0x09U)  /*!< September */
N#define MS32_RTC_MONTH_OCTOBER               ((uint8_t)0x10U)  /*!< October   */
N#define MS32_RTC_MONTH_NOVEMBER              ((uint8_t)0x11U)  /*!< November  */
N#define MS32_RTC_MONTH_DECEMBER              ((uint8_t)0x12U)  /*!< December  */
N
N
N/** @defgroup RTC_EC_HOURFORMAT  HOUR FORMAT
N  * @{
N  */
N#define MS32_RTC_HOURFORMAT_24HOUR           0x00000000U           /*!< 24 hour/day format */
N#define MS32_RTC_HOURFORMAT_AMPM             RTC_CR_FMT            /*!< AM/PM hour format */
N
N
N/** @defgroup RTC_EC_ALARMOUT  ALARM OUTPUT
N  * @{
N  */
N#define MS32_RTC_ALARMOUT_DISABLE            0x00000000U             /*!< Output disabled */
N#define MS32_RTC_ALARMOUT_ALMA               RTC_CR_OSEL_0           /*!< Alarm A output enabled */
N
N
N/** @defgroup RTC_EC_ALARM_OUTPUTTYPE  ALARM OUTPUT TYPE
N  * @{
N  */
N#define MS32_RTC_ALARM_OUTPUTTYPE_OPENDRAIN  0x00000000U           /*!< RTC_ALARM, when mapped on PC13, is open-drain output */
N#define MS32_RTC_ALARM_OUTPUTTYPE_PUSHPULL   RTC_TAFCR_PC13VALUE   /*!< RTC_ALARM, when mapped on PC13, is push-pull output */
N
N
N/** @defgroup RTC_EC_PIN PIN
N  * @{
N  */
N#define MS32_RTC_PIN_PC13                    RTC_TAFCR_PC13MODE    /*!< PC13 is forced to push-pull output if all RTC alternate functions are disabled */
N#define MS32_RTC_PIN_PC14                    RTC_TAFCR_PC14MODE    /*!< PC14 is forced to push-pull output if LSE is disabled */
N#define MS32_RTC_PIN_PC15                    RTC_TAFCR_PC15MODE    /*!< PC15 is forced to push-pull output if LSE is disabled */
N
N
N/** @defgroup RTC_EC_PIN PIN
N  * @{
N  */
N#define MS32_RTC_PIN_LOW                     (0x00000000U)
N#define MS32_RTC_PIN_HIGH                    (0x00000001U)
N
N
N/** @defgroup RTC_EC_OUTPUTPOLARITY_PIN  OUTPUT POLARITY PIN
N  * @{
N  */
N#define MS32_RTC_OUTPUTPOLARITY_PIN_HIGH     0x00000000U           /*!< Pin is high when ALRAF/ALRBF/WUTF is asserted (depending on OSEL)*/
N#define MS32_RTC_OUTPUTPOLARITY_PIN_LOW      RTC_CR_POL            /*!< Pin is low when ALRAF/ALRBF/WUTF is asserted (depending on OSEL) */
N
N
N/** @defgroup RTC_EC_TIME_FORMAT TIME FORMAT
N  * @{
N  */
N#define MS32_RTC_TIME_FORMAT_AM_OR_24        0x00000000U           /*!< AM or 24-hour format */
N#define MS32_RTC_TIME_FORMAT_PM              RTC_TR_PM             /*!< PM */
N
N
N/** @defgroup RTC_EC_ADD_SUB_ONE_HOUR  add/sub one hour
N  * @{
N  */
N#define MS32_RTC_ADD_ONE_HOUR                RTC_CR_ADD1H          /* Add one hour */
N#define MS32_RTC_SUB_ONE_HOUR                RTC_CR_SUB1H          /* Sub one hour */
N
N
N/** @defgroup RTC_EC_SHIFT_SECOND  SHIFT SECOND
N  * @{
N  */
N#define MS32_RTC_SHIFT_SECOND_DELAY          0x00000000U           /* Delay (seconds) = SUBFS / (PREDIV_S + 1) */
N#define MS32_RTC_SHIFT_SECOND_ADVANCE        RTC_SHIFTR_ADD1S      /* Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))) */
N
N
N/** @defgroup RTC_EC_ALARM_MASK  ALARMA MASK
N  * @{
N  */
N#define MS32_RTC_ALARM_MASK_NONE              0x00000000U             /*!< No masks applied on Alarm A*/
N#define MS32_RTC_ALARM_MASK_DATEWEEKDAY       RTC_ALRMAR_MSK4         /*!< Date/day do not care in Alarm A comparison */
N#define MS32_RTC_ALARM_MASK_HOURS             RTC_ALRMAR_MSK3         /*!< Hours do not care in Alarm A comparison */
N#define MS32_RTC_ALARM_MASK_MINUTES           RTC_ALRMAR_MSK2         /*!< Minutes do not care in Alarm A comparison */
N#define MS32_RTC_ALARM_MASK_SECONDS           RTC_ALRMAR_MSK1         /*!< Seconds do not care in Alarm A comparison */
N#define MS32_RTC_ALARM_MASK_ALL               (RTC_ALRMAR_MSK4 | RTC_ALRMAR_MSK3 | RTC_ALRMAR_MSK2 | RTC_ALRMAR_MSK1) /*!< Masks all */
N
N
N/** @defgroup RTC_EC_ALARM_TIME_FORMAT  ALARMA TIME FORMAT
N  * @{
N  */
N#define MS32_RTC_ALARM_TIME_FORMAT_AM         0x00000000U           /*!< AM or 24-hour format */
N#define MS32_RTC_ALARM_TIME_FORMAT_PM         RTC_ALRMAR_PM         /*!< PM */
N
N
N/** @defgroup RTC_EC_TIMESTAMP_EDGE  TIMESTAMP EDGE
N  * @{
N  */
N#define MS32_RTC_TIMESTAMP_EDGE_RISING       0x00000000U           /*!< RTC_TS input rising edge generates a time-stamp event */
N#define MS32_RTC_TIMESTAMP_EDGE_FALLING      RTC_CR_TSEDGE         /*!< RTC_TS input falling edge generates a time-stamp even */
N
N
N/** @defgroup RTC_EC_TS_TIME_FORMAT  TIMESTAMP TIME FORMAT
N  * @{
N  */
N#define MS32_RTC_TS_TIME_FORMAT_AM           0x00000000U           /*!< AM or 24-hour format */
N#define MS32_RTC_TS_TIME_FORMAT_PM           RTC_TSTR_PM           /*!< PM */
N
N
N/** @defgroup RTC_EC_TAMPER_PULLUP  TAMPER PULLUP
N  * @{
N  */
N#define MS32_RTC_TAMPER_PULLUP_ENABLE        0x00000000U
N#define MS32_RTC_TAMPER_PULLUP_DISABLE       RTC_TAFCR_TAMPPUDIS
N
N
N/** @defgroup RTC_EC_TAMPER_DURATION  TAMPER DURATION
N  * @{
N  */
N#define MS32_RTC_TAMPER_DURATION_1RTCCLK     0x00000000U           /*!< Tamper pins are pre-charged before sampling during 1 RTCCLK cycle  */
N#define MS32_RTC_TAMPER_DURATION_2RTCCLK     RTC_TAFCR_TAMPPRCH_0  /*!< Tamper pins are pre-charged before sampling during 2 RTCCLK cycles */
N#define MS32_RTC_TAMPER_DURATION_4RTCCLK     RTC_TAFCR_TAMPPRCH_1  /*!< Tamper pins are pre-charged before sampling during 4 RTCCLK cycles */
N#define MS32_RTC_TAMPER_DURATION_8RTCCLK     RTC_TAFCR_TAMPPRCH    /*!< Tamper pins are pre-charged before sampling during 8 RTCCLK cycles */
N
N
N/** @defgroup RTC_EC_TAMPER_FILTER  TAMPER FILTER
N  * @{
N  */
N#define MS32_RTC_TAMPER_FILTER_DISABLE       0x00000000U            /*!< Tamper filter is disabled */
N#define MS32_RTC_TAMPER_FILTER_2SAMPLE       RTC_TAFCR_TAMPFLT_0    /*!< Tamper is activated after 2 consecutive samples at the active level */
N#define MS32_RTC_TAMPER_FILTER_4SAMPLE       RTC_TAFCR_TAMPFLT_1    /*!< Tamper is activated after 4 consecutive samples at the active level */
N#define MS32_RTC_TAMPER_FILTER_8SAMPLE       RTC_TAFCR_TAMPFLT      /*!< Tamper is activated after 8 consecutive samples at the active level. */
N
N
N/** @defgroup RTC_EC_TAMPER_SAMPLFREQDIV  TAMPER SAMPLING FREQUENCY DIVIDER
N  * @{
N  */
N#define MS32_RTC_TAMPER_SAMPLFREQDIV_32768   0x00000000U                                    /*!< Each of the tamper inputs are sampled with a frequency =  RTCCLK / 32768 */
N#define MS32_RTC_TAMPER_SAMPLFREQDIV_16384   RTC_TAFCR_TAMPFREQ_0                           /*!< Each of the tamper inputs are sampled with a frequency =  RTCCLK / 16384 */
N#define MS32_RTC_TAMPER_SAMPLFREQDIV_8192    RTC_TAFCR_TAMPFREQ_1                           /*!< Each of the tamper inputs are sampled with a frequency =  RTCCLK / 8192 */
N#define MS32_RTC_TAMPER_SAMPLFREQDIV_4096    (RTC_TAFCR_TAMPFREQ_1 | RTC_TAFCR_TAMPFREQ_0) /*!< Each of the tamper inputs are sampled with a frequency =  RTCCLK / 4096 */
N#define MS32_RTC_TAMPER_SAMPLFREQDIV_2048    RTC_TAFCR_TAMPFREQ_2                           /*!< Each of the tamper inputs are sampled with a frequency =  RTCCLK / 2048 */
N#define MS32_RTC_TAMPER_SAMPLFREQDIV_1024    (RTC_TAFCR_TAMPFREQ_2 | RTC_TAFCR_TAMPFREQ_0) /*!< Each of the tamper inputs are sampled with a frequency =  RTCCLK / 1024 */
N#define MS32_RTC_TAMPER_SAMPLFREQDIV_512     (RTC_TAFCR_TAMPFREQ_2 | RTC_TAFCR_TAMPFREQ_1) /*!< Each of the tamper inputs are sampled with a frequency =  RTCCLK / 512 */
N#define MS32_RTC_TAMPER_SAMPLFREQDIV_256     RTC_TAFCR_TAMPFREQ                             /*!< Each of the tamper inputs are sampled with a frequency =  RTCCLK / 256 */
N
N
N/** @defgroup RTC_EC_TAMPER_TS  TAMPER TS
N  * @{
N  */
N#define MS32_RTC_TAMPER_TS_DISABLE           0x00000000U
N#define MS32_RTC_TAMPER_TS_ENABLE            RTC_TAFCR_TAMPTS
N
N
N/** @defgroup RTC_EC_TAMPER1_ACTIVELEVEL  TAMPER1 ACTIVE LEVEL
N  * @{
N  */
N#define MS32_RTC_TAMPER_INACTIVELEVEL_TAMP1  0x00000000U        /*!< RTC_TAMP1 input rising edge (if TAMPFLT = 00) or staying low (if TAMPFLT != 00) triggers a tamper detection event*/
N#define MS32_RTC_TAMPER_ACTIVELEVEL_TAMP1    RTC_TAFCR_TAMP1TRG /*!< RTC_TAMP1 input falling edge (if TAMPFLT = 00) or staying high (if TAMPFLT != 00) triggers a tamper detection event*/
N
N
N/** @defgroup RTC_EC_TAMPER2_ACTIVELEVEL  TAMPER2 ACTIVE LEVEL
N  * @{
N  */
N#define MS32_RTC_TAMPER_INACTIVELEVEL_TAMP2  0x00000000U        /*!< RTC_TAMP2 input rising edge (if TAMPFLT = 00) or staying low (if TAMPFLT != 00) triggers a tamper detection event*/
N#define MS32_RTC_TAMPER_ACTIVELEVEL_TAMP2    RTC_TAFCR_TAMP2TRG /*!< RTC_TAMP2 input falling edge (if TAMPFLT = 00) or staying high (if TAMPFLT != 00) triggers a tamper detection event*/
N
N
N/** @defgroup RTC_EC_TAMPER1  TAMPER1
N  * @{
N  */
N#define MS32_RTC_TAMPER_1_DIS                0x00000000U
N#define MS32_RTC_TAMPER_1_EN                 RTC_TAFCR_TAMP1E /*!< RTC_TAMP1 input detection */
N
N
N/** @defgroup RTC_EC_TAMPER2  TAMPER2
N  * @{
N  */
N#define MS32_RTC_TAMPER_2_DIS                0x00000000U
N#define MS32_RTC_TAMPER_2_EN                 RTC_TAFCR_TAMP2E /*!< RTC_TAMP2 input detection */
N
N
N
N/** @defgroup RTC_EC_BKP  BACKUP
N  * @{
N  */
N#define MS32_RTC_BKP_DR0                     0x00000000U
N#define MS32_RTC_BKP_DR1                     0x00000001U
N#define MS32_RTC_BKP_DR2                     0x00000002U
N#define MS32_RTC_BKP_DR3                     0x00000003U
N#define MS32_RTC_BKP_DR4                     0x00000004U
N
N
N/** @defgroup RTC_EC_CALIB_OUTPUT  Calibration output
N  * @{
N  */
N#define MS32_RTC_CALIB_OUTPUT_NONE           0x00000000U                 /*!< Calibration output disabled */
N#define MS32_RTC_CALIB_OUTPUT_1HZ            (RTC_CR_COE | RTC_CR_COSEL) /*!< Calibration output is 1 Hz */
N#define MS32_RTC_CALIB_OUTPUT_512HZ          (RTC_CR_COE)                /*!< Calibration output is 512 Hz */
N
N
N/** @defgroup RTC_EC_CALIB_INSERTPULSE  Calibration pulse insertion
N  * @{
N  */
N#define MS32_RTC_CALIB_INSERTPULSE_NONE      0x00000000U           /*!< No RTCCLK pulses are added */
N#define MS32_RTC_CALIB_INSERTPULSE_SET       RTC_CALR_CALP         /*!< One RTCCLK pulse is effectively inserted every 2exp11 pulses (frequency increased by 488.5 ppm) */
N
N
N/** @defgroup RTC_EC_CALIB_PERIOD  Calibration period
N  * @{
N  */
N#define MS32_RTC_CALIB_PERIOD_32SEC          0x00000000U           /*!< Use a 32-second calibration cycle period */
N#define MS32_RTC_CALIB_PERIOD_16SEC          RTC_CALR_CALW16       /*!< Use a 16-second calibration cycle period */
N#define MS32_RTC_CALIB_PERIOD_8SEC           RTC_CALR_CALW8        /*!< Use a 8-second calibration cycle period */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup RTC_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in RTC register
N  * @param  __INSTANCE__ RTC Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_RTC_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in RTC register
N  * @param  __INSTANCE__ RTC Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_RTC_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N
N/** @defgroup RTC_EM_Convert Convert helper Macros
N  * @{
N  */
N
N/**
N  * @brief  Helper macro to convert a value from 2 digit decimal format to BCD format
N  * @param  __VALUE__ Byte to be converted
N  * @retval Converted byte
N  */
N#define __MS32_RTC_CONVERT_BIN2BCD(__VALUE__) (uint8_t)((((__VALUE__) / 10U) << 4U) | ((__VALUE__) % 10U))
N
N/**
N  * @brief  Helper macro to convert a value from BCD format to 2 digit decimal format
N  * @param  __VALUE__ BCD value to be converted
N  * @retval Converted byte
N  */
N#define __MS32_RTC_CONVERT_BCD2BIN(__VALUE__) (uint8_t)(((uint8_t)((__VALUE__) & (uint8_t)0xF0U) >> (uint8_t)0x4U) * 10U + ((__VALUE__) & (uint8_t)0x0FU))
N
N
N/** @defgroup RTC_EM_Date Date helper Macros
N  * @{
N  */
N
N/**
N  * @brief  Helper macro to retrieve weekday.
N  * @param  __RTC_DATE__ Date returned by @ref  MS32_RTC_DATE_Get function.
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_WEEKDAY_MONDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_TUESDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_WEDNESDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_THURSDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_FRIDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_SATURDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_SUNDAY
N  */
N#define __MS32_RTC_GET_WEEKDAY(__RTC_DATE__) (((__RTC_DATE__) >> RTC_OFFSET_WEEKDAY) & 0x000000FFU)
N
N/**
N  * @brief  Helper macro to retrieve Year in BCD format
N  * @param  __RTC_DATE__ Value returned by @ref  MS32_RTC_DATE_Get
N  * @retval Year in BCD format (0x00 . . . 0x99)
N  */
N#define __MS32_RTC_GET_YEAR(__RTC_DATE__) ((__RTC_DATE__) & 0x000000FFU)
N
N/**
N  * @brief  Helper macro to retrieve Month in BCD format
N  * @param  __RTC_DATE__ Value returned by @ref  MS32_RTC_DATE_Get
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_MONTH_JANUARY
N  *         @arg @ref MS32_RTC_MONTH_FEBRUARY
N  *         @arg @ref MS32_RTC_MONTH_MARCH
N  *         @arg @ref MS32_RTC_MONTH_APRIL
N  *         @arg @ref MS32_RTC_MONTH_MAY
N  *         @arg @ref MS32_RTC_MONTH_JUNE
N  *         @arg @ref MS32_RTC_MONTH_JULY
N  *         @arg @ref MS32_RTC_MONTH_AUGUST
N  *         @arg @ref MS32_RTC_MONTH_SEPTEMBER
N  *         @arg @ref MS32_RTC_MONTH_OCTOBER
N  *         @arg @ref MS32_RTC_MONTH_NOVEMBER
N  *         @arg @ref MS32_RTC_MONTH_DECEMBER
N  */
N#define __MS32_RTC_GET_MONTH(__RTC_DATE__) (((__RTC_DATE__) >>RTC_OFFSET_MONTH) & 0x000000FFU)
N
N/**
N  * @brief  Helper macro to retrieve Day in BCD format
N  * @param  __RTC_DATE__ Value returned by @ref  MS32_RTC_DATE_Get
N  * @retval Day in BCD format (0x01 . . . 0x31)
N  */
N#define __MS32_RTC_GET_DAY(__RTC_DATE__) (((__RTC_DATE__) >>RTC_OFFSET_DAY) & 0x000000FFU)
N
N
N/** @defgroup RTC_EM_Time Time helper Macros
N  * @{
N  */
N
N/**
N  * @brief  Helper macro to retrieve hour in BCD format
N  * @param  __RTC_TIME__ RTC time returned by @ref MS32_RTC_TIME_Get function
N  * @retval Hours in BCD format (0x01. . .0x12 or between Min_Data=0x00 and Max_Data=0x23)
N  */
N#define __MS32_RTC_GET_HOUR(__RTC_TIME__) (((__RTC_TIME__) >> RTC_OFFSET_HOUR) & 0x000000FFU)
N
N/**
N  * @brief  Helper macro to retrieve minute in BCD format
N  * @param  __RTC_TIME__ RTC time returned by @ref MS32_RTC_TIME_Get function
N  * @retval Minutes in BCD format (0x00. . .0x59)
N  */
N#define __MS32_RTC_GET_MINUTE(__RTC_TIME__) (((__RTC_TIME__) >> RTC_OFFSET_MINUTE) & 0x000000FFU)
N
N/**
N  * @brief  Helper macro to retrieve second in BCD format
N  * @param  __RTC_TIME__ RTC time returned by @ref MS32_RTC_TIME_Get function
N  * @retval Seconds in  format (0x00. . .0x59)
N  */
N#define __MS32_RTC_GET_SECOND(__RTC_TIME__) ((__RTC_TIME__) & 0x000000FFU)
N
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup RTC_EF_Configuration Configuration
N  * @{
N  */
N
N/**
N  * @brief  Set Hours format (24 hour/day or AM/PM hour format)
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @note   It can be written in initialization mode only (@ref MS32_RTC_EnableInitMode function)
N  * @rmtoll CR           FMT           MS32_RTC_SetHourFormat
N  * @param  RTCx RTC Instance
N  * @param  HourFormat This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_HOURFORMAT_24HOUR
N  *         @arg @ref MS32_RTC_HOURFORMAT_AMPM
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_SetHourFormat(RTC_TypeDef *RTCx, uint32_t HourFormat) {
Xstatic __inline void MS32_RTC_SetHourFormat(RTC_TypeDef *RTCx, uint32_t HourFormat) {
N  MODIFY_REG(RTCx->CR, RTC_CR_FMT, HourFormat);
X  (((RTCx->CR)) = ((((((RTCx->CR))) & (~((0x1UL << (6U))))) | (HourFormat))));
N}
N
N/**
N  * @brief  Get Hours format (24 hour/day or AM/PM hour format)
N  * @rmtoll CR           FMT           MS32_RTC_GetHourFormat
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_HOURFORMAT_24HOUR
N  *         @arg @ref MS32_RTC_HOURFORMAT_AMPM
N  */
N__STATIC_INLINE uint32_t MS32_RTC_GetHourFormat(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_GetHourFormat(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->CR, RTC_CR_FMT));
X  return (uint32_t)(((RTCx->CR) & ((0x1UL << (6U)))));
N}
N
N/**
N  * @brief  Select the flag to be routed to RTC_ALARM output
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           OSEL          MS32_RTC_SetAlarmOutEvent
N  * @param  RTCx RTC Instance
N  * @param  AlarmOutput This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_ALARMOUT_DISABLE
N  *         @arg @ref MS32_RTC_ALARMOUT_ALMA
N  *         @arg @ref MS32_RTC_ALARMOUT_ALMB
N  *         @arg @ref MS32_RTC_ALARMOUT_WAKEUP
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_SetAlarmOutEvent(RTC_TypeDef *RTCx, uint32_t AlarmOutput) {
Xstatic __inline void MS32_RTC_SetAlarmOutEvent(RTC_TypeDef *RTCx, uint32_t AlarmOutput) {
N  MODIFY_REG(RTCx->CR, RTC_CR_OSEL, AlarmOutput);
X  (((RTCx->CR)) = ((((((RTCx->CR))) & (~((0x3UL << (21U))))) | (AlarmOutput))));
N}
N
N/**
N  * @brief  Get the flag to be routed to RTC_ALARM output
N  * @rmtoll CR           OSEL          MS32_RTC_GetAlarmOutEvent
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_ALARMOUT_DISABLE
N  *         @arg @ref MS32_RTC_ALARMOUT_ALMA
N  *         @arg @ref MS32_RTC_ALARMOUT_ALMB
N  *         @arg @ref MS32_RTC_ALARMOUT_WAKEUP
N  */
N__STATIC_INLINE uint32_t MS32_RTC_GetAlarmOutEvent(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_GetAlarmOutEvent(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->CR, RTC_CR_OSEL));
X  return (uint32_t)(((RTCx->CR) & ((0x3UL << (21U)))));
N}
N
N/**
N  * @brief  Set RTC_ALARM output type (ALARM in push-pull or open-drain output)
N  * @note   Used only when RTC_ALARM is mapped on PC13
N  * @note   If all RTC alternate functions are disabled and PC13MODE = 1, PC13VALUE configures the
N  *         PC13 output data
N  * @rmtoll TAFCR        ALARMOUTTYPE  MS32_RTC_SetAlarmOutputType
N  * @param  RTCx RTC Instance
N  * @param  Output This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_ALARM_OUTPUTTYPE_OPENDRAIN
N  *         @arg @ref MS32_RTC_ALARM_OUTPUTTYPE_PUSHPULL
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_SetAlarmOutputType(RTC_TypeDef *RTCx, uint32_t Output) {
Xstatic __inline void MS32_RTC_SetAlarmOutputType(RTC_TypeDef *RTCx, uint32_t Output) {
N  MODIFY_REG(RTCx->TAFCR, RTC_TAFCR_PC13VALUE  , Output);
X  (((RTCx->TAFCR)) = ((((((RTCx->TAFCR))) & (~((0x1UL << (18U))))) | (Output))));
N}
N
N/**
N  * @brief  Get RTC_ALARM output type (ALARM in push-pull or open-drain output)
N  * @note   used only when RTC_ALARM is mapped on PC13
N  * @note   If all RTC alternate functions are disabled and PC13MODE = 1, PC13VALUE configures the
N  *         PC13 output data
N  * @rmtoll TAFCR        ALARMOUTTYPE  MS32_RTC_GetAlarmOutputType
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_ALARM_OUTPUTTYPE_OPENDRAIN
N  *         @arg @ref MS32_RTC_ALARM_OUTPUTTYPE_PUSHPULL
N  */
N__STATIC_INLINE uint32_t MS32_RTC_GetAlarmOutputType(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_GetAlarmOutputType(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->TAFCR, RTC_TAFCR_PC13VALUE  ));
X  return (uint32_t)(((RTCx->TAFCR) & ((0x1UL << (18U)))));
N}
N
N/**
N  * @brief  Enable push-pull output on PC13, PC14 and/or PC15
N  * @note   PC13 forced to push-pull output if all RTC alternate functions are disabled
N  * @note   PC14 and PC15 forced to push-pull output if LSE is disabled
N  * @rmtoll TAFCR        PC13MODE  MS32_RTC_EnablePushPullMode\n
N  * @rmtoll TAFCR        PC14MODE  MS32_RTC_EnablePushPullMode\n
N  * @rmtoll TAFCR        PC15MODE  MS32_RTC_EnablePushPullMode
N  * @param  RTCx RTC Instance
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref MS32_RTC_PIN_PC13
N  *         @arg @ref MS32_RTC_PIN_PC14
N  *         @arg @ref MS32_RTC_PIN_PC15
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_EnablePushPullMode(RTC_TypeDef *RTCx, uint32_t PinMask) {
Xstatic __inline void MS32_RTC_EnablePushPullMode(RTC_TypeDef *RTCx, uint32_t PinMask) {
N  SET_BIT(RTCx->TAFCR, PinMask);
X  ((RTCx->TAFCR) |= (PinMask));
N}
N
N/**
N  * @brief  Disable push-pull output on PC13, PC14 and/or PC15
N  * @note   PC13, PC14 and/or PC15 are controlled by the GPIO configuration registers.
N  *         Consequently PC13, PC14 and/or PC15 are floating in Standby mode.
N  * @rmtoll TAFCR        PC13MODE      MS32_RTC_DisablePushPullMode\n
N  *         TAFCR        PC14MODE      MS32_RTC_DisablePushPullMode\n
N  *         TAFCR        PC15MODE      MS32_RTC_DisablePushPullMode
N  * @param  RTCx RTC Instance
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref MS32_RTC_PIN_PC13
N  *         @arg @ref MS32_RTC_PIN_PC14
N  *         @arg @ref MS32_RTC_PIN_PC15
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_DisablePushPullMode(RTC_TypeDef *RTCx, uint32_t PinMask) {
Xstatic __inline void MS32_RTC_DisablePushPullMode(RTC_TypeDef *RTCx, uint32_t PinMask) {
N  CLEAR_BIT(RTCx->TAFCR, PinMask);
X  ((RTCx->TAFCR) &= ~(PinMask));
N}
N
N/**
N  * @brief  Set PC14 and/or PC15 to high level.
N  * @note   Output data configuration is possible if the LSE is disabled and PushPull output is enabled (through @ref MS32_RTC_EnablePushPullMode)
N  * @rmtoll TAFCR        PC14VALUE     MS32_RTC_SetOutputPin\n
N  *         TAFCR        PC15VALUE     MS32_RTC_SetOutputPin
N  * @param  RTCx RTC Instance
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref MS32_RTC_PIN_PC14
N  *         @arg @ref MS32_RTC_PIN_PC15
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_SetOutputPin(RTC_TypeDef *RTCx, uint32_t PinMask) {
Xstatic __inline void MS32_RTC_SetOutputPin(RTC_TypeDef *RTCx, uint32_t PinMask) {
N  SET_BIT(RTCx->TAFCR, (PinMask >> 1));
X  ((RTCx->TAFCR) |= ((PinMask >> 1)));
N}
N
N/**
N  * @brief  Set PC14 and/or PC15 to low level.
N  * @note   Output data configuration is possible if the LSE is disabled and PushPull output is enabled (through @ref MS32_RTC_EnablePushPullMode)
N  * @rmtoll TAFCR        PC14VALUE     MS32_RTC_ResetOutputPin\n
N  *         TAFCR        PC15VALUE     MS32_RTC_ResetOutputPin
N  * @param  RTCx RTC Instance
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref MS32_RTC_PIN_PC14
N  *         @arg @ref MS32_RTC_PIN_PC15
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ResetOutputPin(RTC_TypeDef *RTCx, uint32_t PinMask) {
Xstatic __inline void MS32_RTC_ResetOutputPin(RTC_TypeDef *RTCx, uint32_t PinMask) {
N  CLEAR_BIT(RTCx->TAFCR, (PinMask >> 1));
X  ((RTCx->TAFCR) &= ~((PinMask >> 1)));
N}
N
N/**
N  * @brief  Enable initialization mode
N  * @note   Initialization mode is used to program time and date register (RTC_TR and RTC_DR)
N  *         and prescaler register (RTC_PRER).
N  *         Counters are stopped and start counting from the new value when INIT is reset.
N  * @rmtoll ISR          INIT          MS32_RTC_EnableInitMode
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_EnableInitMode(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_EnableInitMode(RTC_TypeDef *RTCx) {
N  /* Set the Initialization mode */
N  WRITE_REG(RTCx->ISR, RTC_INIT_MASK);
X  ((RTCx->ISR) = (0xFFFFFFFFU));
N}
N
N/**
N  * @brief  Disable initialization mode (Free running mode)
N  * @rmtoll ISR          INIT          MS32_RTC_DisableInitMode
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_DisableInitMode(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_DisableInitMode(RTC_TypeDef *RTCx) {
N  /* Exit Initialization mode */
N  WRITE_REG(RTCx->ISR, (uint32_t)~RTC_ISR_INIT);
X  ((RTCx->ISR) = ((uint32_t)~(0x1UL << (7U))));
N}
N
N/**
N  * @brief  Set Output polarity (pin is low when ALRAF/ALRBF/WUTF is asserted)
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           POL           MS32_RTC_SetOutputPolarity
N  * @param  RTCx RTC Instance
N  * @param  Polarity This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_OUTPUTPOLARITY_PIN_HIGH
N  *         @arg @ref MS32_RTC_OUTPUTPOLARITY_PIN_LOW
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_SetOutputPolarity(RTC_TypeDef *RTCx, uint32_t Polarity) {
Xstatic __inline void MS32_RTC_SetOutputPolarity(RTC_TypeDef *RTCx, uint32_t Polarity) {
N  MODIFY_REG(RTCx->CR, RTC_CR_POL, Polarity);
X  (((RTCx->CR)) = ((((((RTCx->CR))) & (~((0x1UL << (20U))))) | (Polarity))));
N}
N
N/**
N  * @brief  Get Output polarity
N  * @rmtoll CR           POL           MS32_RTC_GetOutputPolarity
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_OUTPUTPOLARITY_PIN_HIGH
N  *         @arg @ref MS32_RTC_OUTPUTPOLARITY_PIN_LOW
N  */
N__STATIC_INLINE uint32_t MS32_RTC_GetOutputPolarity(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_GetOutputPolarity(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->CR, RTC_CR_POL));
X  return (uint32_t)(((RTCx->CR) & ((0x1UL << (20U)))));
N}
N
N/**
N  * @brief  Enable Bypass the shadow registers
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           BYPSHAD       MS32_RTC_EnableShadowRegBypass
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_EnableShadowRegBypass(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_EnableShadowRegBypass(RTC_TypeDef *RTCx) {
N  SET_BIT(RTCx->CR, RTC_CR_BYPSHAD);
X  ((RTCx->CR) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Disable Bypass the shadow registers
N  * @rmtoll CR           BYPSHAD       MS32_RTC_DisableShadowRegBypass
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_DisableShadowRegBypass(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_DisableShadowRegBypass(RTC_TypeDef *RTCx) {
N  CLEAR_BIT(RTCx->CR, RTC_CR_BYPSHAD);
X  ((RTCx->CR) &= ~((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Check if Shadow registers bypass is enabled or not.
N  * @rmtoll CR           BYPSHAD       MS32_RTC_IsShadowRegBypassEnabled
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_IsShadowRegBypassEnabled(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_IsShadowRegBypassEnabled(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->CR, RTC_CR_BYPSHAD) == (RTC_CR_BYPSHAD));
X  return (((RTCx->CR) & ((0x1UL << (5U)))) == ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Enable RTC_REFIN reference clock detection (50 or 60 Hz)
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @note   It can be written in initialization mode only (@ref MS32_RTC_EnableInitMode function)
N  * @rmtoll CR           REFCKON       MS32_RTC_EnableRefClock
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_EnableRefClock(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_EnableRefClock(RTC_TypeDef *RTCx) {
N  SET_BIT(RTCx->CR, RTC_CR_REFCKON);
X  ((RTCx->CR) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Disable RTC_REFIN reference clock detection (50 or 60 Hz)
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @note   It can be written in initialization mode only (@ref MS32_RTC_EnableInitMode function)
N  * @rmtoll CR           REFCKON       MS32_RTC_DisableRefClock
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_DisableRefClock(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_DisableRefClock(RTC_TypeDef *RTCx) {
N  CLEAR_BIT(RTCx->CR, RTC_CR_REFCKON);
X  ((RTCx->CR) &= ~((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Set Asynchronous prescaler factor
N  * @rmtoll PRER         PREDIV_A      MS32_RTC_SetAsynchPrescaler
N  * @param  RTCx RTC Instance
N  * @param  AsynchPrescaler Value between Min_Data = 0 and Max_Data = 0x7F
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_SetAsynchPrescaler(RTC_TypeDef *RTCx, uint32_t AsynchPrescaler) {
Xstatic __inline void MS32_RTC_SetAsynchPrescaler(RTC_TypeDef *RTCx, uint32_t AsynchPrescaler) {
N  MODIFY_REG(RTCx->PRER, RTC_PRER_PREDIV_A, AsynchPrescaler << RTC_PRER_PREDIV_A_Pos);
X  (((RTCx->PRER)) = ((((((RTCx->PRER))) & (~((0x7FUL << (16U))))) | (AsynchPrescaler << (16U)))));
N}
N
N/**
N  * @brief  Set Synchronous prescaler factor
N  * @rmtoll PRER         PREDIV_S      MS32_RTC_SetSynchPrescaler
N  * @param  RTCx RTC Instance
N  * @param  SynchPrescaler Value between Min_Data = 0 and Max_Data = 0x7FFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_SetSynchPrescaler(RTC_TypeDef *RTCx, uint32_t SynchPrescaler) {
Xstatic __inline void MS32_RTC_SetSynchPrescaler(RTC_TypeDef *RTCx, uint32_t SynchPrescaler) {
N  MODIFY_REG(RTCx->PRER, RTC_PRER_PREDIV_S, SynchPrescaler);
X  (((RTCx->PRER)) = ((((((RTCx->PRER))) & (~((0x7FFFUL << (0U))))) | (SynchPrescaler))));
N}
N
N/**
N  * @brief  Get Asynchronous prescaler factor
N  * @rmtoll PRER         PREDIV_A      MS32_RTC_GetAsynchPrescaler
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data = 0 and Max_Data = 0x7F
N  */
N__STATIC_INLINE uint32_t MS32_RTC_GetAsynchPrescaler(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_GetAsynchPrescaler(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->PRER, RTC_PRER_PREDIV_A) >> RTC_PRER_PREDIV_A_Pos);
X  return (uint32_t)(((RTCx->PRER) & ((0x7FUL << (16U)))) >> (16U));
N}
N
N/**
N  * @brief  Get Synchronous prescaler factor
N  * @rmtoll PRER         PREDIV_S      MS32_RTC_GetSynchPrescaler
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data = 0 and Max_Data = 0x7FFF
N  */
N__STATIC_INLINE uint32_t MS32_RTC_GetSynchPrescaler(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_GetSynchPrescaler(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->PRER, RTC_PRER_PREDIV_S));
X  return (uint32_t)(((RTCx->PRER) & ((0x7FFFUL << (0U)))));
N}
N
N/**
N  * @brief  Enable the write protection for RTC registers.
N  * @rmtoll WPR          KEY           MS32_RTC_EnableWriteProtection
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_EnableWriteProtection(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_EnableWriteProtection(RTC_TypeDef *RTCx) {
N  WRITE_REG(RTCx->WPR, RTC_WRITE_PROTECTION_DISABLE);
X  ((RTCx->WPR) = (((uint8_t)0xFFU)));
N}
N
N/**
N  * @brief  Disable the write protection for RTC registers.
N  * @rmtoll WPR          KEY           MS32_RTC_DisableWriteProtection
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_DisableWriteProtection(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_DisableWriteProtection(RTC_TypeDef *RTCx) {
N  WRITE_REG(RTCx->WPR, RTC_WRITE_PROTECTION_ENABLE_1);
X  ((RTCx->WPR) = (((uint8_t)0xCAU)));
N  WRITE_REG(RTCx->WPR, RTC_WRITE_PROTECTION_ENABLE_2);
X  ((RTCx->WPR) = (((uint8_t)0x53U)));
N}
N
N
N/** @defgroup RTC_EF_Time Time
N  * @{
N  */
N
N/**
N  * @brief  Set time format (AM/24-hour or PM notation)
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @note   It can be written in initialization mode only (@ref MS32_RTC_EnableInitMode function)
N  * @rmtoll TR           PM            MS32_RTC_TIME_SetFormat
N  * @param  RTCx RTC Instance
N  * @param  TimeFormat This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_TIME_FORMAT_AM_OR_24
N  *         @arg @ref MS32_RTC_TIME_FORMAT_PM
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TIME_SetFormat(RTC_TypeDef *RTCx, uint32_t TimeFormat) {
Xstatic __inline void MS32_RTC_TIME_SetFormat(RTC_TypeDef *RTCx, uint32_t TimeFormat) {
N  MODIFY_REG(RTCx->TR, RTC_TR_PM, TimeFormat);
X  (((RTCx->TR)) = ((((((RTCx->TR))) & (~((0x1UL << (22U))))) | (TimeFormat))));
N}
N
N/**
N  * @brief  Get time format (AM or PM notation)
N  * @note if shadow mode is disabled (BYPSHAD=0), need to check if RSF flag is set
N  *       before reading this bit
N  * @note Read either RTC_SSR or RTC_TR locks the values in the higher-order calendar
N  *       shadow registers until RTC_DR is read (MS32_RTC_ReadReg(RTC, DR)).
N  * @rmtoll TR           PM            MS32_RTC_TIME_GetFormat
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_TIME_FORMAT_AM_OR_24
N  *         @arg @ref MS32_RTC_TIME_FORMAT_PM
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TIME_GetFormat(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TIME_GetFormat(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->TR, RTC_TR_PM));
X  return (uint32_t)(((RTCx->TR) & ((0x1UL << (22U)))));
N}
N
N/**
N  * @brief  Set Hours in BCD format
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @note   It can be written in initialization mode only (@ref MS32_RTC_EnableInitMode function)
N  * @note helper macro __MS32_RTC_CONVERT_BIN2BCD is available to convert hour from binary to BCD format
N  * @rmtoll TR           HT            MS32_RTC_TIME_SetHour\n
N  *         TR           HU            MS32_RTC_TIME_SetHour
N  * @param  RTCx RTC Instance
N  * @param  Hours Value between Min_Data=0x01 and Max_Data=0x12 or between Min_Data=0x00 and Max_Data=0x23
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TIME_SetHour(RTC_TypeDef *RTCx, uint32_t Hours) {
Xstatic __inline void MS32_RTC_TIME_SetHour(RTC_TypeDef *RTCx, uint32_t Hours) {
N  MODIFY_REG(RTCx->TR, (RTC_TR_HT | RTC_TR_HU),
N             (((Hours & 0xF0U) << (RTC_TR_HT_Pos - 4U)) | ((Hours & 0x0FU) << RTC_TR_HU_Pos)));
X  (((RTCx->TR)) = ((((((RTCx->TR))) & (~(((0x3UL << (20U)) | (0xFUL << (16U)))))) | ((((Hours & 0xF0U) << ((20U) - 4U)) | ((Hours & 0x0FU) << (16U)))))));
N}
N
N/**
N  * @brief  Get Hours in BCD format
N  * @note if shadow mode is disabled (BYPSHAD=0), need to check if RSF flag is set
N  *       before reading this bit
N  * @note Read either RTC_SSR or RTC_TR locks the values in the higher-order calendar
N  *       shadow registers until RTC_DR is read (MS32_RTC_ReadReg(RTC, DR)).
N  * @note helper macro __MS32_RTC_CONVERT_BCD2BIN is available to convert hour from BCD to
N  *       Binary format
N  * @rmtoll TR           HT            MS32_RTC_TIME_GetHour\n
N  *         TR           HU            MS32_RTC_TIME_GetHour
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x01 and Max_Data=0x12 or between Min_Data=0x00 and Max_Data=0x23
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TIME_GetHour(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TIME_GetHour(RTC_TypeDef *RTCx) {
N  return (uint32_t)((READ_BIT(RTCx->TR, (RTC_TR_HT | RTC_TR_HU))) >> RTC_TR_HU_Pos);
X  return (uint32_t)((((RTCx->TR) & (((0x3UL << (20U)) | (0xFUL << (16U)))))) >> (16U));
N}
N
N/**
N  * @brief  Set Minutes in BCD format
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @note   It can be written in initialization mode only (@ref MS32_RTC_EnableInitMode function)
N  * @note helper macro __MS32_RTC_CONVERT_BIN2BCD is available to convert Minutes from binary to BCD format
N  * @rmtoll TR           MNT           MS32_RTC_TIME_SetMinute\n
N  *         TR           MNU           MS32_RTC_TIME_SetMinute
N  * @param  RTCx RTC Instance
N  * @param  Minutes Value between Min_Data=0x00 and Max_Data=0x59
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TIME_SetMinute(RTC_TypeDef *RTCx, uint32_t Minutes) {
Xstatic __inline void MS32_RTC_TIME_SetMinute(RTC_TypeDef *RTCx, uint32_t Minutes) {
N  MODIFY_REG(RTCx->TR, (RTC_TR_MNT | RTC_TR_MNU),
N             (((Minutes & 0xF0U) << (RTC_TR_MNT_Pos - 4U)) | ((Minutes & 0x0FU) << RTC_TR_MNU_Pos)));
X  (((RTCx->TR)) = ((((((RTCx->TR))) & (~(((0x7UL << (12U)) | (0xFUL << (8U)))))) | ((((Minutes & 0xF0U) << ((12U) - 4U)) | ((Minutes & 0x0FU) << (8U)))))));
N}
N
N/**
N  * @brief  Get Minutes in BCD format
N  * @note if shadow mode is disabled (BYPSHAD=0), need to check if RSF flag is set
N  *       before reading this bit
N  * @note Read either RTC_SSR or RTC_TR locks the values in the higher-order calendar
N  *       shadow registers until RTC_DR is read (MS32_RTC_ReadReg(RTC, DR)).
N  * @note helper macro __MS32_RTC_CONVERT_BCD2BIN is available to convert minute from BCD
N  *       to Binary format
N  * @rmtoll TR           MNT           MS32_RTC_TIME_GetMinute\n
N  *         TR           MNU           MS32_RTC_TIME_GetMinute
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0x59
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TIME_GetMinute(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TIME_GetMinute(RTC_TypeDef *RTCx) {
N  return (uint32_t)((READ_BIT(RTCx->TR, (RTC_TR_MNT | RTC_TR_MNU))) >> RTC_TR_MNU_Pos);
X  return (uint32_t)((((RTCx->TR) & (((0x7UL << (12U)) | (0xFUL << (8U)))))) >> (8U));
N}
N
N/**
N  * @brief  Set Seconds in BCD format
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @note   It can be written in initialization mode only (@ref MS32_RTC_EnableInitMode function)
N  * @note helper macro __MS32_RTC_CONVERT_BIN2BCD is available to convert Seconds from binary to BCD format
N  * @rmtoll TR           ST            MS32_RTC_TIME_SetSecond\n
N  *         TR           SU            MS32_RTC_TIME_SetSecond
N  * @param  RTCx RTC Instance
N  * @param  Seconds Value between Min_Data=0x00 and Max_Data=0x59
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TIME_SetSecond(RTC_TypeDef *RTCx, uint32_t Seconds) {
Xstatic __inline void MS32_RTC_TIME_SetSecond(RTC_TypeDef *RTCx, uint32_t Seconds) {
N  MODIFY_REG(RTCx->TR, (RTC_TR_ST | RTC_TR_SU),
N             (((Seconds & 0xF0U) << (RTC_TR_ST_Pos - 4U)) | ((Seconds & 0x0FU) << RTC_TR_SU_Pos)));
X  (((RTCx->TR)) = ((((((RTCx->TR))) & (~(((0x7UL << (4U)) | (0xFUL << (0U)))))) | ((((Seconds & 0xF0U) << ((4U) - 4U)) | ((Seconds & 0x0FU) << (0U)))))));
N}
N
N/**
N  * @brief  Get Seconds in BCD format
N  * @note if shadow mode is disabled (BYPSHAD=0), need to check if RSF flag is set
N  *       before reading this bit
N  * @note Read either RTC_SSR or RTC_TR locks the values in the higher-order calendar
N  *       shadow registers until RTC_DR is read (MS32_RTC_ReadReg(RTC, DR)).
N  * @note helper macro __MS32_RTC_CONVERT_BCD2BIN is available to convert Seconds from BCD
N  *       to Binary format
N  * @rmtoll TR           ST            MS32_RTC_TIME_GetSecond\n
N  *         TR           SU            MS32_RTC_TIME_GetSecond
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0x59
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TIME_GetSecond(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TIME_GetSecond(RTC_TypeDef *RTCx) {
N  return (uint32_t)((READ_BIT(RTCx->TR, (RTC_TR_ST | RTC_TR_SU))) >> RTC_TR_SU_Pos);
X  return (uint32_t)((((RTCx->TR) & (((0x7UL << (4U)) | (0xFUL << (0U)))))) >> (0U));
N}
N
N/**
N  * @brief  Set time (hour, minute and second) in BCD format
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @note   It can be written in initialization mode only (@ref MS32_RTC_EnableInitMode function)
N  * @note TimeFormat and Hours should follow the same format
N  * @rmtoll TR           PM            MS32_RTC_TIME_Config\n
N  *         TR           HT            MS32_RTC_TIME_Config\n
N  *         TR           HU            MS32_RTC_TIME_Config\n
N  *         TR           MNT           MS32_RTC_TIME_Config\n
N  *         TR           MNU           MS32_RTC_TIME_Config\n
N  *         TR           ST            MS32_RTC_TIME_Config\n
N  *         TR           SU            MS32_RTC_TIME_Config
N  * @param  RTCx RTC Instance
N  * @param  Format12_24 This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_TIME_FORMAT_AM_OR_24
N  *         @arg @ref MS32_RTC_TIME_FORMAT_PM
N  * @param  Hours Value between Min_Data=0x01 and Max_Data=0x12 or between Min_Data=0x00 and Max_Data=0x23
N  * @param  Minutes Value between Min_Data=0x00 and Max_Data=0x59
N  * @param  Seconds Value between Min_Data=0x00 and Max_Data=0x59
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TIME_Config(RTC_TypeDef *RTCx, uint32_t Format12_24, uint32_t Hours, uint32_t Minutes, uint32_t Seconds) {
Xstatic __inline void MS32_RTC_TIME_Config(RTC_TypeDef *RTCx, uint32_t Format12_24, uint32_t Hours, uint32_t Minutes, uint32_t Seconds) {
N  register uint32_t temp = 0U;
N
N  temp = Format12_24                                                                                    | \
N         (((Hours & 0xF0U) << (RTC_TR_HT_Pos - 4U)) | ((Hours & 0x0FU) << RTC_TR_HU_Pos))     | \
N         (((Minutes & 0xF0U) << (RTC_TR_MNT_Pos - 4U)) | ((Minutes & 0x0FU) << RTC_TR_MNU_Pos)) | \
N         (((Seconds & 0xF0U) << (RTC_TR_ST_Pos - 4U)) | ((Seconds & 0x0FU) << RTC_TR_SU_Pos));
X  temp = Format12_24                                                                                    |          (((Hours & 0xF0U) << ((20U) - 4U)) | ((Hours & 0x0FU) << (16U)))     |          (((Minutes & 0xF0U) << ((12U) - 4U)) | ((Minutes & 0x0FU) << (8U))) |          (((Seconds & 0xF0U) << ((4U) - 4U)) | ((Seconds & 0x0FU) << (0U)));
N  MODIFY_REG(RTCx->TR, (RTC_TR_PM | RTC_TR_HT | RTC_TR_HU | RTC_TR_MNT | RTC_TR_MNU | RTC_TR_ST | RTC_TR_SU), temp);
X  (((RTCx->TR)) = ((((((RTCx->TR))) & (~(((0x1UL << (22U)) | (0x3UL << (20U)) | (0xFUL << (16U)) | (0x7UL << (12U)) | (0xFUL << (8U)) | (0x7UL << (4U)) | (0xFUL << (0U)))))) | (temp))));
N}
N
N/**
N  * @brief  Get time (hour, minute and second) in BCD format
N  * @note if shadow mode is disabled (BYPSHAD=0), need to check if RSF flag is set
N  *       before reading this bit
N  * @note Read either RTC_SSR or RTC_TR locks the values in the higher-order calendar
N  *       shadow registers until RTC_DR is read (MS32_RTC_ReadReg(RTC, DR)).
N  * @note helper macros __MS32_RTC_GET_HOUR, __MS32_RTC_GET_MINUTE and __MS32_RTC_GET_SECOND
N  *       are available to get independently each parameter.
N  * @rmtoll TR           HT            MS32_RTC_TIME_Get\n
N  *         TR           HU            MS32_RTC_TIME_Get\n
N  *         TR           MNT           MS32_RTC_TIME_Get\n
N  *         TR           MNU           MS32_RTC_TIME_Get\n
N  *         TR           ST            MS32_RTC_TIME_Get\n
N  *         TR           SU            MS32_RTC_TIME_Get
N  * @param  RTCx RTC Instance
N  * @retval Combination of hours, minutes and seconds (Format: 0x00HHMMSS).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TIME_Get(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TIME_Get(RTC_TypeDef *RTCx) {
N  register uint32_t temp = 0U;
N
N  temp = READ_BIT(RTCx->TR, (RTC_TR_HT | RTC_TR_HU | RTC_TR_MNT | RTC_TR_MNU | RTC_TR_ST | RTC_TR_SU));
X  temp = ((RTCx->TR) & (((0x3UL << (20U)) | (0xFUL << (16U)) | (0x7UL << (12U)) | (0xFUL << (8U)) | (0x7UL << (4U)) | (0xFUL << (0U)))));
N  return (uint32_t)((((((temp & RTC_TR_HT) >> RTC_TR_HT_Pos) << 4U) | ((temp & RTC_TR_HU) >> RTC_TR_HU_Pos)) << RTC_OFFSET_HOUR) |  \
N                    (((((temp & RTC_TR_MNT) >> RTC_TR_MNT_Pos) << 4U) | ((temp & RTC_TR_MNU) >> RTC_TR_MNU_Pos)) << RTC_OFFSET_MINUTE) | \
N                    ((((temp & RTC_TR_ST) >> RTC_TR_ST_Pos) << 4U) | ((temp & RTC_TR_SU) >> RTC_TR_SU_Pos)));
X  return (uint32_t)((((((temp & (0x3UL << (20U))) >> (20U)) << 4U) | ((temp & (0xFUL << (16U))) >> (16U))) << 16U) |                      (((((temp & (0x7UL << (12U))) >> (12U)) << 4U) | ((temp & (0xFUL << (8U))) >> (8U))) << 8U) |                     ((((temp & (0x7UL << (4U))) >> (4U)) << 4U) | ((temp & (0xFUL << (0U))) >> (0U))));
N}
N
N/**
N  * @brief  Memorize whether the daylight saving time change has been performed
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           BKP           MS32_RTC_TIME_EnableDayLightStore
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TIME_EnableDayLightStore(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_TIME_EnableDayLightStore(RTC_TypeDef *RTCx) {
N  SET_BIT(RTCx->CR, RTC_CR_BKP);
X  ((RTCx->CR) |= ((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Disable memorization whether the daylight saving time change has been performed.
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           BKP           MS32_RTC_TIME_DisableDayLightStore
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TIME_DisableDayLightStore(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_TIME_DisableDayLightStore(RTC_TypeDef *RTCx) {
N  CLEAR_BIT(RTCx->CR, RTC_CR_BKP);
X  ((RTCx->CR) &= ~((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Check if RTC Day Light Saving stored operation has been enabled or not
N  * @rmtoll CR           BKP           MS32_RTC_TIME_IsDayLightStoreEnabled
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TIME_IsDayLightStoreEnabled(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TIME_IsDayLightStoreEnabled(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->CR, RTC_CR_BKP) == (RTC_CR_BKP));
X  return (((RTCx->CR) & ((0x1UL << (18U)))) == ((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Subtract 1 hour (winter time change)
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           SUB1H         MS32_RTC_TIME_DecHour
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TIME_DecHour(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_TIME_DecHour(RTC_TypeDef *RTCx) {
N  SET_BIT(RTCx->CR, RTC_CR_SUB1H);
X  ((RTCx->CR) |= ((0x1UL << (17U))));
N}
N
N/**
N  * @brief  Add 1 hour (summer time change)
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           ADD1H         MS32_RTC_TIME_IncHour
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TIME_IncHour(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_TIME_IncHour(RTC_TypeDef *RTCx) {
N  SET_BIT(RTCx->CR, RTC_CR_ADD1H);
X  ((RTCx->CR) |= ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Get Sub second value in the synchronous prescaler counter.
N  * @note  You can use both SubSeconds value and SecondFraction (PREDIV_S through
N  *        MS32_RTC_GetSynchPrescaler function) terms returned to convert Calendar
N  *        SubSeconds value in second fraction ratio with time unit following
N  *        generic formula:
N  *          ==> Seconds fraction ratio * time_unit= [(SecondFraction-SubSeconds)/(SecondFraction+1)] * time_unit
N  *        This conversion can be performed only if no shift operation is pending
N  *        (ie. SHFP=0) when PREDIV_S >= SS.
N  * @rmtoll SSR          SS            MS32_RTC_TIME_GetSubSecond
N  * @param  RTCx RTC Instance
N  * @retval Sub second value (number between 0 and 65535)
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TIME_GetSubSecond(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TIME_GetSubSecond(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->SSR, RTC_SSR_SS));
X  return (uint32_t)(((RTCx->SSR) & ((0xFFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Synchronize to a remote clock with a high degree of precision.
N  * @note   This operation effectively subtracts from (delays) or advance the clock of a fraction of a second.
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @note   When REFCKON is set, firmware must not write to Shift control register.
N  * @rmtoll SHIFTR       ADD1S         MS32_RTC_TIME_Synchronize\n
N  *         SHIFTR       SUBFS         MS32_RTC_TIME_Synchronize
N  * @param  RTCx RTC Instance
N  * @param  ShiftSecond This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_SHIFT_SECOND_DELAY
N  *         @arg @ref MS32_RTC_SHIFT_SECOND_ADVANCE
N  * @param  Fraction Number of Seconds Fractions (any value from 0 to 0x7FFF)
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TIME_Synchronize(RTC_TypeDef *RTCx, uint32_t ShiftSecond, uint32_t Fraction) {
Xstatic __inline void MS32_RTC_TIME_Synchronize(RTC_TypeDef *RTCx, uint32_t ShiftSecond, uint32_t Fraction) {
N  WRITE_REG(RTCx->SHIFTR, ShiftSecond | Fraction);
X  ((RTCx->SHIFTR) = (ShiftSecond | Fraction));
N}
N
N
N/** @defgroup RTC_EF_Date Date
N  * @{
N  */
N
N/**
N  * @brief  Set Year in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BIN2BCD is available to convert Year from binary to BCD format
N  * @rmtoll DR           YT            MS32_RTC_DATE_SetYear\n
N  *         DR           YU            MS32_RTC_DATE_SetYear
N  * @param  RTCx RTC Instance
N  * @param  Year Value between Min_Data=0x00 and Max_Data=0x99
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_DATE_SetYear(RTC_TypeDef *RTCx, uint32_t Year) {
Xstatic __inline void MS32_RTC_DATE_SetYear(RTC_TypeDef *RTCx, uint32_t Year) {
N  MODIFY_REG(RTCx->DR, (RTC_DR_YT | RTC_DR_YU),
N             (((Year & 0xF0U) << (RTC_DR_YT_Pos - 4U)) | ((Year & 0x0FU) << RTC_DR_YU_Pos)));
X  (((RTCx->DR)) = ((((((RTCx->DR))) & (~(((0xFUL << (20U)) | (0xFUL << (16U)))))) | ((((Year & 0xF0U) << ((20U) - 4U)) | ((Year & 0x0FU) << (16U)))))));
N}
N
N/**
N  * @brief  Get Year in BCD format
N  * @note if shadow mode is disabled (BYPSHAD=0), need to check if RSF flag is set
N  *       before reading this bit
N  * @note helper macro __MS32_RTC_CONVERT_BCD2BIN is available to convert Year from BCD to Binary format
N  * @rmtoll DR           YT            MS32_RTC_DATE_GetYear\n
N  *         DR           YU            MS32_RTC_DATE_GetYear
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0x99
N  */
N__STATIC_INLINE uint32_t MS32_RTC_DATE_GetYear(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_DATE_GetYear(RTC_TypeDef *RTCx) {
N  return (uint32_t)((READ_BIT(RTCx->DR, (RTC_DR_YT | RTC_DR_YU))) >> RTC_DR_YU_Pos);
X  return (uint32_t)((((RTCx->DR) & (((0xFUL << (20U)) | (0xFUL << (16U)))))) >> (16U));
N}
N
N/**
N  * @brief  Set Week day
N  * @rmtoll DR           WDU           MS32_RTC_DATE_SetWeekDay
N  * @param  RTCx RTC Instance
N  * @param  WeekDay This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_WEEKDAY_MONDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_TUESDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_WEDNESDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_THURSDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_FRIDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_SATURDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_SUNDAY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_DATE_SetWeekDay(RTC_TypeDef *RTCx, uint32_t WeekDay) {
Xstatic __inline void MS32_RTC_DATE_SetWeekDay(RTC_TypeDef *RTCx, uint32_t WeekDay) {
N  MODIFY_REG(RTCx->DR, RTC_DR_WDU, WeekDay << RTC_DR_WDU_Pos);
X  (((RTCx->DR)) = ((((((RTCx->DR))) & (~((0x7UL << (13U))))) | (WeekDay << (13U)))));
N}
N
N/**
N  * @brief  Get Week day
N  * @note if shadow mode is disabled (BYPSHAD=0), need to check if RSF flag is set
N  *       before reading this bit
N  * @rmtoll DR           WDU           MS32_RTC_DATE_GetWeekDay
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_WEEKDAY_MONDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_TUESDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_WEDNESDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_THURSDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_FRIDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_SATURDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_SUNDAY
N  */
N__STATIC_INLINE uint32_t MS32_RTC_DATE_GetWeekDay(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_DATE_GetWeekDay(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->DR, RTC_DR_WDU) >> RTC_DR_WDU_Pos);
X  return (uint32_t)(((RTCx->DR) & ((0x7UL << (13U)))) >> (13U));
N}
N
N/**
N  * @brief  Set Month in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BIN2BCD is available to convert Month from binary to BCD format
N  * @rmtoll DR           MT            MS32_RTC_DATE_SetMonth\n
N  *         DR           MU            MS32_RTC_DATE_SetMonth
N  * @param  RTCx RTC Instance
N  * @param  Month This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_MONTH_JANUARY
N  *         @arg @ref MS32_RTC_MONTH_FEBRUARY
N  *         @arg @ref MS32_RTC_MONTH_MARCH
N  *         @arg @ref MS32_RTC_MONTH_APRIL
N  *         @arg @ref MS32_RTC_MONTH_MAY
N  *         @arg @ref MS32_RTC_MONTH_JUNE
N  *         @arg @ref MS32_RTC_MONTH_JULY
N  *         @arg @ref MS32_RTC_MONTH_AUGUST
N  *         @arg @ref MS32_RTC_MONTH_SEPTEMBER
N  *         @arg @ref MS32_RTC_MONTH_OCTOBER
N  *         @arg @ref MS32_RTC_MONTH_NOVEMBER
N  *         @arg @ref MS32_RTC_MONTH_DECEMBER
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_DATE_SetMonth(RTC_TypeDef *RTCx, uint32_t Month) {
Xstatic __inline void MS32_RTC_DATE_SetMonth(RTC_TypeDef *RTCx, uint32_t Month) {
N  MODIFY_REG(RTCx->DR, (RTC_DR_MT | RTC_DR_MU),
N             (((Month & 0xF0U) << (RTC_DR_MT_Pos - 4U)) | ((Month & 0x0FU) << RTC_DR_MU_Pos)));
X  (((RTCx->DR)) = ((((((RTCx->DR))) & (~(((0x1UL << (12U)) | (0xFUL << (8U)))))) | ((((Month & 0xF0U) << ((12U) - 4U)) | ((Month & 0x0FU) << (8U)))))));
N}
N
N/**
N  * @brief  Get Month in BCD format
N  * @note if shadow mode is disabled (BYPSHAD=0), need to check if RSF flag is set
N  *       before reading this bit
N  * @note helper macro __MS32_RTC_CONVERT_BCD2BIN is available to convert Month from BCD to Binary format
N  * @rmtoll DR           MT            MS32_RTC_DATE_GetMonth\n
N  *         DR           MU            MS32_RTC_DATE_GetMonth
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_MONTH_JANUARY
N  *         @arg @ref MS32_RTC_MONTH_FEBRUARY
N  *         @arg @ref MS32_RTC_MONTH_MARCH
N  *         @arg @ref MS32_RTC_MONTH_APRIL
N  *         @arg @ref MS32_RTC_MONTH_MAY
N  *         @arg @ref MS32_RTC_MONTH_JUNE
N  *         @arg @ref MS32_RTC_MONTH_JULY
N  *         @arg @ref MS32_RTC_MONTH_AUGUST
N  *         @arg @ref MS32_RTC_MONTH_SEPTEMBER
N  *         @arg @ref MS32_RTC_MONTH_OCTOBER
N  *         @arg @ref MS32_RTC_MONTH_NOVEMBER
N  *         @arg @ref MS32_RTC_MONTH_DECEMBER
N  */
N__STATIC_INLINE uint32_t MS32_RTC_DATE_GetMonth(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_DATE_GetMonth(RTC_TypeDef *RTCx) {
N  return (uint32_t)((READ_BIT(RTCx->DR, (RTC_DR_MT | RTC_DR_MU))) >> RTC_DR_MU_Pos);
X  return (uint32_t)((((RTCx->DR) & (((0x1UL << (12U)) | (0xFUL << (8U)))))) >> (8U));
N}
N
N/**
N  * @brief  Set Day in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BIN2BCD is available to convert Day from binary to BCD format
N  * @rmtoll DR           DT            MS32_RTC_DATE_SetDay\n
N  *         DR           DU            MS32_RTC_DATE_SetDay
N  * @param  RTCx RTC Instance
N  * @param  Day Value between Min_Data=0x01 and Max_Data=0x31
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_DATE_SetDay(RTC_TypeDef *RTCx, uint32_t Day) {
Xstatic __inline void MS32_RTC_DATE_SetDay(RTC_TypeDef *RTCx, uint32_t Day) {
N  MODIFY_REG(RTCx->DR, (RTC_DR_DT | RTC_DR_DU),
N             (((Day & 0xF0U) << (RTC_DR_DT_Pos - 4U)) | ((Day & 0x0FU) << RTC_DR_DU_Pos)));
X  (((RTCx->DR)) = ((((((RTCx->DR))) & (~(((0x3UL << (4U)) | (0xFUL << (0U)))))) | ((((Day & 0xF0U) << ((4U) - 4U)) | ((Day & 0x0FU) << (0U)))))));
N}
N
N/**
N  * @brief  Get Day in BCD format
N  * @note if shadow mode is disabled (BYPSHAD=0), need to check if RSF flag is set
N  *       before reading this bit
N  * @note helper macro __MS32_RTC_CONVERT_BCD2BIN is available to convert Day from BCD to Binary format
N  * @rmtoll DR           DT            MS32_RTC_DATE_GetDay\n
N  *         DR           DU            MS32_RTC_DATE_GetDay
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x01 and Max_Data=0x31
N  */
N__STATIC_INLINE uint32_t MS32_RTC_DATE_GetDay(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_DATE_GetDay(RTC_TypeDef *RTCx) {
N  return (uint32_t)((READ_BIT(RTCx->DR, (RTC_DR_DT | RTC_DR_DU))) >> RTC_DR_DU_Pos);
X  return (uint32_t)((((RTCx->DR) & (((0x3UL << (4U)) | (0xFUL << (0U)))))) >> (0U));
N}
N
N/**
N  * @brief  Set date (WeekDay, Day, Month and Year) in BCD format
N  * @rmtoll DR           WDU           MS32_RTC_DATE_Config\n
N  *         DR           MT            MS32_RTC_DATE_Config\n
N  *         DR           MU            MS32_RTC_DATE_Config\n
N  *         DR           DT            MS32_RTC_DATE_Config\n
N  *         DR           DU            MS32_RTC_DATE_Config\n
N  *         DR           YT            MS32_RTC_DATE_Config\n
N  *         DR           YU            MS32_RTC_DATE_Config
N  * @param  RTCx RTC Instance
N  * @param  WeekDay This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_WEEKDAY_MONDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_TUESDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_WEDNESDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_THURSDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_FRIDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_SATURDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_SUNDAY
N  * @param  Day Value between Min_Data=0x01 and Max_Data=0x31
N  * @param  Month This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_MONTH_JANUARY
N  *         @arg @ref MS32_RTC_MONTH_FEBRUARY
N  *         @arg @ref MS32_RTC_MONTH_MARCH
N  *         @arg @ref MS32_RTC_MONTH_APRIL
N  *         @arg @ref MS32_RTC_MONTH_MAY
N  *         @arg @ref MS32_RTC_MONTH_JUNE
N  *         @arg @ref MS32_RTC_MONTH_JULY
N  *         @arg @ref MS32_RTC_MONTH_AUGUST
N  *         @arg @ref MS32_RTC_MONTH_SEPTEMBER
N  *         @arg @ref MS32_RTC_MONTH_OCTOBER
N  *         @arg @ref MS32_RTC_MONTH_NOVEMBER
N  *         @arg @ref MS32_RTC_MONTH_DECEMBER
N  * @param  Year Value between Min_Data=0x00 and Max_Data=0x99
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_DATE_Config(RTC_TypeDef *RTCx, uint32_t WeekDay, uint32_t Day, uint32_t Month, uint32_t Year) {
Xstatic __inline void MS32_RTC_DATE_Config(RTC_TypeDef *RTCx, uint32_t WeekDay, uint32_t Day, uint32_t Month, uint32_t Year) {
N  register uint32_t temp = 0U;
N
N  temp = (WeekDay << RTC_DR_WDU_Pos)                                                      | \
N         (((Year & 0xF0U) << (RTC_DR_YT_Pos - 4U)) | ((Year & 0x0FU) << RTC_DR_YU_Pos))   | \
N         (((Month & 0xF0U) << (RTC_DR_MT_Pos - 4U)) | ((Month & 0x0FU) << RTC_DR_MU_Pos)) | \
N         (((Day & 0xF0U) << (RTC_DR_DT_Pos - 4U)) | ((Day & 0x0FU) << RTC_DR_DU_Pos));
X  temp = (WeekDay << (13U))                                                      |          (((Year & 0xF0U) << ((20U) - 4U)) | ((Year & 0x0FU) << (16U)))   |          (((Month & 0xF0U) << ((12U) - 4U)) | ((Month & 0x0FU) << (8U))) |          (((Day & 0xF0U) << ((4U) - 4U)) | ((Day & 0x0FU) << (0U)));
N
N  MODIFY_REG(RTCx->DR, (RTC_DR_WDU | RTC_DR_MT | RTC_DR_MU | RTC_DR_DT | RTC_DR_DU | RTC_DR_YT | RTC_DR_YU), temp);
X  (((RTCx->DR)) = ((((((RTCx->DR))) & (~(((0x7UL << (13U)) | (0x1UL << (12U)) | (0xFUL << (8U)) | (0x3UL << (4U)) | (0xFUL << (0U)) | (0xFUL << (20U)) | (0xFUL << (16U)))))) | (temp))));
N}
N
N/**
N  * @brief  Get date (WeekDay, Day, Month and Year) in BCD format
N  * @note if shadow mode is disabled (BYPSHAD=0), need to check if RSF flag is set
N  *       before reading this bit
N  * @note helper macros __MS32_RTC_GET_WEEKDAY, __MS32_RTC_GET_YEAR, __MS32_RTC_GET_MONTH,
N  * and __MS32_RTC_GET_DAY are available to get independently each parameter.
N  * @rmtoll DR           WDU           MS32_RTC_DATE_Get\n
N  *         DR           MT            MS32_RTC_DATE_Get\n
N  *         DR           MU            MS32_RTC_DATE_Get\n
N  *         DR           DT            MS32_RTC_DATE_Get\n
N  *         DR           DU            MS32_RTC_DATE_Get\n
N  *         DR           YT            MS32_RTC_DATE_Get\n
N  *         DR           YU            MS32_RTC_DATE_Get
N  * @param  RTCx RTC Instance
N  * @retval Combination of WeekDay, Day, Month and Year (Format: 0xWWDDMMYY).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_DATE_Get(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_DATE_Get(RTC_TypeDef *RTCx) {
N  register uint32_t temp = 0U;
N
N  temp = READ_BIT(RTCx->DR, (RTC_DR_WDU | RTC_DR_MT | RTC_DR_MU | RTC_DR_DT | RTC_DR_DU | RTC_DR_YT | RTC_DR_YU));
X  temp = ((RTCx->DR) & (((0x7UL << (13U)) | (0x1UL << (12U)) | (0xFUL << (8U)) | (0x3UL << (4U)) | (0xFUL << (0U)) | (0xFUL << (20U)) | (0xFUL << (16U)))));
N  return (uint32_t)((((temp & RTC_DR_WDU) >> RTC_DR_WDU_Pos) << RTC_OFFSET_WEEKDAY) | \
N                    (((((temp & RTC_DR_DT) >> RTC_DR_DT_Pos) << 4U) | ((temp & RTC_DR_DU) >> RTC_DR_DU_Pos)) << RTC_OFFSET_DAY) | \
N                    (((((temp & RTC_DR_MT) >> RTC_DR_MT_Pos) << 4U) | ((temp & RTC_DR_MU) >> RTC_DR_MU_Pos)) << RTC_OFFSET_MONTH) | \
N                    ((((temp & RTC_DR_YT) >> RTC_DR_YT_Pos) << 4U) | ((temp & RTC_DR_YU) >> RTC_DR_YU_Pos)));
X  return (uint32_t)((((temp & (0x7UL << (13U))) >> (13U)) << 24U) |                     (((((temp & (0x3UL << (4U))) >> (4U)) << 4U) | ((temp & (0xFUL << (0U))) >> (0U))) << 16U) |                     (((((temp & (0x1UL << (12U))) >> (12U)) << 4U) | ((temp & (0xFUL << (8U))) >> (8U))) << 8U) |                     ((((temp & (0xFUL << (20U))) >> (20U)) << 4U) | ((temp & (0xFUL << (16U))) >> (16U))));
N}
N
N
N/** @defgroup RTC_EF_ALARMA ALARMA
N  * @{
N  */
N
N/**
N  * @brief  Enable Alarm A
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           ALRAE         MS32_RTC_ALARM_Enable
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ALARM_Enable(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_ALARM_Enable(RTC_TypeDef *RTCx) {
N  SET_BIT(RTCx->CR, RTC_CR_ALRAE);
X  ((RTCx->CR) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable Alarm A
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           ALRAE         MS32_RTC_ALARM_Disable
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ALARM_Disable(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_ALARM_Disable(RTC_TypeDef *RTCx) {
N  CLEAR_BIT(RTCx->CR, RTC_CR_ALRAE);
X  ((RTCx->CR) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Specify the Alarm A masks.
N  * @rmtoll ALRMAR       MSK4          MS32_RTC_ALARM_SetMask\n
N  *         ALRMAR       MSK3          MS32_RTC_ALARM_SetMask\n
N  *         ALRMAR       MSK2          MS32_RTC_ALARM_SetMask\n
N  *         ALRMAR       MSK1          MS32_RTC_ALARM_SetMask
N  * @param  RTCx RTC Instance
N  * @param  Mask This parameter can be a combination of the following values:
N  *         @arg @ref MS32_RTC_ALARM_MASK_NONE
N  *         @arg @ref MS32_RTC_ALARM_MASK_DATEWEEKDAY
N  *         @arg @ref MS32_RTC_ALARM_MASK_HOURS
N  *         @arg @ref MS32_RTC_ALARM_MASK_MINUTES
N  *         @arg @ref MS32_RTC_ALARM_MASK_SECONDS
N  *         @arg @ref MS32_RTC_ALARM_MASK_ALL
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ALARM_SetMask(RTC_TypeDef *RTCx, uint32_t Mask) {
Xstatic __inline void MS32_RTC_ALARM_SetMask(RTC_TypeDef *RTCx, uint32_t Mask) {
N  MODIFY_REG(RTCx->ALRMAR, RTC_ALRMAR_MSK4 | RTC_ALRMAR_MSK3 | RTC_ALRMAR_MSK2 | RTC_ALRMAR_MSK1, Mask);
X  (((RTCx->ALRMAR)) = ((((((RTCx->ALRMAR))) & (~((0x1UL << (31U)) | (0x1UL << (23U)) | (0x1UL << (15U)) | (0x1UL << (7U))))) | (Mask))));
N}
N
N/**
N  * @brief  Get the Alarm A masks.
N  * @rmtoll ALRMAR       MSK4          MS32_RTC_ALARM_GetMask\n
N  *         ALRMAR       MSK3          MS32_RTC_ALARM_GetMask\n
N  *         ALRMAR       MSK2          MS32_RTC_ALARM_GetMask\n
N  *         ALRMAR       MSK1          MS32_RTC_ALARM_GetMask
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be can be a combination of the following values:
N  *         @arg @ref MS32_RTC_ALARM_MASK_NONE
N  *         @arg @ref MS32_RTC_ALARM_MASK_DATEWEEKDAY
N  *         @arg @ref MS32_RTC_ALARM_MASK_HOURS
N  *         @arg @ref MS32_RTC_ALARM_MASK_MINUTES
N  *         @arg @ref MS32_RTC_ALARM_MASK_SECONDS
N  *         @arg @ref MS32_RTC_ALARM_MASK_ALL
N  */
N__STATIC_INLINE uint32_t MS32_RTC_ALARM_GetMask(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_ALARM_GetMask(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->ALRMAR, RTC_ALRMAR_MSK4 | RTC_ALRMAR_MSK3 | RTC_ALRMAR_MSK2 | RTC_ALRMAR_MSK1));
X  return (uint32_t)(((RTCx->ALRMAR) & ((0x1UL << (31U)) | (0x1UL << (23U)) | (0x1UL << (15U)) | (0x1UL << (7U)))));
N}
N
N/**
N  * @brief  Enable AlarmA Week day selection (DU[3:0] represents the week day. DT[1:0] is do not care)
N  * @rmtoll ALRMAR       WDSEL         MS32_RTC_ALARM_EnableWeekday
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ALARM_EnableWeekday(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_ALARM_EnableWeekday(RTC_TypeDef *RTCx) {
N  SET_BIT(RTCx->ALRMAR, RTC_ALRMAR_WDSEL);
X  ((RTCx->ALRMAR) |= ((0x1UL << (30U))));
N}
N
N/**
N  * @brief  Disable AlarmA Week day selection (DU[3:0] represents the date )
N  * @rmtoll ALRMAR       WDSEL         MS32_RTC_ALARM_DisableWeekday
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ALARM_DisableWeekday(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_ALARM_DisableWeekday(RTC_TypeDef *RTCx) {
N  CLEAR_BIT(RTCx->ALRMAR, RTC_ALRMAR_WDSEL);
X  ((RTCx->ALRMAR) &= ~((0x1UL << (30U))));
N}
N
N/**
N  * @brief  Set ALARM A Day in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BIN2BCD is available to convert Day from binary to BCD format
N  * @rmtoll ALRMAR       DT            MS32_RTC_ALARM_SetDay\n
N  *         ALRMAR       DU            MS32_RTC_ALARM_SetDay
N  * @param  RTCx RTC Instance
N  * @param  Day Value between Min_Data=0x01 and Max_Data=0x31
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ALARM_SetDay(RTC_TypeDef *RTCx, uint32_t Day) {
Xstatic __inline void MS32_RTC_ALARM_SetDay(RTC_TypeDef *RTCx, uint32_t Day) {
N  MODIFY_REG(RTCx->ALRMAR, (RTC_ALRMAR_DT | RTC_ALRMAR_DU),
N             (((Day & 0xF0U) << (RTC_ALRMAR_DT_Pos - 4U)) | ((Day & 0x0FU) << RTC_ALRMAR_DU_Pos)));
X  (((RTCx->ALRMAR)) = ((((((RTCx->ALRMAR))) & (~(((0x3UL << (28U)) | (0xFUL << (24U)))))) | ((((Day & 0xF0U) << ((28U) - 4U)) | ((Day & 0x0FU) << (24U)))))));
N}
N
N/**
N  * @brief  Get ALARM A Day in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BCD2BIN is available to convert Day from BCD to Binary format
N  * @rmtoll ALRMAR       DT            MS32_RTC_ALARM_GetDay\n
N  *         ALRMAR       DU            MS32_RTC_ALARM_GetDay
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x01 and Max_Data=0x31
N  */
N__STATIC_INLINE uint32_t MS32_RTC_ALARM_GetDay(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_ALARM_GetDay(RTC_TypeDef *RTCx) {
N  return (uint32_t)((READ_BIT(RTCx->ALRMAR, (RTC_ALRMAR_DT | RTC_ALRMAR_DU))) >> RTC_ALRMAR_DU_Pos);
X  return (uint32_t)((((RTCx->ALRMAR) & (((0x3UL << (28U)) | (0xFUL << (24U)))))) >> (24U));
N}
N
N/**
N  * @brief  Set ALARM A Weekday
N  * @rmtoll ALRMAR       DU            MS32_RTC_ALARM_SetWeekDay
N  * @param  RTCx RTC Instance
N  * @param  WeekDay This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_WEEKDAY_MONDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_TUESDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_WEDNESDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_THURSDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_FRIDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_SATURDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_SUNDAY
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ALARM_SetWeekDay(RTC_TypeDef *RTCx, uint32_t WeekDay) {
Xstatic __inline void MS32_RTC_ALARM_SetWeekDay(RTC_TypeDef *RTCx, uint32_t WeekDay) {
N  MODIFY_REG(RTCx->ALRMAR, RTC_ALRMAR_DU, WeekDay << RTC_ALRMAR_DU_Pos);
X  (((RTCx->ALRMAR)) = ((((((RTCx->ALRMAR))) & (~((0xFUL << (24U))))) | (WeekDay << (24U)))));
N}
N
N/**
N  * @brief  Get ALARM A Weekday
N  * @rmtoll ALRMAR       DU            MS32_RTC_ALARM_GetWeekDay
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_WEEKDAY_MONDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_TUESDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_WEDNESDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_THURSDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_FRIDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_SATURDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_SUNDAY
N  */
N__STATIC_INLINE uint32_t MS32_RTC_ALARM_GetWeekDay(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_ALARM_GetWeekDay(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->ALRMAR, RTC_ALRMAR_DU) >> RTC_ALRMAR_DU_Pos);
X  return (uint32_t)(((RTCx->ALRMAR) & ((0xFUL << (24U)))) >> (24U));
N}
N
N/**
N  * @brief  Set Alarm A time format (AM/24-hour or PM notation)
N  * @rmtoll ALRMAR       PM            MS32_RTC_ALARM_SetTimeFormat
N  * @param  RTCx RTC Instance
N  * @param  TimeFormat This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_ALARM_TIME_FORMAT_AM
N  *         @arg @ref MS32_RTC_ALARM_TIME_FORMAT_PM
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ALARM_SetTimeFormat(RTC_TypeDef *RTCx, uint32_t TimeFormat) {
Xstatic __inline void MS32_RTC_ALARM_SetTimeFormat(RTC_TypeDef *RTCx, uint32_t TimeFormat) {
N  MODIFY_REG(RTCx->ALRMAR, RTC_ALRMAR_PM, TimeFormat);
X  (((RTCx->ALRMAR)) = ((((((RTCx->ALRMAR))) & (~((0x1UL << (22U))))) | (TimeFormat))));
N}
N
N/**
N  * @brief  Get Alarm A time format (AM or PM notation)
N  * @rmtoll ALRMAR       PM            MS32_RTC_ALARM_GetTimeFormat
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_ALARM_TIME_FORMAT_AM
N  *         @arg @ref MS32_RTC_ALARM_TIME_FORMAT_PM
N  */
N__STATIC_INLINE uint32_t MS32_RTC_ALARM_GetTimeFormat(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_ALARM_GetTimeFormat(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->ALRMAR, RTC_ALRMAR_PM));
X  return (uint32_t)(((RTCx->ALRMAR) & ((0x1UL << (22U)))));
N}
N
N/**
N  * @brief  Set ALARM A Hours in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BIN2BCD is available to convert Hours from binary to BCD format
N  * @rmtoll ALRMAR       HT            MS32_RTC_ALARM_SetHour\n
N  *         ALRMAR       HU            MS32_RTC_ALARM_SetHour
N  * @param  RTCx RTC Instance
N  * @param  Hours Value between Min_Data=0x01 and Max_Data=0x12 or between Min_Data=0x00 and Max_Data=0x23
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ALARM_SetHour(RTC_TypeDef *RTCx, uint32_t Hours) {
Xstatic __inline void MS32_RTC_ALARM_SetHour(RTC_TypeDef *RTCx, uint32_t Hours) {
N  MODIFY_REG(RTCx->ALRMAR, (RTC_ALRMAR_HT | RTC_ALRMAR_HU),
N             (((Hours & 0xF0U) << (RTC_ALRMAR_HT_Pos - 4U)) | ((Hours & 0x0FU) << RTC_ALRMAR_HU_Pos)));
X  (((RTCx->ALRMAR)) = ((((((RTCx->ALRMAR))) & (~(((0x3UL << (20U)) | (0xFUL << (16U)))))) | ((((Hours & 0xF0U) << ((20U) - 4U)) | ((Hours & 0x0FU) << (16U)))))));
N}
N
N/**
N  * @brief  Get ALARM A Hours in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BCD2BIN is available to convert Hours from BCD to Binary format
N  * @rmtoll ALRMAR       HT            MS32_RTC_ALARM_GetHour\n
N  *         ALRMAR       HU            MS32_RTC_ALARM_GetHour
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x01 and Max_Data=0x12 or between Min_Data=0x00 and Max_Data=0x23
N  */
N__STATIC_INLINE uint32_t MS32_RTC_ALARM_GetHour(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_ALARM_GetHour(RTC_TypeDef *RTCx) {
N  return (uint32_t)((READ_BIT(RTCx->ALRMAR, (RTC_ALRMAR_HT | RTC_ALRMAR_HU))) >> RTC_ALRMAR_HU_Pos);
X  return (uint32_t)((((RTCx->ALRMAR) & (((0x3UL << (20U)) | (0xFUL << (16U)))))) >> (16U));
N}
N
N/**
N  * @brief  Set ALARM A Minutes in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BIN2BCD is available to convert Minutes from binary to BCD format
N  * @rmtoll ALRMAR       MNT           MS32_RTC_ALARM_SetMinute\n
N  *         ALRMAR       MNU           MS32_RTC_ALARM_SetMinute
N  * @param  RTCx RTC Instance
N  * @param  Minutes Value between Min_Data=0x00 and Max_Data=0x59
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ALARM_SetMinute(RTC_TypeDef *RTCx, uint32_t Minutes) {
Xstatic __inline void MS32_RTC_ALARM_SetMinute(RTC_TypeDef *RTCx, uint32_t Minutes) {
N  MODIFY_REG(RTCx->ALRMAR, (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU),
N             (((Minutes & 0xF0U) << (RTC_ALRMAR_MNT_Pos - 4U)) | ((Minutes & 0x0FU) << RTC_ALRMAR_MNU_Pos)));
X  (((RTCx->ALRMAR)) = ((((((RTCx->ALRMAR))) & (~(((0x7UL << (12U)) | (0xFUL << (8U)))))) | ((((Minutes & 0xF0U) << ((12U) - 4U)) | ((Minutes & 0x0FU) << (8U)))))));
N}
N
N/**
N  * @brief  Get ALARM A Minutes in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BCD2BIN is available to convert Minutes from BCD to Binary format
N  * @rmtoll ALRMAR       MNT           MS32_RTC_ALARM_GetMinute\n
N  *         ALRMAR       MNU           MS32_RTC_ALARM_GetMinute
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0x59
N  */
N__STATIC_INLINE uint32_t MS32_RTC_ALARM_GetMinute(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_ALARM_GetMinute(RTC_TypeDef *RTCx) {
N  return (uint32_t)((READ_BIT(RTCx->ALRMAR, (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU))) >> RTC_ALRMAR_MNU_Pos);
X  return (uint32_t)((((RTCx->ALRMAR) & (((0x7UL << (12U)) | (0xFUL << (8U)))))) >> (8U));
N}
N
N/**
N  * @brief  Set ALARM A Seconds in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BIN2BCD is available to convert Seconds from binary to BCD format
N  * @rmtoll ALRMAR       ST            MS32_RTC_ALARM_SetSecond\n
N  *         ALRMAR       SU            MS32_RTC_ALARM_SetSecond
N  * @param  RTCx RTC Instance
N  * @param  Seconds Value between Min_Data=0x00 and Max_Data=0x59
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ALARM_SetSecond(RTC_TypeDef *RTCx, uint32_t Seconds) {
Xstatic __inline void MS32_RTC_ALARM_SetSecond(RTC_TypeDef *RTCx, uint32_t Seconds) {
N  MODIFY_REG(RTCx->ALRMAR, (RTC_ALRMAR_ST | RTC_ALRMAR_SU),
N             (((Seconds & 0xF0U) << (RTC_ALRMAR_ST_Pos - 4U)) | ((Seconds & 0x0FU) << RTC_ALRMAR_SU_Pos)));
X  (((RTCx->ALRMAR)) = ((((((RTCx->ALRMAR))) & (~(((0x7UL << (4U)) | (0xFUL << (0U)))))) | ((((Seconds & 0xF0U) << ((4U) - 4U)) | ((Seconds & 0x0FU) << (0U)))))));
N}
N
N/**
N  * @brief  Get ALARM A Seconds in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BCD2BIN is available to convert Seconds from BCD to Binary format
N  * @rmtoll ALRMAR       ST            MS32_RTC_ALARM_GetSecond\n
N  *         ALRMAR       SU            MS32_RTC_ALARM_GetSecond
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0x59
N  */
N__STATIC_INLINE uint32_t MS32_RTC_ALARM_GetSecond(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_ALARM_GetSecond(RTC_TypeDef *RTCx) {
N  return (uint32_t)((READ_BIT(RTCx->ALRMAR, (RTC_ALRMAR_ST | RTC_ALRMAR_SU))) >> RTC_ALRMAR_SU_Pos);
X  return (uint32_t)((((RTCx->ALRMAR) & (((0x7UL << (4U)) | (0xFUL << (0U)))))) >> (0U));
N}
N
N/**
N  * @brief  Set Alarm A Time (hour, minute and second) in BCD format
N  * @rmtoll ALRMAR       PM            MS32_RTC_ALARM_ConfigTime\n
N  *         ALRMAR       HT            MS32_RTC_ALARM_ConfigTime\n
N  *         ALRMAR       HU            MS32_RTC_ALARM_ConfigTime\n
N  *         ALRMAR       MNT           MS32_RTC_ALARM_ConfigTime\n
N  *         ALRMAR       MNU           MS32_RTC_ALARM_ConfigTime\n
N  *         ALRMAR       ST            MS32_RTC_ALARM_ConfigTime\n
N  *         ALRMAR       SU            MS32_RTC_ALARM_ConfigTime
N  * @param  RTCx RTC Instance
N  * @param  Format12_24 This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_ALARM_TIME_FORMAT_AM
N  *         @arg @ref MS32_RTC_ALARM_TIME_FORMAT_PM
N  * @param  Hours Value between Min_Data=0x01 and Max_Data=0x12 or between Min_Data=0x00 and Max_Data=0x23
N  * @param  Minutes Value between Min_Data=0x00 and Max_Data=0x59
N  * @param  Seconds Value between Min_Data=0x00 and Max_Data=0x59
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ALARM_ConfigTime(RTC_TypeDef *RTCx, uint32_t Format12_24, uint32_t Hours, uint32_t Minutes, uint32_t Seconds) {
Xstatic __inline void MS32_RTC_ALARM_ConfigTime(RTC_TypeDef *RTCx, uint32_t Format12_24, uint32_t Hours, uint32_t Minutes, uint32_t Seconds) {
N  register uint32_t temp = 0U;
N
N  temp = Format12_24 | (((Hours & 0xF0U) << (RTC_ALRMAR_HT_Pos - 4U)) | ((Hours & 0x0FU) << RTC_ALRMAR_HU_Pos))    | \
N         (((Minutes & 0xF0U) << (RTC_ALRMAR_MNT_Pos - 4U)) | ((Minutes & 0x0FU) << RTC_ALRMAR_MNU_Pos)) | \
N         (((Seconds & 0xF0U) << (RTC_ALRMAR_ST_Pos - 4U)) | ((Seconds & 0x0FU) << RTC_ALRMAR_SU_Pos));
X  temp = Format12_24 | (((Hours & 0xF0U) << ((20U) - 4U)) | ((Hours & 0x0FU) << (16U)))    |          (((Minutes & 0xF0U) << ((12U) - 4U)) | ((Minutes & 0x0FU) << (8U))) |          (((Seconds & 0xF0U) << ((4U) - 4U)) | ((Seconds & 0x0FU) << (0U)));
N
N  MODIFY_REG(RTCx->ALRMAR, RTC_ALRMAR_PM | RTC_ALRMAR_HT | RTC_ALRMAR_HU | RTC_ALRMAR_MNT | RTC_ALRMAR_MNU | RTC_ALRMAR_ST | RTC_ALRMAR_SU, temp);
X  (((RTCx->ALRMAR)) = ((((((RTCx->ALRMAR))) & (~((0x1UL << (22U)) | (0x3UL << (20U)) | (0xFUL << (16U)) | (0x7UL << (12U)) | (0xFUL << (8U)) | (0x7UL << (4U)) | (0xFUL << (0U))))) | (temp))));
N}
N
N/**
N  * @brief  Get Alarm B Time (hour, minute and second) in BCD format
N  * @note helper macros __MS32_RTC_GET_HOUR, __MS32_RTC_GET_MINUTE and __MS32_RTC_GET_SECOND
N  * are available to get independently each parameter.
N  * @rmtoll ALRMAR       HT            MS32_RTC_ALARM_GetTime\n
N  *         ALRMAR       HU            MS32_RTC_ALARM_GetTime\n
N  *         ALRMAR       MNT           MS32_RTC_ALARM_GetTime\n
N  *         ALRMAR       MNU           MS32_RTC_ALARM_GetTime\n
N  *         ALRMAR       ST            MS32_RTC_ALARM_GetTime\n
N  *         ALRMAR       SU            MS32_RTC_ALARM_GetTime
N  * @param  RTCx RTC Instance
N  * @retval Combination of hours, minutes and seconds.
N  */
N__STATIC_INLINE uint32_t MS32_RTC_ALARM_GetTime(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_ALARM_GetTime(RTC_TypeDef *RTCx) {
N  return (uint32_t)((MS32_RTC_ALARM_GetHour(RTCx) << RTC_OFFSET_HOUR) | (MS32_RTC_ALARM_GetMinute(RTCx) << RTC_OFFSET_MINUTE) | MS32_RTC_ALARM_GetSecond(RTCx));
X  return (uint32_t)((MS32_RTC_ALARM_GetHour(RTCx) << 16U) | (MS32_RTC_ALARM_GetMinute(RTCx) << 8U) | MS32_RTC_ALARM_GetSecond(RTCx));
N}
N
N/**
N  * @brief  Set Alarm A Mask the most-significant bits starting at this bit
N  * @note This register can be written only when ALRAE is reset in RTC_CR register,
N  *       or in initialization mode.
N  * @rmtoll ALRMASSR     MASKSS        MS32_RTC_ALARM_SetSubSecondMask
N  * @param  RTCx RTC Instance
N  * @param  Mask Value between Min_Data=0x00 and Max_Data=0xF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ALARM_SetSubSecondMask(RTC_TypeDef *RTCx, uint32_t Mask) {
Xstatic __inline void MS32_RTC_ALARM_SetSubSecondMask(RTC_TypeDef *RTCx, uint32_t Mask) {
N  MODIFY_REG(RTCx->ALRMASSR, RTC_ALRMASSR_MASKSS, Mask << RTC_ALRMASSR_MASKSS_Pos);
X  (((RTCx->ALRMASSR)) = ((((((RTCx->ALRMASSR))) & (~((0xFUL << (24U))))) | (Mask << (24U)))));
N}
N
N/**
N  * @brief  Get Alarm A Mask the most-significant bits starting at this bit
N  * @rmtoll ALRMASSR     MASKSS        MS32_RTC_ALARM_GetSubSecondMask
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0xF
N  */
N__STATIC_INLINE uint32_t MS32_RTC_ALARM_GetSubSecondMask(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_ALARM_GetSubSecondMask(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->ALRMASSR, RTC_ALRMASSR_MASKSS) >> RTC_ALRMASSR_MASKSS_Pos);
X  return (uint32_t)(((RTCx->ALRMASSR) & ((0xFUL << (24U)))) >> (24U));
N}
N
N/**
N  * @brief  Set Alarm A Sub seconds value
N  * @rmtoll ALRMASSR     SS            MS32_RTC_ALARM_SetSubSecond
N  * @param  RTCx RTC Instance
N  * @param  Subsecond Value between Min_Data=0x00 and Max_Data=0x7FFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ALARM_SetSubSecond(RTC_TypeDef *RTCx, uint32_t Subsecond) {
Xstatic __inline void MS32_RTC_ALARM_SetSubSecond(RTC_TypeDef *RTCx, uint32_t Subsecond) {
N  MODIFY_REG(RTCx->ALRMASSR, RTC_ALRMASSR_SS, Subsecond);
X  (((RTCx->ALRMASSR)) = ((((((RTCx->ALRMASSR))) & (~((0x7FFFUL << (0U))))) | (Subsecond))));
N}
N
N/**
N  * @brief  Get Alarm A Sub seconds value
N  * @rmtoll ALRMASSR     SS            MS32_RTC_ALARM_GetSubSecond
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0x7FFF
N  */
N__STATIC_INLINE uint32_t MS32_RTC_ALARM_GetSubSecond(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_ALARM_GetSubSecond(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->ALRMASSR, RTC_ALRMASSR_SS));
X  return (uint32_t)(((RTCx->ALRMASSR) & ((0x7FFFUL << (0U)))));
N}
N
N
N/** @defgroup RTC_EF_Timestamp Timestamp
N  * @{
N  */
N
N/**
N  * @brief  Enable Timestamp
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           TSE           MS32_RTC_TS_Enable
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TS_Enable(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_TS_Enable(RTC_TypeDef *RTCx) {
N  SET_BIT(RTCx->CR, RTC_CR_TSE);
X  ((RTCx->CR) |= ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Disable Timestamp
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           TSE           MS32_RTC_TS_Disable
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TS_Disable(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_TS_Disable(RTC_TypeDef *RTCx) {
N  CLEAR_BIT(RTCx->CR, RTC_CR_TSE);
X  ((RTCx->CR) &= ~((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Set Time-stamp event active edge
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @note TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting
N  * @rmtoll CR           TSEDGE        MS32_RTC_TS_SetActiveEdge
N  * @param  RTCx RTC Instance
N  * @param  Edge This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_TIMESTAMP_EDGE_RISING
N  *         @arg @ref MS32_RTC_TIMESTAMP_EDGE_FALLING
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TS_SetActiveEdge(RTC_TypeDef *RTCx, uint32_t Edge) {
Xstatic __inline void MS32_RTC_TS_SetActiveEdge(RTC_TypeDef *RTCx, uint32_t Edge) {
N  MODIFY_REG(RTCx->CR, RTC_CR_TSEDGE, Edge);
X  (((RTCx->CR)) = ((((((RTCx->CR))) & (~((0x1UL << (3U))))) | (Edge))));
N}
N
N/**
N  * @brief  Get Time-stamp event active edge
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           TSEDGE        MS32_RTC_TS_GetActiveEdge
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_TIMESTAMP_EDGE_RISING
N  *         @arg @ref MS32_RTC_TIMESTAMP_EDGE_FALLING
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TS_GetActiveEdge(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TS_GetActiveEdge(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->CR, RTC_CR_TSEDGE));
X  return (uint32_t)(((RTCx->CR) & ((0x1UL << (3U)))));
N}
N
N/**
N  * @brief  Get Timestamp AM/PM notation (AM or 24-hour format)
N  * @rmtoll TSTR         PM            MS32_RTC_TS_GetTimeFormat
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_TS_TIME_FORMAT_AM
N  *         @arg @ref MS32_RTC_TS_TIME_FORMAT_PM
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TS_GetTimeFormat(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TS_GetTimeFormat(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->TSTR, RTC_TSTR_PM));
X  return (uint32_t)(((RTCx->TSTR) & ((0x1UL << (22U)))));
N}
N
N/**
N  * @brief  Get Timestamp Hours in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BCD2BIN is available to convert Hours from BCD to Binary format
N  * @rmtoll TSTR         HT            MS32_RTC_TS_GetHour\n
N  *         TSTR         HU            MS32_RTC_TS_GetHour
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x01 and Max_Data=0x12 or between Min_Data=0x00 and Max_Data=0x23
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TS_GetHour(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TS_GetHour(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->TSTR, RTC_TSTR_HT | RTC_TSTR_HU) >> RTC_TSTR_HU_Pos);
X  return (uint32_t)(((RTCx->TSTR) & ((0x3UL << (20U)) | (0xFUL << (16U)))) >> (16U));
N}
N
N/**
N  * @brief  Get Timestamp Minutes in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BCD2BIN is available to convert Minutes from BCD to Binary format
N  * @rmtoll TSTR         MNT           MS32_RTC_TS_GetMinute\n
N  *         TSTR         MNU           MS32_RTC_TS_GetMinute
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0x59
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TS_GetMinute(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TS_GetMinute(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->TSTR, RTC_TSTR_MNT | RTC_TSTR_MNU) >> RTC_TSTR_MNU_Pos);
X  return (uint32_t)(((RTCx->TSTR) & ((0x7UL << (12U)) | (0xFUL << (8U)))) >> (8U));
N}
N
N/**
N  * @brief  Get Timestamp Seconds in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BCD2BIN is available to convert Seconds from BCD to Binary format
N  * @rmtoll TSTR         ST            MS32_RTC_TS_GetSecond\n
N  *         TSTR         SU            MS32_RTC_TS_GetSecond
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0x59
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TS_GetSecond(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TS_GetSecond(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->TSTR, RTC_TSTR_ST | RTC_TSTR_SU));
X  return (uint32_t)(((RTCx->TSTR) & ((0x7UL << (4U)) | (0xFUL << (0U)))));
N}
N
N/**
N  * @brief  Get Timestamp time (hour, minute and second) in BCD format
N  * @note helper macros __MS32_RTC_GET_HOUR, __MS32_RTC_GET_MINUTE and __MS32_RTC_GET_SECOND
N  * are available to get independently each parameter.
N  * @rmtoll TSTR         HT            MS32_RTC_TS_GetTime\n
N  *         TSTR         HU            MS32_RTC_TS_GetTime\n
N  *         TSTR         MNT           MS32_RTC_TS_GetTime\n
N  *         TSTR         MNU           MS32_RTC_TS_GetTime\n
N  *         TSTR         ST            MS32_RTC_TS_GetTime\n
N  *         TSTR         SU            MS32_RTC_TS_GetTime
N  * @param  RTCx RTC Instance
N  * @retval Combination of hours, minutes and seconds.
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TS_GetTime(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TS_GetTime(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->TSTR,
N                             RTC_TSTR_HT | RTC_TSTR_HU | RTC_TSTR_MNT | RTC_TSTR_MNU | RTC_TSTR_ST | RTC_TSTR_SU));
X  return (uint32_t)(((RTCx->TSTR) & ((0x3UL << (20U)) | (0xFUL << (16U)) | (0x7UL << (12U)) | (0xFUL << (8U)) | (0x7UL << (4U)) | (0xFUL << (0U)))));
N}
N
N/**
N  * @brief  Get Timestamp Week day
N  * @rmtoll TSDR         WDU           MS32_RTC_TS_GetWeekDay
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_WEEKDAY_MONDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_TUESDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_WEDNESDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_THURSDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_FRIDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_SATURDAY
N  *         @arg @ref MS32_RTC_WEEKDAY_SUNDAY
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TS_GetWeekDay(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TS_GetWeekDay(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->TSDR, RTC_TSDR_WDU) >> RTC_TSDR_WDU_Pos);
X  return (uint32_t)(((RTCx->TSDR) & ((0x7UL << (13U)))) >> (13U));
N}
N
N/**
N  * @brief  Get Timestamp Month in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BCD2BIN is available to convert Month from BCD to Binary format
N  * @rmtoll TSDR         MT            MS32_RTC_TS_GetMonth\n
N  *         TSDR         MU            MS32_RTC_TS_GetMonth
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_MONTH_JANUARY
N  *         @arg @ref MS32_RTC_MONTH_FEBRUARY
N  *         @arg @ref MS32_RTC_MONTH_MARCH
N  *         @arg @ref MS32_RTC_MONTH_APRIL
N  *         @arg @ref MS32_RTC_MONTH_MAY
N  *         @arg @ref MS32_RTC_MONTH_JUNE
N  *         @arg @ref MS32_RTC_MONTH_JULY
N  *         @arg @ref MS32_RTC_MONTH_AUGUST
N  *         @arg @ref MS32_RTC_MONTH_SEPTEMBER
N  *         @arg @ref MS32_RTC_MONTH_OCTOBER
N  *         @arg @ref MS32_RTC_MONTH_NOVEMBER
N  *         @arg @ref MS32_RTC_MONTH_DECEMBER
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TS_GetMonth(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TS_GetMonth(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->TSDR, RTC_TSDR_MT | RTC_TSDR_MU) >> RTC_TSDR_MU_Pos);
X  return (uint32_t)(((RTCx->TSDR) & ((0x1UL << (12U)) | (0xFUL << (8U)))) >> (8U));
N}
N
N/**
N  * @brief  Get Timestamp Day in BCD format
N  * @note helper macro __MS32_RTC_CONVERT_BCD2BIN is available to convert Day from BCD to Binary format
N  * @rmtoll TSDR         DT            MS32_RTC_TS_GetDay\n
N  *         TSDR         DU            MS32_RTC_TS_GetDay
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x01 and Max_Data=0x31
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TS_GetDay(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TS_GetDay(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->TSDR, RTC_TSDR_DT | RTC_TSDR_DU));
X  return (uint32_t)(((RTCx->TSDR) & ((0x3UL << (4U)) | (0xFUL << (0U)))));
N}
N
N/**
N  * @brief  Get Timestamp date (WeekDay, Day and Month) in BCD format
N  * @note helper macros __MS32_RTC_GET_WEEKDAY, __MS32_RTC_GET_MONTH,
N  * and __MS32_RTC_GET_DAY are available to get independently each parameter.
N  * @rmtoll TSDR         WDU           MS32_RTC_TS_GetDate\n
N  *         TSDR         MT            MS32_RTC_TS_GetDate\n
N  *         TSDR         MU            MS32_RTC_TS_GetDate\n
N  *         TSDR         DT            MS32_RTC_TS_GetDate\n
N  *         TSDR         DU            MS32_RTC_TS_GetDate
N  * @param  RTCx RTC Instance
N  * @retval Combination of Weekday, Day and Month
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TS_GetDate(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TS_GetDate(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->TSDR, RTC_TSDR_WDU | RTC_TSDR_MT | RTC_TSDR_MU | RTC_TSDR_DT | RTC_TSDR_DU));
X  return (uint32_t)(((RTCx->TSDR) & ((0x7UL << (13U)) | (0x1UL << (12U)) | (0xFUL << (8U)) | (0x3UL << (4U)) | (0xFUL << (0U)))));
N}
N
N/**
N  * @brief  Get time-stamp sub second value
N  * @rmtoll TSSSR        SS            MS32_RTC_TS_GetSubSecond
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFFFF
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TS_GetSubSecond(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TS_GetSubSecond(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->TSSSR, RTC_TSSSR_SS));
X  return (uint32_t)(((RTCx->TSSSR) & ((0xFFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Activate timestamp on tamper detection event
N  * @rmtoll TAFCR       TAMPTS        MS32_RTC_TS_EnableOnTamper
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TS_EnableOnTamper(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_TS_EnableOnTamper(RTC_TypeDef *RTCx) {
N  SET_BIT(RTCx->TAFCR, RTC_TAFCR_TAMPTS);
X  ((RTCx->TAFCR) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable timestamp on tamper detection event
N  * @rmtoll TAFCR       TAMPTS        MS32_RTC_TS_DisableOnTamper
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TS_DisableOnTamper(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_TS_DisableOnTamper(RTC_TypeDef *RTCx) {
N  CLEAR_BIT(RTCx->TAFCR, RTC_TAFCR_TAMPTS);
X  ((RTCx->TAFCR) &= ~((0x1UL << (7U))));
N}
N
N
N/** @defgroup RTC_EF_Tamper Tamper
N  * @{
N  */
N
N/**
N  * @brief  Enable RTC_TAMPx input detection
N  * @rmtoll TAFCR       TAMP1E        MS32_RTC_TAMPER_Enable\n
N  *         TAFCR       TAMP2E        MS32_RTC_TAMPER_Enable\n
N  *         TAFCR       TAMP3E        MS32_RTC_TAMPER_Enable
N  * @param  RTCx RTC Instance
N  * @param  Tamper This parameter can be a combination of the following values:
N  *         @arg @ref MS32_RTC_TAMPER_1
N  *         @arg @ref MS32_RTC_TAMPER_2
N  *         @arg @ref MS32_RTC_TAMPER_3 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TAMPER_Enable(RTC_TypeDef *RTCx, uint32_t Tamper) {
Xstatic __inline void MS32_RTC_TAMPER_Enable(RTC_TypeDef *RTCx, uint32_t Tamper) {
N  SET_BIT(RTCx->TAFCR, Tamper);
X  ((RTCx->TAFCR) |= (Tamper));
N}
N
N/**
N  * @brief  Clear RTC_TAMPx input detection
N  * @rmtoll TAFCR       TAMP1E        MS32_RTC_TAMPER_Disable\n
N  *         TAFCR       TAMP2E        MS32_RTC_TAMPER_Disable\n
N  *         TAFCR       TAMP3E        MS32_RTC_TAMPER_Disable
N  * @param  RTCx RTC Instance
N  * @param  Tamper This parameter can be a combination of the following values:
N  *         @arg @ref MS32_RTC_TAMPER_1
N  *         @arg @ref MS32_RTC_TAMPER_2
N  *         @arg @ref MS32_RTC_TAMPER_3 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TAMPER_Disable(RTC_TypeDef *RTCx, uint32_t Tamper) {
Xstatic __inline void MS32_RTC_TAMPER_Disable(RTC_TypeDef *RTCx, uint32_t Tamper) {
N  CLEAR_BIT(RTCx->TAFCR, Tamper);
X  ((RTCx->TAFCR) &= ~(Tamper));
N}
N
N/**
N  * @brief  Disable RTC_TAMPx pull-up disable (Disable precharge of RTC_TAMPx pins)
N  * @rmtoll TAFCR       TAMPPUDIS     MS32_RTC_TAMPER_DisablePullUp
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TAMPER_DisablePullUp(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_TAMPER_DisablePullUp(RTC_TypeDef *RTCx) {
N  SET_BIT(RTCx->TAFCR, RTC_TAFCR_TAMPPUDIS);
X  ((RTCx->TAFCR) |= ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Enable RTC_TAMPx pull-up disable ( Precharge RTC_TAMPx pins before sampling)
N  * @rmtoll TAFCR       TAMPPUDIS     MS32_RTC_TAMPER_EnablePullUp
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TAMPER_EnablePullUp(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_TAMPER_EnablePullUp(RTC_TypeDef *RTCx) {
N  CLEAR_BIT(RTCx->TAFCR, RTC_TAFCR_TAMPPUDIS);
X  ((RTCx->TAFCR) &= ~((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Set RTC_TAMPx precharge duration
N  * @rmtoll TAFCR       TAMPPRCH      MS32_RTC_TAMPER_SetPrecharge
N  * @param  RTCx RTC Instance
N  * @param  Duration This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_TAMPER_DURATION_1RTCCLK
N  *         @arg @ref MS32_RTC_TAMPER_DURATION_2RTCCLK
N  *         @arg @ref MS32_RTC_TAMPER_DURATION_4RTCCLK
N  *         @arg @ref MS32_RTC_TAMPER_DURATION_8RTCCLK
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TAMPER_SetPrecharge(RTC_TypeDef *RTCx, uint32_t Duration) {
Xstatic __inline void MS32_RTC_TAMPER_SetPrecharge(RTC_TypeDef *RTCx, uint32_t Duration) {
N  MODIFY_REG(RTCx->TAFCR, RTC_TAFCR_TAMPPRCH, Duration);
X  (((RTCx->TAFCR)) = ((((((RTCx->TAFCR))) & (~((0x3UL << (13U))))) | (Duration))));
N}
N
N/**
N  * @brief  Get RTC_TAMPx precharge duration
N  * @rmtoll TAFCR       TAMPPRCH      MS32_RTC_TAMPER_GetPrecharge
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_TAMPER_DURATION_1RTCCLK
N  *         @arg @ref MS32_RTC_TAMPER_DURATION_2RTCCLK
N  *         @arg @ref MS32_RTC_TAMPER_DURATION_4RTCCLK
N  *         @arg @ref MS32_RTC_TAMPER_DURATION_8RTCCLK
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TAMPER_GetPrecharge(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TAMPER_GetPrecharge(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->TAFCR, RTC_TAFCR_TAMPPRCH));
X  return (uint32_t)(((RTCx->TAFCR) & ((0x3UL << (13U)))));
N}
N
N/**
N  * @brief  Set RTC_TAMPx filter count
N  * @rmtoll TAFCR       TAMPFLT       MS32_RTC_TAMPER_SetFilterCount
N  * @param  RTCx RTC Instance
N  * @param  FilterCount This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_TAMPER_FILTER_DISABLE
N  *         @arg @ref MS32_RTC_TAMPER_FILTER_2SAMPLE
N  *         @arg @ref MS32_RTC_TAMPER_FILTER_4SAMPLE
N  *         @arg @ref MS32_RTC_TAMPER_FILTER_8SAMPLE
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TAMPER_SetFilterCount(RTC_TypeDef *RTCx, uint32_t FilterCount) {
Xstatic __inline void MS32_RTC_TAMPER_SetFilterCount(RTC_TypeDef *RTCx, uint32_t FilterCount) {
N  MODIFY_REG(RTCx->TAFCR, RTC_TAFCR_TAMPFLT, FilterCount);
X  (((RTCx->TAFCR)) = ((((((RTCx->TAFCR))) & (~((0x3UL << (11U))))) | (FilterCount))));
N}
N
N/**
N  * @brief  Get RTC_TAMPx filter count
N  * @rmtoll TAFCR       TAMPFLT       MS32_RTC_TAMPER_GetFilterCount
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_TAMPER_FILTER_DISABLE
N  *         @arg @ref MS32_RTC_TAMPER_FILTER_2SAMPLE
N  *         @arg @ref MS32_RTC_TAMPER_FILTER_4SAMPLE
N  *         @arg @ref MS32_RTC_TAMPER_FILTER_8SAMPLE
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TAMPER_GetFilterCount(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TAMPER_GetFilterCount(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->TAFCR, RTC_TAFCR_TAMPFLT));
X  return (uint32_t)(((RTCx->TAFCR) & ((0x3UL << (11U)))));
N}
N
N/**
N  * @brief  Set Tamper sampling frequency
N  * @rmtoll TAFCR       TAMPFREQ      MS32_RTC_TAMPER_SetSamplingFreq
N  * @param  RTCx RTC Instance
N  * @param  SamplingFreq This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_32768
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_16384
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_8192
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_4096
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_2048
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_1024
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_512
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_256
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TAMPER_SetSamplingFreq(RTC_TypeDef *RTCx, uint32_t SamplingFreq) {
Xstatic __inline void MS32_RTC_TAMPER_SetSamplingFreq(RTC_TypeDef *RTCx, uint32_t SamplingFreq) {
N  MODIFY_REG(RTCx->TAFCR, RTC_TAFCR_TAMPFREQ, SamplingFreq);
X  (((RTCx->TAFCR)) = ((((((RTCx->TAFCR))) & (~((0x7UL << (8U))))) | (SamplingFreq))));
N}
N
N/**
N  * @brief  Get Tamper sampling frequency
N  * @rmtoll TAFCR       TAMPFREQ      MS32_RTC_TAMPER_GetSamplingFreq
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_32768
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_16384
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_8192
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_4096
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_2048
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_1024
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_512
N  *         @arg @ref MS32_RTC_TAMPER_SAMPLFREQDIV_256
N  */
N__STATIC_INLINE uint32_t MS32_RTC_TAMPER_GetSamplingFreq(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_TAMPER_GetSamplingFreq(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->TAFCR, RTC_TAFCR_TAMPFREQ));
X  return (uint32_t)(((RTCx->TAFCR) & ((0x7UL << (8U)))));
N}
N
N/**
N  * @brief  Enable Active level for Tamper input
N  * @rmtoll TAFCR       TAMP1TRG      MS32_RTC_TAMPER_EnableActiveLevel\n
N  *         TAFCR       TAMP2TRG      MS32_RTC_TAMPER_EnableActiveLevel\n
N  *         TAFCR       TAMP3TRG      MS32_RTC_TAMPER_EnableActiveLevel
N  * @param  RTCx RTC Instance
N  * @param  Tamper This parameter can be a combination of the following values:
N  *         @arg @ref MS32_RTC_TAMPER_ACTIVELEVEL_TAMP1
N  *         @arg @ref MS32_RTC_TAMPER_ACTIVELEVEL_TAMP2
N  *         @arg @ref MS32_RTC_TAMPER_ACTIVELEVEL_TAMP3 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TAMPER_EnableActiveLevel(RTC_TypeDef *RTCx, uint32_t Tamper) {
Xstatic __inline void MS32_RTC_TAMPER_EnableActiveLevel(RTC_TypeDef *RTCx, uint32_t Tamper) {
N  SET_BIT(RTCx->TAFCR, Tamper);
X  ((RTCx->TAFCR) |= (Tamper));
N}
N
N/**
N  * @brief  Disable Active level for Tamper input
N  * @rmtoll TAFCR       TAMP1TRG      MS32_RTC_TAMPER_DisableActiveLevel\n
N  *         TAFCR       TAMP2TRG      MS32_RTC_TAMPER_DisableActiveLevel\n
N  *         TAFCR       TAMP3TRG      MS32_RTC_TAMPER_DisableActiveLevel
N  * @param  RTCx RTC Instance
N  * @param  Tamper This parameter can be a combination of the following values:
N  *         @arg @ref MS32_RTC_TAMPER_ACTIVELEVEL_TAMP1
N  *         @arg @ref MS32_RTC_TAMPER_ACTIVELEVEL_TAMP2
N  *         @arg @ref MS32_RTC_TAMPER_ACTIVELEVEL_TAMP3 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_TAMPER_DisableActiveLevel(RTC_TypeDef *RTCx, uint32_t Tamper) {
Xstatic __inline void MS32_RTC_TAMPER_DisableActiveLevel(RTC_TypeDef *RTCx, uint32_t Tamper) {
N  CLEAR_BIT(RTCx->TAFCR, Tamper);
X  ((RTCx->TAFCR) &= ~(Tamper));
N}
N
N
N/** @defgroup RTC_EF_Backup_Registers Backup_Registers
N  * @{
N  */
N
N/**
N  * @brief  Writes a data in a specified RTC Backup data register.
N  * @rmtoll BKPxR        BKP           MS32_RTC_BAK_SetRegister
N  * @param  RTCx RTC Instance
N  * @param  BackupRegister This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_BKP_DR0
N  *         @arg @ref MS32_RTC_BKP_DR1
N  *         @arg @ref MS32_RTC_BKP_DR2
N  *         @arg @ref MS32_RTC_BKP_DR3
N  *         @arg @ref MS32_RTC_BKP_DR4
N  * @param  Data Value between Min_Data=0x00 and Max_Data=0xFFFFFFFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_BAK_SetRegister(RTC_TypeDef *RTCx, uint32_t BackupRegister, uint32_t Data) {
Xstatic __inline void MS32_RTC_BAK_SetRegister(RTC_TypeDef *RTCx, uint32_t BackupRegister, uint32_t Data) {
N  register uint32_t tmp = 0U;
N
N  tmp = (uint32_t)(&(RTCx->BKP0R));
N  tmp += (BackupRegister * 4U);
N
N  /* Write the specified register */
N  *(__IO uint32_t *)tmp = (uint32_t)Data;
X  *(volatile uint32_t *)tmp = (uint32_t)Data;
N}
N
N/**
N  * @brief  Reads data from the specified RTC Backup data Register.
N  * @rmtoll BKPxR        BKP           MS32_RTC_BAK_GetRegister
N  * @param  RTCx RTC Instance
N  * @param  BackupRegister This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_BKP_DR0
N  *         @arg @ref MS32_RTC_BKP_DR1
N  *         @arg @ref MS32_RTC_BKP_DR2
N  *         @arg @ref MS32_RTC_BKP_DR3
N  *         @arg @ref MS32_RTC_BKP_DR4
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFFFFFFFF
N  */
N__STATIC_INLINE uint32_t MS32_RTC_BAK_GetRegister(RTC_TypeDef *RTCx, uint32_t BackupRegister) {
Xstatic __inline uint32_t MS32_RTC_BAK_GetRegister(RTC_TypeDef *RTCx, uint32_t BackupRegister) {
N  register uint32_t tmp = 0U;
N
N  tmp = (uint32_t)(&(RTCx->BKP0R));
N  tmp += (BackupRegister * 4U);
N
N  /* Read the specified register */
N  return (*(__IO uint32_t *)tmp);
X  return (*(volatile uint32_t *)tmp);
N}
N
N
N/** @defgroup RTC_EF_Calibration Calibration
N  * @{
N  */
N
N/**
N  * @brief  Set Calibration output frequency (1 Hz or 512 Hz)
N  * @note Bits are write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           COE           MS32_RTC_CAL_SetOutputFreq\n
N  *         CR           COSEL         MS32_RTC_CAL_SetOutputFreq
N  * @param  RTCx RTC Instance
N  * @param  Frequency This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_CALIB_OUTPUT_NONE
N  *         @arg @ref MS32_RTC_CALIB_OUTPUT_1HZ
N  *         @arg @ref MS32_RTC_CALIB_OUTPUT_512HZ
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_CAL_SetOutputFreq(RTC_TypeDef *RTCx, uint32_t Frequency) {
Xstatic __inline void MS32_RTC_CAL_SetOutputFreq(RTC_TypeDef *RTCx, uint32_t Frequency) {
N  MODIFY_REG(RTCx->CR, RTC_CR_COE | RTC_CR_COSEL, Frequency);
X  (((RTCx->CR)) = ((((((RTCx->CR))) & (~((0x1UL << (23U)) | (0x1UL << (19U))))) | (Frequency))));
N}
N
N/**
N  * @brief  Get Calibration output frequency (1 Hz or 512 Hz)
N  * @rmtoll CR           COE           MS32_RTC_CAL_GetOutputFreq\n
N  *         CR           COSEL         MS32_RTC_CAL_GetOutputFreq
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_CALIB_OUTPUT_NONE
N  *         @arg @ref MS32_RTC_CALIB_OUTPUT_1HZ
N  *         @arg @ref MS32_RTC_CALIB_OUTPUT_512HZ
N  */
N__STATIC_INLINE uint32_t MS32_RTC_CAL_GetOutputFreq(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_CAL_GetOutputFreq(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->CR, RTC_CR_COE | RTC_CR_COSEL));
X  return (uint32_t)(((RTCx->CR) & ((0x1UL << (23U)) | (0x1UL << (19U)))));
N}
N
N/**
N  * @brief  Insert or not One RTCCLK pulse every 2exp11 pulses (frequency increased by 488.5 ppm)
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @note Bit can be written only when RECALPF is set to 0 in RTC_ISR
N  * @rmtoll CALR         CALP          MS32_RTC_CAL_SetPulse
N  * @param  RTCx RTC Instance
N  * @param  Pulse This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_CALIB_INSERTPULSE_NONE
N  *         @arg @ref MS32_RTC_CALIB_INSERTPULSE_SET
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_CAL_SetPulse(RTC_TypeDef *RTCx, uint32_t Pulse) {
Xstatic __inline void MS32_RTC_CAL_SetPulse(RTC_TypeDef *RTCx, uint32_t Pulse) {
N  MODIFY_REG(RTCx->CALR, RTC_CALR_CALP, Pulse);
X  (((RTCx->CALR)) = ((((((RTCx->CALR))) & (~((0x1UL << (15U))))) | (Pulse))));
N}
N
N/**
N  * @brief  Check if one RTCCLK has been inserted or not every 2exp11 pulses (frequency increased by 488.5 ppm)
N  * @rmtoll CALR         CALP          MS32_RTC_CAL_IsPulseInserted
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_CAL_IsPulseInserted(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_CAL_IsPulseInserted(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->CALR, RTC_CALR_CALP) == (RTC_CALR_CALP));
X  return (((RTCx->CALR) & ((0x1UL << (15U)))) == ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Set the calibration cycle period
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @note   Bit can be written only when RECALPF is set to 0 in RTC_ISR
N  * @rmtoll CALR         CALW8         MS32_RTC_CAL_SetPeriod\n
N  *         CALR         CALW16        MS32_RTC_CAL_SetPeriod
N  * @param  RTCx RTC Instance
N  * @param  Period This parameter can be one of the following values:
N  *         @arg @ref MS32_RTC_CALIB_PERIOD_32SEC
N  *         @arg @ref MS32_RTC_CALIB_PERIOD_16SEC
N  *         @arg @ref MS32_RTC_CALIB_PERIOD_8SEC
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_CAL_SetPeriod(RTC_TypeDef *RTCx, uint32_t Period) {
Xstatic __inline void MS32_RTC_CAL_SetPeriod(RTC_TypeDef *RTCx, uint32_t Period) {
N  MODIFY_REG(RTCx->CALR, RTC_CALR_CALW8 | RTC_CALR_CALW16, Period);
X  (((RTCx->CALR)) = ((((((RTCx->CALR))) & (~((0x1UL << (14U)) | (0x1UL << (13U))))) | (Period))));
N}
N
N/**
N  * @brief  Get the calibration cycle period
N  * @rmtoll CALR         CALW8         MS32_RTC_CAL_GetPeriod\n
N  *         CALR         CALW16        MS32_RTC_CAL_GetPeriod
N  * @param  RTCx RTC Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_RTC_CALIB_PERIOD_32SEC
N  *         @arg @ref MS32_RTC_CALIB_PERIOD_16SEC
N  *         @arg @ref MS32_RTC_CALIB_PERIOD_8SEC
N  */
N__STATIC_INLINE uint32_t MS32_RTC_CAL_GetPeriod(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_CAL_GetPeriod(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->CALR, RTC_CALR_CALW8 | RTC_CALR_CALW16));
X  return (uint32_t)(((RTCx->CALR) & ((0x1UL << (14U)) | (0x1UL << (13U)))));
N}
N
N/**
N  * @brief  Set Calibration minus
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @note   Bit can be written only when RECALPF is set to 0 in RTC_ISR
N  * @rmtoll CALR         CALM          MS32_RTC_CAL_SetMinus
N  * @param  RTCx RTC Instance
N  * @param  CalibMinus Value between Min_Data=0x00 and Max_Data=0x1FF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_CAL_SetMinus(RTC_TypeDef *RTCx, uint32_t CalibMinus) {
Xstatic __inline void MS32_RTC_CAL_SetMinus(RTC_TypeDef *RTCx, uint32_t CalibMinus) {
N  MODIFY_REG(RTCx->CALR, RTC_CALR_CALM, CalibMinus);
X  (((RTCx->CALR)) = ((((((RTCx->CALR))) & (~((0x1FFUL << (0U))))) | (CalibMinus))));
N}
N
N/**
N  * @brief  Get Calibration minus
N  * @rmtoll CALR         CALM          MS32_RTC_CAL_GetMinus
N  * @param  RTCx RTC Instance
N  * @retval Value between Min_Data=0x00 and Max_Data= 0x1FF
N  */
N__STATIC_INLINE uint32_t MS32_RTC_CAL_GetMinus(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_CAL_GetMinus(RTC_TypeDef *RTCx) {
N  return (uint32_t)(READ_BIT(RTCx->CALR, RTC_CALR_CALM));
X  return (uint32_t)(((RTCx->CALR) & ((0x1FFUL << (0U)))));
N}
N
N
N/** @defgroup RTC_EF_FLAG_Management FLAG_Management
N  * @{
N  */
N
N/**
N  * @brief  Get Recalibration pending Flag
N  * @rmtoll ISR          RECALPF       MS32_RTC_IsActiveFlag_RECALP
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_IsActiveFlag_RECALP(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_IsActiveFlag_RECALP(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->ISR, RTC_ISR_RECALPF) == (RTC_ISR_RECALPF));
X  return (((RTCx->ISR) & ((0x1UL << (16U)))) == ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Get RTC_TAMP2 detection flag
N  * @rmtoll ISR          TAMP2F        MS32_RTC_IsActiveFlag_TAMP2
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_IsActiveFlag_TAMP2(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_IsActiveFlag_TAMP2(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->ISR, RTC_ISR_TAMP2F) == (RTC_ISR_TAMP2F));
X  return (((RTCx->ISR) & ((0x1UL << (14U)))) == ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Get RTC_TAMP1 detection flag
N  * @rmtoll ISR          TAMP1F        MS32_RTC_IsActiveFlag_TAMP1
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_IsActiveFlag_TAMP1(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_IsActiveFlag_TAMP1(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->ISR, RTC_ISR_TAMP1F) == (RTC_ISR_TAMP1F));
X  return (((RTCx->ISR) & ((0x1UL << (13U)))) == ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Get Time-stamp overflow flag
N  * @rmtoll ISR          TSOVF         MS32_RTC_IsActiveFlag_TSOV
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_IsActiveFlag_TSOV(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_IsActiveFlag_TSOV(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->ISR, RTC_ISR_TSOVF) == (RTC_ISR_TSOVF));
X  return (((RTCx->ISR) & ((0x1UL << (12U)))) == ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Get Time-stamp flag
N  * @rmtoll ISR          TSF           MS32_RTC_IsActiveFlag_TS
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_IsActiveFlag_TS(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_IsActiveFlag_TS(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->ISR, RTC_ISR_TSF) == (RTC_ISR_TSF));
X  return (((RTCx->ISR) & ((0x1UL << (11U)))) == ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Get Alarm A flag
N  * @rmtoll ISR          ALRAF         MS32_RTC_IsActiveFlag_ALRA
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_IsActiveFlag_ALRA(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_IsActiveFlag_ALRA(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->ISR, RTC_ISR_ALRAF) == (RTC_ISR_ALRAF));
X  return (((RTCx->ISR) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Clear RTC_TAMP2 detection flag
N  * @rmtoll ISR          TAMP2F        MS32_RTC_ClearFlag_TAMP2
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ClearFlag_TAMP2(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_ClearFlag_TAMP2(RTC_TypeDef *RTCx) {
N  WRITE_REG(RTCx->ISR, (~((RTC_ISR_TAMP2F | RTC_ISR_INIT) & 0x0000FFFFU) | (RTCx->ISR & RTC_ISR_INIT)));
X  ((RTCx->ISR) = ((~(((0x1UL << (14U)) | (0x1UL << (7U))) & 0x0000FFFFU) | (RTCx->ISR & (0x1UL << (7U))))));
N}
N
N/**
N  * @brief  Clear RTC_TAMP1 detection flag
N  * @rmtoll ISR          TAMP1F        MS32_RTC_ClearFlag_TAMP1
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ClearFlag_TAMP1(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_ClearFlag_TAMP1(RTC_TypeDef *RTCx) {
N  WRITE_REG(RTCx->ISR, (~((RTC_ISR_TAMP1F | RTC_ISR_INIT) & 0x0000FFFFU) | (RTCx->ISR & RTC_ISR_INIT)));
X  ((RTCx->ISR) = ((~(((0x1UL << (13U)) | (0x1UL << (7U))) & 0x0000FFFFU) | (RTCx->ISR & (0x1UL << (7U))))));
N}
N
N/**
N  * @brief  Clear Time-stamp overflow flag
N  * @rmtoll ISR          TSOVF         MS32_RTC_ClearFlag_TSOV
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ClearFlag_TSOV(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_ClearFlag_TSOV(RTC_TypeDef *RTCx) {
N  WRITE_REG(RTCx->ISR, (~((RTC_ISR_TSOVF | RTC_ISR_INIT) & 0x0000FFFFU) | (RTCx->ISR & RTC_ISR_INIT)));
X  ((RTCx->ISR) = ((~(((0x1UL << (12U)) | (0x1UL << (7U))) & 0x0000FFFFU) | (RTCx->ISR & (0x1UL << (7U))))));
N}
N
N/**
N  * @brief  Clear Time-stamp flag
N  * @rmtoll ISR          TSF           MS32_RTC_ClearFlag_TS
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ClearFlag_TS(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_ClearFlag_TS(RTC_TypeDef *RTCx) {
N  WRITE_REG(RTCx->ISR, (~((RTC_ISR_TSF | RTC_ISR_INIT) & 0x0000FFFFU) | (RTCx->ISR & RTC_ISR_INIT)));
X  ((RTCx->ISR) = ((~(((0x1UL << (11U)) | (0x1UL << (7U))) & 0x0000FFFFU) | (RTCx->ISR & (0x1UL << (7U))))));
N}
N
N/**
N  * @brief  Clear Alarm A flag
N  * @rmtoll ISR          ALRAF         MS32_RTC_ClearFlag_ALRA
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ClearFlag_ALRA(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_ClearFlag_ALRA(RTC_TypeDef *RTCx) {
N  WRITE_REG(RTCx->ISR, (~((RTC_ISR_ALRAF | RTC_ISR_INIT) & 0x0000FFFFU) | (RTCx->ISR & RTC_ISR_INIT)));
X  ((RTCx->ISR) = ((~(((0x1UL << (8U)) | (0x1UL << (7U))) & 0x0000FFFFU) | (RTCx->ISR & (0x1UL << (7U))))));
N}
N
N/**
N  * @brief  Get Initialization flag
N  * @rmtoll ISR          INITF         MS32_RTC_IsActiveFlag_INIT
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_IsActiveFlag_INIT(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_IsActiveFlag_INIT(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->ISR, RTC_ISR_INITF) == (RTC_ISR_INITF));
X  return (((RTCx->ISR) & ((0x1UL << (6U)))) == ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Get Registers synchronization flag
N  * @rmtoll ISR          RSF           MS32_RTC_IsActiveFlag_RS
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_IsActiveFlag_RS(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_IsActiveFlag_RS(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->ISR, RTC_ISR_RSF) == (RTC_ISR_RSF));
X  return (((RTCx->ISR) & ((0x1UL << (5U)))) == ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Clear Registers synchronization flag
N  * @rmtoll ISR          RSF           MS32_RTC_ClearFlag_RS
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_ClearFlag_RS(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_ClearFlag_RS(RTC_TypeDef *RTCx) {
N  WRITE_REG(RTCx->ISR, (~((RTC_ISR_RSF | RTC_ISR_INIT) & 0x0000FFFFU) | (RTCx->ISR & RTC_ISR_INIT)));
X  ((RTCx->ISR) = ((~(((0x1UL << (5U)) | (0x1UL << (7U))) & 0x0000FFFFU) | (RTCx->ISR & (0x1UL << (7U))))));
N}
N
N/**
N  * @brief  Get Initialization status flag
N  * @rmtoll ISR          INITS         MS32_RTC_IsActiveFlag_INITS
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_IsActiveFlag_INITS(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_IsActiveFlag_INITS(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->ISR, RTC_ISR_INITS) == (RTC_ISR_INITS));
X  return (((RTCx->ISR) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Get Shift operation pending flag
N  * @rmtoll ISR          SHPF          MS32_RTC_IsActiveFlag_SHP
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_IsActiveFlag_SHP(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_IsActiveFlag_SHP(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->ISR, RTC_ISR_SHPF) == (RTC_ISR_SHPF));
X  return (((RTCx->ISR) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Get Alarm A write flag
N  * @rmtoll ISR          ALRAWF        MS32_RTC_IsActiveFlag_ALRAW
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_IsActiveFlag_ALRAW(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_IsActiveFlag_ALRAW(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->ISR, RTC_ISR_ALRAWF) == (RTC_ISR_ALRAWF));
X  return (((RTCx->ISR) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N
N/** @defgroup RTC_EF_IT_Management IT_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable Time-stamp interrupt
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           TSIE          MS32_RTC_EnableIT_TS
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_EnableIT_TS(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_EnableIT_TS(RTC_TypeDef *RTCx) {
N  SET_BIT(RTCx->CR, RTC_CR_TSIE);
X  ((RTCx->CR) |= ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Disable Time-stamp interrupt
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           TSIE          MS32_RTC_DisableIT_TS
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_DisableIT_TS(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_DisableIT_TS(RTC_TypeDef *RTCx) {
N  CLEAR_BIT(RTCx->CR, RTC_CR_TSIE);
X  ((RTCx->CR) &= ~((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Enable Alarm A interrupt
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           ALRAIE        MS32_RTC_EnableIT_ALRA
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_EnableIT_ALRA(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_EnableIT_ALRA(RTC_TypeDef *RTCx) {
N  SET_BIT(RTCx->CR, RTC_CR_ALRAIE);
X  ((RTCx->CR) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Disable Alarm A interrupt
N  * @note   Bit is write-protected. @ref MS32_RTC_DisableWriteProtection function should be called before.
N  * @rmtoll CR           ALRAIE        MS32_RTC_DisableIT_ALRA
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_DisableIT_ALRA(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_DisableIT_ALRA(RTC_TypeDef *RTCx) {
N  CLEAR_BIT(RTCx->CR, RTC_CR_ALRAIE);
X  ((RTCx->CR) &= ~((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Enable all Tamper Interrupt
N  * @rmtoll TAFCR       TAMPIE        MS32_RTC_EnableIT_TAMP
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_EnableIT_TAMP(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_EnableIT_TAMP(RTC_TypeDef *RTCx) {
N  SET_BIT(RTCx->TAFCR, RTC_TAFCR_TAMPIE);
X  ((RTCx->TAFCR) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Disable all Tamper Interrupt
N  * @rmtoll TAFCR       TAMPIE        MS32_RTC_DisableIT_TAMP
N  * @param  RTCx RTC Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_RTC_DisableIT_TAMP(RTC_TypeDef *RTCx) {
Xstatic __inline void MS32_RTC_DisableIT_TAMP(RTC_TypeDef *RTCx) {
N  CLEAR_BIT(RTCx->TAFCR, RTC_TAFCR_TAMPIE);
X  ((RTCx->TAFCR) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Check if  Time-stamp interrupt is enabled or not
N  * @rmtoll CR           TSIE          MS32_RTC_IsEnabledIT_TS
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_IsEnabledIT_TS(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_IsEnabledIT_TS(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->CR, RTC_CR_TSIE) == (RTC_CR_TSIE));
X  return (((RTCx->CR) & ((0x1UL << (15U)))) == ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Check if  Alarm A interrupt is enabled or not
N  * @rmtoll CR           ALRAIE        MS32_RTC_IsEnabledIT_ALRA
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_IsEnabledIT_ALRA(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_IsEnabledIT_ALRA(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->CR, RTC_CR_ALRAIE) == (RTC_CR_ALRAIE));
X  return (((RTCx->CR) & ((0x1UL << (12U)))) == ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Check if all the TAMPER interrupts are enabled or not
N  * @rmtoll TAFCR       TAMPIE        MS32_RTC_IsEnabledIT_TAMP
N  * @param  RTCx RTC Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_RTC_IsEnabledIT_TAMP(RTC_TypeDef *RTCx) {
Xstatic __inline uint32_t MS32_RTC_IsEnabledIT_TAMP(RTC_TypeDef *RTCx) {
N  return (READ_BIT(RTCx->TAFCR,
N                   RTC_TAFCR_TAMPIE) == (RTC_TAFCR_TAMPIE));
X  return (((RTCx->TAFCR) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N
N/** @defgroup RTC_EF_Init Initialization and de-initialization functions
N  * @{
N  */
NErrorStatus MS32_RTC_ClockInit      (uint32_t RtcClock);
NErrorStatus MS32_RTC_DeInit         (RTC_TypeDef *RTCx);
Nvoid        MS32_RTC_StructInit     (MS32_RTC_InitTypeDef *RtcInitStr);
NErrorStatus MS32_RTC_Init           (RTC_TypeDef *RTCx, MS32_RTC_InitTypeDef *RtcInitStr, uint32_t RefInEn, uint32_t CoeFunc);
Nvoid        MS32_RTC_ITConfig       (RTC_TypeDef *RTCx, uint32_t InterruptFunc, uint32_t Priority);
N
NErrorStatus MS32_RTC_SetTime        (RTC_TypeDef *RTCx, uint32_t RtcFormat, MS32_RTC_TimeTypeDef *RtcTimeStr, uint32_t ShadowBypassEn);
Nvoid        MS32_RTC_GetTime        (RTC_TypeDef *RTCx, MS32_RTC_TimeTypeDef *RtcTimeStr);
NErrorStatus MS32_RTC_SetDate        (RTC_TypeDef *RTCx, uint32_t RtcFormat, MS32_RTC_DateTypeDef *RtcDateStr);
Nvoid        MS32_RTC_GetDate        (RTC_TypeDef *RTCx, MS32_RTC_DateTypeDef *RtcDateStr);
NErrorStatus MS32_RTC_SetAlarm       (RTC_TypeDef *RTCx, uint32_t RtcFormat, MS32_RTC_AlarmTypeDef *RtcAlarmStr);
Nvoid        MS32_RTC_GetAlarm       (RTC_TypeDef *RTCx, MS32_RTC_AlarmTypeDef *RtcAlarmStr);
Nvoid        MS32_RTC_GetTimStamp    (RTC_TypeDef *RTCx, MS32_RTC_TimStampTypeDef *RtcTimStampStr);
N
Nvoid        MS32_RTC_AlarmConfig    (RTC_TypeDef *RTCx, uint32_t AlarmOutEn, uint32_t AlarmOutPol, FunctionalState AlarmEn);
Nvoid        MS32_RTC_TimStampConfig (RTC_TypeDef *RTCx, uint32_t TimStampEn, uint32_t TimStampEdge);
Nvoid        MS32_RTC_TampConfig     (RTC_TypeDef *RTCx, uint32_t TampPu, uint32_t TampPre, uint32_t TampFlt, uint32_t );
N
N/** @defgroup RTC_EF_Application function
N  * @{
N  */
NFlagStatus  MS32_RTC_GetStatusFlag  (RTC_TypeDef *RTCx, uint32_t Flags);
Nvoid        MS32_RTC_ChangeOneHour  (RTC_TypeDef *RTCx, uint32_t Effect);
Nvoid        MS32_RTC_ShiftSec       (RTC_TypeDef *RTCx, uint32_t ShiftSecond, uint16_t Fraction);
Nvoid        MS32_RTC_Cal            (RTC_TypeDef *RTCx, uint32_t InsertPulse, uint32_t Period, uint16_t CalMin);
Nvoid        MS32_RTC_SetPin         (RTC_TypeDef *RTCx, uint32_t Pin, uint32_t Level);
NErrorStatus MS32_RTC_EnterInitMode  (RTC_TypeDef *RTCx);
NErrorStatus MS32_RTC_ExitInitMode   (RTC_TypeDef *RTCx);
NErrorStatus MS32_RTC_WaitForSynchro (RTC_TypeDef *RTCx);
N
N
N#endif /* __MS32F0XX_RTC_H */
N
N/******************************** END OF FILE *********************************/
L 78 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_spi.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_spi.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_SPI_H
N#define __MS32F0XX_SPI_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/**
N  * @brief  SPI Init structures definition
N  */
Ntypedef struct {
N  uint32_t TransferDirection;       /*!< Specifies the SPI unidirectional or bidirectional data mode.
N                                         This parameter can be a value of @ref SPI_EC_TRANSFER_MODE.
N                                         This feature can be modified afterwards using unitary function @ref MS32_SPI_SetTransferDirection().*/
N  uint32_t Mode;                    /*!< Specifies the SPI mode (Master/Slave).
N                                         This parameter can be a value of @ref SPI_EC_MODE.
N                                         This feature can be modified afterwards using unitary function @ref MS32_SPI_SetMode().*/
N  uint32_t DataWidth;               /*!< Specifies the SPI data width.
N                                         This parameter can be a value of @ref SPI_EC_DATAWIDTH.
N                                         This feature can be modified afterwards using unitary function @ref MS32_SPI_SetDataWidth().*/
N  uint32_t ClockPolarity;           /*!< Specifies the serial clock steady state.
N                                         This parameter can be a value of @ref SPI_EC_POLARITY.
N                                         This feature can be modified afterwards using unitary function @ref MS32_SPI_SetClockPolarity().*/
N  uint32_t ClockPhase;              /*!< Specifies the clock active edge for the bit capture.
N                                         This parameter can be a value of @ref SPI_EC_PHASE.
N                                         This feature can be modified afterwards using unitary function @ref MS32_SPI_SetClockPhase().*/
N  uint32_t NSS;                     /*!< Specifies whether the NSS signal is managed by hardware (NSS pin) or by software using the SSI bit.
N                                         This parameter can be a value of @ref SPI_EC_NSS_MODE.
N                                         This feature can be modified afterwards using unitary function @ref MS32_SPI_SetNSSMode().*/
N  uint32_t BaudRate;                /*!< Specifies the BaudRate prescaler value which will be used to configure the transmit and receive SCK clock.
N                                         This parameter can be a value of @ref SPI_EC_BAUDRATEPRESCALER.
N                                         @note The communication clock is derived from the master clock. The slave clock does not need to be set.
N                                         This feature can be modified afterwards using unitary function @ref MS32_SPI_SetBaudRatePrescaler().*/
N  uint32_t BitOrder;                /*!< Specifies whether data transfers start from MSB or LSB bit.
N                                         This parameter can be a value of @ref SPI_EC_BIT_ORDER.
N                                         This feature can be modified afterwards using unitary function @ref MS32_SPI_SetTransferBitOrder().*/
N  uint32_t CRCCalculation;          /*!< Specifies if the CRC calculation is enabled or not.
N                                         This parameter can be a value of @ref SPI_EC_CRC_CALCULATION.
N                                         This feature can be modified afterwards using unitary functions @ref MS32_SPI_EnableCRC() and @ref MS32_SPI_DisableCRC().*/
N  uint32_t CRCPoly;                 /*!< Specifies the polynomial used for the CRC calculation.
N                                         This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFFFF.
N                                         This feature can be modified afterwards using unitary function @ref MS32_SPI_SetCRCPolynomial().*/
N} MS32_SPI_InitTypeDef;
N
N/**
N  * @brief  I2S Init structure definition
N  */
Ntypedef struct {
N  uint32_t Mode;                    /*!< Specifies the I2S operating mode.
N                                         This parameter can be a value of @ref I2S_EC_MODE
N                                         This feature can be modified afterwards using unitary function @ref MS32_I2S_SetTransferMode().*/
N  uint32_t Standard;                /*!< Specifies the standard used for the I2S communication.
N                                         This parameter can be a value of @ref I2S_EC_STANDARD
N                                         This feature can be modified afterwards using unitary function @ref MS32_I2S_SetStandard().*/
N  uint32_t DataFormat;              /*!< Specifies the data format for the I2S communication.
N                                         This parameter can be a value of @ref I2S_EC_DATA_FORMAT
N                                         This feature can be modified afterwards using unitary function @ref MS32_I2S_SetDataFormat().*/
N  uint32_t MCLKOutput;              /*!< Specifies whether the I2S MCLK output is enabled or not.
N                                         This parameter can be a value of @ref I2S_EC_MCLK_OUTPUT
N                                         This feature can be modified afterwards using unitary functions @ref MS32_I2S_EnableMasterClock() or @ref MS32_I2S_DisableMasterClock.*/
N  uint32_t AudioFreq;               /*!< Specifies the frequency selected for the I2S communication.
N                                         This parameter can be a value of @ref I2S_EC_AUDIO_FREQ
N                                         Audio Frequency can be modified afterwards using Reference manual formulas to calculate Prescaler Linear, Parity
N                                         and unitary functions @ref MS32_I2S_SetPrescalerLinear() and @ref MS32_I2S_SetPrescalerParity() to set it.*/
N  uint32_t ClockPolarity;           /*!< Specifies the idle state of the I2S clock.
N                                         This parameter can be a value of @ref I2S_EC_POLARITY
N                                         This feature can be modified afterwards using unitary function @ref MS32_I2S_SetClockPolarity().*/
N} MS32_I2S_InitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup SPI_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with MS32_SPI_ReadReg function
N  * @{
N  */
N#define MS32_SPI_SR_RXNE                     SPI_SR_RXNE               /*!< Rx buffer not empty flag         */
N#define MS32_SPI_SR_TXE                      SPI_SR_TXE                /*!< Tx buffer empty flag             */
N#define MS32_SPI_SR_BSY                      SPI_SR_BSY                /*!< Busy flag                        */
N#define MS32_SPI_SR_CRCERR                   SPI_SR_CRCERR             /*!< CRC error flag                   */
N#define MS32_SPI_SR_MODF                     SPI_SR_MODF               /*!< Mode fault flag                  */
N#define MS32_SPI_SR_OVR                      SPI_SR_OVR                /*!< Overrun flag                     */
N#define MS32_SPI_SR_FRE                      SPI_SR_FRE                /*!< TI mode frame format error flag  */
N
N#define MS32_SPI_SR_ALLIF                    (SPI_SR_RXNE | SPI_SR_TXE | SPI_SR_CRCERR | SPI_SR_MODF | SPI_SR_OVR | SPI_SR_FRE)
N
N
N/** @defgroup SPI_EC_IT IT Defines
N  * @brief    IT defines which can be used with MS32_SPI_ReadReg and  MS32_SPI_WriteReg functions
N  * @{
N  */
N#define MS32_SPI_CR2_RXNEIE                  SPI_CR2_RXNEIE            /*!< Rx buffer not empty interrupt enable */
N#define MS32_SPI_CR2_TXEIE                   SPI_CR2_TXEIE             /*!< Tx buffer empty interrupt enable     */
N#define MS32_SPI_CR2_ERRIE                   SPI_CR2_ERRIE             /*!< Error interrupt enable               */
N
N#define MS32_SPI_CR2_ALLIE                   (SPI_CR2_RXNEIE | SPI_CR2_TXEIE | SPI_CR2_ERRIE)
N
N
N/** @defgroup SPI_EC_MODE Operation Mode
N  * @{
N  */
N#define MS32_SPI_MODE_MASTER                 (SPI_CR1_MSTR | SPI_CR1_SSI)    /*!< Master configuration  */
N#define MS32_SPI_MODE_SLAVE                  0x00000000U                     /*!< Slave configuration   */
N
N
N/** @defgroup SPI_EC_PROTOCOL Serial Protocol
N  * @{
N  */
N#define MS32_SPI_PROTOCOL_MOTOROLA           0x00000000U               /*!< Motorola mode. Used as default value */
N#define MS32_SPI_PROTOCOL_TI                 (SPI_CR2_FRF)             /*!< TI mode                              */
N
N
N/** @defgroup SPI_EC_PHASE Clock Phase
N  * @{
N  */
N#define MS32_SPI_PHASE_1EDGE                 0x00000000U               /*!< First clock transition is the first data capture edge  */
N#define MS32_SPI_PHASE_2EDGE                 (SPI_CR1_CPHA)            /*!< Second clock transition is the first data capture edge */
N
N
N/** @defgroup SPI_EC_POLARITY Clock Polarity
N  * @{
N  */
N#define MS32_SPI_POLARITY_LOW                0x00000000U               /*!< Clock to 0 when idle */
N#define MS32_SPI_POLARITY_HIGH               (SPI_CR1_CPOL)            /*!< Clock to 1 when idle */
N
N
N/** @defgroup SPI_EC_BAUDRATEPRESCALER Baud Rate Prescaler
N  * @{
N  */
N#define MS32_SPI_BAUDRATEPRESCALER_DIV2      0x00000000U                                    /*!< BaudRate control equal to fPCLK/2   */
N#define MS32_SPI_BAUDRATEPRESCALER_DIV4      (SPI_CR1_BR_0)                                 /*!< BaudRate control equal to fPCLK/4   */
N#define MS32_SPI_BAUDRATEPRESCALER_DIV8      (SPI_CR1_BR_1)                                 /*!< BaudRate control equal to fPCLK/8   */
N#define MS32_SPI_BAUDRATEPRESCALER_DIV16     (SPI_CR1_BR_1 | SPI_CR1_BR_0)                  /*!< BaudRate control equal to fPCLK/16  */
N#define MS32_SPI_BAUDRATEPRESCALER_DIV32     (SPI_CR1_BR_2)                                 /*!< BaudRate control equal to fPCLK/32  */
N#define MS32_SPI_BAUDRATEPRESCALER_DIV64     (SPI_CR1_BR_2 | SPI_CR1_BR_0)                  /*!< BaudRate control equal to fPCLK/64  */
N#define MS32_SPI_BAUDRATEPRESCALER_DIV128    (SPI_CR1_BR_2 | SPI_CR1_BR_1)                  /*!< BaudRate control equal to fPCLK/128 */
N#define MS32_SPI_BAUDRATEPRESCALER_DIV256    (SPI_CR1_BR_2 | SPI_CR1_BR_1 | SPI_CR1_BR_0)   /*!< BaudRate control equal to fPCLK/256 */
N
N
N/** @defgroup SPI_EC_BIT_ORDER Transmission Bit Order
N  * @{
N  */
N#define MS32_SPI_LSB_FIRST                   (SPI_CR1_LSBFIRST)        /*!< Data is transmitted/received with the LSB first */
N#define MS32_SPI_MSB_FIRST                   0x00000000U               /*!< Data is transmitted/received with the MSB first */
N
N
N/** @defgroup SPI_EC_TRANSFER_MODE Transfer Mode
N  * @{
N  */
N#define MS32_SPI_FUMS32_DUPLEX                 0x00000000U                          /*!< Full-Duplex mode. Rx and Tx transfer on 2 lines */
N#define MS32_SPI_SIMPLEX_RX                  (SPI_CR1_RXONLY)                     /*!< Simplex Rx mode.  Rx transfer only on 1 line    */
N#define MS32_SPI_HALF_DUPLEX_RX              (SPI_CR1_BIDIMODE)                   /*!< Half-Duplex Rx mode. Rx transfer on 1 line      */
N#define MS32_SPI_HALF_DUPLEX_TX              (SPI_CR1_BIDIMODE | SPI_CR1_BIDIOE)  /*!< Half-Duplex Tx mode. Tx transfer on 1 line      */
N
N
N/** @defgroup SPI_EC_NSS_MODE Slave Select Pin Mode
N  * @{
N  */
N#define MS32_SPI_NSS_SOFT                    (SPI_CR1_SSM)                     /*!< NSS managed internally. NSS pin not used and free              */
N#define MS32_SPI_NSS_HARD_INPUT              0x00000000U                       /*!< NSS pin used in Input. Only used in Master mode                */
N#define MS32_SPI_NSS_HARD_OUTPUT             (((uint32_t)SPI_CR2_SSOE << 16U)) /*!< NSS pin used in Output. Only used in Slave mode as chip select */
N
N
N/** @defgroup SPI_EC_DATAWIDTH Datawidth
N  * @{
N  */
N#define MS32_SPI_DATAWIDTH_4BIT              (SPI_CR2_DS_0 | SPI_CR2_DS_1)                               /*!< Data length for SPI transfer:  4 bits */
N#define MS32_SPI_DATAWIDTH_5BIT              (SPI_CR2_DS_2)                                              /*!< Data length for SPI transfer:  5 bits */
N#define MS32_SPI_DATAWIDTH_6BIT              (SPI_CR2_DS_2 | SPI_CR2_DS_0)                               /*!< Data length for SPI transfer:  6 bits */
N#define MS32_SPI_DATAWIDTH_7BIT              (SPI_CR2_DS_2 | SPI_CR2_DS_1)                               /*!< Data length for SPI transfer:  7 bits */
N#define MS32_SPI_DATAWIDTH_8BIT              (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0)                /*!< Data length for SPI transfer:  8 bits */
N#define MS32_SPI_DATAWIDTH_9BIT              (SPI_CR2_DS_3)                                              /*!< Data length for SPI transfer:  9 bits */
N#define MS32_SPI_DATAWIDTH_10BIT             (SPI_CR2_DS_3 | SPI_CR2_DS_0)                               /*!< Data length for SPI transfer: 10 bits */
N#define MS32_SPI_DATAWIDTH_11BIT             (SPI_CR2_DS_3 | SPI_CR2_DS_1)                               /*!< Data length for SPI transfer: 11 bits */
N#define MS32_SPI_DATAWIDTH_12BIT             (SPI_CR2_DS_3 | SPI_CR2_DS_1 | SPI_CR2_DS_0)                /*!< Data length for SPI transfer: 12 bits */
N#define MS32_SPI_DATAWIDTH_13BIT             (SPI_CR2_DS_3 | SPI_CR2_DS_2)                               /*!< Data length for SPI transfer: 13 bits */
N#define MS32_SPI_DATAWIDTH_14BIT             (SPI_CR2_DS_3 | SPI_CR2_DS_2 | SPI_CR2_DS_0)                /*!< Data length for SPI transfer: 14 bits */
N#define MS32_SPI_DATAWIDTH_15BIT             (SPI_CR2_DS_3 | SPI_CR2_DS_2 | SPI_CR2_DS_1)                /*!< Data length for SPI transfer: 15 bits */
N#define MS32_SPI_DATAWIDTH_16BIT             (SPI_CR2_DS_3 | SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0) /*!< Data length for SPI transfer: 16 bits */
N
N
N/** @defgroup SPI_EC_CRC_CALCULATION CRC Calculation
N  * @{
N  */
N#define MS32_SPI_CRCCALCULATION_DISABLE      0x00000000U               /*!< CRC calculation disabled */
N#define MS32_SPI_CRCCALCULATION_ENABLE       (SPI_CR1_CRCEN)           /*!< CRC calculation enabled  */
N
N
N/** @defgroup SPI_EC_CRC_LENGTH CRC Length
N  * @{
N  */
N#define MS32_SPI_CRC_8BIT                    0x00000000U               /*!<  8-bit CRC length */
N#define MS32_SPI_CRC_16BIT                   (SPI_CR1_CRCL)            /*!< 16-bit CRC length */
N
N
N/** @defgroup SPI_EC_RX_FIFO_TH RX FIFO Threshold
N  * @{
N  */
N#define MS32_SPI_RX_FIFO_TH_HALF             0x00000000U               /*!< RXNE event is generated if FIFO level is greater than or equel to 1/2 (16-bit) */
N#define MS32_SPI_RX_FIFO_TH_QUARTER          (SPI_CR2_FRXTH)           /*!< RXNE event is generated if FIFO level is greater than or equel to 1/4 (8-bit)  */
N
N
N/** @defgroup SPI_EC_RX_FIFO RX FIFO Level
N  * @{
N  */
N#define MS32_SPI_RX_FIFO_EMPTY               0x00000000U                       /*!< FIFO reception empty */
N#define MS32_SPI_RX_FIFO_QUARTER_FULL        (SPI_SR_FRLVL_0)                  /*!< FIFO reception 1/4   */
N#define MS32_SPI_RX_FIFO_HALF_FULL           (SPI_SR_FRLVL_1)                  /*!< FIFO reception 1/2   */
N#define MS32_SPI_RX_FIFO_FULL                (SPI_SR_FRLVL_1 | SPI_SR_FRLVL_0) /*!< FIFO reception full  */
N
N
N/** @defgroup SPI_EC_TX_FIFO TX FIFO Level
N  * @{
N  */
N#define MS32_SPI_TX_FIFO_EMPTY               0x00000000U                       /*!< FIFO transmission empty */
N#define MS32_SPI_TX_FIFO_QUARTER_FULL        (SPI_SR_FTLVL_0)                  /*!< FIFO transmission 1/4   */
N#define MS32_SPI_TX_FIFO_HALF_FULL           (SPI_SR_FTLVL_1)                  /*!< FIFO transmission 1/2   */
N#define MS32_SPI_TX_FIFO_FULL                (SPI_SR_FTLVL_1 | SPI_SR_FTLVL_0) /*!< FIFO transmission full  */
N
N
N/** @defgroup SPI_EC_DMA_PARITY DMA Parity
N  * @{
N  */
N#define MS32_SPI_DMA_PARITY_EVEN             0x00000000U   /*!< Select DMA parity Even */
N#define MS32_SPI_DMA_PARITY_ODD              0x00000001U   /*!< Select DMA parity Odd  */
N
N
N
N/** @defgroup I2S_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with MS32_I2S_ReadReg function
N  * @{
N  */
N#define MS32_I2S_SR_RXNE                     MS32_SPI_SR_RXNE            /*!< Rx buffer not empty flag         */
N#define MS32_I2S_SR_TXE                      MS32_SPI_SR_TXE             /*!< Tx buffer empty flag             */
N#define MS32_I2S_SR_BSY                      MS32_SPI_SR_BSY             /*!< Busy flag                        */
N#define MS32_I2S_SR_UDR                      SPI_SR_UDR                /*!< Underrun flag                    */
N#define MS32_I2S_SR_OVR                      MS32_SPI_SR_OVR             /*!< Overrun flag                     */
N#define MS32_I2S_SR_FRE                      MS32_SPI_SR_FRE             /*!< TI mode frame format error flag  */
N
N
N/** @defgroup SPI_EC_IT IT Defines
N  * @brief    IT defines which can be used with MS32_SPI_ReadReg and  MS32_SPI_WriteReg functions
N  * @{
N  */
N#define MS32_I2S_CR2_RXNEIE                  MS32_SPI_CR2_RXNEIE         /*!< Rx buffer not empty interrupt enable */
N#define MS32_I2S_CR2_TXEIE                   MS32_SPI_CR2_TXEIE          /*!< Tx buffer empty interrupt enable     */
N#define MS32_I2S_CR2_ERRIE                   MS32_SPI_CR2_ERRIE          /*!< Error interrupt enable               */
N
N
N/** @defgroup I2S_EC_DATA_FORMAT Data format
N  * @{
N  */
N#define MS32_I2S_DATAFORMAT_16B              0x00000000U                                   /*!< Data length 16 bits, Channel lenght 16bit */
N#define MS32_I2S_DATAFORMAT_16B_EXTENDED     (SPI_I2SCFGR_CHLEN)                           /*!< Data length 16 bits, Channel lenght 32bit */
N#define MS32_I2S_DATAFORMAT_24B              (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN_0)    /*!< Data length 24 bits, Channel lenght 32bit */
N#define MS32_I2S_DATAFORMAT_32B              (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN_1)    /*!< Data length 16 bits, Channel lenght 32bit */
N
N
N/** @defgroup I2S_EC_POLARITY Clock Polarity
N  * @{
N  */
N#define MS32_I2S_POLARITY_LOW                0x00000000U               /*!< Clock steady state is low level  */
N#define MS32_I2S_POLARITY_HIGH               (SPI_I2SCFGR_CKPOL)       /*!< Clock steady state is high level */
N
N
N/** @defgroup I2S_EC_STANDARD I2s Standard
N  * @{
N  */
N#define MS32_I2S_STANDARD_PHILIPS            0x00000000U                                                         /*!< I2S standard philips                      */
N#define MS32_I2S_STANDARD_MSB                (SPI_I2SCFGR_I2SSTD_0)                                              /*!< MSB justified standard (left justified)   */
N#define MS32_I2S_STANDARD_LSB                (SPI_I2SCFGR_I2SSTD_1)                                              /*!< LSB justified standard (right justified)  */
N#define MS32_I2S_STANDARD_PCM_SHORT          (SPI_I2SCFGR_I2SSTD_0 | SPI_I2SCFGR_I2SSTD_1)                       /*!< PCM standard, short frame synchronization */
N#define MS32_I2S_STANDARD_PCM_LONG           (SPI_I2SCFGR_I2SSTD_0 | SPI_I2SCFGR_I2SSTD_1 | SPI_I2SCFGR_PCMSYNC) /*!< PCM standard, long frame synchronization  */
N
N
N/** @defgroup I2S_EC_MODE Operation Mode
N  * @{
N  */
N#define MS32_I2S_MODE_SLAVE_TX               0x00000000U                                   /*!< Slave Tx configuration  */
N#define MS32_I2S_MODE_SLAVE_RX               (SPI_I2SCFGR_I2SCFG_0)                        /*!< Slave Rx configuration  */
N#define MS32_I2S_MODE_MASTER_TX              (SPI_I2SCFGR_I2SCFG_1)                        /*!< Master Tx configuration */
N#define MS32_I2S_MODE_MASTER_RX              (SPI_I2SCFGR_I2SCFG_0 | SPI_I2SCFGR_I2SCFG_1) /*!< Master Rx configuration */
N
N
N/** @defgroup I2S_EC_PRESCALER_FACTOR Prescaler Factor
N  * @{
N  */
N#define MS32_I2S_PRESCALER_PARITY_EVEN       0x00000000U               /*!< Odd factor: Real divider value is =  I2SDIV * 2    */
N#define MS32_I2S_PRESCALER_PARITY_ODD        (SPI_I2SPR_ODD >> 8U)     /*!< Odd factor: Real divider value is = (I2SDIV * 2)+1 */
N
N
N/** @defgroup I2S_EC_MCLK_OUTPUT MCLK Output
N  * @{
N  */
N#define MS32_I2S_MCLK_OUTPUT_DISABLE         0x00000000U               /*!< Master clock output is disabled */
N#define MS32_I2S_MCLK_OUTPUT_ENABLE          (SPI_I2SPR_MCKOE)         /*!< Master clock output is enabled  */
N
N
N/** @defgroup I2S_EC_AUDIO_FREQ Audio Frequency
N  * @{
N  */
N
N#define MS32_I2S_AUDIOFREQ_192K              192000U       /*!< Audio Frequency configuration 192000 Hz       */
N#define MS32_I2S_AUDIOFREQ_96K               96000U        /*!< Audio Frequency configuration  96000 Hz       */
N#define MS32_I2S_AUDIOFREQ_48K               48000U        /*!< Audio Frequency configuration  48000 Hz       */
N#define MS32_I2S_AUDIOFREQ_44K               44100U        /*!< Audio Frequency configuration  44100 Hz       */
N#define MS32_I2S_AUDIOFREQ_32K               32000U        /*!< Audio Frequency configuration  32000 Hz       */
N#define MS32_I2S_AUDIOFREQ_22K               22050U        /*!< Audio Frequency configuration  22050 Hz       */
N#define MS32_I2S_AUDIOFREQ_16K               16000U        /*!< Audio Frequency configuration  16000 Hz       */
N#define MS32_I2S_AUDIOFREQ_11K               11025U        /*!< Audio Frequency configuration  11025 Hz       */
N#define MS32_I2S_AUDIOFREQ_8K                8000U         /*!< Audio Frequency configuration   8000 Hz       */
N#define MS32_I2S_AUDIOFREQ_DEFAULT           2U            /*!< Audio Freq not specified. Register I2SDIV = 2 */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup SPI_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in SPI register
N  * @param  __INSTANCE__ SPI Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_SPI_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in SPI register
N  * @param  __INSTANCE__ SPI Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_SPI_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N
N
N/** @defgroup I2S_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in I2S register
N  * @param  __INSTANCE__ I2S Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_I2S_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in I2S register
N  * @param  __INSTANCE__ I2S Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_I2S_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup SPI_EF_Configuration Configuration
N  * @{
N  */
N
N/**
N  * @brief  Enable SPI peripheral
N  * @rmtoll CR1          SPE           MS32_SPI_Enable
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_Enable(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_Enable(SPI_TypeDef *SPIx) {
N  SET_BIT(SPIx->CR1, SPI_CR1_SPE);
X  ((SPIx->CR1) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Disable SPI peripheral
N  * @note   When disabling the SPI, follow the procedure described in the Reference Manual.
N  * @rmtoll CR1          SPE           MS32_SPI_Disable
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_Disable(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_Disable(SPI_TypeDef *SPIx) {
N  CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
X  ((SPIx->CR1) &= ~((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Check if SPI peripheral is enabled
N  * @rmtoll CR1          SPE           MS32_SPI_IsEnabled
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SPI_IsEnabled(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_IsEnabled(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->CR1, SPI_CR1_SPE) == (SPI_CR1_SPE)) ? 1UL : 0UL);
X  return ((((SPIx->CR1) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set SPI operation mode to Master or Slave
N  * @note   This bit should not be changed when communication is ongoing.
N  * @rmtoll CR1          MSTR          MS32_SPI_SetMode\n
N  *         CR1          SSI           MS32_SPI_SetMode
N  * @param  SPIx SPI Instance
N  * @param  Mode This parameter can be one of the following values:
N  *         @arg @ref MS32_SPI_MODE_MASTER
N  *         @arg @ref MS32_SPI_MODE_SLAVE
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_SetMode(SPI_TypeDef *SPIx, uint32_t Mode) {
Xstatic __inline void MS32_SPI_SetMode(SPI_TypeDef *SPIx, uint32_t Mode) {
N  MODIFY_REG(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI, Mode);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x1UL << (2U)) | (0x1UL << (8U))))) | (Mode))));
N}
N
N/**
N  * @brief  Get SPI operation mode (Master or Slave)
N  * @rmtoll CR1          MSTR          MS32_SPI_GetMode\n
N  *         CR1          SSI           MS32_SPI_GetMode
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SPI_MODE_MASTER
N  *         @arg @ref MS32_SPI_MODE_SLAVE
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetMode(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetMode(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI));
X  return (uint32_t)(((SPIx->CR1) & ((0x1UL << (2U)) | (0x1UL << (8U)))));
N}
N
N/**
N  * @brief  Set serial protocol used
N  * @note   This bit should be written only when SPI is disabled (SPE = 0) for correct operation.
N  * @rmtoll CR2          FRF           MS32_SPI_SetStandard
N  * @param  SPIx SPI Instance
N  * @param  Standard This parameter can be one of the following values:
N  *         @arg @ref MS32_SPI_PROTOCOL_MOTOROLA
N  *         @arg @ref MS32_SPI_PROTOCOL_TI
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_SetStandard(SPI_TypeDef *SPIx, uint32_t Standard) {
Xstatic __inline void MS32_SPI_SetStandard(SPI_TypeDef *SPIx, uint32_t Standard) {
N  MODIFY_REG(SPIx->CR2, SPI_CR2_FRF, Standard);
X  (((SPIx->CR2)) = ((((((SPIx->CR2))) & (~((0x1UL << (4U))))) | (Standard))));
N}
N
N/**
N  * @brief  Get serial protocol used
N  * @rmtoll CR2          FRF           MS32_SPI_GetStandard
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SPI_PROTOCOL_MOTOROLA
N  *         @arg @ref MS32_SPI_PROTOCOL_TI
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetStandard(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetStandard(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->CR2, SPI_CR2_FRF));
X  return (uint32_t)(((SPIx->CR2) & ((0x1UL << (4U)))));
N}
N
N/**
N  * @brief  Set clock phase
N  * @note   This bit should not be changed when communication is ongoing.
N  *         This bit is not used in SPI TI mode.
N  * @rmtoll CR1          CPHA          MS32_SPI_SetClockPhase
N  * @param  SPIx SPI Instance
N  * @param  ClockPhase This parameter can be one of the following values:
N  *         @arg @ref MS32_SPI_PHASE_1EDGE
N  *         @arg @ref MS32_SPI_PHASE_2EDGE
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_SetClockPhase(SPI_TypeDef *SPIx, uint32_t ClockPhase) {
Xstatic __inline void MS32_SPI_SetClockPhase(SPI_TypeDef *SPIx, uint32_t ClockPhase) {
N  MODIFY_REG(SPIx->CR1, SPI_CR1_CPHA, ClockPhase);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x1UL << (0U))))) | (ClockPhase))));
N}
N
N/**
N  * @brief  Get clock phase
N  * @rmtoll CR1          CPHA          MS32_SPI_GetClockPhase
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SPI_PHASE_1EDGE
N  *         @arg @ref MS32_SPI_PHASE_2EDGE
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetClockPhase(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetClockPhase(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_CPHA));
X  return (uint32_t)(((SPIx->CR1) & ((0x1UL << (0U)))));
N}
N
N/**
N  * @brief  Set clock polarity
N  * @note   This bit should not be changed when communication is ongoing.
N  *         This bit is not used in SPI TI mode.
N  * @rmtoll CR1          CPOL          MS32_SPI_SetClockPolarity
N  * @param  SPIx SPI Instance
N  * @param  ClockPolarity This parameter can be one of the following values:
N  *         @arg @ref MS32_SPI_POLARITY_LOW
N  *         @arg @ref MS32_SPI_POLARITY_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_SetClockPolarity(SPI_TypeDef *SPIx, uint32_t ClockPolarity) {
Xstatic __inline void MS32_SPI_SetClockPolarity(SPI_TypeDef *SPIx, uint32_t ClockPolarity) {
N  MODIFY_REG(SPIx->CR1, SPI_CR1_CPOL, ClockPolarity);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x1UL << (1U))))) | (ClockPolarity))));
N}
N
N/**
N  * @brief  Get clock polarity
N  * @rmtoll CR1          CPOL          MS32_SPI_GetClockPolarity
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SPI_POLARITY_LOW
N  *         @arg @ref MS32_SPI_POLARITY_HIGH
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetClockPolarity(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetClockPolarity(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_CPOL));
X  return (uint32_t)(((SPIx->CR1) & ((0x1UL << (1U)))));
N}
N
N/**
N  * @brief  Set baud rate prescaler
N  * @note   These bits should not be changed when communication is ongoing. SPI BaudRate = fPCLK/Prescaler.
N  * @rmtoll CR1          BR            MS32_SPI_SetBaudRatePrescaler
N  * @param  SPIx SPI Instance
N  * @param  BaudRate This parameter can be one of the following values:
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV2
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV4
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV8
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV16
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV32
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV64
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV128
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV256
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_SetBaudRatePrescaler(SPI_TypeDef *SPIx, uint32_t BaudRate) {
Xstatic __inline void MS32_SPI_SetBaudRatePrescaler(SPI_TypeDef *SPIx, uint32_t BaudRate) {
N  MODIFY_REG(SPIx->CR1, SPI_CR1_BR, BaudRate);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x7UL << (3U))))) | (BaudRate))));
N}
N
N/**
N  * @brief  Get baud rate prescaler
N  * @rmtoll CR1          BR            MS32_SPI_GetBaudRatePrescaler
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV2
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV4
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV8
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV16
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV32
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV64
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV128
N  *         @arg @ref MS32_SPI_BAUDRATEPRESCALER_DIV256
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetBaudRatePrescaler(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetBaudRatePrescaler(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_BR));
X  return (uint32_t)(((SPIx->CR1) & ((0x7UL << (3U)))));
N}
N
N/**
N  * @brief  Set transfer bit order
N  * @note   This bit should not be changed when communication is ongoing. This bit is not used in SPI TI mode.
N  * @rmtoll CR1          LSBFIRST      MS32_SPI_SetTransferBitOrder
N  * @param  SPIx SPI Instance
N  * @param  BitOrder This parameter can be one of the following values:
N  *         @arg @ref MS32_SPI_LSB_FIRST
N  *         @arg @ref MS32_SPI_MSB_FIRST
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_SetTransferBitOrder(SPI_TypeDef *SPIx, uint32_t BitOrder) {
Xstatic __inline void MS32_SPI_SetTransferBitOrder(SPI_TypeDef *SPIx, uint32_t BitOrder) {
N  MODIFY_REG(SPIx->CR1, SPI_CR1_LSBFIRST, BitOrder);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x1UL << (7U))))) | (BitOrder))));
N}
N
N/**
N  * @brief  Get transfer bit order
N  * @rmtoll CR1          LSBFIRST      MS32_SPI_GetTransferBitOrder
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SPI_LSB_FIRST
N  *         @arg @ref MS32_SPI_MSB_FIRST
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetTransferBitOrder(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetTransferBitOrder(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_LSBFIRST));
X  return (uint32_t)(((SPIx->CR1) & ((0x1UL << (7U)))));
N}
N
N/**
N  * @brief  Set transfer direction mode
N  * @note   For Half-Duplex mode, Rx Direction is set by default.
N  *         In master mode, the MOSI pin is used and in slave mode, the MISO pin is used for Half-Duplex.
N  * @rmtoll CR1          RXONLY        MS32_SPI_SetTransferDirection\n
N  *         CR1          BIDIMODE      MS32_SPI_SetTransferDirection\n
N  *         CR1          BIDIOE        MS32_SPI_SetTransferDirection
N  * @param  SPIx SPI Instance
N  * @param  TransferDirection This parameter can be one of the following values:
N  *         @arg @ref MS32_SPI_FUMS32_DUPLEX
N  *         @arg @ref MS32_SPI_SIMPLEX_RX
N  *         @arg @ref MS32_SPI_HALF_DUPLEX_RX
N  *         @arg @ref MS32_SPI_HALF_DUPLEX_TX
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_SetTransferDirection(SPI_TypeDef *SPIx, uint32_t TransferDirection) {
Xstatic __inline void MS32_SPI_SetTransferDirection(SPI_TypeDef *SPIx, uint32_t TransferDirection) {
N  MODIFY_REG(SPIx->CR1, SPI_CR1_RXONLY | SPI_CR1_BIDIMODE | SPI_CR1_BIDIOE, TransferDirection);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x1UL << (10U)) | (0x1UL << (15U)) | (0x1UL << (14U))))) | (TransferDirection))));
N}
N
N/**
N  * @brief  Get transfer direction mode
N  * @rmtoll CR1          RXONLY        MS32_SPI_GetTransferDirection\n
N  *         CR1          BIDIMODE      MS32_SPI_GetTransferDirection\n
N  *         CR1          BIDIOE        MS32_SPI_GetTransferDirection
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SPI_FUMS32_DUPLEX
N  *         @arg @ref MS32_SPI_SIMPLEX_RX
N  *         @arg @ref MS32_SPI_HALF_DUPLEX_RX
N  *         @arg @ref MS32_SPI_HALF_DUPLEX_TX
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetTransferDirection(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetTransferDirection(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_RXONLY | SPI_CR1_BIDIMODE | SPI_CR1_BIDIOE));
X  return (uint32_t)(((SPIx->CR1) & ((0x1UL << (10U)) | (0x1UL << (15U)) | (0x1UL << (14U)))));
N}
N
N/**
N  * @brief  Set frame data width
N  * @rmtoll CR2          DS            MS32_SPI_SetDataWidth
N  * @param  SPIx SPI Instance
N  * @param  DataWidth This parameter can be one of the following values:
N  *         @arg @ref MS32_SPI_DATAWIDTH_4BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_5BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_6BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_7BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_8BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_9BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_10BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_11BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_12BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_13BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_14BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_15BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_16BIT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_SetDataWidth(SPI_TypeDef *SPIx, uint32_t DataWidth) {
Xstatic __inline void MS32_SPI_SetDataWidth(SPI_TypeDef *SPIx, uint32_t DataWidth) {
N  MODIFY_REG(SPIx->CR2, SPI_CR2_DS, DataWidth);
X  (((SPIx->CR2)) = ((((((SPIx->CR2))) & (~((0xFUL << (8U))))) | (DataWidth))));
N}
N
N/**
N  * @brief  Get frame data width
N  * @rmtoll CR2          DS            MS32_SPI_GetDataWidth
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SPI_DATAWIDTH_4BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_5BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_6BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_7BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_8BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_9BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_10BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_11BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_12BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_13BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_14BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_15BIT
N  *         @arg @ref MS32_SPI_DATAWIDTH_16BIT
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetDataWidth(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetDataWidth(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->CR2, SPI_CR2_DS));
X  return (uint32_t)(((SPIx->CR2) & ((0xFUL << (8U)))));
N}
N
N/**
N  * @brief  Set threshold of RXFIFO that triggers an RXNE event
N  * @rmtoll CR2          FRXTH         MS32_SPI_SetRxFIFOThreshold
N  * @param  SPIx SPI Instance
N  * @param  Threshold This parameter can be one of the following values:
N  *         @arg @ref MS32_SPI_RX_FIFO_TH_HALF
N  *         @arg @ref MS32_SPI_RX_FIFO_TH_QUARTER
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_SetRxFIFOThreshold(SPI_TypeDef *SPIx, uint32_t Threshold) {
Xstatic __inline void MS32_SPI_SetRxFIFOThreshold(SPI_TypeDef *SPIx, uint32_t Threshold) {
N  MODIFY_REG(SPIx->CR2, SPI_CR2_FRXTH, Threshold);
X  (((SPIx->CR2)) = ((((((SPIx->CR2))) & (~((0x1UL << (12U))))) | (Threshold))));
N}
N
N/**
N  * @brief  Get threshold of RXFIFO that triggers an RXNE event
N  * @rmtoll CR2          FRXTH         MS32_SPI_GetRxFIFOThreshold
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SPI_RX_FIFO_TH_HALF
N  *         @arg @ref MS32_SPI_RX_FIFO_TH_QUARTER
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetRxFIFOThreshold(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetRxFIFOThreshold(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->CR2, SPI_CR2_FRXTH));
X  return (uint32_t)(((SPIx->CR2) & ((0x1UL << (12U)))));
N}
N
N
N/** @defgroup SPI_EF_CRC_Management CRC Management
N  * @{
N  */
N
N/**
N  * @brief  Enable CRC
N  * @note   This bit should be written only when SPI is disabled (SPE = 0) for correct operation.
N  * @rmtoll CR1          CRCEN         MS32_SPI_EnableCRC
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_EnableCRC(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_EnableCRC(SPI_TypeDef *SPIx) {
N  SET_BIT(SPIx->CR1, SPI_CR1_CRCEN);
X  ((SPIx->CR1) |= ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Disable CRC
N  * @note   This bit should be written only when SPI is disabled (SPE = 0) for correct operation.
N  * @rmtoll CR1          CRCEN         MS32_SPI_DisableCRC
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_DisableCRC(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_DisableCRC(SPI_TypeDef *SPIx) {
N  CLEAR_BIT(SPIx->CR1, SPI_CR1_CRCEN);
X  ((SPIx->CR1) &= ~((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Check if CRC is enabled
N  * @note   This bit should be written only when SPI is disabled (SPE = 0) for correct operation.
N  * @rmtoll CR1          CRCEN         MS32_SPI_IsEnabledCRC
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SPI_IsEnabledCRC(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_IsEnabledCRC(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->CR1, SPI_CR1_CRCEN) == (SPI_CR1_CRCEN)) ? 1UL : 0UL);
X  return ((((SPIx->CR1) & ((0x1UL << (13U)))) == ((0x1UL << (13U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set CRC Length
N  * @note   This bit should be written only when SPI is disabled (SPE = 0) for correct operation.
N  * @rmtoll CR1          CRCL          MS32_SPI_SetCRCWidth
N  * @param  SPIx SPI Instance
N  * @param  CRCLength This parameter can be one of the following values:
N  *         @arg @ref MS32_SPI_CRC_8BIT
N  *         @arg @ref MS32_SPI_CRC_16BIT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_SetCRCWidth(SPI_TypeDef *SPIx, uint32_t CRCLength) {
Xstatic __inline void MS32_SPI_SetCRCWidth(SPI_TypeDef *SPIx, uint32_t CRCLength) {
N  MODIFY_REG(SPIx->CR1, SPI_CR1_CRCL, CRCLength);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x1UL << (11U))))) | (CRCLength))));
N}
N
N/**
N  * @brief  Get CRC Length
N  * @rmtoll CR1          CRCL          MS32_SPI_GetCRCWidth
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SPI_CRC_8BIT
N  *         @arg @ref MS32_SPI_CRC_16BIT
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetCRCWidth(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetCRCWidth(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_CRCL));
X  return (uint32_t)(((SPIx->CR1) & ((0x1UL << (11U)))));
N}
N
N/**
N  * @brief  Set CRCNext to transfer CRC on the line
N  * @note   This bit has to be written as soon as the last data is written in the SPIx_DR register.
N  * @rmtoll CR1          CRCNEXT       MS32_SPI_SetCRCNext
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_SetCRCNext(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_SetCRCNext(SPI_TypeDef *SPIx) {
N  SET_BIT(SPIx->CR1, SPI_CR1_CRCNEXT);
X  ((SPIx->CR1) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Set polynomial for CRC calculation
N  * @rmtoll CRCPR        CRCPOLY       MS32_SPI_SetCRCPolynomial
N  * @param  SPIx SPI Instance
N  * @param  CRCPoly This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFFFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_SetCRCPolynomial(SPI_TypeDef *SPIx, uint32_t CRCPoly) {
Xstatic __inline void MS32_SPI_SetCRCPolynomial(SPI_TypeDef *SPIx, uint32_t CRCPoly) {
N  WRITE_REG(SPIx->CRCPR, (uint16_t)CRCPoly);
X  ((SPIx->CRCPR) = ((uint16_t)CRCPoly));
N}
N
N/**
N  * @brief  Get polynomial for CRC calculation
N  * @rmtoll CRCPR        CRCPOLY       MS32_SPI_GetCRCPolynomial
N  * @param  SPIx SPI Instance
N  * @retval Returned value is a number between Min_Data = 0x00 and Max_Data = 0xFFFF
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetCRCPolynomial(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetCRCPolynomial(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_REG(SPIx->CRCPR));
X  return (uint32_t)(((SPIx->CRCPR)));
N}
N
N/**
N  * @brief  Get Rx CRC
N  * @rmtoll RXCRCR       RXCRC         MS32_SPI_GetRxCRC
N  * @param  SPIx SPI Instance
N  * @retval Returned value is a number between Min_Data = 0x00 and Max_Data = 0xFFFF
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetRxCRC(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetRxCRC(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_REG(SPIx->RXCRCR));
X  return (uint32_t)(((SPIx->RXCRCR)));
N}
N
N/**
N  * @brief  Get Tx CRC
N  * @rmtoll TXCRCR       TXCRC         MS32_SPI_GetTxCRC
N  * @param  SPIx SPI Instance
N  * @retval Returned value is a number between Min_Data = 0x00 and Max_Data = 0xFFFF
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetTxCRC(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetTxCRC(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_REG(SPIx->TXCRCR));
X  return (uint32_t)(((SPIx->TXCRCR)));
N}
N
N
N/** @defgroup SPI_EF_NSS_Management Slave Select Pin Management
N  * @{
N  */
N
N/**
N  * @brief  Set NSS mode
N  * @note   MS32_SPI_NSS_SOFT Mode is not used in SPI TI mode.
N  * @rmtoll CR1          SSM           MS32_SPI_SetNSSMode\n
N  * @rmtoll CR2          SSOE          MS32_SPI_SetNSSMode
N  * @param  SPIx SPI Instance
N  * @param  NSS This parameter can be one of the following values:
N  *         @arg @ref MS32_SPI_NSS_SOFT
N  *         @arg @ref MS32_SPI_NSS_HARD_INPUT
N  *         @arg @ref MS32_SPI_NSS_HARD_OUTPUT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_SetNSSMode(SPI_TypeDef *SPIx, uint32_t NSS) {
Xstatic __inline void MS32_SPI_SetNSSMode(SPI_TypeDef *SPIx, uint32_t NSS) {
N  MODIFY_REG(SPIx->CR1, SPI_CR1_SSM,  NSS);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x1UL << (9U))))) | (NSS))));
N  MODIFY_REG(SPIx->CR2, SPI_CR2_SSOE, ((uint32_t)(NSS >> 16U)));
X  (((SPIx->CR2)) = ((((((SPIx->CR2))) & (~((0x1UL << (2U))))) | (((uint32_t)(NSS >> 16U))))));
N}
N
N/**
N  * @brief  Get NSS mode
N  * @rmtoll CR1          SSM           MS32_SPI_GetNSSMode\n
N  * @rmtoll CR2          SSOE          MS32_SPI_GetNSSMode
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SPI_NSS_SOFT
N  *         @arg @ref MS32_SPI_NSS_HARD_INPUT
N  *         @arg @ref MS32_SPI_NSS_HARD_OUTPUT
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetNSSMode(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetNSSMode(SPI_TypeDef *SPIx) {
N  register uint32_t Ssm  = (READ_BIT(SPIx->CR1, SPI_CR1_SSM));
X  register uint32_t Ssm  = (((SPIx->CR1) & ((0x1UL << (9U)))));
N  register uint32_t Ssoe = (READ_BIT(SPIx->CR2,  SPI_CR2_SSOE) << 16U);
X  register uint32_t Ssoe = (((SPIx->CR2) & ((0x1UL << (2U)))) << 16U);
N  return (Ssm | Ssoe);
N}
N
N/**
N  * @brief  Enable NSS pulse management
N  * @note   This bit should not be changed when communication is ongoing. This bit is not used in SPI TI mode.
N  * @rmtoll CR2          NSSP          MS32_SPI_EnableNSSPulseMgt
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_EnableNSSPulseMgt(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_EnableNSSPulseMgt(SPI_TypeDef *SPIx) {
N  SET_BIT(SPIx->CR2, SPI_CR2_NSSP);
X  ((SPIx->CR2) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Disable NSS pulse management
N  * @note   This bit should not be changed when communication is ongoing. This bit is not used in SPI TI mode.
N  * @rmtoll CR2          NSSP          MS32_SPI_DisableNSSPulseMgt
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_DisableNSSPulseMgt(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_DisableNSSPulseMgt(SPI_TypeDef *SPIx) {
N  CLEAR_BIT(SPIx->CR2, SPI_CR2_NSSP);
X  ((SPIx->CR2) &= ~((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Check if NSS pulse is enabled
N  * @note   This bit should not be changed when communication is ongoing. This bit is not used in SPI TI mode.
N  * @rmtoll CR2          NSSP          MS32_SPI_IsEnabledNSSPulse
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SPI_IsEnabledNSSPulse(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_IsEnabledNSSPulse(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->CR2, SPI_CR2_NSSP) == (SPI_CR2_NSSP)) ? 1UL : 0UL);
X  return ((((SPIx->CR2) & ((0x1UL << (3U)))) == ((0x1UL << (3U)))) ? 1UL : 0UL);
N}
N
N
N/** @defgroup SPI_EF_FLAG_Management FLAG Management
N  * @{
N  */
N
N/**
N  * @brief  Check if Rx buffer is not empty
N  * @rmtoll SR           RXNE          MS32_SPI_IsActiveFlag_RXNE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SPI_IsActiveFlag_RXNE(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_IsActiveFlag_RXNE(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->SR, SPI_SR_RXNE) == (SPI_SR_RXNE)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if Tx buffer is empty
N  * @rmtoll SR           TXE           MS32_SPI_IsActiveFlag_TXE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SPI_IsActiveFlag_TXE(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_IsActiveFlag_TXE(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->SR, SPI_SR_TXE) == (SPI_SR_TXE)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (1U)))) == ((0x1UL << (1U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get CRC error flag
N  * @rmtoll SR           CRCERR        MS32_SPI_IsActiveFlag_CRCERR
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SPI_IsActiveFlag_CRCERR(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_IsActiveFlag_CRCERR(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->SR, SPI_SR_CRCERR) == (SPI_SR_CRCERR)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (4U)))) == ((0x1UL << (4U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get mode fault error flag
N  * @rmtoll SR           MODF          MS32_SPI_IsActiveFlag_MODF
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SPI_IsActiveFlag_MODF(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_IsActiveFlag_MODF(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->SR, SPI_SR_MODF) == (SPI_SR_MODF)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (5U)))) == ((0x1UL << (5U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get overrun error flag
N  * @rmtoll SR           OVR           MS32_SPI_IsActiveFlag_OVR
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SPI_IsActiveFlag_OVR(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_IsActiveFlag_OVR(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->SR, SPI_SR_OVR) == (SPI_SR_OVR)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get busy flag
N  * @note   The BSY flag is cleared under any one of the following conditions:
N  * -When the SPI is correctly disabled
N  * -When a fault is detected in Master mode (MODF bit set to 1)
N  * -In Master mode, when it finishes a data transmission and no new data is ready to be
N  * sent
N  * -In Slave mode, when the BSY flag is set to '0' for at least one SPI clock cycle between
N  * each data transfer.
N  * @rmtoll SR           BSY           MS32_SPI_IsActiveFlag_BSY
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SPI_IsActiveFlag_BSY(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_IsActiveFlag_BSY(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->SR, SPI_SR_BSY) == (SPI_SR_BSY)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get frame format error flag
N  * @rmtoll SR           FRE           MS32_SPI_IsActiveFlag_FRE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SPI_IsActiveFlag_FRE(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_IsActiveFlag_FRE(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->SR, SPI_SR_FRE) == (SPI_SR_FRE)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (8U)))) == ((0x1UL << (8U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get FIFO reception Level
N  * @rmtoll SR           FRLVL         MS32_SPI_GetRxFIFOLevel
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SPI_RX_FIFO_EMPTY
N  *         @arg @ref MS32_SPI_RX_FIFO_QUARTER_FULL
N  *         @arg @ref MS32_SPI_RX_FIFO_HALF_FULL
N  *         @arg @ref MS32_SPI_RX_FIFO_FULL
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetRxFIFOLevel(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetRxFIFOLevel(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->SR, SPI_SR_FRLVL));
X  return (uint32_t)(((SPIx->SR) & ((0x3UL << (9U)))));
N}
N
N/**
N  * @brief  Get FIFO Transmission Level
N  * @rmtoll SR           FTLVL         MS32_SPI_GetTxFIFOLevel
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SPI_TX_FIFO_EMPTY
N  *         @arg @ref MS32_SPI_TX_FIFO_QUARTER_FULL
N  *         @arg @ref MS32_SPI_TX_FIFO_HALF_FULL
N  *         @arg @ref MS32_SPI_TX_FIFO_FULL
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetTxFIFOLevel(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetTxFIFOLevel(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->SR, SPI_SR_FTLVL));
X  return (uint32_t)(((SPIx->SR) & ((0x3UL << (11U)))));
N}
N
N/**
N  * @brief  Clear CRC error flag
N  * @rmtoll SR           CRCERR        MS32_SPI_ClearFlag_CRCERR
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_ClearFlag_CRCERR(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_ClearFlag_CRCERR(SPI_TypeDef *SPIx) {
N  CLEAR_BIT(SPIx->SR, SPI_SR_CRCERR);
X  ((SPIx->SR) &= ~((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Clear mode fault error flag
N  * @note   Clearing this flag is done by a read access to the SPIx_SR
N  *         register followed by a write access to the SPIx_CR1 register
N  * @rmtoll SR           MODF          MS32_SPI_ClearFlag_MODF
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_ClearFlag_MODF(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_ClearFlag_MODF(SPI_TypeDef *SPIx) {
N  __IO uint32_t tmpreg_sr;
X  volatile uint32_t tmpreg_sr;
N  tmpreg_sr = SPIx->SR;
N  (void) tmpreg_sr;
N  CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
X  ((SPIx->CR1) &= ~((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Clear overrun error flag
N  * @note   Clearing this flag is done by a read access to the SPIx_DR
N  *         register followed by a read access to the SPIx_SR register
N  * @rmtoll SR           OVR           MS32_SPI_ClearFlag_OVR
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_ClearFlag_OVR(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_ClearFlag_OVR(SPI_TypeDef *SPIx) {
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  tmpreg = SPIx->DR;
N  (void) tmpreg;
N  tmpreg = SPIx->SR;
N  (void) tmpreg;
N}
N
N/**
N  * @brief  Clear frame format error flag
N  * @note   Clearing this flag is done by reading SPIx_SR register
N  * @rmtoll SR           FRE           MS32_SPI_ClearFlag_FRE
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_ClearFlag_FRE(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_ClearFlag_FRE(SPI_TypeDef *SPIx) {
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  tmpreg = SPIx->SR;
N  (void) tmpreg;
N}
N
N
N/** @defgroup SPI_EF_IT_Management Interrupt Management
N  * @{
N  */
N
N/**
N  * @brief  Enable error interrupt
N  * @note   This bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR, MODF in SPI mode, FRE at TI mode).
N  * @rmtoll CR2          ERRIE         MS32_SPI_EnableIT_ERR
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_EnableIT_ERR(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_EnableIT_ERR(SPI_TypeDef *SPIx) {
N  SET_BIT(SPIx->CR2, SPI_CR2_ERRIE);
X  ((SPIx->CR2) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Enable Rx buffer not empty interrupt
N  * @rmtoll CR2          RXNEIE        MS32_SPI_EnableIT_RXNE
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_EnableIT_RXNE(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_EnableIT_RXNE(SPI_TypeDef *SPIx) {
N  SET_BIT(SPIx->CR2, SPI_CR2_RXNEIE);
X  ((SPIx->CR2) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Enable Tx buffer empty interrupt
N  * @rmtoll CR2          TXEIE         MS32_SPI_EnableIT_TXE
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_EnableIT_TXE(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_EnableIT_TXE(SPI_TypeDef *SPIx) {
N  SET_BIT(SPIx->CR2, SPI_CR2_TXEIE);
X  ((SPIx->CR2) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable error interrupt
N  * @note   This bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR, MODF in SPI mode, FRE at TI mode).
N  * @rmtoll CR2          ERRIE         MS32_SPI_DisableIT_ERR
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_DisableIT_ERR(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_DisableIT_ERR(SPI_TypeDef *SPIx) {
N  CLEAR_BIT(SPIx->CR2, SPI_CR2_ERRIE);
X  ((SPIx->CR2) &= ~((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Disable Rx buffer not empty interrupt
N  * @rmtoll CR2          RXNEIE        MS32_SPI_DisableIT_RXNE
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_DisableIT_RXNE(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_DisableIT_RXNE(SPI_TypeDef *SPIx) {
N  CLEAR_BIT(SPIx->CR2, SPI_CR2_RXNEIE);
X  ((SPIx->CR2) &= ~((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Disable Tx buffer empty interrupt
N  * @rmtoll CR2          TXEIE         MS32_SPI_DisableIT_TXE
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_DisableIT_TXE(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_DisableIT_TXE(SPI_TypeDef *SPIx) {
N  CLEAR_BIT(SPIx->CR2, SPI_CR2_TXEIE);
X  ((SPIx->CR2) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Check if error interrupt is enabled
N  * @rmtoll CR2          ERRIE         MS32_SPI_IsEnabledIT_ERR
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SPI_IsEnabledIT_ERR(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_IsEnabledIT_ERR(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->CR2, SPI_CR2_ERRIE) == (SPI_CR2_ERRIE)) ? 1UL : 0UL);
X  return ((((SPIx->CR2) & ((0x1UL << (5U)))) == ((0x1UL << (5U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if Rx buffer not empty interrupt is enabled
N  * @rmtoll CR2          RXNEIE        MS32_SPI_IsEnabledIT_RXNE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SPI_IsEnabledIT_RXNE(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_IsEnabledIT_RXNE(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->CR2, SPI_CR2_RXNEIE) == (SPI_CR2_RXNEIE)) ? 1UL : 0UL);
X  return ((((SPIx->CR2) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if Tx buffer empty interrupt
N  * @rmtoll CR2          TXEIE         MS32_SPI_IsEnabledIT_TXE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SPI_IsEnabledIT_TXE(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_IsEnabledIT_TXE(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->CR2, SPI_CR2_TXEIE) == (SPI_CR2_TXEIE)) ? 1UL : 0UL);
X  return ((((SPIx->CR2) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N
N/** @defgroup SPI_EF_DMA_Management DMA Management
N  * @{
N  */
N
N/**
N  * @brief  Enable DMA Rx
N  * @rmtoll CR2          RXDMAEN       MS32_SPI_EnableDMAReq_RX
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_EnableDMAReq_RX(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_EnableDMAReq_RX(SPI_TypeDef *SPIx) {
N  SET_BIT(SPIx->CR2, SPI_CR2_RXDMAEN);
X  ((SPIx->CR2) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable DMA Rx
N  * @rmtoll CR2          RXDMAEN       MS32_SPI_DisableDMAReq_RX
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_DisableDMAReq_RX(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_DisableDMAReq_RX(SPI_TypeDef *SPIx) {
N  CLEAR_BIT(SPIx->CR2, SPI_CR2_RXDMAEN);
X  ((SPIx->CR2) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if DMA Rx is enabled
N  * @rmtoll CR2          RXDMAEN       MS32_SPI_IsEnabledDMAReq_RX
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SPI_IsEnabledDMAReq_RX(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_IsEnabledDMAReq_RX(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->CR2, SPI_CR2_RXDMAEN) == (SPI_CR2_RXDMAEN)) ? 1UL : 0UL);
X  return ((((SPIx->CR2) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable DMA Tx
N  * @rmtoll CR2          TXDMAEN       MS32_SPI_EnableDMAReq_TX
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_EnableDMAReq_TX(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_EnableDMAReq_TX(SPI_TypeDef *SPIx) {
N  SET_BIT(SPIx->CR2, SPI_CR2_TXDMAEN);
X  ((SPIx->CR2) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable DMA Tx
N  * @rmtoll CR2          TXDMAEN       MS32_SPI_DisableDMAReq_TX
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_DisableDMAReq_TX(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_SPI_DisableDMAReq_TX(SPI_TypeDef *SPIx) {
N  CLEAR_BIT(SPIx->CR2, SPI_CR2_TXDMAEN);
X  ((SPIx->CR2) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Check if DMA Tx is enabled
N  * @rmtoll CR2          TXDMAEN       MS32_SPI_IsEnabledDMAReq_TX
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SPI_IsEnabledDMAReq_TX(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_IsEnabledDMAReq_TX(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->CR2, SPI_CR2_TXDMAEN) == (SPI_CR2_TXDMAEN)) ? 1UL : 0UL);
X  return ((((SPIx->CR2) & ((0x1UL << (1U)))) == ((0x1UL << (1U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set parity of  Last DMA reception
N  * @rmtoll CR2          LDMARX        MS32_SPI_SetDMAParity_RX
N  * @param  SPIx SPI Instance
N  * @param  Parity This parameter can be one of the following values:
N  *         @arg @ref MS32_SPI_DMA_PARITY_ODD
N  *         @arg @ref MS32_SPI_DMA_PARITY_EVEN
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_SetDMAParity_RX(SPI_TypeDef *SPIx, uint32_t Parity) {
Xstatic __inline void MS32_SPI_SetDMAParity_RX(SPI_TypeDef *SPIx, uint32_t Parity) {
N  MODIFY_REG(SPIx->CR2, SPI_CR2_LDMARX, (Parity << SPI_CR2_LDMARX_Pos));
X  (((SPIx->CR2)) = ((((((SPIx->CR2))) & (~((0x1UL << (13U))))) | ((Parity << (13U))))));
N}
N
N/**
N  * @brief  Get parity configuration for  Last DMA reception
N  * @rmtoll CR2          LDMARX        MS32_SPI_GetDMAParity_RX
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SPI_DMA_PARITY_ODD
N  *         @arg @ref MS32_SPI_DMA_PARITY_EVEN
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetDMAParity_RX(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetDMAParity_RX(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->CR2, SPI_CR2_LDMARX) >> SPI_CR2_LDMARX_Pos);
X  return (uint32_t)(((SPIx->CR2) & ((0x1UL << (13U)))) >> (13U));
N}
N
N/**
N  * @brief  Set parity of  Last DMA transmission
N  * @rmtoll CR2          LDMATX        MS32_SPI_SetDMAParity_TX
N  * @param  SPIx SPI Instance
N  * @param  Parity This parameter can be one of the following values:
N  *         @arg @ref MS32_SPI_DMA_PARITY_ODD
N  *         @arg @ref MS32_SPI_DMA_PARITY_EVEN
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_SetDMAParity_TX(SPI_TypeDef *SPIx, uint32_t Parity) {
Xstatic __inline void MS32_SPI_SetDMAParity_TX(SPI_TypeDef *SPIx, uint32_t Parity) {
N  MODIFY_REG(SPIx->CR2, SPI_CR2_LDMATX, (Parity << SPI_CR2_LDMATX_Pos));
X  (((SPIx->CR2)) = ((((((SPIx->CR2))) & (~((0x1UL << (14U))))) | ((Parity << (14U))))));
N}
N
N/**
N  * @brief  Get parity configuration for Last DMA transmission
N  * @rmtoll CR2          LDMATX        MS32_SPI_GetDMAParity_TX
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SPI_DMA_PARITY_ODD
N  *         @arg @ref MS32_SPI_DMA_PARITY_EVEN
N  */
N__STATIC_INLINE uint32_t MS32_SPI_GetDMAParity_TX(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_GetDMAParity_TX(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->CR2, SPI_CR2_LDMATX) >> SPI_CR2_LDMATX_Pos);
X  return (uint32_t)(((SPIx->CR2) & ((0x1UL << (14U)))) >> (14U));
N}
N
N/**
N  * @brief  Get the data register address used for DMA transfer
N  * @rmtoll DR           DR            MS32_SPI_DMA_GetRegAddr
N  * @param  SPIx SPI Instance
N  * @retval Address of data register
N  */
N__STATIC_INLINE uint32_t MS32_SPI_DMA_GetRegAddr(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_SPI_DMA_GetRegAddr(SPI_TypeDef *SPIx) {
N  return (uint32_t) &(SPIx->DR);
N}
N
N
N/** @defgroup SPI_EF_DATA_Management DATA Management
N  * @{
N  */
N
N/**
N  * @brief  Read 8-Bits in the data register
N  * @rmtoll DR           DR            MS32_SPI_ReceiveData8
N  * @param  SPIx SPI Instance
N  * @retval RxData Value between Min_Data=0x00 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint8_t MS32_SPI_ReceiveData8(SPI_TypeDef *SPIx) {
Xstatic __inline uint8_t MS32_SPI_ReceiveData8(SPI_TypeDef *SPIx) {
N  return (uint8_t)(READ_REG(SPIx->DR));
X  return (uint8_t)(((SPIx->DR)));
N}
N
N/**
N  * @brief  Read 16-Bits in the data register
N  * @rmtoll DR           DR            MS32_SPI_ReceiveData16
N  * @param  SPIx SPI Instance
N  * @retval RxData Value between Min_Data=0x00 and Max_Data=0xFFFF
N  */
N__STATIC_INLINE uint16_t MS32_SPI_ReceiveData16(SPI_TypeDef *SPIx) {
Xstatic __inline uint16_t MS32_SPI_ReceiveData16(SPI_TypeDef *SPIx) {
N  return (uint16_t)(READ_REG(SPIx->DR));
X  return (uint16_t)(((SPIx->DR)));
N}
N
N/**
N  * @brief  Write 8-Bits in the data register
N  * @rmtoll DR           DR            MS32_SPI_TransmitData8
N  * @param  SPIx SPI Instance
N  * @param  TxData Value between Min_Data=0x00 and Max_Data=0xFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_TransmitData8(SPI_TypeDef *SPIx, uint8_t TxData) {
Xstatic __inline void MS32_SPI_TransmitData8(SPI_TypeDef *SPIx, uint8_t TxData) {
N#if defined (__GNUC__)
X#if 0L
S  __IO uint8_t *spidr = ((__IO uint8_t *)&SPIx->DR);
S  *spidr = TxData;
N#else
N  *((__IO uint8_t *)&SPIx->DR) = TxData;
X  *((volatile uint8_t *)&SPIx->DR) = TxData;
N#endif /* __GNUC__ */
N}
N
N/**
N  * @brief  Write 16-Bits in the data register
N  * @rmtoll DR           DR            MS32_SPI_TransmitData16
N  * @param  SPIx SPI Instance
N  * @param  TxData Value between Min_Data=0x00 and Max_Data=0xFFFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SPI_TransmitData16(SPI_TypeDef *SPIx, uint16_t TxData) {
Xstatic __inline void MS32_SPI_TransmitData16(SPI_TypeDef *SPIx, uint16_t TxData) {
N#if defined (__GNUC__)
X#if 0L
S  __IO uint16_t *spidr = ((__IO uint16_t *)&SPIx->DR);
S  *spidr = TxData;
N#else
N  SPIx->DR = TxData;
N#endif /* __GNUC__ */
N}
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup I2S_EF_Configuration Configuration
N  * @{
N  */
N
N/**
N  * @brief  Select I2S mode and Enable I2S peripheral
N  * @rmtoll I2SCFGR      I2SMOD        MS32_I2S_Enable\n
N  *         I2SCFGR      I2SE          MS32_I2S_Enable
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_Enable(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_Enable(SPI_TypeDef *SPIx) {
N  SET_BIT(SPIx->I2SCFGR, SPI_I2SCFGR_I2SMOD | SPI_I2SCFGR_I2SE);
X  ((SPIx->I2SCFGR) |= ((0x1UL << (11U)) | (0x1UL << (10U))));
N}
N
N/**
N  * @brief  Disable I2S peripheral
N  * @rmtoll I2SCFGR      I2SE          MS32_I2S_Disable
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_Disable(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_Disable(SPI_TypeDef *SPIx) {
N  CLEAR_BIT(SPIx->I2SCFGR, SPI_I2SCFGR_I2SMOD | SPI_I2SCFGR_I2SE);
X  ((SPIx->I2SCFGR) &= ~((0x1UL << (11U)) | (0x1UL << (10U))));
N}
N
N/**
N  * @brief  Check if I2S peripheral is enabled
N  * @rmtoll I2SCFGR      I2SE          MS32_I2S_IsEnabled
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2S_IsEnabled(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_IsEnabled(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->I2SCFGR, SPI_I2SCFGR_I2SE) == (SPI_I2SCFGR_I2SE)) ? 1UL : 0UL);
X  return ((((SPIx->I2SCFGR) & ((0x1UL << (10U)))) == ((0x1UL << (10U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set I2S data frame length
N  * @rmtoll I2SCFGR      DATLEN        MS32_I2S_SetDataFormat\n
N  *         I2SCFGR      CHLEN         MS32_I2S_SetDataFormat
N  * @param  SPIx SPI Instance
N  * @param  DataFormat This parameter can be one of the following values:
N  *         @arg @ref MS32_I2S_DATAFORMAT_16B
N  *         @arg @ref MS32_I2S_DATAFORMAT_16B_EXTENDED
N  *         @arg @ref MS32_I2S_DATAFORMAT_24B
N  *         @arg @ref MS32_I2S_DATAFORMAT_32B
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_SetDataFormat(SPI_TypeDef *SPIx, uint32_t DataFormat) {
Xstatic __inline void MS32_I2S_SetDataFormat(SPI_TypeDef *SPIx, uint32_t DataFormat) {
N  MODIFY_REG(SPIx->I2SCFGR, SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN, DataFormat);
X  (((SPIx->I2SCFGR)) = ((((((SPIx->I2SCFGR))) & (~((0x3UL << (1U)) | (0x1UL << (0U))))) | (DataFormat))));
N}
N
N/**
N  * @brief  Get I2S data frame length
N  * @rmtoll I2SCFGR      DATLEN        MS32_I2S_GetDataFormat\n
N  *         I2SCFGR      CHLEN         MS32_I2S_GetDataFormat
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_I2S_DATAFORMAT_16B
N  *         @arg @ref MS32_I2S_DATAFORMAT_16B_EXTENDED
N  *         @arg @ref MS32_I2S_DATAFORMAT_24B
N  *         @arg @ref MS32_I2S_DATAFORMAT_32B
N  */
N__STATIC_INLINE uint32_t MS32_I2S_GetDataFormat(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_GetDataFormat(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->I2SCFGR, SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN));
X  return (uint32_t)(((SPIx->I2SCFGR) & ((0x3UL << (1U)) | (0x1UL << (0U)))));
N}
N
N/**
N  * @brief  Set I2S clock polarity
N  * @rmtoll I2SCFGR      CKPOL         MS32_I2S_SetClockPolarity
N  * @param  SPIx SPI Instance
N  * @param  ClockPolarity This parameter can be one of the following values:
N  *         @arg @ref MS32_I2S_POLARITY_LOW
N  *         @arg @ref MS32_I2S_POLARITY_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_SetClockPolarity(SPI_TypeDef *SPIx, uint32_t ClockPolarity) {
Xstatic __inline void MS32_I2S_SetClockPolarity(SPI_TypeDef *SPIx, uint32_t ClockPolarity) {
N  SET_BIT(SPIx->I2SCFGR, ClockPolarity);
X  ((SPIx->I2SCFGR) |= (ClockPolarity));
N}
N
N/**
N  * @brief  Get I2S clock polarity
N  * @rmtoll I2SCFGR      CKPOL         MS32_I2S_GetClockPolarity
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_I2S_POLARITY_LOW
N  *         @arg @ref MS32_I2S_POLARITY_HIGH
N  */
N__STATIC_INLINE uint32_t MS32_I2S_GetClockPolarity(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_GetClockPolarity(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->I2SCFGR, SPI_I2SCFGR_CKPOL));
X  return (uint32_t)(((SPIx->I2SCFGR) & ((0x1UL << (3U)))));
N}
N
N/**
N  * @brief  Set I2S standard protocol
N  * @rmtoll I2SCFGR      I2SSTD        MS32_I2S_SetStandard\n
N  *         I2SCFGR      PCMSYNC       MS32_I2S_SetStandard
N  * @param  SPIx SPI Instance
N  * @param  Standard This parameter can be one of the following values:
N  *         @arg @ref MS32_I2S_STANDARD_PHILIPS
N  *         @arg @ref MS32_I2S_STANDARD_MSB
N  *         @arg @ref MS32_I2S_STANDARD_LSB
N  *         @arg @ref MS32_I2S_STANDARD_PCM_SHORT
N  *         @arg @ref MS32_I2S_STANDARD_PCM_LONG
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_SetStandard(SPI_TypeDef *SPIx, uint32_t Standard) {
Xstatic __inline void MS32_I2S_SetStandard(SPI_TypeDef *SPIx, uint32_t Standard) {
N  MODIFY_REG(SPIx->I2SCFGR, SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC, Standard);
X  (((SPIx->I2SCFGR)) = ((((((SPIx->I2SCFGR))) & (~((0x3UL << (4U)) | (0x1UL << (7U))))) | (Standard))));
N}
N
N/**
N  * @brief  Get I2S standard protocol
N  * @rmtoll I2SCFGR      I2SSTD        MS32_I2S_GetStandard\n
N  *         I2SCFGR      PCMSYNC       MS32_I2S_GetStandard
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_I2S_STANDARD_PHILIPS
N  *         @arg @ref MS32_I2S_STANDARD_MSB
N  *         @arg @ref MS32_I2S_STANDARD_LSB
N  *         @arg @ref MS32_I2S_STANDARD_PCM_SHORT
N  *         @arg @ref MS32_I2S_STANDARD_PCM_LONG
N  */
N__STATIC_INLINE uint32_t MS32_I2S_GetStandard(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_GetStandard(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->I2SCFGR, SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC));
X  return (uint32_t)(((SPIx->I2SCFGR) & ((0x3UL << (4U)) | (0x1UL << (7U)))));
N}
N
N/**
N  * @brief  Set I2S transfer mode
N  * @rmtoll I2SCFGR      I2SCFG        MS32_I2S_SetTransferMode
N  * @param  SPIx SPI Instance
N  * @param  Mode This parameter can be one of the following values:
N  *         @arg @ref MS32_I2S_MODE_SLAVE_TX
N  *         @arg @ref MS32_I2S_MODE_SLAVE_RX
N  *         @arg @ref MS32_I2S_MODE_MASTER_TX
N  *         @arg @ref MS32_I2S_MODE_MASTER_RX
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_SetTransferMode(SPI_TypeDef *SPIx, uint32_t Mode) {
Xstatic __inline void MS32_I2S_SetTransferMode(SPI_TypeDef *SPIx, uint32_t Mode) {
N  MODIFY_REG(SPIx->I2SCFGR, SPI_I2SCFGR_I2SCFG, Mode);
X  (((SPIx->I2SCFGR)) = ((((((SPIx->I2SCFGR))) & (~((0x3UL << (8U))))) | (Mode))));
N}
N
N/**
N  * @brief  Get I2S transfer mode
N  * @rmtoll I2SCFGR      I2SCFG        MS32_I2S_GetTransferMode
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_I2S_MODE_SLAVE_TX
N  *         @arg @ref MS32_I2S_MODE_SLAVE_RX
N  *         @arg @ref MS32_I2S_MODE_MASTER_TX
N  *         @arg @ref MS32_I2S_MODE_MASTER_RX
N  */
N__STATIC_INLINE uint32_t MS32_I2S_GetTransferMode(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_GetTransferMode(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->I2SCFGR, SPI_I2SCFGR_I2SCFG));
X  return (uint32_t)(((SPIx->I2SCFGR) & ((0x3UL << (8U)))));
N}
N
N/**
N  * @brief  Set I2S linear prescaler
N  * @rmtoll I2SPR        I2SDIV        MS32_I2S_SetPrescalerLinear
N  * @param  SPIx SPI Instance
N  * @param  PrescalerLinear Value between Min_Data=0x02 and Max_Data=0xFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_SetPrescalerLinear(SPI_TypeDef *SPIx, uint8_t PrescalerLinear) {
Xstatic __inline void MS32_I2S_SetPrescalerLinear(SPI_TypeDef *SPIx, uint8_t PrescalerLinear) {
N  MODIFY_REG(SPIx->I2SPR, SPI_I2SPR_I2SDIV, PrescalerLinear);
X  (((SPIx->I2SPR)) = ((((((SPIx->I2SPR))) & (~((0xFFUL << (0U))))) | (PrescalerLinear))));
N}
N
N/**
N  * @brief  Get I2S linear prescaler
N  * @rmtoll I2SPR        I2SDIV        MS32_I2S_GetPrescalerLinear
N  * @param  SPIx SPI Instance
N  * @retval PrescalerLinear Value between Min_Data=0x02 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint32_t MS32_I2S_GetPrescalerLinear(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_GetPrescalerLinear(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->I2SPR, SPI_I2SPR_I2SDIV));
X  return (uint32_t)(((SPIx->I2SPR) & ((0xFFUL << (0U)))));
N}
N
N/**
N  * @brief  Set I2S parity prescaler
N  * @rmtoll I2SPR        ODD           MS32_I2S_SetPrescalerParity
N  * @param  SPIx SPI Instance
N  * @param  PrescalerParity This parameter can be one of the following values:
N  *         @arg @ref MS32_I2S_PRESCALER_PARITY_EVEN
N  *         @arg @ref MS32_I2S_PRESCALER_PARITY_ODD
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_SetPrescalerParity(SPI_TypeDef *SPIx, uint32_t PrescalerParity) {
Xstatic __inline void MS32_I2S_SetPrescalerParity(SPI_TypeDef *SPIx, uint32_t PrescalerParity) {
N  MODIFY_REG(SPIx->I2SPR, SPI_I2SPR_ODD, PrescalerParity << 8U);
X  (((SPIx->I2SPR)) = ((((((SPIx->I2SPR))) & (~((0x1UL << (8U))))) | (PrescalerParity << 8U))));
N}
N
N/**
N  * @brief  Get I2S parity prescaler
N  * @rmtoll I2SPR        ODD           MS32_I2S_GetPrescalerParity
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_I2S_PRESCALER_PARITY_EVEN
N  *         @arg @ref MS32_I2S_PRESCALER_PARITY_ODD
N  */
N__STATIC_INLINE uint32_t MS32_I2S_GetPrescalerParity(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_GetPrescalerParity(SPI_TypeDef *SPIx) {
N  return (uint32_t)(READ_BIT(SPIx->I2SPR, SPI_I2SPR_ODD) >> 8U);
X  return (uint32_t)(((SPIx->I2SPR) & ((0x1UL << (8U)))) >> 8U);
N}
N
N/**
N  * @brief  Enable the master clock ouput (Pin MCK)
N  * @rmtoll I2SPR        MCKOE         MS32_I2S_EnableMasterClock
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_EnableMasterClock(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_EnableMasterClock(SPI_TypeDef *SPIx) {
N  SET_BIT(SPIx->I2SPR, SPI_I2SPR_MCKOE);
X  ((SPIx->I2SPR) |= ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Disable the master clock ouput (Pin MCK)
N  * @rmtoll I2SPR        MCKOE         MS32_I2S_DisableMasterClock
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_DisableMasterClock(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_DisableMasterClock(SPI_TypeDef *SPIx) {
N  CLEAR_BIT(SPIx->I2SPR, SPI_I2SPR_MCKOE);
X  ((SPIx->I2SPR) &= ~((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Check if the master clock ouput (Pin MCK) is enabled
N  * @rmtoll I2SPR        MCKOE         MS32_I2S_IsEnabledMasterClock
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2S_IsEnabledMasterClock(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_IsEnabledMasterClock(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->I2SPR, SPI_I2SPR_MCKOE) == (SPI_I2SPR_MCKOE)) ? 1UL : 0UL);
X  return ((((SPIx->I2SPR) & ((0x1UL << (9U)))) == ((0x1UL << (9U)))) ? 1UL : 0UL);
N}
N
N
N/** @defgroup I2S_EF_FLAG FLAG Management
N  * @{
N  */
N
N/**
N  * @brief  Check if Rx buffer is not empty
N  * @rmtoll SR           RXNE          MS32_I2S_IsActiveFlag_RXNE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2S_IsActiveFlag_RXNE(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_IsActiveFlag_RXNE(SPI_TypeDef *SPIx) {
N  return MS32_SPI_IsActiveFlag_RXNE(SPIx);
N}
N
N/**
N  * @brief  Check if Tx buffer is empty
N  * @rmtoll SR           TXE           MS32_I2S_IsActiveFlag_TXE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2S_IsActiveFlag_TXE(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_IsActiveFlag_TXE(SPI_TypeDef *SPIx) {
N  return MS32_SPI_IsActiveFlag_TXE(SPIx);
N}
N
N/**
N  * @brief  Get busy flag
N  * @rmtoll SR           BSY           MS32_I2S_IsActiveFlag_BSY
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2S_IsActiveFlag_BSY(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_IsActiveFlag_BSY(SPI_TypeDef *SPIx) {
N  return MS32_SPI_IsActiveFlag_BSY(SPIx);
N}
N
N/**
N  * @brief  Get overrun error flag
N  * @rmtoll SR           OVR           MS32_I2S_IsActiveFlag_OVR
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2S_IsActiveFlag_OVR(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_IsActiveFlag_OVR(SPI_TypeDef *SPIx) {
N  return MS32_SPI_IsActiveFlag_OVR(SPIx);
N}
N
N/**
N  * @brief  Get underrun error flag
N  * @rmtoll SR           UDR           MS32_I2S_IsActiveFlag_UDR
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2S_IsActiveFlag_UDR(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_IsActiveFlag_UDR(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->SR, SPI_SR_UDR) == (SPI_SR_UDR)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (3U)))) == ((0x1UL << (3U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get frame format error flag
N  * @rmtoll SR           FRE           MS32_I2S_IsActiveFlag_FRE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2S_IsActiveFlag_FRE(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_IsActiveFlag_FRE(SPI_TypeDef *SPIx) {
N  return MS32_SPI_IsActiveFlag_FRE(SPIx);
N}
N
N/**
N  * @brief  Get channel side flag.
N  * @note   0: Channel Left has to be transmitted or has been received\n
N  *         1: Channel Right has to be transmitted or has been received\n
N  *         It has no significance in PCM mode.
N  * @rmtoll SR           CHSIDE        MS32_I2S_IsActiveFlag_CHSIDE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2S_IsActiveFlag_CHSIDE(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_IsActiveFlag_CHSIDE(SPI_TypeDef *SPIx) {
N  return ((READ_BIT(SPIx->SR, SPI_SR_CHSIDE) == (SPI_SR_CHSIDE)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (2U)))) == ((0x1UL << (2U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear overrun error flag
N  * @rmtoll SR           OVR           MS32_I2S_ClearFlag_OVR
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_ClearFlag_OVR(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_ClearFlag_OVR(SPI_TypeDef *SPIx) {
N  MS32_SPI_ClearFlag_OVR(SPIx);
N}
N
N/**
N  * @brief  Clear underrun error flag
N  * @rmtoll SR           UDR           MS32_I2S_ClearFlag_UDR
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_ClearFlag_UDR(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_ClearFlag_UDR(SPI_TypeDef *SPIx) {
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  tmpreg = SPIx->SR;
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Clear frame format error flag
N  * @rmtoll SR           FRE           MS32_I2S_ClearFlag_FRE
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_ClearFlag_FRE(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_ClearFlag_FRE(SPI_TypeDef *SPIx) {
N  MS32_SPI_ClearFlag_FRE(SPIx);
N}
N
N
N/** @defgroup I2S_EF_IT Interrupt Management
N  * @{
N  */
N
N/**
N  * @brief  Enable error IT
N  * @note   This bit controls the generation of an interrupt when an error condition occurs (OVR, UDR and FRE in I2S mode).
N  * @rmtoll CR2          ERRIE         MS32_I2S_EnableIT_ERR
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_EnableIT_ERR(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_EnableIT_ERR(SPI_TypeDef *SPIx) {
N  MS32_SPI_EnableIT_ERR(SPIx);
N}
N
N/**
N  * @brief  Enable Rx buffer not empty IT
N  * @rmtoll CR2          RXNEIE        MS32_I2S_EnableIT_RXNE
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_EnableIT_RXNE(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_EnableIT_RXNE(SPI_TypeDef *SPIx) {
N  MS32_SPI_EnableIT_RXNE(SPIx);
N}
N
N/**
N  * @brief  Enable Tx buffer empty IT
N  * @rmtoll CR2          TXEIE         MS32_I2S_EnableIT_TXE
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_EnableIT_TXE(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_EnableIT_TXE(SPI_TypeDef *SPIx) {
N  MS32_SPI_EnableIT_TXE(SPIx);
N}
N
N/**
N  * @brief  Disable error IT
N  * @note   This bit controls the generation of an interrupt when an error condition occurs (OVR, UDR and FRE in I2S mode).
N  * @rmtoll CR2          ERRIE         MS32_I2S_DisableIT_ERR
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_DisableIT_ERR(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_DisableIT_ERR(SPI_TypeDef *SPIx) {
N  MS32_SPI_DisableIT_ERR(SPIx);
N}
N
N/**
N  * @brief  Disable Rx buffer not empty IT
N  * @rmtoll CR2          RXNEIE        MS32_I2S_DisableIT_RXNE
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_DisableIT_RXNE(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_DisableIT_RXNE(SPI_TypeDef *SPIx) {
N  MS32_SPI_DisableIT_RXNE(SPIx);
N}
N
N/**
N  * @brief  Disable Tx buffer empty IT
N  * @rmtoll CR2          TXEIE         MS32_I2S_DisableIT_TXE
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_DisableIT_TXE(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_DisableIT_TXE(SPI_TypeDef *SPIx) {
N  MS32_SPI_DisableIT_TXE(SPIx);
N}
N
N/**
N  * @brief  Check if ERR IT is enabled
N  * @rmtoll CR2          ERRIE         MS32_I2S_IsEnabledIT_ERR
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2S_IsEnabledIT_ERR(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_IsEnabledIT_ERR(SPI_TypeDef *SPIx) {
N  return MS32_SPI_IsEnabledIT_ERR(SPIx);
N}
N
N/**
N  * @brief  Check if RXNE IT is enabled
N  * @rmtoll CR2          RXNEIE        MS32_I2S_IsEnabledIT_RXNE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2S_IsEnabledIT_RXNE(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_IsEnabledIT_RXNE(SPI_TypeDef *SPIx) {
N  return MS32_SPI_IsEnabledIT_RXNE(SPIx);
N}
N
N/**
N  * @brief  Check if TXE IT is enabled
N  * @rmtoll CR2          TXEIE         MS32_I2S_IsEnabledIT_TXE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2S_IsEnabledIT_TXE(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_IsEnabledIT_TXE(SPI_TypeDef *SPIx) {
N  return MS32_SPI_IsEnabledIT_TXE(SPIx);
N}
N
N
N/** @defgroup I2S_EF_DMA DMA Management
N  * @{
N  */
N
N/**
N  * @brief  Enable DMA Rx
N  * @rmtoll CR2          RXDMAEN       MS32_I2S_EnableDMAReq_RX
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_EnableDMAReq_RX(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_EnableDMAReq_RX(SPI_TypeDef *SPIx) {
N  MS32_SPI_EnableDMAReq_RX(SPIx);
N}
N
N/**
N  * @brief  Disable DMA Rx
N  * @rmtoll CR2          RXDMAEN       MS32_I2S_DisableDMAReq_RX
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_DisableDMAReq_RX(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_DisableDMAReq_RX(SPI_TypeDef *SPIx) {
N  MS32_SPI_DisableDMAReq_RX(SPIx);
N}
N
N/**
N  * @brief  Check if DMA Rx is enabled
N  * @rmtoll CR2          RXDMAEN       MS32_I2S_IsEnabledDMAReq_RX
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2S_IsEnabledDMAReq_RX(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_IsEnabledDMAReq_RX(SPI_TypeDef *SPIx) {
N  return MS32_SPI_IsEnabledDMAReq_RX(SPIx);
N}
N
N/**
N  * @brief  Enable DMA Tx
N  * @rmtoll CR2          TXDMAEN       MS32_I2S_EnableDMAReq_TX
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_EnableDMAReq_TX(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_EnableDMAReq_TX(SPI_TypeDef *SPIx) {
N  MS32_SPI_EnableDMAReq_TX(SPIx);
N}
N
N/**
N  * @brief  Disable DMA Tx
N  * @rmtoll CR2          TXDMAEN       MS32_I2S_DisableDMAReq_TX
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_DisableDMAReq_TX(SPI_TypeDef *SPIx) {
Xstatic __inline void MS32_I2S_DisableDMAReq_TX(SPI_TypeDef *SPIx) {
N  MS32_SPI_DisableDMAReq_TX(SPIx);
N}
N
N/**
N  * @brief  Check if DMA Tx is enabled
N  * @rmtoll CR2          TXDMAEN       MS32_I2S_IsEnabledDMAReq_TX
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_I2S_IsEnabledDMAReq_TX(SPI_TypeDef *SPIx) {
Xstatic __inline uint32_t MS32_I2S_IsEnabledDMAReq_TX(SPI_TypeDef *SPIx) {
N  return MS32_SPI_IsEnabledDMAReq_TX(SPIx);
N}
N
N
N/** @defgroup I2S_EF_DATA DATA Management
N  * @{
N  */
N
N/**
N  * @brief  Read 16-Bits in data register
N  * @rmtoll DR           DR            MS32_I2S_ReceiveData16
N  * @param  SPIx SPI Instance
N  * @retval RxData Value between Min_Data=0x0000 and Max_Data=0xFFFF
N  */
N__STATIC_INLINE uint16_t MS32_I2S_ReceiveData16(SPI_TypeDef *SPIx) {
Xstatic __inline uint16_t MS32_I2S_ReceiveData16(SPI_TypeDef *SPIx) {
N  return MS32_SPI_ReceiveData16(SPIx);
N}
N
N/**
N  * @brief  Write 16-Bits in data register
N  * @rmtoll DR           DR            MS32_I2S_TransmitData16
N  * @param  SPIx SPI Instance
N  * @param  TxData Value between Min_Data=0x0000 and Max_Data=0xFFFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_I2S_TransmitData16(SPI_TypeDef *SPIx, uint16_t TxData) {
Xstatic __inline void MS32_I2S_TransmitData16(SPI_TypeDef *SPIx, uint16_t TxData) {
N  MS32_SPI_TransmitData16(SPIx, TxData);
N}
N
N
N/** @defgroup SPI_EF_Init Initialization and de-initialization functions
N  * @{
N  */
NErrorStatus MS32_SPI_DeInit      (SPI_TypeDef *SPIx);
NErrorStatus MS32_SPI_Init        (SPI_TypeDef *SPIx, MS32_SPI_InitTypeDef *SpiInitStr);
Nvoid        MS32_SPI_StructInit  (MS32_SPI_InitTypeDef *SpiInitStr);
Nvoid        MS32_SPI_ITConfig    (SPI_TypeDef *SPIx, uint32_t InterruptFunc, uint32_t Priority);
N
N/** @defgroup I2S_EF_Init Initialization and de-initialization functions
N  * @{
N  */
NErrorStatus MS32_I2S_DeInit          (SPI_TypeDef *SPIx);
NErrorStatus MS32_I2S_Init            (SPI_TypeDef *SPIx, MS32_I2S_InitTypeDef *I2S_InitStruct);
Nvoid        MS32_I2S_StructInit      (MS32_I2S_InitTypeDef *I2S_InitStruct);
Nvoid        MS32_I2S_ConfigPrescaler (SPI_TypeDef *SPIx, uint32_t PrescalerLinear, uint32_t PrescalerParity);
N
N/** @defgroup SPI_EF_Application function
N  * @{
N  */
NFlagStatus MS32_SPI_GetStatusFlag (SPI_TypeDef *SPIx, uint32_t Flags);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_SPI_H */
N
N/******************************** END OF FILE *********************************/
L 79 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_system.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_system.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_SYSTEM_H
N#define __MS32F0XX_SYSTEM_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup SYSTEM_Exported_Constants SYSTEM Exported Constants(APP)
N  * @{
N  */
N
N
N/** @defgroup SYSTEM_Exported_Constants SYSTEM Exported Constants(BASE)
N  * @{
N  */
N/** @defgroup SYSTEM_EC_REMAP SYSCFG Remap
N* @{
N*/
N#define MS32_SYSCFG_REMAP_FLASH              (uint32_t)0x00000000U                               /*!< Main Flash memory mapped at 0x00000000 */
N#define MS32_SYSCFG_REMAP_SYSTEMFLASH        SYSCFG_CFGR1_MEM_MODE_0                             /*!< System Flash memory mapped at 0x00000000 */
N#define MS32_SYSCFG_REMAP_SRAM               (SYSCFG_CFGR1_MEM_MODE_1 | SYSCFG_CFGR1_MEM_MODE_0) /*!< Embedded SRAM mapped at 0x00000000 */
N
N
N/** @defgroup SYSTEM_EC_USART1TX_RMP SYSCFG USART DMA Remap
N  * @{
N  */
N#define MS32_SYSCFG_USART1TX_RMP_DMA1CH2     ((SYSCFG_CFGR1_USART1TX_DMA_RMP >> 8U) | (uint32_t)0x00000000U)         /*!< USART1_TX DMA request mapped on DMA channel 2U */
N#define MS32_SYSCFG_USART1TX_RMP_DMA1CH4     ((SYSCFG_CFGR1_USART1TX_DMA_RMP >> 8U) | SYSCFG_CFGR1_USART1TX_DMA_RMP) /*!< USART1_TX DMA request mapped on DMA channel 4U */
N#define MS32_SYSCFG_USART1RX_RMP_DMA1CH3     ((SYSCFG_CFGR1_USART1RX_DMA_RMP >> 8U) | (uint32_t)0x00000000U)         /*!< USART1_RX DMA request mapped on DMA channel 3U */
N#define MS32_SYSCFG_USART1RX_RMP_DMA1CH5     ((SYSCFG_CFGR1_USART1RX_DMA_RMP >> 8U) | SYSCFG_CFGR1_USART1RX_DMA_RMP) /*!< USART1_RX DMA request mapped on DMA channel 5 */
N
N
N/** @defgroup SYSTEM_EC_TIM16_RMP_DMA1 SYSCFG TIM DMA Remap
N  * @{
N  */
N#define MS32_SYSCFG_TIM16_RMP_DMA1_CH3       ((SYSCFG_CFGR1_TIM16_DMA_RMP >> 8U) | (uint32_t)0x00000000U)      /*!< TIM16_CH1 and TIM16_UP DMA requests mapped on DMA channel 3 */
N#define MS32_SYSCFG_TIM16_RMP_DMA1_CH4       ((SYSCFG_CFGR1_TIM16_DMA_RMP >> 8U) | SYSCFG_CFGR1_TIM16_DMA_RMP) /*!< TIM16_CH1 and TIM16_UP DMA requests mapped on DMA channel 4 */
N#define MS32_SYSCFG_TIM17_RMP_DMA1_CH1       ((SYSCFG_CFGR1_TIM17_DMA_RMP >> 8U) | (uint32_t)0x00000000U)      /*!< TIM17_CH1 and TIM17_UP DMA requests mapped on DMA channel 1 */
N#define MS32_SYSCFG_TIM17_RMP_DMA1_CH2       ((SYSCFG_CFGR1_TIM17_DMA_RMP >> 8U) | SYSCFG_CFGR1_TIM17_DMA_RMP) /*!< TIM17_CH1 and TIM17_UP DMA requests mapped on DMA channel 2 */
N
N
N/** @defgroup SYSTEM_EC_I2C_FASTMODEPLUS SYSCFG I2C FASTMODEPLUS
N  * @{
N  */
N#define MS32_SYSCFG_I2C_FASTMODEPLUS_PB6     SYSCFG_CFGR1_I2C_FMP_PB6  /*!< I2C PB6 Fast mode plus */
N#define MS32_SYSCFG_I2C_FASTMODEPLUS_PB7     SYSCFG_CFGR1_I2C_FMP_PB7  /*!< I2C PB7 Fast mode plus */
N#define MS32_SYSCFG_I2C_FASTMODEPLUS_PB8     SYSCFG_CFGR1_I2C_FMP_PB8  /*!< I2C PB8 Fast mode plus */
N#define MS32_SYSCFG_I2C_FASTMODEPLUS_PB9     SYSCFG_CFGR1_I2C_FMP_PB9  /*!< I2C PB9 Fast mode plus */
N#define MS32_SYSCFG_I2C_FASTMODEPLUS_I2C1    SYSCFG_CFGR1_I2C_FMP_I2C1 /*!< Enable Fast Mode Plus on PB10, PB11, PF6 and PF7  */
N#define MS32_SYSCFG_I2C_FASTMODEPLUS_PA9     SYSCFG_CFGR1_I2C_FMP_PA9  /*!< Enable Fast Mode Plus on PA9  */
N#define MS32_SYSCFG_I2C_FASTMODEPLUS_PA10    SYSCFG_CFGR1_I2C_FMP_PA10 /*!< Enable Fast Mode Plus on PA10 */
N
N
N/** @defgroup SYSTEM_EC_EXTI_PORT SYSCFG EXTI PORT
N  * @{
N  */
N#define MS32_SYSCFG_EXTI_PORTA               (uint32_t)(0U) /*!< EXTI PORT A */
N#define MS32_SYSCFG_EXTI_PORTB               (uint32_t)(1U) /*!< EXTI PORT B */
N#define MS32_SYSCFG_EXTI_PORTC               (uint32_t)(2U) /*!< EXTI PORT C */
N#define MS32_SYSCFG_EXTI_PORTF               (uint32_t)(5U) /*!< EXTI PORT F */
N
N
N/** @defgroup SYSTEM_EC_EXTI_LINE SYSCFG EXTI LINE
N  * @{
N  */
N#define MS32_SYSCFG_EXTI_LINE0               (uint32_t)(0U << 16U | 0U)  /*!< EXTI_POSITION_0  | EXTICR[0] */
N#define MS32_SYSCFG_EXTI_LINE1               (uint32_t)(4U << 16U | 0U)  /*!< EXTI_POSITION_4  | EXTICR[0] */
N#define MS32_SYSCFG_EXTI_LINE2               (uint32_t)(8U << 16U | 0U)  /*!< EXTI_POSITION_8  | EXTICR[0] */
N#define MS32_SYSCFG_EXTI_LINE3               (uint32_t)(12U << 16U | 0U) /*!< EXTI_POSITION_12 | EXTICR[0] */
N#define MS32_SYSCFG_EXTI_LINE4               (uint32_t)(0U << 16U | 1U)  /*!< EXTI_POSITION_0  | EXTICR[1] */
N#define MS32_SYSCFG_EXTI_LINE5               (uint32_t)(4U << 16U | 1U)  /*!< EXTI_POSITION_4  | EXTICR[1] */
N#define MS32_SYSCFG_EXTI_LINE6               (uint32_t)(8U << 16U | 1U)  /*!< EXTI_POSITION_8  | EXTICR[1] */
N#define MS32_SYSCFG_EXTI_LINE7               (uint32_t)(12U << 16U | 1U) /*!< EXTI_POSITION_12 | EXTICR[1] */
N#define MS32_SYSCFG_EXTI_LINE8               (uint32_t)(0U << 16U | 2U)  /*!< EXTI_POSITION_0  | EXTICR[2] */
N#define MS32_SYSCFG_EXTI_LINE9               (uint32_t)(4U << 16U | 2U)  /*!< EXTI_POSITION_4  | EXTICR[2] */
N#define MS32_SYSCFG_EXTI_LINE10              (uint32_t)(8U << 16U | 2U)  /*!< EXTI_POSITION_8  | EXTICR[2] */
N#define MS32_SYSCFG_EXTI_LINE11              (uint32_t)(12U << 16U | 2U) /*!< EXTI_POSITION_12 | EXTICR[2] */
N#define MS32_SYSCFG_EXTI_LINE12              (uint32_t)(0U << 16U | 3U)  /*!< EXTI_POSITION_0  | EXTICR[3] */
N#define MS32_SYSCFG_EXTI_LINE13              (uint32_t)(4U << 16U | 3U)  /*!< EXTI_POSITION_4  | EXTICR[3] */
N#define MS32_SYSCFG_EXTI_LINE14              (uint32_t)(8U << 16U | 3U)  /*!< EXTI_POSITION_8  | EXTICR[3] */
N#define MS32_SYSCFG_EXTI_LINE15              (uint32_t)(12U << 16U | 3U) /*!< EXTI_POSITION_12 | EXTICR[3] */
N
N
N/** @defgroup SYSTEM_EC_TIMBREAK SYSCFG TIMER BREAK
N  * @{
N  */
N#define MS32_SYSCFG_TIMBREAK_PVD             SYSCFG_CFGR2_PVD_LOCK         /*!< Enables and locks the PVD connection with TIM1/15/16U/17 Break Input and also  the PVDE and PLS bits of the Power Control Interface */
N#define MS32_SYSCFG_TIMBREAK_SRAM_PARITY     SYSCFG_CFGR2_SRAM_PARITY_LOCK /*!< Enables and locks the SRAM_PARITY error signal with Break Input of TIM1/15/16/17 */
N#define MS32_SYSCFG_TIMBREAK_LOCKUP          SYSCFG_CFGR2_LOCKUP_LOCK      /*!< Enables and locks the LOCKUP (Hardfault) output of CortexM0 with Break Input of TIM1/15/16/17 */
N
N
N/** @defgroup SYSTEM_EC_APB1_GRP1_STOP_IP  DBGMCU APB1 GRP1 STOP IP
N  * @{
N  */
N#define MS32_DBGMCU_APB1_GRP1_TIM2_STOP      DBGMCU_APB1_FZ_DBG_TIM2_STOP          /*!< TIM2 counter stopped when core is halted */
N#define MS32_DBGMCU_APB1_GRP1_TIM3_STOP      DBGMCU_APB1_FZ_DBG_TIM3_STOP          /*!< TIM3 counter stopped when core is halted */
N#define MS32_DBGMCU_APB1_GRP1_TIM14_STOP     DBGMCU_APB1_FZ_DBG_TIM14_STOP         /*!< TIM14 counter stopped when core is halted */
N#define MS32_DBGMCU_APB1_GRP1_RTC_STOP       DBGMCU_APB1_FZ_DBG_RTC_STOP           /*!< RTC Calendar frozen when core is halted */
N#define MS32_DBGMCU_APB1_GRP1_WWDG_STOP      DBGMCU_APB1_FZ_DBG_WWDG_STOP          /*!< Debug Window Watchdog stopped when Core is halted */
N#define MS32_DBGMCU_APB1_GRP1_IWDG_STOP      DBGMCU_APB1_FZ_DBG_IWDG_STOP          /*!< Debug Independent Watchdog stopped when Core is halted */
N#define MS32_DBGMCU_APB1_GRP1_I2C1_STOP      DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT /*!< I2C1 SMBUS timeout mode stopped when Core is halted */
N
N
N/** @defgroup SYSTEM_EC_APB1 GRP2_STOP_IP DBGMCU APB1 GRP2 STOP IP
N  * @{
N  */
N#define MS32_DBGMCU_APB1_GRP2_TIM1_STOP      DBGMCU_APB2_FZ_DBG_TIM1_STOP  /*!< TIM1 counter stopped when core is halted */
N#define MS32_DBGMCU_APB1_GRP2_TIM16_STOP     DBGMCU_APB2_FZ_DBG_TIM16_STOP /*!< TIM16 counter stopped when core is halted */
N#define MS32_DBGMCU_APB1_GRP2_TIM17_STOP     DBGMCU_APB2_FZ_DBG_TIM17_STOP /*!< TIM17 counter stopped when core is halted */
N
N
N/** @defgroup SYSTEM_EC_LATENCY FLASH LATENCY
N  * @{
N  */
N#define MS32_FLASH_LATENCY_0                 (0x00000000U)     /*!< FLASH Zero Latency cycle */
N#define MS32_FLASH_LATENCY_1                 FLASH_ACR_LATENCY /*!< FLASH One Latency cycle */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup SYSTEM_EF_SYSCFG SYSCFG
N  * @{
N  */
N
N/**
N  * @brief  Set memory mapping at address 0x00000000
N  * @rmtoll SYSCFG_CFGR1 MEM_MODE      MS32_SYSCFG_SetRemapMemory
N  * @param  Memory This parameter can be one of the following values:
N  *         @arg @ref MS32_SYSCFG_REMAP_FLASH
N  *         @arg @ref MS32_SYSCFG_REMAP_SYSTEMFLASH
N  *         @arg @ref MS32_SYSCFG_REMAP_SRAM
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SYSCFG_SetRemapMemory(uint32_t Memory) {
Xstatic __inline void MS32_SYSCFG_SetRemapMemory(uint32_t Memory) {
N  MODIFY_REG(SYSCFG->CFGR1, SYSCFG_CFGR1_MEM_MODE, Memory);
X  (((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->CFGR1)) = ((((((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->CFGR1))) & (~((0x3UL << (0U))))) | (Memory))));
N}
N
N/**
N  * @brief  Get memory mapping at address 0x00000000
N  * @rmtoll SYSCFG_CFGR1 MEM_MODE      MS32_SYSCFG_GetRemapMemory
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SYSCFG_REMAP_FLASH
N  *         @arg @ref MS32_SYSCFG_REMAP_SYSTEMFLASH
N  *         @arg @ref MS32_SYSCFG_REMAP_SRAM
N  */
N__STATIC_INLINE uint32_t MS32_SYSCFG_GetRemapMemory(void) {
Xstatic __inline uint32_t MS32_SYSCFG_GetRemapMemory(void) {
N  return (uint32_t)(READ_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_MEM_MODE));
X  return (uint32_t)(((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->CFGR1) & ((0x3UL << (0U)))));
N}
N
N/**
N  * @brief  Set DMA request remapping bits for USART
N  * @rmtoll SYSCFG_CFGR1 USART1TX_DMA_RMP  MS32_SYSCFG_SetRemapDMA_USART\n
N  *         SYSCFG_CFGR1 USART1RX_DMA_RMP  MS32_SYSCFG_SetRemapDMA_USART\n
N  *         SYSCFG_CFGR1 USART2_DMA_RMP  MS32_SYSCFG_SetRemapDMA_USART\n
N  *         SYSCFG_CFGR1 USART3_DMA_RMP  MS32_SYSCFG_SetRemapDMA_USART
N  * @param  Remap This parameter can be one of the following values:
N  *         @arg @ref MS32_SYSCFG_USART1TX_RMP_DMA1CH2 (*)
N  *         @arg @ref MS32_SYSCFG_USART1TX_RMP_DMA1CH4 (*)
N  *         @arg @ref MS32_SYSCFG_USART1RX_RMP_DMA1CH3 (*)
N  *         @arg @ref MS32_SYSCFG_USART1RX_RMP_DMA1CH5 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SYSCFG_SetRemapDMA_USART(uint32_t Remap) {
Xstatic __inline void MS32_SYSCFG_SetRemapDMA_USART(uint32_t Remap) {
N  MODIFY_REG(SYSCFG->CFGR1, (Remap & 0x00FF00FFU) << 8U, (Remap & 0xFF00FF00U));
X  (((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->CFGR1)) = ((((((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->CFGR1))) & (~((Remap & 0x00FF00FFU) << 8U))) | ((Remap & 0xFF00FF00U)))));
N}
N
N/**
N  * @brief  Set DMA request remapping bits for TIM
N  * @rmtoll SYSCFG_CFGR1 TIM16_DMA_RMP  MS32_SYSCFG_SetRemapDMA_TIM\n
N  *         SYSCFG_CFGR1 TIM17_DMA_RMP  MS32_SYSCFG_SetRemapDMA_TIM\n
N  *         SYSCFG_CFGR1 TIM16_DMA_RMP2 MS32_SYSCFG_SetRemapDMA_TIM\n
N  *         SYSCFG_CFGR1 TIM17_DMA_RMP2 MS32_SYSCFG_SetRemapDMA_TIM\n
N  *         SYSCFG_CFGR1 TIM1_DMA_RMP   MS32_SYSCFG_SetRemapDMA_TIM\n
N  *         SYSCFG_CFGR1 TIM2_DMA_RMP   MS32_SYSCFG_SetRemapDMA_TIM\n
N  *         SYSCFG_CFGR1 TIM3_DMA_RMP   MS32_SYSCFG_SetRemapDMA_TIM
N  * @param  Remap This parameter can be one of the following values:
N  *         @arg @ref MS32_SYSCFG_TIM16_RMP_DMA1_CH3 (*)
N  *         @arg @ref MS32_SYSCFG_TIM16_RMP_DMA1_CH4 (*)
N  *         @arg @ref MS32_SYSCFG_TIM16_RMP_DMA1_CH6 (*)
N  *         @arg @ref MS32_SYSCFG_TIM17_RMP_DMA1_CH1 (*)
N  *         @arg @ref MS32_SYSCFG_TIM17_RMP_DMA1_CH2 (*)
N  *         @arg @ref MS32_SYSCFG_TIM17_RMP_DMA1_CH7 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SYSCFG_SetRemapDMA_TIM(uint32_t Remap) {
Xstatic __inline void MS32_SYSCFG_SetRemapDMA_TIM(uint32_t Remap) {
N  MODIFY_REG(SYSCFG->CFGR1, (Remap & 0x00FF00FFU) << 8U, (Remap & 0xFF00FF00U));
X  (((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->CFGR1)) = ((((((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->CFGR1))) & (~((Remap & 0x00FF00FFU) << 8U))) | ((Remap & 0xFF00FF00U)))));
N}
N
N/**
N  * @brief  Enable the I2C fast mode plus driving capability.
N  * @rmtoll SYSCFG_CFGR1 I2C_FMP_PB6   MS32_SYSCFG_EnableFastModePlus\n
N  *         SYSCFG_CFGR1 I2C_FMP_PB7   MS32_SYSCFG_EnableFastModePlus\n
N  *         SYSCFG_CFGR1 I2C_FMP_PB8   MS32_SYSCFG_EnableFastModePlus\n
N  *         SYSCFG_CFGR1 I2C_FMP_PB9   MS32_SYSCFG_EnableFastModePlus\n
N  *         SYSCFG_CFGR1 I2C_FMP_I2C1  MS32_SYSCFG_EnableFastModePlus\n
N  *         SYSCFG_CFGR1 I2C_FMP_I2C2  MS32_SYSCFG_EnableFastModePlus\n
N  *         SYSCFG_CFGR1 I2C_FMP_PA9   MS32_SYSCFG_EnableFastModePlus\n
N  *         SYSCFG_CFGR1 I2C_FMP_PA10  MS32_SYSCFG_EnableFastModePlus
N  * @param  ConfigFastModePlus This parameter can be a combination of the following values:
N  *         @arg @ref MS32_SYSCFG_I2C_FASTMODEPLUS_PB6
N  *         @arg @ref MS32_SYSCFG_I2C_FASTMODEPLUS_PB7
N  *         @arg @ref MS32_SYSCFG_I2C_FASTMODEPLUS_PB8
N  *         @arg @ref MS32_SYSCFG_I2C_FASTMODEPLUS_PB9
N  *         @arg @ref MS32_SYSCFG_I2C_FASTMODEPLUS_I2C1
N  *         @arg @ref MS32_SYSCFG_I2C_FASTMODEPLUS_PA9
N  *         @arg @ref MS32_SYSCFG_I2C_FASTMODEPLUS_PA10
N  *
N  *         (*) value not defined in all devices
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SYSCFG_EnableFastModePlus(uint32_t ConfigFastModePlus) {
Xstatic __inline void MS32_SYSCFG_EnableFastModePlus(uint32_t ConfigFastModePlus) {
N  SET_BIT(SYSCFG->CFGR1, ConfigFastModePlus);
X  ((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->CFGR1) |= (ConfigFastModePlus));
N}
N
N/**
N  * @brief  Disable the I2C fast mode plus driving capability.
N  * @rmtoll SYSCFG_CFGR1 I2C_FMP_PB6   MS32_SYSCFG_DisableFastModePlus\n
N  *         SYSCFG_CFGR1 I2C_FMP_PB7   MS32_SYSCFG_DisableFastModePlus\n
N  *         SYSCFG_CFGR1 I2C_FMP_PB8   MS32_SYSCFG_DisableFastModePlus\n
N  *         SYSCFG_CFGR1 I2C_FMP_PB9   MS32_SYSCFG_DisableFastModePlus\n
N  *         SYSCFG_CFGR1 I2C_FMP_I2C1  MS32_SYSCFG_DisableFastModePlus\n
N  *         SYSCFG_CFGR1 I2C_FMP_I2C2  MS32_SYSCFG_DisableFastModePlus\n
N  *         SYSCFG_CFGR1 I2C_FMP_PA9   MS32_SYSCFG_DisableFastModePlus\n
N  *         SYSCFG_CFGR1 I2C_FMP_PA10  MS32_SYSCFG_DisableFastModePlus
N  * @param  ConfigFastModePlus This parameter can be a combination of the following values:
N  *         @arg @ref MS32_SYSCFG_I2C_FASTMODEPLUS_PB6
N  *         @arg @ref MS32_SYSCFG_I2C_FASTMODEPLUS_PB7
N  *         @arg @ref MS32_SYSCFG_I2C_FASTMODEPLUS_PB8
N  *         @arg @ref MS32_SYSCFG_I2C_FASTMODEPLUS_PB9
N  *         @arg @ref MS32_SYSCFG_I2C_FASTMODEPLUS_I2C1
N  *         @arg @ref MS32_SYSCFG_I2C_FASTMODEPLUS_PA9
N  *         @arg @ref MS32_SYSCFG_I2C_FASTMODEPLUS_PA10
N  *
N  *         (*) value not defined in all devices
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SYSCFG_DisableFastModePlus(uint32_t ConfigFastModePlus) {
Xstatic __inline void MS32_SYSCFG_DisableFastModePlus(uint32_t ConfigFastModePlus) {
N  CLEAR_BIT(SYSCFG->CFGR1, ConfigFastModePlus);
X  ((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->CFGR1) &= ~(ConfigFastModePlus));
N}
N
N/**
N  * @brief  Configure source input for the EXTI external interrupt.
N  * @rmtoll SYSCFG_EXTICR1 EXTI0         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR1 EXTI1         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR1 EXTI2         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR1 EXTI3         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR2 EXTI4         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR2 EXTI5         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR2 EXTI6         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR2 EXTI7         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR3 EXTI8         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR3 EXTI9         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR3 EXTI10        MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR3 EXTI11        MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR4 EXTI12        MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR4 EXTI13        MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR4 EXTI14        MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR4 EXTI15        MS32_SYSCFG_SetEXTISource
N  * @param  Port This parameter can be one of the following values:
N  *         @arg @ref MS32_SYSCFG_EXTI_PORTA
N  *         @arg @ref MS32_SYSCFG_EXTI_PORTB
N  *         @arg @ref MS32_SYSCFG_EXTI_PORTC
N  *         @arg @ref MS32_SYSCFG_EXTI_PORTF
N  *
N  *         (*) value not defined in all devices
N  * @param  Line This parameter can be one of the following values:
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE0
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE1
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE2
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE3
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE4
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE5
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE6
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE7
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE8
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE9
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE10
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE11
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE12
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE13
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE14
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE15
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SYSCFG_SetEXTISource(uint32_t Port, uint32_t Line) {
Xstatic __inline void MS32_SYSCFG_SetEXTISource(uint32_t Port, uint32_t Line) {
N  MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], SYSCFG_EXTICR1_EXTI0 << (Line >> 16), Port << (Line >> 16));
X  (((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->EXTICR[Line & 0xFF])) = ((((((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->EXTICR[Line & 0xFF]))) & (~((0xFUL << (0U)) << (Line >> 16)))) | (Port << (Line >> 16)))));
N}
N
N/**
N  * @brief  Get the configured defined for specific EXTI Line
N  * @rmtoll SYSCFG_EXTICR1 EXTI0         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR1 EXTI1         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR1 EXTI2         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR1 EXTI3         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR2 EXTI4         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR2 EXTI5         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR2 EXTI6         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR2 EXTI7         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR3 EXTI8         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR3 EXTI9         MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR3 EXTI10        MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR3 EXTI11        MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR4 EXTI12        MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR4 EXTI13        MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR4 EXTI14        MS32_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR4 EXTI15        MS32_SYSCFG_SetEXTISource
N  * @param  Line This parameter can be one of the following values:
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE0
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE1
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE2
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE3
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE4
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE5
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE6
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE7
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE8
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE9
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE10
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE11
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE12
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE13
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE14
N  *         @arg @ref MS32_SYSCFG_EXTI_LINE15
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_SYSCFG_EXTI_PORTA
N  *         @arg @ref MS32_SYSCFG_EXTI_PORTB
N  *         @arg @ref MS32_SYSCFG_EXTI_PORTC
N  *         @arg @ref MS32_SYSCFG_EXTI_PORTF
N  *
N  *         (*) value not defined in all devices
N  */
N__STATIC_INLINE uint32_t MS32_SYSCFG_GetEXTISource(uint32_t Line) {
Xstatic __inline uint32_t MS32_SYSCFG_GetEXTISource(uint32_t Line) {
N  return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0xFF], (SYSCFG_EXTICR1_EXTI0 << (Line >> 16))) >> (Line >> 16));
X  return (uint32_t)(((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->EXTICR[Line & 0xFF]) & (((0xFUL << (0U)) << (Line >> 16)))) >> (Line >> 16));
N}
N
N/**
N  * @brief  Set connections to TIMx Break inputs
N  * @rmtoll SYSCFG_CFGR2 LOCKUP_LOCK   MS32_SYSCFG_SetTIMBreakInputs\n
N  *         SYSCFG_CFGR2 SRAM_PARITY_LOCK  MS32_SYSCFG_SetTIMBreakInputs\n
N  *         SYSCFG_CFGR2 PVD_LOCK      MS32_SYSCFG_SetTIMBreakInputs
N  * @param  Break This parameter can be a combination of the following values:
N  *         @arg @ref MS32_SYSCFG_TIMBREAK_PVD
N  *         @arg @ref MS32_SYSCFG_TIMBREAK_SRAM_PARITY
N  *         @arg @ref MS32_SYSCFG_TIMBREAK_LOCKUP
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SYSCFG_SetTIMBreakInputs(uint32_t Break) {
Xstatic __inline void MS32_SYSCFG_SetTIMBreakInputs(uint32_t Break) {
N  MODIFY_REG(SYSCFG->CFGR2, SYSCFG_CFGR2_LOCKUP_LOCK | SYSCFG_CFGR2_SRAM_PARITY_LOCK | SYSCFG_CFGR2_PVD_LOCK, Break);
X  (((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->CFGR2)) = ((((((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->CFGR2))) & (~((0x1UL << (0U)) | (0x1UL << (1U)) | (0x1UL << (2U))))) | (Break))));
N}
N
N/**
N  * @brief  Get connections to TIMx Break inputs
N  * @rmtoll SYSCFG_CFGR2 LOCKUP_LOCK   MS32_SYSCFG_GetTIMBreakInputs\n
N  *         SYSCFG_CFGR2 SRAM_PARITY_LOCK  MS32_SYSCFG_GetTIMBreakInputs\n
N  *         SYSCFG_CFGR2 PVD_LOCK      MS32_SYSCFG_GetTIMBreakInputs
N  * @retval Returned value can be can be a combination of the following values:
N  *         @arg @ref MS32_SYSCFG_TIMBREAK_PVD
N  *         @arg @ref MS32_SYSCFG_TIMBREAK_SRAM_PARITY
N  *         @arg @ref MS32_SYSCFG_TIMBREAK_LOCKUP
N  */
N__STATIC_INLINE uint32_t MS32_SYSCFG_GetTIMBreakInputs(void) {
Xstatic __inline uint32_t MS32_SYSCFG_GetTIMBreakInputs(void) {
N  return (uint32_t)(READ_BIT(SYSCFG->CFGR2, SYSCFG_CFGR2_LOCKUP_LOCK | SYSCFG_CFGR2_SRAM_PARITY_LOCK | SYSCFG_CFGR2_PVD_LOCK));
X  return (uint32_t)(((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->CFGR2) & ((0x1UL << (0U)) | (0x1UL << (1U)) | (0x1UL << (2U)))));
N}
N
N/**
N  * @brief  Check if SRAM parity error detected
N  * @rmtoll SYSCFG_CFGR2 SRAM_PEF      MS32_SYSCFG_IsActiveFlag_SP
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_SYSCFG_IsActiveFlag_SP(void) {
Xstatic __inline uint32_t MS32_SYSCFG_IsActiveFlag_SP(void) {
N  return (READ_BIT(SYSCFG->CFGR2, SYSCFG_CFGR2_SRAM_PEF) == (SYSCFG_CFGR2_SRAM_PEF));
X  return (((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->CFGR2) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Clear SRAM parity error flag
N  * @rmtoll SYSCFG_CFGR2 SRAM_PEF      MS32_SYSCFG_ClearFlag_SP
N  * @retval None
N  */
N__STATIC_INLINE void MS32_SYSCFG_ClearFlag_SP(void) {
Xstatic __inline void MS32_SYSCFG_ClearFlag_SP(void) {
N  SET_BIT(SYSCFG->CFGR2, SYSCFG_CFGR2_SRAM_PEF);
X  ((((SYSCFG_TypeDef *) (0x40000000UL + 0x00010000UL))->CFGR2) |= ((0x1UL << (8U))));
N}
N
N
N/** @defgroup SYSTEM_EF_DBGMCU DBGMCU
N  * @{
N  */
N
N/**
N  * @brief  Return the device identifier
N  * @note For MS32F03x devices, the device ID is 0x444
N  * @rmtoll DBGMCU_IDCODE DEV_ID        MS32_DBGMCU_GetDeviceID
N  * @retval Values between Min_Data=0x00 and Max_Data=0xFFF
N  */
N__STATIC_INLINE uint32_t MS32_DBGMCU_GetDeviceID(void) {
Xstatic __inline uint32_t MS32_DBGMCU_GetDeviceID(void) {
N  return (uint32_t)(READ_BIT(DBGMCU->IDCODE, DBGMCU_IDCODE_DEV_ID));
X  return (uint32_t)(((((DBGMCU_TypeDef *) (0x40000000UL + 0x00015800UL))->IDCODE) & ((0xFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Return the device revision identifier
N  * @note This field indicates the revision of the device.
N          For example, it is read as 0x1000 for Revision 1.0.
N  * @rmtoll DBGMCU_IDCODE REV_ID        MS32_DBGMCU_GetRevisionID
N  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFF
N  */
N__STATIC_INLINE uint32_t MS32_DBGMCU_GetRevisionID(void) {
Xstatic __inline uint32_t MS32_DBGMCU_GetRevisionID(void) {
N  return (uint32_t)(READ_BIT(DBGMCU->IDCODE, DBGMCU_IDCODE_REV_ID) >> DBGMCU_IDCODE_REV_ID_Pos);
X  return (uint32_t)(((((DBGMCU_TypeDef *) (0x40000000UL + 0x00015800UL))->IDCODE) & ((0xFFFFUL << (16U)))) >> (16U));
N}
N
N/**
N  * @brief  Enable the Debug Module during STOP mode
N  * @rmtoll DBGMCU_CR    DBG_STOP      MS32_DBGMCU_EnableDBGStopMode
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DBGMCU_EnableDBGStopMode(void) {
Xstatic __inline void MS32_DBGMCU_EnableDBGStopMode(void) {
N  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
X  ((((DBGMCU_TypeDef *) (0x40000000UL + 0x00015800UL))->CR) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable the Debug Module during STOP mode
N  * @rmtoll DBGMCU_CR    DBG_STOP      MS32_DBGMCU_DisableDBGStopMode
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DBGMCU_DisableDBGStopMode(void) {
Xstatic __inline void MS32_DBGMCU_DisableDBGStopMode(void) {
N  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
X  ((((DBGMCU_TypeDef *) (0x40000000UL + 0x00015800UL))->CR) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Enable the Debug Module during STANDBY mode
N  * @rmtoll DBGMCU_CR    DBG_STANDBY   MS32_DBGMCU_EnableDBGStandbyMode
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DBGMCU_EnableDBGStandbyMode(void) {
Xstatic __inline void MS32_DBGMCU_EnableDBGStandbyMode(void) {
N  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
X  ((((DBGMCU_TypeDef *) (0x40000000UL + 0x00015800UL))->CR) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Disable the Debug Module during STANDBY mode
N  * @rmtoll DBGMCU_CR    DBG_STANDBY   MS32_DBGMCU_DisableDBGStandbyMode
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DBGMCU_DisableDBGStandbyMode(void) {
Xstatic __inline void MS32_DBGMCU_DisableDBGStandbyMode(void) {
N  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
X  ((((DBGMCU_TypeDef *) (0x40000000UL + 0x00015800UL))->CR) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Freeze APB1 peripherals (group1 peripherals)
N  * @rmtoll DBGMCU_APB1FZ DBG_TIM2_STOP           MS32_DBGMCU_APB1_GRP1_FreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_TIM3_STOP           MS32_DBGMCU_APB1_GRP1_FreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_TIM6_STOP           MS32_DBGMCU_APB1_GRP1_FreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_TIM7_STOP           MS32_DBGMCU_APB1_GRP1_FreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_TIM14_STOP          MS32_DBGMCU_APB1_GRP1_FreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_RTC_STOP            MS32_DBGMCU_APB1_GRP1_FreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_WWDG_STOP           MS32_DBGMCU_APB1_GRP1_FreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_IWDG_STOP           MS32_DBGMCU_APB1_GRP1_FreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_I2C1_SMBUS_TIMEOUT  MS32_DBGMCU_APB1_GRP1_FreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_CAN_STOP  MS32_DBGMCU_APB1_GRP1_FreezePeriph
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_DBGMCU_APB1_GRP1_TIM2_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP1_TIM3_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP1_TIM14_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP1_RTC_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP1_WWDG_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP1_IWDG_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP1_I2C1_STOP
N  *
N  *         (*) value not defined in all devices
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DBGMCU_APB1_GRP1_FreezePeriph(uint32_t Periphs) {
Xstatic __inline void MS32_DBGMCU_APB1_GRP1_FreezePeriph(uint32_t Periphs) {
N  SET_BIT(DBGMCU->APB1FZ, Periphs);
X  ((((DBGMCU_TypeDef *) (0x40000000UL + 0x00015800UL))->APB1FZ) |= (Periphs));
N}
N
N/**
N  * @brief  Unfreeze APB1 peripherals (group1 peripherals)
N  * @rmtoll DBGMCU_APB1FZ DBG_TIM2_STOP           MS32_DBGMCU_APB1_GRP1_UnFreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_TIM3_STOP           MS32_DBGMCU_APB1_GRP1_UnFreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_TIM6_STOP           MS32_DBGMCU_APB1_GRP1_UnFreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_TIM7_STOP           MS32_DBGMCU_APB1_GRP1_UnFreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_TIM14_STOP          MS32_DBGMCU_APB1_GRP1_UnFreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_RTC_STOP            MS32_DBGMCU_APB1_GRP1_UnFreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_WWDG_STOP           MS32_DBGMCU_APB1_GRP1_UnFreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_IWDG_STOP           MS32_DBGMCU_APB1_GRP1_UnFreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_I2C1_SMBUS_TIMEOUT  MS32_DBGMCU_APB1_GRP1_UnFreezePeriph\n
N  *         DBGMCU_APB1FZ DBG_CAN_STOP            MS32_DBGMCU_APB1_GRP1_UnFreezePeriph
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_DBGMCU_APB1_GRP1_TIM2_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP1_TIM3_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP1_TIM14_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP1_RTC_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP1_WWDG_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP1_IWDG_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP1_I2C1_STOP
N  *
N  *         (*) value not defined in all devices
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DBGMCU_APB1_GRP1_UnFreezePeriph(uint32_t Periphs) {
Xstatic __inline void MS32_DBGMCU_APB1_GRP1_UnFreezePeriph(uint32_t Periphs) {
N  CLEAR_BIT(DBGMCU->APB1FZ, Periphs);
X  ((((DBGMCU_TypeDef *) (0x40000000UL + 0x00015800UL))->APB1FZ) &= ~(Periphs));
N}
N
N/**
N  * @brief  Freeze APB1 peripherals (group2 peripherals)
N  * @rmtoll DBGMCU_APB2FZ DBG_TIM1_STOP   MS32_DBGMCU_APB1_GRP2_FreezePeriph\n
N  *         DBGMCU_APB2FZ DBG_TIM15_STOP  MS32_DBGMCU_APB1_GRP2_FreezePeriph\n
N  *         DBGMCU_APB2FZ DBG_TIM16_STOP  MS32_DBGMCU_APB1_GRP2_FreezePeriph\n
N  *         DBGMCU_APB2FZ DBG_TIM17_STOP  MS32_DBGMCU_APB1_GRP2_FreezePeriph
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_DBGMCU_APB1_GRP2_TIM1_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP2_TIM16_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP2_TIM17_STOP
N  *
N  *         (*) value not defined in all devices
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DBGMCU_APB1_GRP2_FreezePeriph(uint32_t Periphs) {
Xstatic __inline void MS32_DBGMCU_APB1_GRP2_FreezePeriph(uint32_t Periphs) {
N  SET_BIT(DBGMCU->APB2FZ, Periphs);
X  ((((DBGMCU_TypeDef *) (0x40000000UL + 0x00015800UL))->APB2FZ) |= (Periphs));
N}
N
N/**
N  * @brief  Unfreeze APB1 peripherals (group2 peripherals)
N  * @rmtoll DBGMCU_APB2FZ DBG_TIM1_STOP   MS32_DBGMCU_APB1_GRP2_UnFreezePeriph\n
N  *         DBGMCU_APB2FZ DBG_TIM15_STOP  MS32_DBGMCU_APB1_GRP2_UnFreezePeriph\n
N  *         DBGMCU_APB2FZ DBG_TIM16_STOP  MS32_DBGMCU_APB1_GRP2_UnFreezePeriph\n
N  *         DBGMCU_APB2FZ DBG_TIM17_STOP  MS32_DBGMCU_APB1_GRP2_UnFreezePeriph
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_DBGMCU_APB1_GRP2_TIM1_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP2_TIM16_STOP
N  *         @arg @ref MS32_DBGMCU_APB1_GRP2_TIM17_STOP
N  *
N  *         (*) value not defined in all devices
N  * @retval None
N  */
N__STATIC_INLINE void MS32_DBGMCU_APB1_GRP2_UnFreezePeriph(uint32_t Periphs) {
Xstatic __inline void MS32_DBGMCU_APB1_GRP2_UnFreezePeriph(uint32_t Periphs) {
N  CLEAR_BIT(DBGMCU->APB2FZ, Periphs);
X  ((((DBGMCU_TypeDef *) (0x40000000UL + 0x00015800UL))->APB2FZ) &= ~(Periphs));
N}
N
N/** @defgroup SYSTEM_EF_FLASH FLASH
N  * @{
N  */
N
N/**
N  * @brief  Set FLASH Latency
N  * @rmtoll FLASH_ACR    LATENCY       MS32_FLASH_SetLatency
N  * @param  Latency This parameter can be one of the following values:
N  *         @arg @ref MS32_FLASH_LATENCY_0
N  *         @arg @ref MS32_FLASH_LATENCY_1
N  * @retval None
N  */
N__STATIC_INLINE void MS32_FLASH_SetLatency(uint32_t Latency) {
Xstatic __inline void MS32_FLASH_SetLatency(uint32_t Latency) {
N  MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
X  (((((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00002000UL))->ACR)) = ((((((((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00002000UL))->ACR))) & (~((0x1UL << (0U))))) | (Latency))));
N}
N
N/**
N  * @brief  Get FLASH Latency
N  * @rmtoll FLASH_ACR    LATENCY       MS32_FLASH_GetLatency
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_FLASH_LATENCY_0
N  *         @arg @ref MS32_FLASH_LATENCY_1
N  */
N__STATIC_INLINE uint32_t MS32_FLASH_GetLatency(void) {
Xstatic __inline uint32_t MS32_FLASH_GetLatency(void) {
N  return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
X  return (uint32_t)(((((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00002000UL))->ACR) & ((0x1UL << (0U)))));
N}
N
N/**
N  * @brief  Enable Prefetch
N  * @rmtoll FLASH_ACR    PRFTBE        MS32_FLASH_EnablePrefetch
N  * @retval None
N  */
N__STATIC_INLINE void MS32_FLASH_EnablePrefetch(void) {
Xstatic __inline void MS32_FLASH_EnablePrefetch(void) {
N  SET_BIT(FLASH->ACR, FLASH_ACR_PRFTBE);
X  ((((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00002000UL))->ACR) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Disable Prefetch
N  * @rmtoll FLASH_ACR    PRFTBE        MS32_FLASH_DisablePrefetch
N  * @retval None
N  */
N__STATIC_INLINE void MS32_FLASH_DisablePrefetch(void) {
Xstatic __inline void MS32_FLASH_DisablePrefetch(void) {
N  CLEAR_BIT(FLASH->ACR, FLASH_ACR_PRFTBE);
X  ((((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00002000UL))->ACR) &= ~((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Check if Prefetch buffer is enabled
N  * @rmtoll FLASH_ACR    PRFTBS        MS32_FLASH_IsPrefetchEnabled
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_FLASH_IsPrefetchEnabled(void) {
Xstatic __inline uint32_t MS32_FLASH_IsPrefetchEnabled(void) {
N  return (READ_BIT(FLASH->ACR, FLASH_ACR_PRFTBS) == (FLASH_ACR_PRFTBS));
X  return (((((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00002000UL))->ACR) & ((0x1UL << (5U)))) == ((0x1UL << (5U))));
N}
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_SYSTEM_H */
N
N/******************************** END OF FILE *********************************/
L 80 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_tim.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_tim.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_TIM_H
N#define __MS32F0XX_TIM_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup TIM_Private_Variables TIM Private Variables
N  * @{
N  */
Nstatic const uint8_t OFFSET_TAB_CCMRx[] = {
N  0x00U,   /* 0: TIMx_CH1  */
N  0x00U,   /* 1: TIMx_CH1N */
N  0x00U,   /* 2: TIMx_CH2  */
N  0x00U,   /* 3: TIMx_CH2N */
N  0x04U,   /* 4: TIMx_CH3  */
N  0x04U,   /* 5: TIMx_CH3N */
N  0x04U    /* 6: TIMx_CH4  */
N};
N
Nstatic const uint8_t SHIFT_TAB_OCxx[] = {
N  0U,            /* 0: OC1M, OC1FE, OC1PE */
N  0U,            /* 1: - NA */
N  8U,            /* 2: OC2M, OC2FE, OC2PE */
N  0U,            /* 3: - NA */
N  0U,            /* 4: OC3M, OC3FE, OC3PE */
N  0U,            /* 5: - NA */
N  8U             /* 6: OC4M, OC4FE, OC4PE */
N};
N
Nstatic const uint8_t SHIFT_TAB_ICxx[] = {
N  0U,            /* 0: CC1S, IC1PSC, IC1F */
N  0U,            /* 1: - NA */
N  8U,            /* 2: CC2S, IC2PSC, IC2F */
N  0U,            /* 3: - NA */
N  0U,            /* 4: CC3S, IC3PSC, IC3F */
N  0U,            /* 5: - NA */
N  8U             /* 6: CC4S, IC4PSC, IC4F */
N};
N
Nstatic const uint8_t SHIFT_TAB_CCxP[] = {
N  0U,            /* 0: CC1P */
N  2U,            /* 1: CC1NP */
N  4U,            /* 2: CC2P */
N  6U,            /* 3: CC2NP */
N  8U,            /* 4: CC3P */
N  10U,           /* 5: CC3NP */
N  12U            /* 6: CC4P */
N};
N
Nstatic const uint8_t SHIFT_TAB_OISx[] = {
N  0U,            /* 0: OIS1 */
N  1U,            /* 1: OIS1N */
N  2U,            /* 2: OIS2 */
N  3U,            /* 3: OIS2N */
N  4U,            /* 4: OIS3 */
N  5U,            /* 5: OIS3N */
N  6U             /* 6: OIS4 */
N};
N
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup TIM_Private_Constants TIM Private Constants
N  * @{
N  */
N#define TIMx_OR_RMP_SHIFT  16U
N#define TIMx_OR_RMP_MASK   0x0000FFFFU
N#define TIM14_OR_RMP_MASK  (TIM14_OR_TI1_RMP << TIMx_OR_RMP_SHIFT)
N
N/* Mask used to set the TDG[x:0] of the DTG bits of the TIMx_BDTR register */
N#define DT_DELAY_1 ((uint8_t)0x7F)
N#define DT_DELAY_2 ((uint8_t)0x3F)
N#define DT_DELAY_3 ((uint8_t)0x1F)
N#define DT_DELAY_4 ((uint8_t)0x1F)
N
N/* Mask used to set the DTG[7:5] bits of the DTG bits of the TIMx_BDTR register */
N#define DT_RANGE_1 ((uint8_t)0x00)
N#define DT_RANGE_2 ((uint8_t)0x80)
N#define DT_RANGE_3 ((uint8_t)0xC0)
N#define DT_RANGE_4 ((uint8_t)0xE0)
N
N
N/* Private macros ------------------------------------------------------------*/
N
N/** @defgroup TIM_Private_Macros TIM Private Macros
N  * @{
N  */
N
N/** @brief  Convert channel id into channel index.
N  * @param  __CHANNEL__ This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH1N
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH2N
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH3N
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval none
N  */
N#define TIM_GET_CHANNEL_INDEX( __CHANNEL__) \
N  (((__CHANNEL__) == MS32_TIM_CHANNEL_CH1) ? 0U :\
N   ((__CHANNEL__) == MS32_TIM_CHANNEL_CH1N) ? 1U :\
N   ((__CHANNEL__) == MS32_TIM_CHANNEL_CH2) ? 2U :\
N   ((__CHANNEL__) == MS32_TIM_CHANNEL_CH2N) ? 3U :\
N   ((__CHANNEL__) == MS32_TIM_CHANNEL_CH3) ? 4U :\
N   ((__CHANNEL__) == MS32_TIM_CHANNEL_CH3N) ? 5U : 6U)
X#define TIM_GET_CHANNEL_INDEX( __CHANNEL__)   (((__CHANNEL__) == MS32_TIM_CHANNEL_CH1) ? 0U :   ((__CHANNEL__) == MS32_TIM_CHANNEL_CH1N) ? 1U :   ((__CHANNEL__) == MS32_TIM_CHANNEL_CH2) ? 2U :   ((__CHANNEL__) == MS32_TIM_CHANNEL_CH2N) ? 3U :   ((__CHANNEL__) == MS32_TIM_CHANNEL_CH3) ? 4U :   ((__CHANNEL__) == MS32_TIM_CHANNEL_CH3N) ? 5U : 6U)
N
N/** @brief  Calculate the deadtime sampling period(in ps).
N  * @param  __TIMCLK__ timer input clock frequency (in Hz).
N  * @param  __CKD__ This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CLOCKDIVISION_DIV1
N  *         @arg @ref MS32_TIM_CLOCKDIVISION_DIV2
N  *         @arg @ref MS32_TIM_CLOCKDIVISION_DIV4
N  * @retval none
N  */
N#define TIM_CALC_DTS(__TIMCLK__, __CKD__)                                                        \
N  (((__CKD__) == MS32_TIM_CLOCKDIVISION_DIV1) ? ((uint64_t)1000000000000U/(__TIMCLK__))         : \
N   ((__CKD__) == MS32_TIM_CLOCKDIVISION_DIV2) ? ((uint64_t)1000000000000U/((__TIMCLK__) >> 1U)) : \
N   ((uint64_t)1000000000000U/((__TIMCLK__) >> 2U)))
X#define TIM_CALC_DTS(__TIMCLK__, __CKD__)                                                          (((__CKD__) == MS32_TIM_CLOCKDIVISION_DIV1) ? ((uint64_t)1000000000000U/(__TIMCLK__))         :    ((__CKD__) == MS32_TIM_CLOCKDIVISION_DIV2) ? ((uint64_t)1000000000000U/((__TIMCLK__) >> 1U)) :    ((uint64_t)1000000000000U/((__TIMCLK__) >> 2U)))
N
N
N
N/* Exported types ------------------------------------------------------------*/
N/**
N  * @brief  TIM Time Base configuration structure definition.
N  */
Ntypedef struct {
N  uint16_t Prescaler;         /*!< Specifies the prescaler value used to divide the TIM clock.
N                                   This parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF.
N                                   This feature can be modified afterwards using unitary function @ref MS32_TIM_SetPrescaler().*/
N  uint32_t CounterMode;       /*!< Specifies the counter mode.
N                                   This parameter can be a value of @ref TIM_EC_COUNTERMODE.
N                                   This feature can be modified afterwards using unitary function @ref MS32_TIM_SetCounterMode().*/
N  uint32_t Autoreload;        /*!< Specifies the auto reload value to be loaded into the active
N                                   Auto-Reload Register at the next update event.
N                                   This parameter must be a number between Min_Data=0x0000 and Max_Data=0xFFFF.
N                                   Some timer instances may support 32 bits counters. In that case this parameter must be a number between 0x0000 and 0xFFFFFFFF.
N                                   This feature can be modified afterwards using unitary function @ref MS32_TIM_SetAutoReload().*/
N  uint32_t AutoreloadPreload; /*!< Specifies the auto reload preload to be loaded into the active
N                                   This parameter can be a value of @ref TIM_EC_AUTORELOAD_PRELOAD_ENABLE.*/
N  uint32_t OnePulseMode;      /*!< Specifies the one pulse mode to be loaded into the active
N                                   This parameter can be a value of @ref TIM_EC_ONEPULSEMODE.*/
N  uint32_t UpdateSource;      /*!< Specifies the update request source to be loaded into the active
N                                   This parameter can be a value of @ref TIM_EC_UPDATESOURCE.*/
N  uint32_t UpdateEvent;       /*!< Specifies the update event enable to be loaded into the active
N                                   This parameter can be a value of @ref TIM_EC_UPDATE_EVENT_DISABLE.*/
N  uint32_t ClockDivision;     /*!< Specifies the clock division.
N                                   This parameter can be a value of @ref TIM_EC_CLOCKDIVISION.
N                                   This feature can be modified afterwards using unitary function @ref MS32_TIM_SetClockDivision().*/
N  uint8_t RepetitionCounter;  /*!< Specifies the repetition counter value. Each time the RCR downcounter
N                                   reaches zero, an update event is generated and counting restarts
N                                   from the RCR value (N).
N                                   This means in PWM mode that (N+1) corresponds to:
N                                      - the number of PWM periods in edge-aligned mode
N                                      - the number of half PWM period in center-aligned mode
N                                   This parameter must be a number between 0x00 and 0xFF.
N                                   This feature can be modified afterwards using unitary function @ref MS32_TIM_SetRepetitionCounter().*/
N} MS32_TIM_InitTypeDef;
N
N/**
N  * @brief  TIM Output Compare configuration structure definition.
N  */
Ntypedef struct {
N  uint32_t OCMode;        /*!< Specifies the output mode.
N                               This parameter can be a value of @ref TIM_EC_OCMODE.
N                               This feature can be modified afterwards using unitary function @ref MS32_TIM_OC_SetMode().*/
N  uint32_t OCState;       /*!< Specifies the TIM Output Compare state.
N                               This parameter can be a value of @ref TIM_EC_OCSTATE.
N                               This feature can be modified afterwards using unitary functions @ref MS32_TIM_CC_EnableChannel() or @ref MS32_TIM_CC_DisableChannel().*/
N  uint32_t OCNState;      /*!< Specifies the TIM complementary Output Compare state.
N                               This parameter can be a value of @ref TIM_EC_OCSTATE.
N                               This feature can be modified afterwards using unitary functions @ref MS32_TIM_CC_EnableChannel() or @ref MS32_TIM_CC_DisableChannel().*/
N  uint32_t CompareValue;  /*!< Specifies the Compare value to be loaded into the Capture Compare Register.
N                               This parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF.
N                               This feature can be modified afterwards using unitary function MS32_TIM_OC_SetCompareCHx (x=1..6).*/
N  uint32_t OCPolarity;    /*!< Specifies the output polarity.
N                               This parameter can be a value of @ref TIM_EC_OCPOLARITY.
N                               This feature can be modified afterwards using unitary function @ref MS32_TIM_OC_SetPolarity().*/
N  uint32_t OCNPolarity;   /*!< Specifies the complementary output polarity.
N                               This parameter can be a value of @ref TIM_EC_OCPOLARITY.
N                               This feature can be modified afterwards using unitary function @ref MS32_TIM_OC_SetPolarity().*/
N  uint32_t OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
N                               This parameter can be a value of @ref TIM_EC_OCIDLESTATE.
N                               This feature can be modified afterwards using unitary function @ref MS32_TIM_OC_SetIdleState().*/
N  uint32_t OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
N                               This parameter can be a value of @ref TIM_EC_OCIDLESTATE.
N                               This feature can be modified afterwards using unitary function @ref MS32_TIM_OC_SetIdleState().*/
N} MS32_TIM_OC_InitTypeDef;
N
N/**
N  * @brief  TIM Input Capture configuration structure definition.
N  */
Ntypedef struct {
N  uint32_t ICPolarity;    /*!< Specifies the active edge of the input signal.
N                               This parameter can be a value of @ref TIM_EC_IC_POLARITY.
N                               This feature can be modified afterwards using unitary function @ref MS32_TIM_IC_SetPolarity().*/
N  uint32_t ICActiveInput; /*!< Specifies the input.
N                               This parameter can be a value of @ref TIM_EC_ACTIVEINPUT.
N                               This feature can be modified afterwards using unitary function @ref MS32_TIM_IC_SetActiveInput().*/
N  uint32_t ICPrescaler;   /*!< Specifies the Input Capture Prescaler.
N                               This parameter can be a value of @ref TIM_EC_ICPSC.
N                               This feature can be modified afterwards using unitary function @ref MS32_TIM_IC_SetPrescaler().*/
N  uint32_t ICFilter;      /*!< Specifies the input capture filter.
N                               This parameter can be a value of @ref TIM_EC_IC_FILTER.
N                               This feature can be modified afterwards using unitary function @ref MS32_TIM_IC_SetFilter().*/
N} MS32_TIM_IC_InitTypeDef;
N
N
N/**
N  * @brief  TIM Encoder interface configuration structure definition.
N  */
Ntypedef struct {
N  uint32_t EncoderMode;     /*!< Specifies the encoder resolution (x2 or x4).
N                                 This parameter can be a value of @ref TIM_EC_ENCODERMODE.
N                                 This feature can be modified afterwards using unitary function @ref MS32_TIM_SetEncoderMode().*/
N  uint32_t IC1Polarity;     /*!< Specifies the active edge of TI1 input.
N                                 This parameter can be a value of @ref TIM_EC_IC_POLARITY.
N                                 This feature can be modified afterwards using unitary function @ref MS32_TIM_IC_SetPolarity().*/
N  uint32_t IC1ActiveInput;  /*!< Specifies the TI1 input source
N                                 This parameter can be a value of @ref TIM_EC_ACTIVEINPUT.
N                                 This feature can be modified afterwards using unitary function @ref MS32_TIM_IC_SetActiveInput().*/
N  uint32_t IC1Prescaler;    /*!< Specifies the TI1 input prescaler value.
N                                 This parameter can be a value of @ref TIM_EC_ICPSC.
N                                 This feature can be modified afterwards using unitary function @ref MS32_TIM_IC_SetPrescaler().*/
N  uint32_t IC1Filter;       /*!< Specifies the TI1 input filter.
N                                 This parameter can be a value of @ref TIM_EC_IC_FILTER.
N                                 This feature can be modified afterwards using unitary function @ref MS32_TIM_IC_SetFilter().*/
N  uint32_t IC2Polarity;     /*!< Specifies the active edge of TI2 input.
N                                 This parameter can be a value of @ref TIM_EC_IC_POLARITY.
N                                 This feature can be modified afterwards using unitary function @ref MS32_TIM_IC_SetPolarity().*/
N  uint32_t IC2ActiveInput;  /*!< Specifies the TI2 input source
N                                 This parameter can be a value of @ref TIM_EC_ACTIVEINPUT.
N                                 This feature can be modified afterwards using unitary function @ref MS32_TIM_IC_SetActiveInput().*/
N  uint32_t IC2Prescaler;    /*!< Specifies the TI2 input prescaler value.
N                                 This parameter can be a value of @ref TIM_EC_ICPSC.
N                                 This feature can be modified afterwards using unitary function @ref MS32_TIM_IC_SetPrescaler().*/
N  uint32_t IC2Filter;       /*!< Specifies the TI2 input filter.
N                                 This parameter can be a value of @ref TIM_EC_IC_FILTER.
N                                 This feature can be modified afterwards using unitary function @ref MS32_TIM_IC_SetFilter().*/
N} MS32_TIM_ENCODER_InitTypeDef;
N
N/**
N  * @brief  TIM Hall sensor interface configuration structure definition.
N  */
Ntypedef struct {
N
N  uint32_t IC1Polarity;        /*!< Specifies the active edge of TI1 input.
N                                    This parameter can be a value of @ref TIM_EC_IC_POLARITY.
N                                    This feature can be modified afterwards using unitary function @ref MS32_TIM_IC_SetPolarity().*/
N  uint32_t IC1Prescaler;       /*!< Specifies the TI1 input prescaler value.
N                                    Prescaler must be set to get a maximum counter period longer than the
N                                    time interval between 2 consecutive changes on the Hall inputs.
N                                    This parameter can be a value of @ref TIM_EC_ICPSC.
N                                    This feature can be modified afterwards using unitary function @ref MS32_TIM_IC_SetPrescaler().*/
N  uint32_t IC1Filter;          /*!< Specifies the TI1 input filter.
N                                    This parameter can be a value of @ref TIM_EC_IC_FILTER.
N                                    This feature can be modified afterwards using unitary function @ref MS32_TIM_IC_SetFilter().*/
N} MS32_TIM_HALLSENSOR_InitTypeDef;
N
N/**
N  * @brief  BDTR (Break and Dead Time) structure definition
N  */
Ntypedef struct {
N  uint32_t OSSRState;            /*!< Specifies the Off-State selection used in Run mode.
N                                      This parameter can be a value of @ref TIM_EC_OSSR
N                                      This feature can be modified afterwards using unitary function @ref MS32_TIM_SetOffStates()
N                                      @note This bit-field cannot be modified as long as LOCK level 2 has been programmed. */
N  uint32_t OSSIState;            /*!< Specifies the Off-State used in Idle state.
N                                      This parameter can be a value of @ref TIM_EC_OSSI
N                                      This feature can be modified afterwards using unitary function @ref MS32_TIM_SetOffStates()
N                                      @note This bit-field cannot be modified as long as LOCK level 2 has been programmed. */
N  uint32_t LockLevel;            /*!< Specifies the LOCK level parameters.
N                                      This parameter can be a value of @ref TIM_EC_LOCKLEVEL
N                                      @note The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register
N                                            has been written, their content is frozen until the next reset.*/
N  uint8_t DeadTime;              /*!< Specifies the delay time between the switching-off and the
N                                      switching-on of the outputs.
N                                      This parameter can be a number between Min_Data = 0x00 and Max_Data = 0xFF.
N                                      This feature can be modified afterwards using unitary function @ref MS32_TIM_OC_SetDeadTime()
N                                      @note This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed. */
N  uint16_t BreakState;           /*!< Specifies whether the TIM Break input is enabled or not.
N                                      This parameter can be a value of @ref TIM_EC_BREAK_ENABLE
N                                      This feature can be modified afterwards using unitary functions @ref MS32_TIM_EnableBRK() or @ref MS32_TIM_DisableBRK()
N                                      @note This bit-field can not be modified as long as LOCK level 1 has been programmed. */
N  uint32_t BreakPolarity;        /*!< Specifies the TIM Break Input pin polarity.
N                                      This parameter can be a value of @ref TIM_EC_BREAK_POLARITY
N                                      This feature can be modified afterwards using unitary function @ref MS32_TIM_ConfigBRK()
N                                      @note This bit-field can not be modified as long as LOCK level 1 has been programmed. */
N  uint32_t AutomaticOutput;      /*!< Specifies whether the TIM Automatic Output feature is enabled or not.
N                                      This parameter can be a value of @ref TIM_EC_AUTOMATICOUTPUT_ENABLE
N                                      This feature can be modified afterwards using unitary functions @ref MS32_TIM_EnableAutomaticOutput() or @ref MS32_TIM_DisableAutomaticOutput()
N                                      @note This bit-field can not be modified as long as LOCK level 1 has been programmed. */
N} MS32_TIM_BDTR_InitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup TIM_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with MS32_TIM_ReadReg function.
N  * @{
N  */
N#define MS32_TIM_SR_UIF                          TIM_SR_UIF           /*!< Update interrupt flag */
N#define MS32_TIM_SR_CC1IF                        TIM_SR_CC1IF         /*!< Capture/compare 1 interrupt flag */
N#define MS32_TIM_SR_CC2IF                        TIM_SR_CC2IF         /*!< Capture/compare 2 interrupt flag */
N#define MS32_TIM_SR_CC3IF                        TIM_SR_CC3IF         /*!< Capture/compare 3 interrupt flag */
N#define MS32_TIM_SR_CC4IF                        TIM_SR_CC4IF         /*!< Capture/compare 4 interrupt flag */
N#define MS32_TIM_SR_COMIF                        TIM_SR_COMIF         /*!< COM interrupt flag */
N#define MS32_TIM_SR_TIF                          TIM_SR_TIF           /*!< Trigger interrupt flag */
N#define MS32_TIM_SR_BIF                          TIM_SR_BIF           /*!< Break interrupt flag */
N#define MS32_TIM_SR_CC1OF                        TIM_SR_CC1OF         /*!< Capture/Compare 1 overcapture flag */
N#define MS32_TIM_SR_CC2OF                        TIM_SR_CC2OF         /*!< Capture/Compare 2 overcapture flag */
N#define MS32_TIM_SR_CC3OF                        TIM_SR_CC3OF         /*!< Capture/Compare 3 overcapture flag */
N#define MS32_TIM_SR_CC4OF                        TIM_SR_CC4OF         /*!< Capture/Compare 4 overcapture flag */
N
N#define MS32_TIM_SR_ALLIF                        (MS32_TIM_SR_UIF   | MS32_TIM_SR_CC1IF | MS32_TIM_SR_CC2IF | MS32_TIM_SR_CC3IF |\
N                                                  MS32_TIM_SR_CC4IF | MS32_TIM_SR_COMIF | MS32_TIM_SR_TIF   | MS32_TIM_SR_BIF)
X#define MS32_TIM_SR_ALLIF                        (MS32_TIM_SR_UIF   | MS32_TIM_SR_CC1IF | MS32_TIM_SR_CC2IF | MS32_TIM_SR_CC3IF |                                                  MS32_TIM_SR_CC4IF | MS32_TIM_SR_COMIF | MS32_TIM_SR_TIF   | MS32_TIM_SR_BIF)
N
N
N/** @defgroup TIM_EC_AUTORELOAD_PRELOAD_ENABLE Autoreload Preload Enable
N  * @{
N  */
N#define MS32_TIM_AUTORELOAD_PRE_DISABLE          0x00000000U             /*!< Autoreload preload function disabled */
N#define MS32_TIM_AUTORELOAD_PRE_ENABLE           TIM_CR1_ARPE            /*!< Autoreload preload function enabled */
N
N
N/** @defgroup TIM_EC_UPDATE_EVENT_DISABLE Update Event Disable
N  * @{
N  */
N#define MS32_TIM_UPDATE_EVENT_ENABLE             0x00000000U             /*!< Update Event Enable */
N#define MS32_TIM_UPDATE_EVENT_DISABLE            TIM_CR1_UDIS            /*!< Update Event Disable */
N
N
N/** @defgroup TIM_EC_BREAK_ENABLE Break Enable
N  * @{
N  */
N#define MS32_TIM_BREAK_DISABLE                   0x00000000U             /*!< Break function disabled */
N#define MS32_TIM_BREAK_ENABLE                    TIM_BDTR_BKE            /*!< Break function enabled */
N
N
N/** @defgroup TIM_EC_AUTOMATICOUTPUT_ENABLE Automatic output enable
N  * @{
N  */
N#define MS32_TIM_AUTOMATICOUTPUT_DISABLE         0x00000000U             /*!< MOE can be set only by software */
N#define MS32_TIM_AUTOMATICOUTPUT_ENABLE          TIM_BDTR_AOE            /*!< MOE can be set by software or automatically at the next update event */
N
N
N/** @defgroup TIM_EC_IT IT Defines
N  * @brief    IT defines which can be used with MS32_TIM_ReadReg and  MS32_TIM_WriteReg functions.
N  * @{
N  */
N#define MS32_TIM_DIER_UIE                        TIM_DIER_UIE         /*!< Update interrupt enable */
N#define MS32_TIM_DIER_CC1IE                      TIM_DIER_CC1IE       /*!< Capture/compare 1 interrupt enable */
N#define MS32_TIM_DIER_CC2IE                      TIM_DIER_CC2IE       /*!< Capture/compare 2 interrupt enable */
N#define MS32_TIM_DIER_CC3IE                      TIM_DIER_CC3IE       /*!< Capture/compare 3 interrupt enable */
N#define MS32_TIM_DIER_CC4IE                      TIM_DIER_CC4IE       /*!< Capture/compare 4 interrupt enable */
N#define MS32_TIM_DIER_COMIE                      TIM_DIER_COMIE       /*!< COM interrupt enable */
N#define MS32_TIM_DIER_TIE                        TIM_DIER_TIE         /*!< Trigger interrupt enable */
N#define MS32_TIM_DIER_BIE                        TIM_DIER_BIE         /*!< Break interrupt enable */
N
N
N/** @defgroup TIM_EC_UPDATESOURCE Update Source
N  * @{
N  */
N#define MS32_TIM_UPDATESOURCE_REGULAR            0x00000000U          /*!< Counter overflow/underflow, Setting the UG bit or Update generation through the slave mode controller generates an update request */
N#define MS32_TIM_UPDATESOURCE_COUNTER            TIM_CR1_URS          /*!< Only counter overflow/underflow generates an update request */
N
N
N/** @defgroup TIM_EC_ONEPULSEMODE One Pulse Mode
N  * @{
N  */
N#define MS32_TIM_ONEPULSEMODE_SINGLE             TIM_CR1_OPM          /*!< Counter is not stopped at update event */
N#define MS32_TIM_ONEPULSEMODE_REPETITIVE         0x00000000U          /*!< Counter stops counting at the next update event */
N
N
N/** @defgroup TIM_EC_COUNTERMODE Counter Mode
N  * @{
N  */
N#define MS32_TIM_COUNTERMODE_UP                  0x00000000U          /*!<Counter used as upcounter */
N#define MS32_TIM_COUNTERMODE_DOWN                TIM_CR1_DIR          /*!< Counter used as downcounter */
N#define MS32_TIM_COUNTERMODE_CENTER1             TIM_CR1_CMS_0        /*!< The counter counts up and down alternatively. Output compare interrupt flags of output channels are set only when the counter is counting down. */
N#define MS32_TIM_COUNTERMODE_CENTER2             TIM_CR1_CMS_1        /*!< The counter counts up and down alternatively. Output compare interrupt flags of output channels are set only when the counter is counting up */
N#define MS32_TIM_COUNTERMODE_CENTER3             TIM_CR1_CMS          /*!< The counter counts up and down alternatively. Output compare interrupt flags of output channels are set only when the counter is counting up or down. */
N
N
N/** @defgroup TIM_EC_CLOCKDIVISION Clock Division
N  * @{
N  */
N#define MS32_TIM_CLOCKDIVISION_DIV1              0x00000000U          /*!< tDTS=tCK_INT */
N#define MS32_TIM_CLOCKDIVISION_DIV2              TIM_CR1_CKD_0        /*!< tDTS=2*tCK_INT */
N#define MS32_TIM_CLOCKDIVISION_DIV4              TIM_CR1_CKD_1        /*!< tDTS=4*tCK_INT */
N
N
N/** @defgroup TIM_EC_COUNTERDIRECTION Counter Direction
N  * @{
N  */
N#define MS32_TIM_COUNTERDIRECTION_UP             0x00000000U          /*!< Timer counter counts up */
N#define MS32_TIM_COUNTERDIRECTION_DOWN           TIM_CR1_DIR          /*!< Timer counter counts down */
N
N
N/** @defgroup TIM_EC_CCUPDATESOURCE Capture Compare  Update Source
N  * @{
N  */
N#define MS32_TIM_CCUPDATESOURCE_COMG_ONLY        0x00000000U          /*!< Capture/compare control bits are updated by setting the COMG bit only */
N#define MS32_TIM_CCUPDATESOURCE_COMG_AND_TRGI    TIM_CR2_CCUS         /*!< Capture/compare control bits are updated by setting the COMG bit or when a rising edge occurs on trigger input (TRGI) */
N
N
N/** @defgroup TIM_EC_CCDMAREQUEST Capture Compare DMA Request
N  * @{
N  */
N#define MS32_TIM_CCDMAREQUEST_CC                 0x00000000U          /*!< CCx DMA request sent when CCx event occurs */
N#define MS32_TIM_CCDMAREQUEST_UPDATE             TIM_CR2_CCDS         /*!< CCx DMA requests sent when update event occurs */
N
N
N/** @defgroup TIM_EC_LOCKLEVEL Lock Level
N  * @{
N  */
N#define MS32_TIM_LOCKLEVEL_OFF                   0x00000000U          /*!< LOCK OFF - No bit is write protected */
N#define MS32_TIM_LOCKLEVEL_1                     TIM_BDTR_LOCK_0      /*!< LOCK Level 1 */
N#define MS32_TIM_LOCKLEVEL_2                     TIM_BDTR_LOCK_1      /*!< LOCK Level 2 */
N#define MS32_TIM_LOCKLEVEL_3                     TIM_BDTR_LOCK        /*!< LOCK Level 3 */
N
N
N/** @defgroup TIM_EC_CHANNEL Channel
N  * @{
N  */
N#define MS32_TIM_CHANNEL_CH1                     TIM_CCER_CC1E     /*!< Timer input/output channel 1 */
N#define MS32_TIM_CHANNEL_CH1N                    TIM_CCER_CC1NE    /*!< Timer complementary output channel 1 */
N#define MS32_TIM_CHANNEL_CH2                     TIM_CCER_CC2E     /*!< Timer input/output channel 2 */
N#define MS32_TIM_CHANNEL_CH2N                    TIM_CCER_CC2NE    /*!< Timer complementary output channel 2 */
N#define MS32_TIM_CHANNEL_CH3                     TIM_CCER_CC3E     /*!< Timer input/output channel 3 */
N#define MS32_TIM_CHANNEL_CH3N                    TIM_CCER_CC3NE    /*!< Timer complementary output channel 3 */
N#define MS32_TIM_CHANNEL_CH4                     TIM_CCER_CC4E     /*!< Timer input/output channel 4 */
N
N
N/** @defgroup TIM_EC_OCSTATE Output Configuration State
N  * @{
N  */
N#define MS32_TIM_OCSTATE_DISABLE                 0x00000000U             /*!< OCx is not active */
N#define MS32_TIM_OCSTATE_ENABLE                  TIM_CCER_CC1E           /*!< OCx signal is output on the corresponding output pin */
N
N
N/** @defgroup TIM_EC_OCMODE Output Configuration Mode
N  * @{
N  */
N#define MS32_TIM_OCMODE_FROZEN                   0x00000000U                                              /*!<The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the output channel level */
N#define MS32_TIM_OCMODE_ACTIVE                   TIM_CCMR1_OC1M_0                                         /*!<OCyREF is forced high on compare match*/
N#define MS32_TIM_OCMODE_INACTIVE                 TIM_CCMR1_OC1M_1                                         /*!<OCyREF is forced low on compare match*/
N#define MS32_TIM_OCMODE_TOGGLE                   (TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_0)                    /*!<OCyREF toggles on compare match*/
N#define MS32_TIM_OCMODE_FORCED_INACTIVE          TIM_CCMR1_OC1M_2                                         /*!<OCyREF is forced low*/
N#define MS32_TIM_OCMODE_FORCED_ACTIVE            (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_0)                    /*!<OCyREF is forced high*/
N#define MS32_TIM_OCMODE_PWM1                     (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1)                    /*!<In upcounting, channel y is active as long as TIMx_CNT<TIMx_CCRy else inactive.  In downcounting, channel y is inactive as long as TIMx_CNT>TIMx_CCRy else active.*/
N#define MS32_TIM_OCMODE_PWM2                     (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_0) /*!<In upcounting, channel y is inactive as long as TIMx_CNT<TIMx_CCRy else active.  In downcounting, channel y is active as long as TIMx_CNT>TIMx_CCRy else inactive*/
N
N
N/** @defgroup TIM_EC_OCPOLARITY Output Configuration Polarity
N  * @{
N  */
N#define MS32_TIM_OCPOLARITY_HIGH                 0x00000000U                 /*!< OCxactive high*/
N#define MS32_TIM_OCPOLARITY_LOW                  TIM_CCER_CC1P               /*!< OCxactive low*/
N
N
N/** @defgroup TIM_EC_OCIDLESTATE Output Configuration Idle State
N  * @{
N  */
N#define MS32_TIM_OCIDLESTATE_LOW                 0x00000000U             /*!<OCx=0 (after a dead-time if OC is implemented) when MOE=0*/
N#define MS32_TIM_OCIDLESTATE_HIGH                TIM_CR2_OIS1            /*!<OCx=1 (after a dead-time if OC is implemented) when MOE=0*/
N
N
N
N/** @defgroup TIM_EC_ACTIVEINPUT Active Input Selection
N  * @{
N  */
N#define MS32_TIM_ACTIVEINPUT_DIRECTTI            (TIM_CCMR1_CC1S_0 << 16U) /*!< ICx is mapped on TIx */
N#define MS32_TIM_ACTIVEINPUT_INDIRECTTI          (TIM_CCMR1_CC1S_1 << 16U) /*!< ICx is mapped on TIy */
N#define MS32_TIM_ACTIVEINPUT_TRC                 (TIM_CCMR1_CC1S << 16U)   /*!< ICx is mapped on TRC */
N
N
N/** @defgroup TIM_EC_ICPSC Input Configuration Prescaler
N  * @{
N  */
N#define MS32_TIM_ICPSC_DIV1                      0x00000000U                    /*!< No prescaler, capture is done each time an edge is detected on the capture input */
N#define MS32_TIM_ICPSC_DIV2                      (TIM_CCMR1_IC1PSC_0 << 16U)    /*!< Capture is done once every 2 events */
N#define MS32_TIM_ICPSC_DIV4                      (TIM_CCMR1_IC1PSC_1 << 16U)    /*!< Capture is done once every 4 events */
N#define MS32_TIM_ICPSC_DIV8                      (TIM_CCMR1_IC1PSC << 16U)      /*!< Capture is done once every 8 events */
N
N
N/** @defgroup TIM_EC_IC_FILTER Input Configuration Filter
N  * @{
N  */
N#define MS32_TIM_IC_FILTER_FDIV1                 0x00000000U                                                        /*!< No filter, sampling is done at fDTS */
N#define MS32_TIM_IC_FILTER_FDIV1_N2              (TIM_CCMR1_IC1F_0 << 16U)                                          /*!< fSAMPLING=fCK_INT, N=2 */
N#define MS32_TIM_IC_FILTER_FDIV1_N4              (TIM_CCMR1_IC1F_1 << 16U)                                          /*!< fSAMPLING=fCK_INT, N=4 */
N#define MS32_TIM_IC_FILTER_FDIV1_N8              ((TIM_CCMR1_IC1F_1 | TIM_CCMR1_IC1F_0) << 16U)                     /*!< fSAMPLING=fCK_INT, N=8 */
N#define MS32_TIM_IC_FILTER_FDIV2_N6              (TIM_CCMR1_IC1F_2 << 16U)                                          /*!< fSAMPLING=fDTS/2, N=6 */
N#define MS32_TIM_IC_FILTER_FDIV2_N8              ((TIM_CCMR1_IC1F_2 | TIM_CCMR1_IC1F_0) << 16U)                     /*!< fSAMPLING=fDTS/2, N=8 */
N#define MS32_TIM_IC_FILTER_FDIV4_N6              ((TIM_CCMR1_IC1F_2 | TIM_CCMR1_IC1F_1) << 16U)                     /*!< fSAMPLING=fDTS/4, N=6 */
N#define MS32_TIM_IC_FILTER_FDIV4_N8              ((TIM_CCMR1_IC1F_2 | TIM_CCMR1_IC1F_1 | TIM_CCMR1_IC1F_0) << 16U)  /*!< fSAMPLING=fDTS/4, N=8 */
N#define MS32_TIM_IC_FILTER_FDIV8_N6              (TIM_CCMR1_IC1F_3 << 16U)                                          /*!< fSAMPLING=fDTS/8, N=6 */
N#define MS32_TIM_IC_FILTER_FDIV8_N8              ((TIM_CCMR1_IC1F_3 | TIM_CCMR1_IC1F_0) << 16U)                     /*!< fSAMPLING=fDTS/8, N=8 */
N#define MS32_TIM_IC_FILTER_FDIV16_N5             ((TIM_CCMR1_IC1F_3 | TIM_CCMR1_IC1F_1) << 16U)                     /*!< fSAMPLING=fDTS/16, N=5 */
N#define MS32_TIM_IC_FILTER_FDIV16_N6             ((TIM_CCMR1_IC1F_3 | TIM_CCMR1_IC1F_1 | TIM_CCMR1_IC1F_0) << 16U)  /*!< fSAMPLING=fDTS/16, N=6 */
N#define MS32_TIM_IC_FILTER_FDIV16_N8             ((TIM_CCMR1_IC1F_3 | TIM_CCMR1_IC1F_2) << 16U)                     /*!< fSAMPLING=fDTS/16, N=8 */
N#define MS32_TIM_IC_FILTER_FDIV32_N5             ((TIM_CCMR1_IC1F_3 | TIM_CCMR1_IC1F_2 | TIM_CCMR1_IC1F_0) << 16U)  /*!< fSAMPLING=fDTS/32, N=5 */
N#define MS32_TIM_IC_FILTER_FDIV32_N6             ((TIM_CCMR1_IC1F_3 | TIM_CCMR1_IC1F_2 | TIM_CCMR1_IC1F_1) << 16U)  /*!< fSAMPLING=fDTS/32, N=6 */
N#define MS32_TIM_IC_FILTER_FDIV32_N8             (TIM_CCMR1_IC1F << 16U)                                            /*!< fSAMPLING=fDTS/32, N=8 */
N
N
N/** @defgroup TIM_EC_IC_POLARITY Input Configuration Polarity
N  * @{
N  */
N#define MS32_TIM_IC_POLARITY_RISING              0x00000000U                      /*!< The circuit is sensitive to TIxFP1 rising edge, TIxFP1 is not inverted */
N#define MS32_TIM_IC_POLARITY_FALLING             TIM_CCER_CC1P                    /*!< The circuit is sensitive to TIxFP1 falling edge, TIxFP1 is inverted */
N#define MS32_TIM_IC_POLARITY_BOTHEDGE            (TIM_CCER_CC1P | TIM_CCER_CC1NP) /*!< The circuit is sensitive to both TIxFP1 rising and falling edges, TIxFP1 is not inverted */
N
N
N/** @defgroup TIM_EC_CLOCKSOURCE Clock Source
N  * @{
N  */
N#define MS32_TIM_CLOCKSOURCE_INTERNAL            0x00000000U                                          /*!< The timer is clocked by the internal clock provided from the RCC */
N#define MS32_TIM_CLOCKSOURCE_EXT_MODE1           (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0)   /*!< Counter counts at each rising or falling edge on a selected input*/
N#define MS32_TIM_CLOCKSOURCE_EXT_MODE2           TIM_SMCR_ECE                                         /*!< Counter counts at each rising or falling edge on the external trigger input ETR */
N
N
N/** @defgroup TIM_EC_ENCODERMODE Encoder Mode
N  * @{
N  */
N#define MS32_TIM_ENCODERMODE_X2_TI1                     TIM_SMCR_SMS_0                                                     /*!< Quadrature encoder mode 1, x2 mode - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level */
N#define MS32_TIM_ENCODERMODE_X2_TI2                     TIM_SMCR_SMS_1                                                     /*!< Quadrature encoder mode 2, x2 mode - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level */
N#define MS32_TIM_ENCODERMODE_X4_TI12                   (TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0)                                   /*!< Quadrature encoder mode 3, x4 mode - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input */
N
N
N/** @defgroup TIM_EC_TRGO Trigger Output
N  * @{
N  */
N#define MS32_TIM_TRGO_RESET                      0x00000000U                                     /*!< UG bit from the TIMx_EGR register is used as trigger output */
N#define MS32_TIM_TRGO_ENABLE                     TIM_CR2_MMS_0                                   /*!< Counter Enable signal (CNT_EN) is used as trigger output */
N#define MS32_TIM_TRGO_UPDATE                     TIM_CR2_MMS_1                                   /*!< Update event is used as trigger output */
N#define MS32_TIM_TRGO_CC1IF                      (TIM_CR2_MMS_1 | TIM_CR2_MMS_0)                 /*!< CC1 capture or a compare match is used as trigger output */
N#define MS32_TIM_TRGO_OC1REF                     TIM_CR2_MMS_2                                   /*!< OC1REF signal is used as trigger output */
N#define MS32_TIM_TRGO_OC2REF                     (TIM_CR2_MMS_2 | TIM_CR2_MMS_0)                 /*!< OC2REF signal is used as trigger output */
N#define MS32_TIM_TRGO_OC3REF                     (TIM_CR2_MMS_2 | TIM_CR2_MMS_1)                 /*!< OC3REF signal is used as trigger output */
N#define MS32_TIM_TRGO_OC4REF                     (TIM_CR2_MMS_2 | TIM_CR2_MMS_1 | TIM_CR2_MMS_0) /*!< OC4REF signal is used as trigger output */
N
N
N/** @defgroup TIM_EC_SLAVEMODE Slave Mode
N  * @{
N  */
N#define MS32_TIM_SLAVEMODE_DISABLED              0x00000000U                         /*!< Slave mode disabled */
N#define MS32_TIM_SLAVEMODE_RESET                 TIM_SMCR_SMS_2                      /*!< Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter */
N#define MS32_TIM_SLAVEMODE_GATED                 (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_0)   /*!< Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high */
N#define MS32_TIM_SLAVEMODE_TRIGGER               (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1)   /*!< Trigger Mode - The counter starts at a rising edge of the trigger TRGI */
N
N
N/** @defgroup TIM_EC_TS Trigger Selection
N  * @{
N  */
N#define MS32_TIM_TS_ITR0                         0x00000000U                                                     /*!< Internal Trigger 0 (ITR0) is used as trigger input */
N#define MS32_TIM_TS_ITR1                         TIM_SMCR_TS_0                                                   /*!< Internal Trigger 1 (ITR1) is used as trigger input */
N#define MS32_TIM_TS_ITR2                         TIM_SMCR_TS_1                                                   /*!< Internal Trigger 2 (ITR2) is used as trigger input */
N#define MS32_TIM_TS_ITR3                         (TIM_SMCR_TS_0 | TIM_SMCR_TS_1)                                 /*!< Internal Trigger 3 (ITR3) is used as trigger input */
N#define MS32_TIM_TS_TI1F_ED                      TIM_SMCR_TS_2                                                   /*!< TI1 Edge Detector (TI1F_ED) is used as trigger input */
N#define MS32_TIM_TS_TI1FP1                       (TIM_SMCR_TS_2 | TIM_SMCR_TS_0)                                 /*!< Filtered Timer Input 1 (TI1FP1) is used as trigger input */
N#define MS32_TIM_TS_TI2FP2                       (TIM_SMCR_TS_2 | TIM_SMCR_TS_1)                                 /*!< Filtered Timer Input 2 (TI12P2) is used as trigger input */
N#define MS32_TIM_TS_ETRF                         (TIM_SMCR_TS_2 | TIM_SMCR_TS_1 | TIM_SMCR_TS_0)                 /*!< Filtered external Trigger (ETRF) is used as trigger input */
N
N
N/** @defgroup TIM_EC_ETR_POLARITY External Trigger Polarity
N  * @{
N  */
N#define MS32_TIM_ETR_POLARITY_NONINVERTED        0x00000000U             /*!< ETR is non-inverted, active at high level or rising edge */
N#define MS32_TIM_ETR_POLARITY_INVERTED           TIM_SMCR_ETP            /*!< ETR is inverted, active at low level or falling edge */
N
N
N/** @defgroup TIM_EC_ETR_PRESCALER External Trigger Prescaler
N  * @{
N  */
N#define MS32_TIM_ETR_PRESCALER_DIV1              0x00000000U             /*!< ETR prescaler OFF */
N#define MS32_TIM_ETR_PRESCALER_DIV2              TIM_SMCR_ETPS_0         /*!< ETR frequency is divided by 2 */
N#define MS32_TIM_ETR_PRESCALER_DIV4              TIM_SMCR_ETPS_1         /*!< ETR frequency is divided by 4 */
N#define MS32_TIM_ETR_PRESCALER_DIV8              TIM_SMCR_ETPS           /*!< ETR frequency is divided by 8 */
N
N
N/** @defgroup TIM_EC_ETR_FILTER External Trigger Filter
N  * @{
N  */
N#define MS32_TIM_ETR_FILTER_FDIV1                0x00000000U                                          /*!< No filter, sampling is done at fDTS */
N#define MS32_TIM_ETR_FILTER_FDIV1_N2             TIM_SMCR_ETF_0                                       /*!< fSAMPLING=fCK_INT, N=2 */
N#define MS32_TIM_ETR_FILTER_FDIV1_N4             TIM_SMCR_ETF_1                                       /*!< fSAMPLING=fCK_INT, N=4 */
N#define MS32_TIM_ETR_FILTER_FDIV1_N8             (TIM_SMCR_ETF_1 | TIM_SMCR_ETF_0)                    /*!< fSAMPLING=fCK_INT, N=8 */
N#define MS32_TIM_ETR_FILTER_FDIV2_N6             TIM_SMCR_ETF_2                                       /*!< fSAMPLING=fDTS/2, N=6 */
N#define MS32_TIM_ETR_FILTER_FDIV2_N8             (TIM_SMCR_ETF_2 | TIM_SMCR_ETF_0)                    /*!< fSAMPLING=fDTS/2, N=8 */
N#define MS32_TIM_ETR_FILTER_FDIV4_N6             (TIM_SMCR_ETF_2 | TIM_SMCR_ETF_1)                    /*!< fSAMPLING=fDTS/4, N=6 */
N#define MS32_TIM_ETR_FILTER_FDIV4_N8             (TIM_SMCR_ETF_2 | TIM_SMCR_ETF_1 | TIM_SMCR_ETF_0)   /*!< fSAMPLING=fDTS/4, N=8 */
N#define MS32_TIM_ETR_FILTER_FDIV8_N6             TIM_SMCR_ETF_3                                       /*!< fSAMPLING=fDTS/8, N=8 */
N#define MS32_TIM_ETR_FILTER_FDIV8_N8             (TIM_SMCR_ETF_3 | TIM_SMCR_ETF_0)                    /*!< fSAMPLING=fDTS/16, N=5 */
N#define MS32_TIM_ETR_FILTER_FDIV16_N5            (TIM_SMCR_ETF_3 | TIM_SMCR_ETF_1)                    /*!< fSAMPLING=fDTS/16, N=6 */
N#define MS32_TIM_ETR_FILTER_FDIV16_N6            (TIM_SMCR_ETF_3 | TIM_SMCR_ETF_1 | TIM_SMCR_ETF_0)   /*!< fSAMPLING=fDTS/16, N=8 */
N#define MS32_TIM_ETR_FILTER_FDIV16_N8            (TIM_SMCR_ETF_3 | TIM_SMCR_ETF_2)                    /*!< fSAMPLING=fDTS/16, N=5 */
N#define MS32_TIM_ETR_FILTER_FDIV32_N5            (TIM_SMCR_ETF_3 | TIM_SMCR_ETF_2 | TIM_SMCR_ETF_0)   /*!< fSAMPLING=fDTS/32, N=5 */
N#define MS32_TIM_ETR_FILTER_FDIV32_N6            (TIM_SMCR_ETF_3 | TIM_SMCR_ETF_2 | TIM_SMCR_ETF_1)   /*!< fSAMPLING=fDTS/32, N=6 */
N#define MS32_TIM_ETR_FILTER_FDIV32_N8            TIM_SMCR_ETF                                         /*!< fSAMPLING=fDTS/32, N=8 */
N
N
N/** @defgroup TIM_EC_BREAK_POLARITY break polarity
N  * @{
N  */
N#define MS32_TIM_BREAK_POLARITY_LOW              0x00000000U               /*!< Break input BRK is active low */
N#define MS32_TIM_BREAK_POLARITY_HIGH             TIM_BDTR_BKP              /*!< Break input BRK is active high */
N
N
N/** @defgroup TIM_EC_OSSI OSSI
N  * @{
N  */
N#define MS32_TIM_OSSI_DISABLE                    0x00000000U             /*!< When inactive, OCx/OCxN outputs are disabled */
N#define MS32_TIM_OSSI_ENABLE                     TIM_BDTR_OSSI           /*!< When inactive, OxC/OCxN outputs are first forced with their inactive level then forced to their idle level after the deadtime */
N
N
N/** @defgroup TIM_EC_OSSR OSSR
N  * @{
N  */
N#define MS32_TIM_OSSR_DISABLE                    0x00000000U             /*!< When inactive, OCx/OCxN outputs are disabled */
N#define MS32_TIM_OSSR_ENABLE                     TIM_BDTR_OSSR           /*!< When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 */
N
N
N/** @defgroup TIM_EC_DMABURST_BASEADDR DMA Burst Base Address
N  * @{
N  */
N#define MS32_TIM_DMABURST_BASEADDR_CR1           0x00000000U                                                      /*!< TIMx_CR1 register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_CR2           TIM_DCR_DBA_0                                                    /*!< TIMx_CR2 register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_SMCR          TIM_DCR_DBA_1                                                    /*!< TIMx_SMCR register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_DIER          (TIM_DCR_DBA_1 |  TIM_DCR_DBA_0)                                 /*!< TIMx_DIER register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_SR            TIM_DCR_DBA_2                                                    /*!< TIMx_SR register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_EGR           (TIM_DCR_DBA_2 | TIM_DCR_DBA_0)                                  /*!< TIMx_EGR register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_CCMR1         (TIM_DCR_DBA_2 | TIM_DCR_DBA_1)                                  /*!< TIMx_CCMR1 register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_CCMR2         (TIM_DCR_DBA_2 | TIM_DCR_DBA_1 | TIM_DCR_DBA_0)                  /*!< TIMx_CCMR2 register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_CCER          TIM_DCR_DBA_3                                                    /*!< TIMx_CCER register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_CNT           (TIM_DCR_DBA_3 | TIM_DCR_DBA_0)                                  /*!< TIMx_CNT register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_PSC           (TIM_DCR_DBA_3 | TIM_DCR_DBA_1)                                  /*!< TIMx_PSC register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_ARR           (TIM_DCR_DBA_3 | TIM_DCR_DBA_1 | TIM_DCR_DBA_0)                  /*!< TIMx_ARR register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_RCR           (TIM_DCR_DBA_3 | TIM_DCR_DBA_2)                                  /*!< TIMx_RCR register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_CCR1          (TIM_DCR_DBA_3 | TIM_DCR_DBA_2 | TIM_DCR_DBA_0)                  /*!< TIMx_CCR1 register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_CCR2          (TIM_DCR_DBA_3 | TIM_DCR_DBA_2 | TIM_DCR_DBA_1)                  /*!< TIMx_CCR2 register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_CCR3          (TIM_DCR_DBA_3 | TIM_DCR_DBA_2 | TIM_DCR_DBA_1 | TIM_DCR_DBA_0)  /*!< TIMx_CCR3 register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_CCR4          TIM_DCR_DBA_4                                                    /*!< TIMx_CCR4 register is the DMA base address for DMA burst */
N#define MS32_TIM_DMABURST_BASEADDR_BDTR          (TIM_DCR_DBA_4 | TIM_DCR_DBA_0)                                  /*!< TIMx_BDTR register is the DMA base address for DMA burst */
N
N
N/** @defgroup TIM_EC_DMABURST_LENGTH DMA Burst Length
N  * @{
N  */
N#define MS32_TIM_DMABURST_LENGTH_1TRANSFER       0x00000000U                                                     /*!< Transfer is done to 1 register starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_2TRANSFERS      TIM_DCR_DBL_0                                                   /*!< Transfer is done to 2 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_3TRANSFERS      TIM_DCR_DBL_1                                                   /*!< Transfer is done to 3 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_4TRANSFERS      (TIM_DCR_DBL_1 |  TIM_DCR_DBL_0)                                /*!< Transfer is done to 4 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_5TRANSFERS      TIM_DCR_DBL_2                                                   /*!< Transfer is done to 5 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_6TRANSFERS      (TIM_DCR_DBL_2 | TIM_DCR_DBL_0)                                 /*!< Transfer is done to 6 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_7TRANSFERS      (TIM_DCR_DBL_2 | TIM_DCR_DBL_1)                                 /*!< Transfer is done to 7 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_8TRANSFERS      (TIM_DCR_DBL_2 | TIM_DCR_DBL_1 | TIM_DCR_DBL_0)                 /*!< Transfer is done to 1 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_9TRANSFERS      TIM_DCR_DBL_3                                                   /*!< Transfer is done to 9 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_10TRANSFERS     (TIM_DCR_DBL_3 | TIM_DCR_DBL_0)                                 /*!< Transfer is done to 10 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_11TRANSFERS     (TIM_DCR_DBL_3 | TIM_DCR_DBL_1)                                 /*!< Transfer is done to 11 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_12TRANSFERS     (TIM_DCR_DBL_3 | TIM_DCR_DBL_1 | TIM_DCR_DBL_0)                 /*!< Transfer is done to 12 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_13TRANSFERS     (TIM_DCR_DBL_3 | TIM_DCR_DBL_2)                                 /*!< Transfer is done to 13 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_14TRANSFERS     (TIM_DCR_DBL_3 | TIM_DCR_DBL_2 | TIM_DCR_DBL_0)                 /*!< Transfer is done to 14 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_15TRANSFERS     (TIM_DCR_DBL_3 | TIM_DCR_DBL_2 | TIM_DCR_DBL_1)                 /*!< Transfer is done to 15 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_16TRANSFERS     (TIM_DCR_DBL_3 | TIM_DCR_DBL_2 | TIM_DCR_DBL_1 | TIM_DCR_DBL_0) /*!< Transfer is done to 16 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_17TRANSFERS     TIM_DCR_DBL_4                                                   /*!< Transfer is done to 17 registers starting from the DMA burst base address */
N#define MS32_TIM_DMABURST_LENGTH_18TRANSFERS     (TIM_DCR_DBL_4 |  TIM_DCR_DBL_0)                                /*!< Transfer is done to 18 registers starting from the DMA burst base address */
N
N
N#define MS32_TIM_TIM14_TI1_RMP_GPIO     TIM14_OR_RMP_MASK                                                        /*!< TIM14_TI1 is connected to Ored GPIO */
N#define MS32_TIM_TIM14_TI1_RMP_RTC_CLK  (TIM14_OR_TI1_RMP_0  | TIM14_OR_RMP_MASK)                                /*!< TIM14_TI1 is connected to RTC clock */
N#define MS32_TIM_TIM14_TI1_RMP_HSE      (TIM14_OR_TI1_RMP_1  | TIM14_OR_RMP_MASK)                                /*!< TIM14_TI1 is connected to HSE/32 clock */
N#define MS32_TIM_TIM14_TI1_RMP_MCO      (TIM14_OR_TI1_RMP_0  | TIM14_OR_TI1_RMP_1  | TIM14_OR_RMP_MASK)          /*!< TIM14_TI1 is connected to MCO */
N
N
N/** @defgroup TIM_EC_OCREF_CLR_INT OCREF clear input selection
N  * @{
N  */
N#define MS32_TIM_OCREF_CLR_INT_OCREF_CLR     0x00000000U         /*!< OCREF_CLR_INT is connected to the OCREF_CLR input */
N#define MS32_TIM_OCREF_CLR_INT_ETR           TIM_SMCR_OCCS       /*!< OCREF_CLR_INT is connected to ETRF */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup TIM_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in TIM register.
N  * @param  __INSTANCE__ TIM Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_TIM_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG((__INSTANCE__)->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in TIM register.
N  * @param  __INSTANCE__ TIM Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_TIM_ReadReg(__INSTANCE__, __REG__) READ_REG((__INSTANCE__)->__REG__)
N
N
N/** @defgroup TIM_EM_Exported_Macros Exported_Macros
N  * @{
N  */
N
N/**
N  * @brief  HELPER macro calculating DTG[0:7] in the TIMx_BDTR register to achieve the requested dead time duration.
N  * @note ex: @ref __MS32_TIM_CALC_DEADTIME (80000000, @ref MS32_TIM_GetClockDivision (), 120);
N  * @param  __TIMCLK__ timer input clock frequency (in Hz)
N  * @param  __CKD__ This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CLOCKDIVISION_DIV1
N  *         @arg @ref MS32_TIM_CLOCKDIVISION_DIV2
N  *         @arg @ref MS32_TIM_CLOCKDIVISION_DIV4
N  * @param  __DT__ deadtime duration (in ns)
N  * @retval DTG[0:7]
N  */
N#define __MS32_TIM_CALC_DEADTIME(__TIMCLK__, __CKD__, __DT__)  \
N  ( (((uint64_t)((__DT__)*1000U)) < ((DT_DELAY_1+1U) * TIM_CALC_DTS((__TIMCLK__), (__CKD__))))    ? (uint8_t)(((uint64_t)((__DT__)*1000U) / TIM_CALC_DTS((__TIMCLK__), (__CKD__)))  & DT_DELAY_1) :                                               \
N    (((uint64_t)((__DT__)*1000U)) < ((64U + (DT_DELAY_2+1U)) * 2U * TIM_CALC_DTS((__TIMCLK__), (__CKD__))))  ? (uint8_t)(DT_RANGE_2 | ((uint8_t)((uint8_t)((((uint64_t)((__DT__)*1000U))/ TIM_CALC_DTS((__TIMCLK__), (__CKD__))) >> 1U) - (uint8_t) 64) & DT_DELAY_2)) :\
N    (((uint64_t)((__DT__)*1000U)) < ((32U + (DT_DELAY_3+1U)) * 8U * TIM_CALC_DTS((__TIMCLK__), (__CKD__))))  ? (uint8_t)(DT_RANGE_3 | ((uint8_t)((uint8_t)(((((uint64_t)(__DT__)*1000U))/ TIM_CALC_DTS((__TIMCLK__), (__CKD__))) >> 3U) - (uint8_t) 32) & DT_DELAY_3)) :\
N    (((uint64_t)((__DT__)*1000U)) < ((32U + (DT_DELAY_4+1U)) * 16U * TIM_CALC_DTS((__TIMCLK__), (__CKD__)))) ? (uint8_t)(DT_RANGE_4 | ((uint8_t)((uint8_t)(((((uint64_t)(__DT__)*1000U))/ TIM_CALC_DTS((__TIMCLK__), (__CKD__))) >> 4U) - (uint8_t) 32) & DT_DELAY_4)) :\
N    0U)
X#define __MS32_TIM_CALC_DEADTIME(__TIMCLK__, __CKD__, __DT__)    ( (((uint64_t)((__DT__)*1000U)) < ((DT_DELAY_1+1U) * TIM_CALC_DTS((__TIMCLK__), (__CKD__))))    ? (uint8_t)(((uint64_t)((__DT__)*1000U) / TIM_CALC_DTS((__TIMCLK__), (__CKD__)))  & DT_DELAY_1) :                                                   (((uint64_t)((__DT__)*1000U)) < ((64U + (DT_DELAY_2+1U)) * 2U * TIM_CALC_DTS((__TIMCLK__), (__CKD__))))  ? (uint8_t)(DT_RANGE_2 | ((uint8_t)((uint8_t)((((uint64_t)((__DT__)*1000U))/ TIM_CALC_DTS((__TIMCLK__), (__CKD__))) >> 1U) - (uint8_t) 64) & DT_DELAY_2)) :    (((uint64_t)((__DT__)*1000U)) < ((32U + (DT_DELAY_3+1U)) * 8U * TIM_CALC_DTS((__TIMCLK__), (__CKD__))))  ? (uint8_t)(DT_RANGE_3 | ((uint8_t)((uint8_t)(((((uint64_t)(__DT__)*1000U))/ TIM_CALC_DTS((__TIMCLK__), (__CKD__))) >> 3U) - (uint8_t) 32) & DT_DELAY_3)) :    (((uint64_t)((__DT__)*1000U)) < ((32U + (DT_DELAY_4+1U)) * 16U * TIM_CALC_DTS((__TIMCLK__), (__CKD__)))) ? (uint8_t)(DT_RANGE_4 | ((uint8_t)((uint8_t)(((((uint64_t)(__DT__)*1000U))/ TIM_CALC_DTS((__TIMCLK__), (__CKD__))) >> 4U) - (uint8_t) 32) & DT_DELAY_4)) :    0U)
N
N/**
N  * @brief  HELPER macro calculating the prescaler value to achieve the required counter clock frequency.
N  * @note ex: @ref __MS32_TIM_CALC_PSC (80000000, 1000000);
N  * @param  __TIMCLK__ timer input clock frequency (in Hz)
N  * @param  __CNTCLK__ counter clock frequency (in Hz)
N  * @retval Prescaler value  (between Min_Data=0 and Max_Data=65535)
N  */
N#define __MS32_TIM_CALC_PSC(__TIMCLK__, __CNTCLK__)   \
N  (((__TIMCLK__) >= (__CNTCLK__)) ? (uint32_t)(((__TIMCLK__)/(__CNTCLK__)) - 1U) : 0U)
X#define __MS32_TIM_CALC_PSC(__TIMCLK__, __CNTCLK__)     (((__TIMCLK__) >= (__CNTCLK__)) ? (uint32_t)(((__TIMCLK__)/(__CNTCLK__)) - 1U) : 0U)
N
N/**
N  * @brief  HELPER macro calculating the auto-reload value to achieve the required output signal frequency.
N  * @note ex: @ref __MS32_TIM_CALC_ARR (1000000, @ref MS32_TIM_GetPrescaler (), 10000);
N  * @param  __TIMCLK__ timer input clock frequency (in Hz)
N  * @param  __PSC__ prescaler
N  * @param  __FREQ__ output signal frequency (in Hz)
N  * @retval  Auto-reload value  (between Min_Data=0 and Max_Data=65535)
N  */
N#define __MS32_TIM_CALC_ARR(__TIMCLK__, __PSC__, __FREQ__) \
N  ((((__TIMCLK__)/((__PSC__) + 1U)) >= (__FREQ__)) ? (((__TIMCLK__)/((__FREQ__) * ((__PSC__) + 1U))) - 1U) : 0U)
X#define __MS32_TIM_CALC_ARR(__TIMCLK__, __PSC__, __FREQ__)   ((((__TIMCLK__)/((__PSC__) + 1U)) >= (__FREQ__)) ? (((__TIMCLK__)/((__FREQ__) * ((__PSC__) + 1U))) - 1U) : 0U)
N
N/**
N  * @brief  HELPER macro calculating the compare value required to achieve the required timer output compare active/inactive delay.
N  * @note ex: @ref __MS32_TIM_CALC_DELAY (1000000, @ref MS32_TIM_GetPrescaler (), 10);
N  * @param  __TIMCLK__ timer input clock frequency (in Hz)
N  * @param  __PSC__ prescaler
N  * @param  __DELAY__ timer output compare active/inactive delay (in us)
N  * @retval Compare value  (between Min_Data=0 and Max_Data=65535)
N  */
N#define __MS32_TIM_CALC_DELAY(__TIMCLK__, __PSC__, __DELAY__)  \
N  ((uint32_t)(((uint64_t)(__TIMCLK__) * (uint64_t)(__DELAY__)) \
N              / ((uint64_t)1000000U * (uint64_t)((__PSC__) + 1U))))
X#define __MS32_TIM_CALC_DELAY(__TIMCLK__, __PSC__, __DELAY__)    ((uint32_t)(((uint64_t)(__TIMCLK__) * (uint64_t)(__DELAY__))               / ((uint64_t)1000000U * (uint64_t)((__PSC__) + 1U))))
N
N/**
N  * @brief  HELPER macro calculating the auto-reload value to achieve the required pulse duration (when the timer operates in one pulse mode).
N  * @note ex: @ref __MS32_TIM_CALC_PULSE (1000000, @ref MS32_TIM_GetPrescaler (), 10, 20);
N  * @param  __TIMCLK__ timer input clock frequency (in Hz)
N  * @param  __PSC__ prescaler
N  * @param  __DELAY__ timer output compare active/inactive delay (in us)
N  * @param  __PULSE__ pulse duration (in us)
N  * @retval Auto-reload value  (between Min_Data=0 and Max_Data=65535)
N  */
N#define __MS32_TIM_CALC_PULSE(__TIMCLK__, __PSC__, __DELAY__, __PULSE__)  \
N  ((uint32_t)(__MS32_TIM_CALC_DELAY((__TIMCLK__), (__PSC__), (__PULSE__)) \
N              + __MS32_TIM_CALC_DELAY((__TIMCLK__), (__PSC__), (__DELAY__))))
X#define __MS32_TIM_CALC_PULSE(__TIMCLK__, __PSC__, __DELAY__, __PULSE__)    ((uint32_t)(__MS32_TIM_CALC_DELAY((__TIMCLK__), (__PSC__), (__PULSE__))               + __MS32_TIM_CALC_DELAY((__TIMCLK__), (__PSC__), (__DELAY__))))
N
N/**
N  * @brief  HELPER macro retrieving the ratio of the input capture prescaler
N  * @note ex: @ref __MS32_TIM_GET_ICPSC_RATIO (@ref MS32_TIM_IC_GetPrescaler ());
N  * @param  __ICPSC__ This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_ICPSC_DIV1
N  *         @arg @ref MS32_TIM_ICPSC_DIV2
N  *         @arg @ref MS32_TIM_ICPSC_DIV4
N  *         @arg @ref MS32_TIM_ICPSC_DIV8
N  * @retval Input capture prescaler ratio (1, 2, 4 or 8)
N  */
N#define __MS32_TIM_GET_ICPSC_RATIO(__ICPSC__)  \
N  ((uint32_t)(0x01U << (((__ICPSC__) >> 16U) >> TIM_CCMR1_IC1PSC_Pos)))
X#define __MS32_TIM_GET_ICPSC_RATIO(__ICPSC__)    ((uint32_t)(0x01U << (((__ICPSC__) >> 16U) >> TIM_CCMR1_IC1PSC_Pos)))
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup TIM_EF_Time_Base Time Base configuration
N  * @{
N  */
N
N/**
N  * @brief  Enable timer counter.
N  * @rmtoll CR1          CEN           MS32_TIM_EnableCounter
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableCounter(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableCounter(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->CR1, TIM_CR1_CEN);
X  ((TIMx->CR1) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable timer counter.
N  * @rmtoll CR1          CEN           MS32_TIM_DisableCounter
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableCounter(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableCounter(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->CR1, TIM_CR1_CEN);
X  ((TIMx->CR1) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Indicates whether the timer counter is enabled.
N  * @rmtoll CR1          CEN           MS32_TIM_IsEnabledCounter
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledCounter(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledCounter(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->CR1, TIM_CR1_CEN) == (TIM_CR1_CEN)) ? 1UL : 0UL);
X  return ((((TIMx->CR1) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable update event generation.
N  * @rmtoll CR1          UDIS          MS32_TIM_EnableUpdateEvent
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableUpdateEvent(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableUpdateEvent(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->CR1, TIM_CR1_UDIS);
X  ((TIMx->CR1) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable update event generation.
N  * @rmtoll CR1          UDIS          MS32_TIM_DisableUpdateEvent
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableUpdateEvent(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableUpdateEvent(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->CR1, TIM_CR1_UDIS);
X  ((TIMx->CR1) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Indicates whether update event generation is enabled.
N  * @rmtoll CR1          UDIS          MS32_TIM_IsEnabledUpdateEvent
N  * @param  TIMx Timer instance
N  * @retval Inverted state of bit (0 or 1).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledUpdateEvent(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledUpdateEvent(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->CR1, TIM_CR1_UDIS) == (uint32_t)RESET) ? 1UL : 0UL);
X  return ((((TIMx->CR1) & ((0x1UL << (1U)))) == (uint32_t)RESET) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set update event source
N  * @note Update event source set to MS32_TIM_UPDATESOURCE_REGULAR: any of the following events
N  *       generate an update interrupt or DMA request if enabled:
N  *        - Counter overflow/underflow
N  *        - Setting the UG bit
N  *        - Update generation through the slave mode controller
N  * @note Update event source set to MS32_TIM_UPDATESOURCE_COUNTER: only counter
N  *       overflow/underflow generates an update interrupt or DMA request if enabled.
N  * @rmtoll CR1          URS           MS32_TIM_SetUpdateSource
N  * @param  TIMx Timer instance
N  * @param  UpdateSource This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_UPDATESOURCE_REGULAR
N  *         @arg @ref MS32_TIM_UPDATESOURCE_COUNTER
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetUpdateSource(TIM_TypeDef *TIMx, uint32_t UpdateSource) {
Xstatic __inline void MS32_TIM_SetUpdateSource(TIM_TypeDef *TIMx, uint32_t UpdateSource) {
N  MODIFY_REG(TIMx->CR1, TIM_CR1_URS, UpdateSource);
X  (((TIMx->CR1)) = ((((((TIMx->CR1))) & (~((0x1UL << (2U))))) | (UpdateSource))));
N}
N
N/**
N  * @brief  Get actual event update source
N  * @rmtoll CR1          URS           MS32_TIM_GetUpdateSource
N  * @param  TIMx Timer instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_TIM_UPDATESOURCE_REGULAR
N  *         @arg @ref MS32_TIM_UPDATESOURCE_COUNTER
N  */
N__STATIC_INLINE uint32_t MS32_TIM_GetUpdateSource(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_GetUpdateSource(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_URS));
X  return (uint32_t)(((TIMx->CR1) & ((0x1UL << (2U)))));
N}
N
N/**
N  * @brief  Set one pulse mode (one shot v.s. repetitive).
N  * @rmtoll CR1          OPM           MS32_TIM_SetOnePulseMode
N  * @param  TIMx Timer instance
N  * @param  OnePulseMode This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_ONEPULSEMODE_SINGLE
N  *         @arg @ref MS32_TIM_ONEPULSEMODE_REPETITIVE
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetOnePulseMode(TIM_TypeDef *TIMx, uint32_t OnePulseMode) {
Xstatic __inline void MS32_TIM_SetOnePulseMode(TIM_TypeDef *TIMx, uint32_t OnePulseMode) {
N  MODIFY_REG(TIMx->CR1, TIM_CR1_OPM, OnePulseMode);
X  (((TIMx->CR1)) = ((((((TIMx->CR1))) & (~((0x1UL << (3U))))) | (OnePulseMode))));
N}
N
N/**
N  * @brief  Get actual one pulse mode.
N  * @rmtoll CR1          OPM           MS32_TIM_GetOnePulseMode
N  * @param  TIMx Timer instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_TIM_ONEPULSEMODE_SINGLE
N  *         @arg @ref MS32_TIM_ONEPULSEMODE_REPETITIVE
N  */
N__STATIC_INLINE uint32_t MS32_TIM_GetOnePulseMode(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_GetOnePulseMode(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_OPM));
X  return (uint32_t)(((TIMx->CR1) & ((0x1UL << (3U)))));
N}
N
N/**
N  * @brief  Set the timer counter counting mode.
N  * @note Macro IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx) can be used to
N  *       check whether or not the counter mode selection feature is supported
N  *       by a timer instance.
N  * @note Switching from Center Aligned counter mode to Edge counter mode (or reverse)
N  *       requires a timer reset to avoid unexpected direction
N  *       due to DIR bit readonly in center aligned mode.
N  * @rmtoll CR1          DIR           MS32_TIM_SetCounterMode\n
N  *         CR1          CMS           MS32_TIM_SetCounterMode
N  * @param  TIMx Timer instance
N  * @param  CounterMode This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_COUNTERMODE_UP
N  *         @arg @ref MS32_TIM_COUNTERMODE_DOWN
N  *         @arg @ref MS32_TIM_COUNTERMODE_CENTER1
N  *         @arg @ref MS32_TIM_COUNTERMODE_CENTER2    
N  *         @arg @ref MS32_TIM_COUNTERMODE_CENTER3       
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetCounterMode(TIM_TypeDef *TIMx, uint32_t CounterMode) {
Xstatic __inline void MS32_TIM_SetCounterMode(TIM_TypeDef *TIMx, uint32_t CounterMode) {
N  MODIFY_REG(TIMx->CR1, (TIM_CR1_DIR | TIM_CR1_CMS), CounterMode);
X  (((TIMx->CR1)) = ((((((TIMx->CR1))) & (~(((0x1UL << (4U)) | (0x3UL << (5U)))))) | (CounterMode))));
N}
N
N/**
N  * @brief  Get actual counter mode.
N  * @note Macro IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx) can be used to
N  *       check whether or not the counter mode selection feature is supported
N  *       by a timer instance.
N  * @rmtoll CR1          DIR           MS32_TIM_GetCounterMode\n
N  *         CR1          CMS           MS32_TIM_GetCounterMode
N  * @param  TIMx Timer instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_TIM_COUNTERMODE_UP
N  *         @arg @ref MS32_TIM_COUNTERMODE_DOWN
N  *         @arg @ref MS32_TIM_COUNTERMODE_CENTER1
N  *         @arg @ref MS32_TIM_COUNTERMODE_CENTER2    
N  *         @arg @ref MS32_TIM_COUNTERMODE_CENTER3       
N  */
N__STATIC_INLINE uint32_t MS32_TIM_GetCounterMode(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_GetCounterMode(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR | TIM_CR1_CMS));
X  return (uint32_t)(((TIMx->CR1) & ((0x1UL << (4U)) | (0x3UL << (5U)))));
N}
N
N/**
N  * @brief  Enable auto-reload (ARR) preload.
N  * @rmtoll CR1          ARPE          MS32_TIM_EnableARRPreload
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableARRPreload(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableARRPreload(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->CR1, TIM_CR1_ARPE);
X  ((TIMx->CR1) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable auto-reload (ARR) preload.
N  * @rmtoll CR1          ARPE          MS32_TIM_DisableARRPreload
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableARRPreload(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableARRPreload(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->CR1, TIM_CR1_ARPE);
X  ((TIMx->CR1) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Indicates whether auto-reload (ARR) preload is enabled.
N  * @rmtoll CR1          ARPE          MS32_TIM_IsEnabledARRPreload
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledARRPreload(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledARRPreload(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->CR1, TIM_CR1_ARPE) == (TIM_CR1_ARPE)) ? 1UL : 0UL);
X  return ((((TIMx->CR1) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set the division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
N  * @note Macro IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
N  *       whether or not the clock division feature is supported by the timer
N  *       instance.
N  * @rmtoll CR1          CKD           MS32_TIM_SetClockDivision
N  * @param  TIMx Timer instance
N  * @param  ClockDivision This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CLOCKDIVISION_DIV1
N  *         @arg @ref MS32_TIM_CLOCKDIVISION_DIV2
N  *         @arg @ref MS32_TIM_CLOCKDIVISION_DIV4
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetClockDivision(TIM_TypeDef *TIMx, uint32_t ClockDivision) {
Xstatic __inline void MS32_TIM_SetClockDivision(TIM_TypeDef *TIMx, uint32_t ClockDivision) {
N  MODIFY_REG(TIMx->CR1, TIM_CR1_CKD, ClockDivision);
X  (((TIMx->CR1)) = ((((((TIMx->CR1))) & (~((0x3UL << (8U))))) | (ClockDivision))));
N}
N
N/**
N  * @brief  Get the actual division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
N  * @note Macro IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
N  *       whether or not the clock division feature is supported by the timer
N  *       instance.
N  * @rmtoll CR1          CKD           MS32_TIM_GetClockDivision
N  * @param  TIMx Timer instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_TIM_CLOCKDIVISION_DIV1
N  *         @arg @ref MS32_TIM_CLOCKDIVISION_DIV2
N  *         @arg @ref MS32_TIM_CLOCKDIVISION_DIV4
N  */
N__STATIC_INLINE uint32_t MS32_TIM_GetClockDivision(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_GetClockDivision(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_CKD));
X  return (uint32_t)(((TIMx->CR1) & ((0x3UL << (8U)))));
N}
N
N/**
N  * @brief  Set the counter value.
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @rmtoll CNT          CNT           MS32_TIM_SetCounter
N  * @param  TIMx Timer instance
N  * @param  Counter Counter value (between Min_Data=0 and Max_Data=0xFFFF or 0xFFFFFFFF)
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t Counter) {
Xstatic __inline void MS32_TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t Counter) {
N  WRITE_REG(TIMx->CNT, Counter);
X  ((TIMx->CNT) = (Counter));
N}
N
N/**
N  * @brief  Get the counter value.
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @rmtoll CNT          CNT           MS32_TIM_GetCounter
N  * @param  TIMx Timer instance
N  * @retval Counter value (between Min_Data=0 and Max_Data=0xFFFF or 0xFFFFFFFF)
N  */
N__STATIC_INLINE uint32_t MS32_TIM_GetCounter(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_GetCounter(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_REG(TIMx->CNT));
X  return (uint32_t)(((TIMx->CNT)));
N}
N
N/**
N  * @brief  Get the current direction of the counter
N  * @rmtoll CR1          DIR           MS32_TIM_GetDirection
N  * @param  TIMx Timer instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_TIM_COUNTERDIRECTION_UP
N  *         @arg @ref MS32_TIM_COUNTERDIRECTION_DOWN
N  */
N__STATIC_INLINE uint32_t MS32_TIM_GetDirection(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_GetDirection(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
X  return (uint32_t)(((TIMx->CR1) & ((0x1UL << (4U)))));
N}
N
N/**
N  * @brief  Set the prescaler value.
N  * @note The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
N  * @note The prescaler can be changed on the fly as this control register is buffered. The new
N  *       prescaler ratio is taken into account at the next update event.
N  * @note Helper macro @ref __MS32_TIM_CALC_PSC can be used to calculate the Prescaler parameter
N  * @rmtoll PSC          PSC           MS32_TIM_SetPrescaler
N  * @param  TIMx Timer instance
N  * @param  Prescaler between Min_Data=0 and Max_Data=65535
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler) {
Xstatic __inline void MS32_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler) {
N  WRITE_REG(TIMx->PSC, Prescaler);
X  ((TIMx->PSC) = (Prescaler));
N}
N
N/**
N  * @brief  Get the prescaler value.
N  * @rmtoll PSC          PSC           MS32_TIM_GetPrescaler
N  * @param  TIMx Timer instance
N  * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
N  */
N__STATIC_INLINE uint32_t MS32_TIM_GetPrescaler(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_GetPrescaler(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_REG(TIMx->PSC));
X  return (uint32_t)(((TIMx->PSC)));
N}
N
N/**
N  * @brief  Set the auto-reload value.
N  * @note The counter is blocked while the auto-reload value is null.
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Helper macro @ref __MS32_TIM_CALC_ARR can be used to calculate the AutoReload parameter
N  * @rmtoll ARR          ARR           MS32_TIM_SetAutoReload
N  * @param  TIMx Timer instance
N  * @param  AutoReload between Min_Data=0 and Max_Data=65535
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload) {
Xstatic __inline void MS32_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload) {
N  WRITE_REG(TIMx->ARR, AutoReload);
X  ((TIMx->ARR) = (AutoReload));
N}
N
N/**
N  * @brief  Get the auto-reload value.
N  * @rmtoll ARR          ARR           MS32_TIM_GetAutoReload
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @param  TIMx Timer instance
N  * @retval Auto-reload value
N  */
N__STATIC_INLINE uint32_t MS32_TIM_GetAutoReload(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_GetAutoReload(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_REG(TIMx->ARR));
X  return (uint32_t)(((TIMx->ARR)));
N}
N
N/**
N  * @brief  Set the repetition counter value.
N  * @note Macro IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a repetition counter.
N  * @rmtoll RCR          REP           MS32_TIM_SetRepetitionCounter
N  * @param  TIMx Timer instance
N  * @param  RepetitionCounter between Min_Data=0 and Max_Data=255
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetRepetitionCounter(TIM_TypeDef *TIMx, uint32_t RepetitionCounter) {
Xstatic __inline void MS32_TIM_SetRepetitionCounter(TIM_TypeDef *TIMx, uint32_t RepetitionCounter) {
N  WRITE_REG(TIMx->RCR, RepetitionCounter);
X  ((TIMx->RCR) = (RepetitionCounter));
N}
N
N/**
N  * @brief  Get the repetition counter value.
N  * @note Macro IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a repetition counter.
N  * @rmtoll RCR          REP           MS32_TIM_GetRepetitionCounter
N  * @param  TIMx Timer instance
N  * @retval Repetition counter value
N  */
N__STATIC_INLINE uint32_t MS32_TIM_GetRepetitionCounter(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_GetRepetitionCounter(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_REG(TIMx->RCR));
X  return (uint32_t)(((TIMx->RCR)));
N}
N
N
N/** @defgroup TIM_EF_Capture_Compare Capture Compare configuration
N  * @{
N  */
N
N/**
N  * @brief  Enable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
N  * @note CCxE, CCxNE and OCxM bits are preloaded, after having been written,
N  *       they are updated only when a commutation event (COM) occurs.
N  * @note Only on channels that have a complementary output.
N  * @note Macro IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance is able to generate a commutation event.
N  * @rmtoll CR2          CCPC          MS32_TIM_CC_EnablePreload
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_CC_EnablePreload(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_CC_EnablePreload(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->CR2, TIM_CR2_CCPC);
X  ((TIMx->CR2) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
N  * @note Macro IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance is able to generate a commutation event.
N  * @rmtoll CR2          CCPC          MS32_TIM_CC_DisablePreload
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_CC_DisablePreload(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_CC_DisablePreload(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->CR2, TIM_CR2_CCPC);
X  ((TIMx->CR2) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Set the updated source of the capture/compare control bits (CCxE, CCxNE and OCxM).
N  * @note Macro IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance is able to generate a commutation event.
N  * @rmtoll CR2          CCUS          MS32_TIM_CC_SetUpdate
N  * @param  TIMx Timer instance
N  * @param  CCUpdateSource This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CCUPDATESOURCE_COMG_ONLY
N  *         @arg @ref MS32_TIM_CCUPDATESOURCE_COMG_AND_TRGI
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_CC_SetUpdate(TIM_TypeDef *TIMx, uint32_t CCUpdateSource) {
Xstatic __inline void MS32_TIM_CC_SetUpdate(TIM_TypeDef *TIMx, uint32_t CCUpdateSource) {
N  MODIFY_REG(TIMx->CR2, TIM_CR2_CCUS, CCUpdateSource);
X  (((TIMx->CR2)) = ((((((TIMx->CR2))) & (~((0x1UL << (2U))))) | (CCUpdateSource))));
N}
N
N/**
N  * @brief  Set the trigger of the capture/compare DMA request.
N  * @rmtoll CR2          CCDS          MS32_TIM_CC_SetDMAReqTrigger
N  * @param  TIMx Timer instance
N  * @param  DMAReqTrigger This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CCDMAREQUEST_CC
N  *         @arg @ref MS32_TIM_CCDMAREQUEST_UPDATE
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_CC_SetDMAReqTrigger(TIM_TypeDef *TIMx, uint32_t DMAReqTrigger) {
Xstatic __inline void MS32_TIM_CC_SetDMAReqTrigger(TIM_TypeDef *TIMx, uint32_t DMAReqTrigger) {
N  MODIFY_REG(TIMx->CR2, TIM_CR2_CCDS, DMAReqTrigger);
X  (((TIMx->CR2)) = ((((((TIMx->CR2))) & (~((0x1UL << (3U))))) | (DMAReqTrigger))));
N}
N
N/**
N  * @brief  Get actual trigger of the capture/compare DMA request.
N  * @rmtoll CR2          CCDS          MS32_TIM_CC_GetDMAReqTrigger
N  * @param  TIMx Timer instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_TIM_CCDMAREQUEST_CC
N  *         @arg @ref MS32_TIM_CCDMAREQUEST_UPDATE
N  */
N__STATIC_INLINE uint32_t MS32_TIM_CC_GetDMAReqTrigger(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_CC_GetDMAReqTrigger(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_BIT(TIMx->CR2, TIM_CR2_CCDS));
X  return (uint32_t)(((TIMx->CR2) & ((0x1UL << (3U)))));
N}
N
N/**
N  * @brief  Set the lock level to freeze the
N  *         configuration of several capture/compare parameters.
N  * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       the lock mechanism is supported by a timer instance.
N  * @rmtoll BDTR         LOCK          MS32_TIM_CC_SetLockLevel
N  * @param  TIMx Timer instance
N  * @param  LockLevel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_LOCKLEVEL_OFF
N  *         @arg @ref MS32_TIM_LOCKLEVEL_1
N  *         @arg @ref MS32_TIM_LOCKLEVEL_2
N  *         @arg @ref MS32_TIM_LOCKLEVEL_3
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_CC_SetLockLevel(TIM_TypeDef *TIMx, uint32_t LockLevel) {
Xstatic __inline void MS32_TIM_CC_SetLockLevel(TIM_TypeDef *TIMx, uint32_t LockLevel) {
N  MODIFY_REG(TIMx->BDTR, TIM_BDTR_LOCK, LockLevel);
X  (((TIMx->BDTR)) = ((((((TIMx->BDTR))) & (~((0x3UL << (8U))))) | (LockLevel))));
N}
N
N/**
N  * @brief  Enable capture/compare channels.
N  * @rmtoll CCER         CC1E          MS32_TIM_CC_EnableChannel\n
N  *         CCER         CC1NE         MS32_TIM_CC_EnableChannel\n
N  *         CCER         CC2E          MS32_TIM_CC_EnableChannel\n
N  *         CCER         CC2NE         MS32_TIM_CC_EnableChannel\n
N  *         CCER         CC3E          MS32_TIM_CC_EnableChannel\n
N  *         CCER         CC3NE         MS32_TIM_CC_EnableChannel\n
N  *         CCER         CC4E          MS32_TIM_CC_EnableChannel
N  * @param  TIMx Timer instance
N  * @param  Channels This parameter can be a combination of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH1N
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH2N
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH3N
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels) {
Xstatic __inline void MS32_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels) {
N  SET_BIT(TIMx->CCER, Channels);
X  ((TIMx->CCER) |= (Channels));
N}
N
N/**
N  * @brief  Disable capture/compare channels.
N  * @rmtoll CCER         CC1E          MS32_TIM_CC_DisableChannel\n
N  *         CCER         CC1NE         MS32_TIM_CC_DisableChannel\n
N  *         CCER         CC2E          MS32_TIM_CC_DisableChannel\n
N  *         CCER         CC2NE         MS32_TIM_CC_DisableChannel\n
N  *         CCER         CC3E          MS32_TIM_CC_DisableChannel\n
N  *         CCER         CC3NE         MS32_TIM_CC_DisableChannel\n
N  *         CCER         CC4E          MS32_TIM_CC_DisableChannel
N  * @param  TIMx Timer instance
N  * @param  Channels This parameter can be a combination of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH1N
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH2N
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH3N
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_CC_DisableChannel(TIM_TypeDef *TIMx, uint32_t Channels) {
Xstatic __inline void MS32_TIM_CC_DisableChannel(TIM_TypeDef *TIMx, uint32_t Channels) {
N  CLEAR_BIT(TIMx->CCER, Channels);
X  ((TIMx->CCER) &= ~(Channels));
N}
N
N/**
N  * @brief  Indicate whether channel(s) is(are) enabled.
N  * @rmtoll CCER         CC1E          MS32_TIM_CC_IsEnabledChannel\n
N  *         CCER         CC1NE         MS32_TIM_CC_IsEnabledChannel\n
N  *         CCER         CC2E          MS32_TIM_CC_IsEnabledChannel\n
N  *         CCER         CC2NE         MS32_TIM_CC_IsEnabledChannel\n
N  *         CCER         CC3E          MS32_TIM_CC_IsEnabledChannel\n
N  *         CCER         CC3NE         MS32_TIM_CC_IsEnabledChannel\n
N  *         CCER         CC4E          MS32_TIM_CC_IsEnabledChannel
N  * @param  TIMx Timer instance
N  * @param  Channels This parameter can be a combination of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH1N
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH2N
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH3N
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_CC_IsEnabledChannel(TIM_TypeDef *TIMx, uint32_t Channels) {
Xstatic __inline uint32_t MS32_TIM_CC_IsEnabledChannel(TIM_TypeDef *TIMx, uint32_t Channels) {
N  return ((READ_BIT(TIMx->CCER, Channels) == (Channels)) ? 1UL : 0UL);
X  return ((((TIMx->CCER) & (Channels)) == (Channels)) ? 1UL : 0UL);
N}
N
N
N/** @defgroup TIM_EF_Output_Channel Output channel configuration
N  * @{
N  */
N
N/**
N  * @brief  Configure an output channel.
N  * @rmtoll CCMR1        CC1S          MS32_TIM_OC_ConfigOutput\n
N  *         CCMR1        CC2S          MS32_TIM_OC_ConfigOutput\n
N  *         CCMR2        CC3S          MS32_TIM_OC_ConfigOutput\n
N  *         CCMR2        CC4S          MS32_TIM_OC_ConfigOutput\n
N  *         CCER         CC1P          MS32_TIM_OC_ConfigOutput\n
N  *         CCER         CC2P          MS32_TIM_OC_ConfigOutput\n
N  *         CCER         CC3P          MS32_TIM_OC_ConfigOutput\n
N  *         CCER         CC4P          MS32_TIM_OC_ConfigOutput\n
N  *         CR2          OIS1          MS32_TIM_OC_ConfigOutput\n
N  *         CR2          OIS2          MS32_TIM_OC_ConfigOutput\n
N  *         CR2          OIS3          MS32_TIM_OC_ConfigOutput\n
N  *         CR2          OIS4          MS32_TIM_OC_ConfigOutput
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @param  Configuration This parameter must be a combination of all the following values:
N  *         @arg @ref MS32_TIM_OCPOLARITY_HIGH or @ref MS32_TIM_OCPOLARITY_LOW
N  *         @arg @ref MS32_TIM_OCIDLESTATE_LOW or @ref MS32_TIM_OCIDLESTATE_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration) {
Xstatic __inline void MS32_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  CLEAR_BIT(*pReg, (TIM_CCMR1_CC1S << SHIFT_TAB_OCxx[iChannel]));
X  ((*pReg) &= ~(((0x3UL << (0U)) << SHIFT_TAB_OCxx[iChannel])));
N  MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),
N             (Configuration & TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]);
X  (((TIMx->CCER)) = ((((((TIMx->CCER))) & (~(((0x1UL << (1U)) << SHIFT_TAB_CCxP[iChannel])))) | ((Configuration & (0x1UL << (1U))) << SHIFT_TAB_CCxP[iChannel]))));
N  MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),
N             (Configuration & TIM_CR2_OIS1) << SHIFT_TAB_OISx[iChannel]);
X  (((TIMx->CR2)) = ((((((TIMx->CR2))) & (~(((0x1UL << (8U)) << SHIFT_TAB_OISx[iChannel])))) | ((Configuration & (0x1UL << (8U))) << SHIFT_TAB_OISx[iChannel]))));
N}
N
N/**
N  * @brief  Define the behavior of the output reference signal OCxREF from which
N  *         OCx and OCxN (when relevant) are derived.
N  * @rmtoll CCMR1        OC1M          MS32_TIM_OC_SetMode\n
N  *         CCMR1        OC2M          MS32_TIM_OC_SetMode\n
N  *         CCMR2        OC3M          MS32_TIM_OC_SetMode\n
N  *         CCMR2        OC4M          MS32_TIM_OC_SetMode
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @param  Mode This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_OCMODE_FROZEN
N  *         @arg @ref MS32_TIM_OCMODE_ACTIVE
N  *         @arg @ref MS32_TIM_OCMODE_INACTIVE
N  *         @arg @ref MS32_TIM_OCMODE_TOGGLE
N  *         @arg @ref MS32_TIM_OCMODE_FORCED_INACTIVE
N  *         @arg @ref MS32_TIM_OCMODE_FORCED_ACTIVE
N  *         @arg @ref MS32_TIM_OCMODE_PWM1
N  *         @arg @ref MS32_TIM_OCMODE_PWM2
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode) {
Xstatic __inline void MS32_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
X  (((*pReg)) = ((((((*pReg))) & (~((((0x7UL << (4U)) | (0x3UL << (0U))) << SHIFT_TAB_OCxx[iChannel])))) | (Mode << SHIFT_TAB_OCxx[iChannel]))));
N}
N
N/**
N  * @brief  Get the output compare mode of an output channel.
N  * @rmtoll CCMR1        OC1M          MS32_TIM_OC_GetMode\n
N  *         CCMR1        OC2M          MS32_TIM_OC_GetMode\n
N  *         CCMR2        OC3M          MS32_TIM_OC_GetMode\n
N  *         CCMR2        OC4M          MS32_TIM_OC_GetMode
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_TIM_OCMODE_FROZEN
N  *         @arg @ref MS32_TIM_OCMODE_ACTIVE
N  *         @arg @ref MS32_TIM_OCMODE_INACTIVE
N  *         @arg @ref MS32_TIM_OCMODE_TOGGLE
N  *         @arg @ref MS32_TIM_OCMODE_FORCED_INACTIVE
N  *         @arg @ref MS32_TIM_OCMODE_FORCED_ACTIVE
N  *         @arg @ref MS32_TIM_OCMODE_PWM1
N  *         @arg @ref MS32_TIM_OCMODE_PWM2
N  */
N__STATIC_INLINE uint32_t MS32_TIM_OC_GetMode(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_TIM_OC_GetMode(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register const __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register const volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  return (READ_BIT(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel])) >> SHIFT_TAB_OCxx[iChannel]);
X  return (((*pReg) & ((((0x7UL << (4U)) | (0x3UL << (0U))) << SHIFT_TAB_OCxx[iChannel]))) >> SHIFT_TAB_OCxx[iChannel]);
N}
N
N/**
N  * @brief  Set the polarity of an output channel.
N  * @rmtoll CCER         CC1P          MS32_TIM_OC_SetPolarity\n
N  *         CCER         CC1NP         MS32_TIM_OC_SetPolarity\n
N  *         CCER         CC2P          MS32_TIM_OC_SetPolarity\n
N  *         CCER         CC2NP         MS32_TIM_OC_SetPolarity\n
N  *         CCER         CC3P          MS32_TIM_OC_SetPolarity\n
N  *         CCER         CC3NP         MS32_TIM_OC_SetPolarity\n
N  *         CCER         CC4P          MS32_TIM_OC_SetPolarity
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH1N
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH2N
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH3N
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @param  Polarity This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_OCPOLARITY_HIGH
N  *         @arg @ref MS32_TIM_OCPOLARITY_LOW
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity) {
Xstatic __inline void MS32_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
X  (((TIMx->CCER)) = ((((((TIMx->CCER))) & (~(((0x1UL << (1U)) << SHIFT_TAB_CCxP[iChannel])))) | (Polarity << SHIFT_TAB_CCxP[iChannel]))));
N}
N
N/**
N  * @brief  Get the polarity of an output channel.
N  * @rmtoll CCER         CC1P          MS32_TIM_OC_GetPolarity\n
N  *         CCER         CC1NP         MS32_TIM_OC_GetPolarity\n
N  *         CCER         CC2P          MS32_TIM_OC_GetPolarity\n
N  *         CCER         CC2NP         MS32_TIM_OC_GetPolarity\n
N  *         CCER         CC3P          MS32_TIM_OC_GetPolarity\n
N  *         CCER         CC3NP         MS32_TIM_OC_GetPolarity\n
N  *         CCER         CC4P          MS32_TIM_OC_GetPolarity
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH1N
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH2N
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH3N
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_TIM_OCPOLARITY_HIGH
N  *         @arg @ref MS32_TIM_OCPOLARITY_LOW
N  */
N__STATIC_INLINE uint32_t MS32_TIM_OC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_TIM_OC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  return (READ_BIT(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel])) >> SHIFT_TAB_CCxP[iChannel]);
X  return (((TIMx->CCER) & (((0x1UL << (1U)) << SHIFT_TAB_CCxP[iChannel]))) >> SHIFT_TAB_CCxP[iChannel]);
N}
N
N/**
N  * @brief  Set the IDLE state of an output channel
N  * @note This function is significant only for the timer instances
N  *       supporting the break feature. Macro IS_TIM_BREAK_INSTANCE(TIMx)
N  *       can be used to check whether or not a timer instance provides
N  *       a break input.
N  * @rmtoll CR2         OIS1          MS32_TIM_OC_SetIdleState\n
N  *         CR2         OIS1N         MS32_TIM_OC_SetIdleState\n
N  *         CR2         OIS2          MS32_TIM_OC_SetIdleState\n
N  *         CR2         OIS2N         MS32_TIM_OC_SetIdleState\n
N  *         CR2         OIS3          MS32_TIM_OC_SetIdleState\n
N  *         CR2         OIS3N         MS32_TIM_OC_SetIdleState\n
N  *         CR2         OIS4          MS32_TIM_OC_SetIdleState
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH1N
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH2N
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH3N
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @param  IdleState This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_OCIDLESTATE_LOW
N  *         @arg @ref MS32_TIM_OCIDLESTATE_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_OC_SetIdleState(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t IdleState) {
Xstatic __inline void MS32_TIM_OC_SetIdleState(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t IdleState) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),  IdleState << SHIFT_TAB_OISx[iChannel]);
X  (((TIMx->CR2)) = ((((((TIMx->CR2))) & (~(((0x1UL << (8U)) << SHIFT_TAB_OISx[iChannel])))) | (IdleState << SHIFT_TAB_OISx[iChannel]))));
N}
N
N/**
N  * @brief  Get the IDLE state of an output channel
N  * @rmtoll CR2         OIS1          MS32_TIM_OC_GetIdleState\n
N  *         CR2         OIS1N         MS32_TIM_OC_GetIdleState\n
N  *         CR2         OIS2          MS32_TIM_OC_GetIdleState\n
N  *         CR2         OIS2N         MS32_TIM_OC_GetIdleState\n
N  *         CR2         OIS3          MS32_TIM_OC_GetIdleState\n
N  *         CR2         OIS3N         MS32_TIM_OC_GetIdleState\n
N  *         CR2         OIS4          MS32_TIM_OC_GetIdleState
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH1N
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH2N
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH3N
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_TIM_OCIDLESTATE_LOW
N  *         @arg @ref MS32_TIM_OCIDLESTATE_HIGH
N  */
N__STATIC_INLINE uint32_t MS32_TIM_OC_GetIdleState(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_TIM_OC_GetIdleState(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  return (READ_BIT(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel])) >> SHIFT_TAB_OISx[iChannel]);
X  return (((TIMx->CR2) & (((0x1UL << (8U)) << SHIFT_TAB_OISx[iChannel]))) >> SHIFT_TAB_OISx[iChannel]);
N}
N
N/**
N  * @brief  Enable fast mode for the output channel.
N  * @note Acts only if the channel is configured in PWM1 or PWM2 mode.
N  * @rmtoll CCMR1        OC1FE          MS32_TIM_OC_EnableFast\n
N  *         CCMR1        OC2FE          MS32_TIM_OC_EnableFast\n
N  *         CCMR2        OC3FE          MS32_TIM_OC_EnableFast\n
N  *         CCMR2        OC4FE          MS32_TIM_OC_EnableFast
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_OC_EnableFast(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline void MS32_TIM_OC_EnableFast(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  SET_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
X  ((*pReg) |= (((0x1UL << (2U)) << SHIFT_TAB_OCxx[iChannel])));
N
N}
N
N/**
N  * @brief  Disable fast mode for the output channel.
N  * @rmtoll CCMR1        OC1FE          MS32_TIM_OC_DisableFast\n
N  *         CCMR1        OC2FE          MS32_TIM_OC_DisableFast\n
N  *         CCMR2        OC3FE          MS32_TIM_OC_DisableFast\n
N  *         CCMR2        OC4FE          MS32_TIM_OC_DisableFast
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline void MS32_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
X  ((*pReg) &= ~(((0x1UL << (2U)) << SHIFT_TAB_OCxx[iChannel])));
N
N}
N
N/**
N  * @brief  Indicates whether fast mode is enabled for the output channel.
N  * @rmtoll CCMR1        OC1FE          MS32_TIM_OC_IsEnabledFast\n
N  *         CCMR1        OC2FE          MS32_TIM_OC_IsEnabledFast\n
N  *         CCMR2        OC3FE          MS32_TIM_OC_IsEnabledFast\n
N  *         CCMR2        OC4FE          MS32_TIM_OC_IsEnabledFast\n
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register const __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register const volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
X  register uint32_t bitfield = (0x1UL << (2U)) << SHIFT_TAB_OCxx[iChannel];
N  return ((READ_BIT(*pReg, bitfield) == bitfield) ? 1UL : 0UL);
X  return ((((*pReg) & (bitfield)) == bitfield) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
N  * @rmtoll CCMR1        OC1PE          MS32_TIM_OC_EnablePreload\n
N  *         CCMR1        OC2PE          MS32_TIM_OC_EnablePreload\n
N  *         CCMR2        OC3PE          MS32_TIM_OC_EnablePreload\n
N  *         CCMR2        OC4PE          MS32_TIM_OC_EnablePreload
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline void MS32_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
X  ((*pReg) |= (((0x1UL << (3U)) << SHIFT_TAB_OCxx[iChannel])));
N}
N
N/**
N  * @brief  Disable compare register (TIMx_CCRx) preload for the output channel.
N  * @rmtoll CCMR1        OC1PE          MS32_TIM_OC_DisablePreload\n
N  *         CCMR1        OC2PE          MS32_TIM_OC_DisablePreload\n
N  *         CCMR2        OC3PE          MS32_TIM_OC_DisablePreload\n
N  *         CCMR2        OC4PE          MS32_TIM_OC_DisablePreload
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_OC_DisablePreload(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline void MS32_TIM_OC_DisablePreload(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  CLEAR_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
X  ((*pReg) &= ~(((0x1UL << (3U)) << SHIFT_TAB_OCxx[iChannel])));
N}
N
N/**
N  * @brief  Indicates whether compare register (TIMx_CCRx) preload is enabled for the output channel.
N  * @rmtoll CCMR1        OC1PE          MS32_TIM_OC_IsEnabledPreload\n
N  *         CCMR1        OC2PE          MS32_TIM_OC_IsEnabledPreload\n
N  *         CCMR2        OC3PE          MS32_TIM_OC_IsEnabledPreload\n
N  *         CCMR2        OC4PE          MS32_TIM_OC_IsEnabledPreload\n
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_OC_IsEnabledPreload(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_TIM_OC_IsEnabledPreload(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register const __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register const volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  register uint32_t bitfield = TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel];
X  register uint32_t bitfield = (0x1UL << (3U)) << SHIFT_TAB_OCxx[iChannel];
N  return ((READ_BIT(*pReg, bitfield) == bitfield) ? 1UL : 0UL);
X  return ((((*pReg) & (bitfield)) == bitfield) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable clearing the output channel on an external event.
N  * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
N  * @note Macro IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
N  *       or not a timer instance can clear the OCxREF signal on an external event.
N  * @rmtoll CCMR1        OC1CE          MS32_TIM_OC_EnableClear\n
N  *         CCMR1        OC2CE          MS32_TIM_OC_EnableClear\n
N  *         CCMR2        OC3CE          MS32_TIM_OC_EnableClear\n
N  *         CCMR2        OC4CE          MS32_TIM_OC_EnableClear
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_OC_EnableClear(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline void MS32_TIM_OC_EnableClear(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  SET_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
X  ((*pReg) |= (((0x1UL << (7U)) << SHIFT_TAB_OCxx[iChannel])));
N}
N
N/**
N  * @brief  Disable clearing the output channel on an external event.
N  * @note Macro IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
N  *       or not a timer instance can clear the OCxREF signal on an external event.
N  * @rmtoll CCMR1        OC1CE          MS32_TIM_OC_DisableClear\n
N  *         CCMR1        OC2CE          MS32_TIM_OC_DisableClear\n
N  *         CCMR2        OC3CE          MS32_TIM_OC_DisableClear\n
N  *         CCMR2        OC4CE          MS32_TIM_OC_DisableClear
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_OC_DisableClear(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline void MS32_TIM_OC_DisableClear(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  CLEAR_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
X  ((*pReg) &= ~(((0x1UL << (7U)) << SHIFT_TAB_OCxx[iChannel])));
N}
N
N/**
N  * @brief  Indicates clearing the output channel on an external event is enabled for the output channel.
N  * @note This function enables clearing the output channel on an external event.
N  * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
N  * @note Macro IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
N  *       or not a timer instance can clear the OCxREF signal on an external event.
N  * @rmtoll CCMR1        OC1CE          MS32_TIM_OC_IsEnabledClear\n
N  *         CCMR1        OC2CE          MS32_TIM_OC_IsEnabledClear\n
N  *         CCMR2        OC3CE          MS32_TIM_OC_IsEnabledClear\n
N  *         CCMR2        OC4CE          MS32_TIM_OC_IsEnabledClear\n
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_OC_IsEnabledClear(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_TIM_OC_IsEnabledClear(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register const __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register const volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  register uint32_t bitfield = TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel];
X  register uint32_t bitfield = (0x1UL << (7U)) << SHIFT_TAB_OCxx[iChannel];
N  return ((READ_BIT(*pReg, bitfield) == bitfield) ? 1UL : 0UL);
X  return ((((*pReg) & (bitfield)) == bitfield) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set the dead-time delay (delay inserted between the rising edge of the OCxREF signal and the rising edge of the Ocx and OCxN signals).
N  * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       dead-time insertion feature is supported by a timer instance.
N  * @note Helper macro @ref __MS32_TIM_CALC_DEADTIME can be used to calculate the DeadTime parameter
N  * @rmtoll BDTR         DTG           MS32_TIM_OC_SetDeadTime
N  * @param  TIMx Timer instance
N  * @param  DeadTime between Min_Data=0 and Max_Data=255
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_OC_SetDeadTime(TIM_TypeDef *TIMx, uint32_t DeadTime) {
Xstatic __inline void MS32_TIM_OC_SetDeadTime(TIM_TypeDef *TIMx, uint32_t DeadTime) {
N  MODIFY_REG(TIMx->BDTR, TIM_BDTR_DTG, DeadTime);
X  (((TIMx->BDTR)) = ((((((TIMx->BDTR))) & (~((0xFFUL << (0U))))) | (DeadTime))));
N}
N
N/**
N  * @brief  Set compare value for output channel 1 (TIMx_CCR1).
N  * @note In 32-bit timer implementations compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 1 is supported by a timer instance.
N  * @rmtoll CCR1         CCR1          MS32_TIM_OC_SetCompareCH1
N  * @param  TIMx Timer instance
N  * @param  CompareValue between Min_Data=0 and Max_Data=65535
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue) {
Xstatic __inline void MS32_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue) {
N  WRITE_REG(TIMx->CCR1, CompareValue);
X  ((TIMx->CCR1) = (CompareValue));
N}
N
N/**
N  * @brief  Set compare value for output channel 2 (TIMx_CCR2).
N  * @note In 32-bit timer implementations compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 2 is supported by a timer instance.
N  * @rmtoll CCR2         CCR2          MS32_TIM_OC_SetCompareCH2
N  * @param  TIMx Timer instance
N  * @param  CompareValue between Min_Data=0 and Max_Data=65535
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue) {
Xstatic __inline void MS32_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue) {
N  WRITE_REG(TIMx->CCR2, CompareValue);
X  ((TIMx->CCR2) = (CompareValue));
N}
N
N/**
N  * @brief  Set compare value for output channel 3 (TIMx_CCR3).
N  * @note In 32-bit timer implementations compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel is supported by a timer instance.
N  * @rmtoll CCR3         CCR3          MS32_TIM_OC_SetCompareCH3
N  * @param  TIMx Timer instance
N  * @param  CompareValue between Min_Data=0 and Max_Data=65535
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue) {
Xstatic __inline void MS32_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue) {
N  WRITE_REG(TIMx->CCR3, CompareValue);
X  ((TIMx->CCR3) = (CompareValue));
N}
N
N/**
N  * @brief  Set compare value for output channel 4 (TIMx_CCR4).
N  * @note In 32-bit timer implementations compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 4 is supported by a timer instance.
N  * @rmtoll CCR4         CCR4          MS32_TIM_OC_SetCompareCH4
N  * @param  TIMx Timer instance
N  * @param  CompareValue between Min_Data=0 and Max_Data=65535
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue) {
Xstatic __inline void MS32_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue) {
N  WRITE_REG(TIMx->CCR4, CompareValue);
X  ((TIMx->CCR4) = (CompareValue));
N}
N
N/**
N  * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
N  * @note In 32-bit timer implementations returned compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 1 is supported by a timer instance.
N  * @rmtoll CCR1         CCR1          MS32_TIM_OC_GetCompareCH1
N  * @param  TIMx Timer instance
N  * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t MS32_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_REG(TIMx->CCR1));
X  return (uint32_t)(((TIMx->CCR1)));
N}
N
N/**
N  * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
N  * @note In 32-bit timer implementations returned compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 2 is supported by a timer instance.
N  * @rmtoll CCR2         CCR2          MS32_TIM_OC_GetCompareCH2
N  * @param  TIMx Timer instance
N  * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t MS32_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_REG(TIMx->CCR2));
X  return (uint32_t)(((TIMx->CCR2)));
N}
N
N/**
N  * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
N  * @note In 32-bit timer implementations returned compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 3 is supported by a timer instance.
N  * @rmtoll CCR3         CCR3          MS32_TIM_OC_GetCompareCH3
N  * @param  TIMx Timer instance
N  * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t MS32_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_REG(TIMx->CCR3));
X  return (uint32_t)(((TIMx->CCR3)));
N}
N
N/**
N  * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
N  * @note In 32-bit timer implementations returned compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 4 is supported by a timer instance.
N  * @rmtoll CCR4         CCR4          MS32_TIM_OC_GetCompareCH4
N  * @param  TIMx Timer instance
N  * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t MS32_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_REG(TIMx->CCR4));
X  return (uint32_t)(((TIMx->CCR4)));
N}
N
N
N
N/** @defgroup TIM_EF_Input_Channel Input channel configuration
N  * @{
N  */
N
N/**
N  * @brief  Configure input channel.
N  * @rmtoll CCMR1        CC1S          MS32_TIM_IC_Config\n
N  *         CCMR1        IC1PSC        MS32_TIM_IC_Config\n
N  *         CCMR1        IC1F          MS32_TIM_IC_Config\n
N  *         CCMR1        CC2S          MS32_TIM_IC_Config\n
N  *         CCMR1        IC2PSC        MS32_TIM_IC_Config\n
N  *         CCMR1        IC2F          MS32_TIM_IC_Config\n
N  *         CCMR2        CC3S          MS32_TIM_IC_Config\n
N  *         CCMR2        IC3PSC        MS32_TIM_IC_Config\n
N  *         CCMR2        IC3F          MS32_TIM_IC_Config\n
N  *         CCMR2        CC4S          MS32_TIM_IC_Config\n
N  *         CCMR2        IC4PSC        MS32_TIM_IC_Config\n
N  *         CCMR2        IC4F          MS32_TIM_IC_Config\n
N  *         CCER         CC1P          MS32_TIM_IC_Config\n
N  *         CCER         CC1NP         MS32_TIM_IC_Config\n
N  *         CCER         CC2P          MS32_TIM_IC_Config\n
N  *         CCER         CC2NP         MS32_TIM_IC_Config\n
N  *         CCER         CC3P          MS32_TIM_IC_Config\n
N  *         CCER         CC3NP         MS32_TIM_IC_Config\n
N  *         CCER         CC4P          MS32_TIM_IC_Config\n
N  *         CCER         CC4NP         MS32_TIM_IC_Config
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @param  Configuration This parameter must be a combination of all the following values:
N  *         @arg @ref MS32_TIM_ACTIVEINPUT_DIRECTTI or @ref MS32_TIM_ACTIVEINPUT_INDIRECTTI or @ref MS32_TIM_ACTIVEINPUT_TRC
N  *         @arg @ref MS32_TIM_ICPSC_DIV1 or ... or @ref MS32_TIM_ICPSC_DIV8
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV1 or ... or @ref MS32_TIM_IC_FILTER_FDIV32_N8
N  *         @arg @ref MS32_TIM_IC_POLARITY_RISING or @ref MS32_TIM_IC_POLARITY_FALLING or @ref MS32_TIM_IC_POLARITY_BOTHEDGE
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration) {
Xstatic __inline void MS32_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
N             ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
X  (((*pReg)) = ((((((*pReg))) & (~((((0xFUL << (4U)) | (0x3UL << (2U)) | (0x3UL << (0U))) << SHIFT_TAB_ICxx[iChannel])))) | (((Configuration >> 16U) & ((0xFUL << (4U)) | (0x3UL << (2U)) | (0x3UL << (0U)))) << SHIFT_TAB_ICxx[iChannel]))));
N  MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
N             (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
X  (((TIMx->CCER)) = ((((((TIMx->CCER))) & (~((((0x1UL << (3U)) | (0x1UL << (1U))) << SHIFT_TAB_CCxP[iChannel])))) | ((Configuration & ((0x1UL << (3U)) | (0x1UL << (1U)))) << SHIFT_TAB_CCxP[iChannel]))));
N}
N
N/**
N  * @brief  Set the active input.
N  * @rmtoll CCMR1        CC1S          MS32_TIM_IC_SetActiveInput\n
N  *         CCMR1        CC2S          MS32_TIM_IC_SetActiveInput\n
N  *         CCMR2        CC3S          MS32_TIM_IC_SetActiveInput\n
N  *         CCMR2        CC4S          MS32_TIM_IC_SetActiveInput
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @param  ICActiveInput This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_ACTIVEINPUT_DIRECTTI
N  *         @arg @ref MS32_TIM_ACTIVEINPUT_INDIRECTTI
N  *         @arg @ref MS32_TIM_ACTIVEINPUT_TRC
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput) {
Xstatic __inline void MS32_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
X  (((*pReg)) = ((((((*pReg))) & (~((((0x3UL << (0U))) << SHIFT_TAB_ICxx[iChannel])))) | ((ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]))));
N}
N
N/**
N  * @brief  Get the current active input.
N  * @rmtoll CCMR1        CC1S          MS32_TIM_IC_GetActiveInput\n
N  *         CCMR1        CC2S          MS32_TIM_IC_GetActiveInput\n
N  *         CCMR2        CC3S          MS32_TIM_IC_GetActiveInput\n
N  *         CCMR2        CC4S          MS32_TIM_IC_GetActiveInput
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_TIM_ACTIVEINPUT_DIRECTTI
N  *         @arg @ref MS32_TIM_ACTIVEINPUT_INDIRECTTI
N  *         @arg @ref MS32_TIM_ACTIVEINPUT_TRC
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register const __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register const volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
X  return ((((*pReg) & ((((0x3UL << (0U))) << SHIFT_TAB_ICxx[iChannel]))) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
N}
N
N/**
N  * @brief  Set the prescaler of input channel.
N  * @rmtoll CCMR1        IC1PSC        MS32_TIM_IC_SetPrescaler\n
N  *         CCMR1        IC2PSC        MS32_TIM_IC_SetPrescaler\n
N  *         CCMR2        IC3PSC        MS32_TIM_IC_SetPrescaler\n
N  *         CCMR2        IC4PSC        MS32_TIM_IC_SetPrescaler
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @param  ICPrescaler This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_ICPSC_DIV1
N  *         @arg @ref MS32_TIM_ICPSC_DIV2
N  *         @arg @ref MS32_TIM_ICPSC_DIV4
N  *         @arg @ref MS32_TIM_ICPSC_DIV8
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler) {
Xstatic __inline void MS32_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
X  (((*pReg)) = ((((((*pReg))) & (~((((0x3UL << (2U))) << SHIFT_TAB_ICxx[iChannel])))) | ((ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]))));
N}
N
N/**
N  * @brief  Get the current prescaler value acting on an  input channel.
N  * @rmtoll CCMR1        IC1PSC        MS32_TIM_IC_GetPrescaler\n
N  *         CCMR1        IC2PSC        MS32_TIM_IC_GetPrescaler\n
N  *         CCMR2        IC3PSC        MS32_TIM_IC_GetPrescaler\n
N  *         CCMR2        IC4PSC        MS32_TIM_IC_GetPrescaler
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_TIM_ICPSC_DIV1
N  *         @arg @ref MS32_TIM_ICPSC_DIV2
N  *         @arg @ref MS32_TIM_ICPSC_DIV4
N  *         @arg @ref MS32_TIM_ICPSC_DIV8
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register const __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register const volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
X  return ((((*pReg) & ((((0x3UL << (2U))) << SHIFT_TAB_ICxx[iChannel]))) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
N}
N
N/**
N  * @brief  Set the input filter duration.
N  * @rmtoll CCMR1        IC1F          MS32_TIM_IC_SetFilter\n
N  *         CCMR1        IC2F          MS32_TIM_IC_SetFilter\n
N  *         CCMR2        IC3F          MS32_TIM_IC_SetFilter\n
N  *         CCMR2        IC4F          MS32_TIM_IC_SetFilter
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @param  ICFilter This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV1
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV1_N2
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV1_N4
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV1_N8
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV2_N6
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV2_N8
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV4_N6
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV4_N8
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV8_N6
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV8_N8
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV16_N5
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV16_N6
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV16_N8
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV32_N5
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV32_N6
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV32_N8
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter) {
Xstatic __inline void MS32_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
X  (((*pReg)) = ((((((*pReg))) & (~((((0xFUL << (4U))) << SHIFT_TAB_ICxx[iChannel])))) | ((ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]))));
N}
N
N/**
N  * @brief  Get the input filter duration.
N  * @rmtoll CCMR1        IC1F          MS32_TIM_IC_GetFilter\n
N  *         CCMR1        IC2F          MS32_TIM_IC_GetFilter\n
N  *         CCMR2        IC3F          MS32_TIM_IC_GetFilter\n
N  *         CCMR2        IC4F          MS32_TIM_IC_GetFilter
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV1
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV1_N2
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV1_N4
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV1_N8
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV2_N6
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV2_N8
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV4_N6
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV4_N8
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV8_N6
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV8_N8
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV16_N5
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV16_N6
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV16_N8
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV32_N5
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV32_N6
N  *         @arg @ref MS32_TIM_IC_FILTER_FDIV32_N8
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  register const __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
X  register const volatile uint32_t *pReg = (volatile uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
X  return ((((*pReg) & ((((0xFUL << (4U))) << SHIFT_TAB_ICxx[iChannel]))) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
N}
N
N/**
N  * @brief  Set the input channel polarity.
N  * @rmtoll CCER         CC1P          MS32_TIM_IC_SetPolarity\n
N  *         CCER         CC1NP         MS32_TIM_IC_SetPolarity\n
N  *         CCER         CC2P          MS32_TIM_IC_SetPolarity\n
N  *         CCER         CC2NP         MS32_TIM_IC_SetPolarity\n
N  *         CCER         CC3P          MS32_TIM_IC_SetPolarity\n
N  *         CCER         CC3NP         MS32_TIM_IC_SetPolarity\n
N  *         CCER         CC4P          MS32_TIM_IC_SetPolarity\n
N  *         CCER         CC4NP         MS32_TIM_IC_SetPolarity
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @param  ICPolarity This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_IC_POLARITY_RISING
N  *         @arg @ref MS32_TIM_IC_POLARITY_FALLING
N  *         @arg @ref MS32_TIM_IC_POLARITY_BOTHEDGE
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity) {
Xstatic __inline void MS32_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
N             ICPolarity << SHIFT_TAB_CCxP[iChannel]);
X  (((TIMx->CCER)) = ((((((TIMx->CCER))) & (~((((0x1UL << (3U)) | (0x1UL << (1U))) << SHIFT_TAB_CCxP[iChannel])))) | (ICPolarity << SHIFT_TAB_CCxP[iChannel]))));
N}
N
N/**
N  * @brief  Get the current input channel polarity.
N  * @rmtoll CCER         CC1P          MS32_TIM_IC_GetPolarity\n
N  *         CCER         CC1NP         MS32_TIM_IC_GetPolarity\n
N  *         CCER         CC2P          MS32_TIM_IC_GetPolarity\n
N  *         CCER         CC2NP         MS32_TIM_IC_GetPolarity\n
N  *         CCER         CC3P          MS32_TIM_IC_GetPolarity\n
N  *         CCER         CC3NP         MS32_TIM_IC_GetPolarity\n
N  *         CCER         CC4P          MS32_TIM_IC_GetPolarity\n
N  *         CCER         CC4NP         MS32_TIM_IC_GetPolarity
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CHANNEL_CH1
N  *         @arg @ref MS32_TIM_CHANNEL_CH2
N  *         @arg @ref MS32_TIM_CHANNEL_CH3
N  *         @arg @ref MS32_TIM_CHANNEL_CH4
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_TIM_IC_POLARITY_RISING
N  *         @arg @ref MS32_TIM_IC_POLARITY_FALLING
N  *         @arg @ref MS32_TIM_IC_POLARITY_BOTHEDGE
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel) {
Xstatic __inline uint32_t MS32_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel) {
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U : ((Channel) == (0x1UL << (2U))) ? 1U : ((Channel) == (0x1UL << (4U))) ? 2U : ((Channel) == (0x1UL << (6U))) ? 3U : ((Channel) == (0x1UL << (8U))) ? 4U : ((Channel) == (0x1UL << (10U))) ? 5U : 6U);
N  return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
X  return (((TIMx->CCER) & ((((0x1UL << (3U)) | (0x1UL << (1U))) << SHIFT_TAB_CCxP[iChannel]))) >>
N          SHIFT_TAB_CCxP[iChannel]);
N}
N
N/**
N  * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
N  * @note Macro IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides an XOR input.
N  * @rmtoll CR2          TI1S          MS32_TIM_IC_EnableXORCombination
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
X  ((TIMx->CR2) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
N  * @note Macro IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides an XOR input.
N  * @rmtoll CR2          TI1S          MS32_TIM_IC_DisableXORCombination
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
X  ((TIMx->CR2) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
N  * @note Macro IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
N  * a timer instance provides an XOR input.
N  * @rmtoll CR2          TI1S          MS32_TIM_IC_IsEnabledXORCombination
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S)) ? 1UL : 0UL);
X  return ((((TIMx->CR2) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get captured value for input channel 1.
N  * @note In 32-bit timer implementations returned captured value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
N  *       input channel 1 is supported by a timer instance.
N  * @rmtoll CCR1         CCR1          MS32_TIM_IC_GetCaptureCH1
N  * @param  TIMx Timer instance
N  * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_REG(TIMx->CCR1));
X  return (uint32_t)(((TIMx->CCR1)));
N}
N
N/**
N  * @brief  Get captured value for input channel 2.
N  * @note In 32-bit timer implementations returned captured value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
N  *       input channel 2 is supported by a timer instance.
N  * @rmtoll CCR2         CCR2          MS32_TIM_IC_GetCaptureCH2
N  * @param  TIMx Timer instance
N  * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_REG(TIMx->CCR2));
X  return (uint32_t)(((TIMx->CCR2)));
N}
N
N/**
N  * @brief  Get captured value for input channel 3.
N  * @note In 32-bit timer implementations returned captured value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
N  *       input channel 3 is supported by a timer instance.
N  * @rmtoll CCR3         CCR3          MS32_TIM_IC_GetCaptureCH3
N  * @param  TIMx Timer instance
N  * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_REG(TIMx->CCR3));
X  return (uint32_t)(((TIMx->CCR3)));
N}
N
N/**
N  * @brief  Get captured value for input channel 4.
N  * @note In 32-bit timer implementations returned captured value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
N  *       input channel 4 is supported by a timer instance.
N  * @rmtoll CCR4         CCR4          MS32_TIM_IC_GetCaptureCH4
N  * @param  TIMx Timer instance
N  * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx) {
N  return (uint32_t)(READ_REG(TIMx->CCR4));
X  return (uint32_t)(((TIMx->CCR4)));
N}
N
N
N/** @defgroup TIM_EF_Clock_Selection Counter clock selection
N  * @{
N  */
N
N/**
N  * @brief  Enable external clock mode 2.
N  * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
N  * @note Macro IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports external clock mode2.
N  * @rmtoll SMCR         ECE           MS32_TIM_EnableExternalClock
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableExternalClock(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableExternalClock(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
X  ((TIMx->SMCR) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Disable external clock mode 2.
N  * @note Macro IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports external clock mode2.
N  * @rmtoll SMCR         ECE           MS32_TIM_DisableExternalClock
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableExternalClock(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableExternalClock(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
X  ((TIMx->SMCR) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Indicate whether external clock mode 2 is enabled.
N  * @note Macro IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports external clock mode2.
N  * @rmtoll SMCR         ECE           MS32_TIM_IsEnabledExternalClock
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE)) ? 1UL : 0UL);
X  return ((((TIMx->SMCR) & ((0x1UL << (14U)))) == ((0x1UL << (14U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set the clock source of the counter clock.
N  * @note when selected clock source is external clock mode 1, the timer input
N  *       the external clock is applied is selected by calling the @ref MS32_TIM_SetTriggerInput()
N  *       function. This timer input must be configured by calling
N  *       the @ref MS32_TIM_IC_Config() function.
N  * @note Macro IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports external clock mode1.
N  * @note Macro IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports external clock mode2.
N  * @rmtoll SMCR         SMS           MS32_TIM_SetClockSource\n
N  *         SMCR         ECE           MS32_TIM_SetClockSource
N  * @param  TIMx Timer instance
N  * @param  ClockSource This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_CLOCKSOURCE_INTERNAL
N  *         @arg @ref MS32_TIM_CLOCKSOURCE_EXT_MODE1
N  *         @arg @ref MS32_TIM_CLOCKSOURCE_EXT_MODE2
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource) {
Xstatic __inline void MS32_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource) {
N  MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
X  (((TIMx->SMCR)) = ((((((TIMx->SMCR))) & (~((0x7UL << (0U)) | (0x1UL << (14U))))) | (ClockSource))));
N}
N
N/**
N  * @brief  Set the encoder interface mode.
N  * @note Macro IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports the encoder mode.
N  * @rmtoll SMCR         SMS           MS32_TIM_SetEncoderMode
N  * @param  TIMx Timer instance
N  * @param  EncoderMode This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_ENCODERMODE_X2_TI1
N  *         @arg @ref MS32_TIM_ENCODERMODE_X2_TI2
N  *         @arg @ref MS32_TIM_ENCODERMODE_X4_TI12
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetEncoderMode(TIM_TypeDef *TIMx, uint32_t EncoderMode) {
Xstatic __inline void MS32_TIM_SetEncoderMode(TIM_TypeDef *TIMx, uint32_t EncoderMode) {
N  MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
X  (((TIMx->SMCR)) = ((((((TIMx->SMCR))) & (~((0x7UL << (0U))))) | (EncoderMode))));
N}
N
N
N/** @defgroup TIM_EF_Timer_Synchronization Timer synchronisation configuration
N  * @{
N  */
N
N/**
N  * @brief  Set the trigger output (TRGO) used for timer synchronization .
N  * @note Macro IS_TIM_MASTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance can operate as a master timer.
N  * @rmtoll CR2          MMS           MS32_TIM_SetTriggerOutput
N  * @param  TIMx Timer instance
N  * @param  TimerSynchronization This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_TRGO_RESET
N  *         @arg @ref MS32_TIM_TRGO_ENABLE
N  *         @arg @ref MS32_TIM_TRGO_UPDATE
N  *         @arg @ref MS32_TIM_TRGO_CC1IF
N  *         @arg @ref MS32_TIM_TRGO_OC1REF
N  *         @arg @ref MS32_TIM_TRGO_OC2REF
N  *         @arg @ref MS32_TIM_TRGO_OC3REF
N  *         @arg @ref MS32_TIM_TRGO_OC4REF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization) {
Xstatic __inline void MS32_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization) {
N  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
X  (((TIMx->CR2)) = ((((((TIMx->CR2))) & (~((0x7UL << (4U))))) | (TimerSynchronization))));
N}
N
N/**
N  * @brief  Set the synchronization mode of a slave timer.
N  * @note Macro IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance can operate as a slave timer.
N  * @rmtoll SMCR         SMS           MS32_TIM_SetSlaveMode
N  * @param  TIMx Timer instance
N  * @param  SlaveMode This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_SLAVEMODE_DISABLED
N  *         @arg @ref MS32_TIM_SLAVEMODE_RESET
N  *         @arg @ref MS32_TIM_SLAVEMODE_GATED
N  *         @arg @ref MS32_TIM_SLAVEMODE_TRIGGER
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode) {
Xstatic __inline void MS32_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode) {
N  MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
X  (((TIMx->SMCR)) = ((((((TIMx->SMCR))) & (~((0x7UL << (0U))))) | (SlaveMode))));
N}
N
N/**
N  * @brief  Set the selects the trigger input to be used to synchronize the counter.
N  * @note Macro IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance can operate as a slave timer.
N  * @rmtoll SMCR         TS            MS32_TIM_SetTriggerInput
N  * @param  TIMx Timer instance
N  * @param  TriggerInput This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_TS_ITR0
N  *         @arg @ref MS32_TIM_TS_ITR1
N  *         @arg @ref MS32_TIM_TS_ITR2
N  *         @arg @ref MS32_TIM_TS_ITR3
N  *         @arg @ref MS32_TIM_TS_TI1F_ED
N  *         @arg @ref MS32_TIM_TS_TI1FP1
N  *         @arg @ref MS32_TIM_TS_TI2FP2
N  *         @arg @ref MS32_TIM_TS_ETRF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput) {
Xstatic __inline void MS32_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput) {
N  MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
X  (((TIMx->SMCR)) = ((((((TIMx->SMCR))) & (~((0x7UL << (4U))))) | (TriggerInput))));
N}
N
N/**
N  * @brief  Enable the Master/Slave mode.
N  * @note Macro IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance can operate as a slave timer.
N  * @rmtoll SMCR         MSM           MS32_TIM_EnableMasterSlaveMode
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableMasterSlaveMode(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableMasterSlaveMode(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->SMCR, TIM_SMCR_MSM);
X  ((TIMx->SMCR) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable the Master/Slave mode.
N  * @note Macro IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance can operate as a slave timer.
N  * @rmtoll SMCR         MSM           MS32_TIM_DisableMasterSlaveMode
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
X  ((TIMx->SMCR) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief Indicates whether the Master/Slave mode is enabled.
N  * @note Macro IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
N  * a timer instance can operate as a slave timer.
N  * @rmtoll SMCR         MSM           MS32_TIM_IsEnabledMasterSlaveMode
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledMasterSlaveMode(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledMasterSlaveMode(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->SMCR, TIM_SMCR_MSM) == (TIM_SMCR_MSM)) ? 1UL : 0UL);
X  return ((((TIMx->SMCR) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Configure the external trigger (ETR) input.
N  * @note Macro IS_TIM_ETR_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides an external trigger input.
N  * @rmtoll SMCR         ETP           MS32_TIM_ConfigETR\n
N  *         SMCR         ETPS          MS32_TIM_ConfigETR\n
N  *         SMCR         ETF           MS32_TIM_ConfigETR
N  * @param  TIMx Timer instance
N  * @param  ETRPolarity This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_ETR_POLARITY_NONINVERTED
N  *         @arg @ref MS32_TIM_ETR_POLARITY_INVERTED
N  * @param  ETRPrescaler This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_ETR_PRESCALER_DIV1
N  *         @arg @ref MS32_TIM_ETR_PRESCALER_DIV2
N  *         @arg @ref MS32_TIM_ETR_PRESCALER_DIV4
N  *         @arg @ref MS32_TIM_ETR_PRESCALER_DIV8
N  * @param  ETRFilter This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV1
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV1_N2
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV1_N4
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV1_N8
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV2_N6
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV2_N8
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV4_N6
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV4_N8
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV8_N6
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV8_N8
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV16_N5
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV16_N6
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV16_N8
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV32_N5
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV32_N6
N  *         @arg @ref MS32_TIM_ETR_FILTER_FDIV32_N8
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_ConfigETR(TIM_TypeDef *TIMx, uint32_t ETRPolarity, uint32_t ETRPrescaler,
Xstatic __inline void MS32_TIM_ConfigETR(TIM_TypeDef *TIMx, uint32_t ETRPolarity, uint32_t ETRPrescaler,
N                                      uint32_t ETRFilter) {
N  MODIFY_REG(TIMx->SMCR, TIM_SMCR_ETP | TIM_SMCR_ETPS | TIM_SMCR_ETF, ETRPolarity | ETRPrescaler | ETRFilter);
X  (((TIMx->SMCR)) = ((((((TIMx->SMCR))) & (~((0x1UL << (15U)) | (0x3UL << (12U)) | (0xFUL << (8U))))) | (ETRPolarity | ETRPrescaler | ETRFilter))));
N}
N
N
N/** @defgroup TIM_EF_Break_Function Break function configuration
N  * @{
N  */
N
N/**
N  * @brief  Enable the break function.
N  * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         BKE           MS32_TIM_EnableBRK
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableBRK(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableBRK(TIM_TypeDef *TIMx) {
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(TIMx->BDTR, TIM_BDTR_BKE);
X  ((TIMx->BDTR) |= ((0x1UL << (12U))));
N  /* Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective. */
N  tmpreg = READ_REG(TIMx->BDTR);
X  tmpreg = ((TIMx->BDTR));
N  (void)(tmpreg);
N}
N
N/**
N  * @brief  Disable the break function.
N  * @rmtoll BDTR         BKE           MS32_TIM_DisableBRK
N  * @param  TIMx Timer instance
N  * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableBRK(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableBRK(TIM_TypeDef *TIMx) {
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  CLEAR_BIT(TIMx->BDTR, TIM_BDTR_BKE);
X  ((TIMx->BDTR) &= ~((0x1UL << (12U))));
N  /* Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective. */
N  tmpreg = READ_REG(TIMx->BDTR);
X  tmpreg = ((TIMx->BDTR));
N  (void)(tmpreg);
N}
N
N/**
N  * @brief  Configure the break input.
N  * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         BKP           MS32_TIM_ConfigBRK
N  * @param  TIMx Timer instance
N  * @param  BreakPolarity This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_BREAK_POLARITY_LOW
N  *         @arg @ref MS32_TIM_BREAK_POLARITY_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_ConfigBRK(TIM_TypeDef *TIMx, uint32_t BreakPolarity) {
Xstatic __inline void MS32_TIM_ConfigBRK(TIM_TypeDef *TIMx, uint32_t BreakPolarity) {
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  MODIFY_REG(TIMx->BDTR, TIM_BDTR_BKP, BreakPolarity);
X  (((TIMx->BDTR)) = ((((((TIMx->BDTR))) & (~((0x1UL << (13U))))) | (BreakPolarity))));
N  /* Note: Any write operation to BKP bit takes a delay of 1 APB clock cycle to become effective. */
N  tmpreg = READ_REG(TIMx->BDTR);
X  tmpreg = ((TIMx->BDTR));
N  (void)(tmpreg);
N}
N
N/**
N  * @brief  Select the outputs off state (enabled v.s. disabled) in Idle and Run modes.
N  * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         OSSI          MS32_TIM_SetOffStates\n
N  *         BDTR         OSSR          MS32_TIM_SetOffStates
N  * @param  TIMx Timer instance
N  * @param  OffStateIdle This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_OSSI_DISABLE
N  *         @arg @ref MS32_TIM_OSSI_ENABLE
N  * @param  OffStateRun This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_OSSR_DISABLE
N  *         @arg @ref MS32_TIM_OSSR_ENABLE
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetOffStates(TIM_TypeDef *TIMx, uint32_t OffStateIdle, uint32_t OffStateRun) {
Xstatic __inline void MS32_TIM_SetOffStates(TIM_TypeDef *TIMx, uint32_t OffStateIdle, uint32_t OffStateRun) {
N  MODIFY_REG(TIMx->BDTR, TIM_BDTR_OSSI | TIM_BDTR_OSSR, OffStateIdle | OffStateRun);
X  (((TIMx->BDTR)) = ((((((TIMx->BDTR))) & (~((0x1UL << (10U)) | (0x1UL << (11U))))) | (OffStateIdle | OffStateRun))));
N}
N
N/**
N  * @brief  Enable automatic output (MOE can be set by software or automatically when a break input is active).
N  * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         AOE           MS32_TIM_EnableAutomaticOutput
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableAutomaticOutput(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableAutomaticOutput(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->BDTR, TIM_BDTR_AOE);
X  ((TIMx->BDTR) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Disable automatic output (MOE can be set only by software).
N  * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         AOE           MS32_TIM_DisableAutomaticOutput
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableAutomaticOutput(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableAutomaticOutput(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->BDTR, TIM_BDTR_AOE);
X  ((TIMx->BDTR) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Indicate whether automatic output is enabled.
N  * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         AOE           MS32_TIM_IsEnabledAutomaticOutput
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledAutomaticOutput(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledAutomaticOutput(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->BDTR, TIM_BDTR_AOE) == (TIM_BDTR_AOE)) ? 1UL : 0UL);
X  return ((((TIMx->BDTR) & ((0x1UL << (14U)))) == ((0x1UL << (14U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable the outputs (set the MOE bit in TIMx_BDTR register).
N  * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
N  *       software and is reset in case of break or break2 event
N  * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         MOE           MS32_TIM_EnableAllOutputs
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableAllOutputs(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableAllOutputs(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
X  ((TIMx->BDTR) |= ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Disable the outputs (reset the MOE bit in TIMx_BDTR register).
N  * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
N  *       software and is reset in case of break or break2 event.
N  * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         MOE           MS32_TIM_DisableAllOutputs
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableAllOutputs(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableAllOutputs(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->BDTR, TIM_BDTR_MOE);
X  ((TIMx->BDTR) &= ~((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Indicates whether outputs are enabled.
N  * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         MOE           MS32_TIM_IsEnabledAllOutputs
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledAllOutputs(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledAllOutputs(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->BDTR, TIM_BDTR_MOE) == (TIM_BDTR_MOE)) ? 1UL : 0UL);
X  return ((((TIMx->BDTR) & ((0x1UL << (15U)))) == ((0x1UL << (15U)))) ? 1UL : 0UL);
N}
N
N
N/** @defgroup TIM_EF_DMA_Burst_Mode DMA burst mode configuration
N  * @{
N  */
N
N/**
N  * @brief  Configures the timer DMA burst feature.
N  * @note Macro IS_TIM_DMABURST_INSTANCE(TIMx) can be used to check whether or
N  *       not a timer instance supports the DMA burst mode.
N  * @rmtoll DCR          DBL           MS32_TIM_ConfigDMABurst\n
N  *         DCR          DBA           MS32_TIM_ConfigDMABurst
N  * @param  TIMx Timer instance
N  * @param  DMABurstBaseAddress This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_CR1
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_CR2
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_SMCR
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_DIER
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_SR
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_EGR
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_CCMR1
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_CCMR2
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_CCER
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_CNT
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_PSC
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_ARR
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_RCR
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_CCR1
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_CCR2
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_CCR3
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_CCR4
N  *         @arg @ref MS32_TIM_DMABURST_BASEADDR_BDTR
N  * @param  DMABurstLength This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_1TRANSFER
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_2TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_3TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_4TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_5TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_6TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_7TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_8TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_9TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_10TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_11TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_12TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_13TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_14TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_15TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_16TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_17TRANSFERS
N  *         @arg @ref MS32_TIM_DMABURST_LENGTH_18TRANSFERS
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_ConfigDMABurst(TIM_TypeDef *TIMx, uint32_t DMABurstBaseAddress, uint32_t DMABurstLength) {
Xstatic __inline void MS32_TIM_ConfigDMABurst(TIM_TypeDef *TIMx, uint32_t DMABurstBaseAddress, uint32_t DMABurstLength) {
N  MODIFY_REG(TIMx->DCR, (TIM_DCR_DBL | TIM_DCR_DBA), (DMABurstBaseAddress | DMABurstLength));
X  (((TIMx->DCR)) = ((((((TIMx->DCR))) & (~(((0x1FUL << (8U)) | (0x1FUL << (0U)))))) | ((DMABurstBaseAddress | DMABurstLength)))));
N}
N
N
N/** @defgroup TIM_EF_Timer_Inputs_Remapping Timer input remapping
N  * @{
N  */
N
N/**
N  * @brief  Remap TIM inputs (input channel, internal/external triggers).
N  * @note Macro IS_TIM_REMAP_INSTANCE(TIMx) can be used to check whether or not
N  *       a some timer inputs can be remapped.
N  * @rmtoll TIM14_OR    TI1_RMP           MS32_TIM_SetRemap
N  * @param  TIMx Timer instance
N  * @param  Remap This parameter can be one of the following values:
N  *            @arg @ref MS32_TIM_TIM14_TI1_RMP_GPIO
N  *            @arg @ref MS32_TIM_TIM14_TI1_RMP_RTC_CLK
N  *            @arg @ref MS32_TIM_TIM14_TI1_RMP_HSE
N  *            @arg @ref MS32_TIM_TIM14_TI1_RMP_MCO
N  *
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetRemap(TIM_TypeDef *TIMx, uint32_t Remap) {
Xstatic __inline void MS32_TIM_SetRemap(TIM_TypeDef *TIMx, uint32_t Remap) {
N  MODIFY_REG(TIMx->OR, (Remap >> TIMx_OR_RMP_SHIFT), (Remap & TIMx_OR_RMP_MASK));
X  (((TIMx->OR)) = ((((((TIMx->OR))) & (~((Remap >> 16U)))) | ((Remap & 0x0000FFFFU)))));
N}
N
N
N/** @defgroup TIM_EF_OCREF_Clear OCREF_Clear_Management
N  * @{
N  */
N
N/**
N  * @brief  Set the OCREF clear input source
N  * @note The OCxREF signal of a given channel can be cleared when a high level is applied on the OCREF_CLR_INPUT
N  * @note This function can only be used in Output compare and PWM modes.
N  * @rmtoll SMCR          OCCS                MS32_TIM_SetOCRefClearInputSource
N  * @param  TIMx Timer instance
N  * @param  OCRefClearInputSource This parameter can be one of the following values:
N  *         @arg @ref MS32_TIM_OCREF_CLR_INT_OCREF_CLR
N  *         @arg @ref MS32_TIM_OCREF_CLR_INT_ETR
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_SetOCRefClearInputSource(TIM_TypeDef *TIMx, uint32_t OCRefClearInputSource) {
Xstatic __inline void MS32_TIM_SetOCRefClearInputSource(TIM_TypeDef *TIMx, uint32_t OCRefClearInputSource) {
N  MODIFY_REG(TIMx->SMCR, TIM_SMCR_OCCS, OCRefClearInputSource);
X  (((TIMx->SMCR)) = ((((((TIMx->SMCR))) & (~((0x1UL << (3U))))) | (OCRefClearInputSource))));
N}
N
N
N/** @defgroup TIM_EF_FLAG_Management FLAG-Management
N  * @{
N  */
N
N/**
N  * @brief  Clear the update interrupt flag (UIF).
N  * @rmtoll SR           UIF           MS32_TIM_ClearFlag_UPDATE
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx) {
N  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
X  ((TIMx->SR) = (~((0x1UL << (0U)))));
N}
N
N/**
N  * @brief  Indicate whether update interrupt flag (UIF) is set (update interrupt is pending).
N  * @rmtoll SR           UIF           MS32_TIM_IsActiveFlag_UPDATE
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsActiveFlag_UPDATE(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsActiveFlag_UPDATE(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 1 interrupt flag (CC1F).
N  * @rmtoll SR           CC1IF         MS32_TIM_ClearFlag_CC1
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx) {
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
X  ((TIMx->SR) = (~((0x1UL << (1U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 1 interrupt flag (CC1F) is set (Capture/Compare 1 interrupt is pending).
N  * @rmtoll SR           CC1IF         MS32_TIM_IsActiveFlag_CC1
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsActiveFlag_CC1(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsActiveFlag_CC1(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (1U)))) == ((0x1UL << (1U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 2 interrupt flag (CC2F).
N  * @rmtoll SR           CC2IF         MS32_TIM_ClearFlag_CC2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_ClearFlag_CC2(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_ClearFlag_CC2(TIM_TypeDef *TIMx) {
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC2IF));
X  ((TIMx->SR) = (~((0x1UL << (2U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 2 interrupt flag (CC2F) is set (Capture/Compare 2 interrupt is pending).
N  * @rmtoll SR           CC2IF         MS32_TIM_IsActiveFlag_CC2
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsActiveFlag_CC2(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsActiveFlag_CC2(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC2IF) == (TIM_SR_CC2IF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (2U)))) == ((0x1UL << (2U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 3 interrupt flag (CC3F).
N  * @rmtoll SR           CC3IF         MS32_TIM_ClearFlag_CC3
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_ClearFlag_CC3(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_ClearFlag_CC3(TIM_TypeDef *TIMx) {
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC3IF));
X  ((TIMx->SR) = (~((0x1UL << (3U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 3 interrupt flag (CC3F) is set (Capture/Compare 3 interrupt is pending).
N  * @rmtoll SR           CC3IF         MS32_TIM_IsActiveFlag_CC3
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsActiveFlag_CC3(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsActiveFlag_CC3(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC3IF) == (TIM_SR_CC3IF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (3U)))) == ((0x1UL << (3U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 4 interrupt flag (CC4F).
N  * @rmtoll SR           CC4IF         MS32_TIM_ClearFlag_CC4
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx) {
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
X  ((TIMx->SR) = (~((0x1UL << (4U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 4 interrupt flag (CC4F) is set (Capture/Compare 4 interrupt is pending).
N  * @rmtoll SR           CC4IF         MS32_TIM_IsActiveFlag_CC4
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (4U)))) == ((0x1UL << (4U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the commutation interrupt flag (COMIF).
N  * @rmtoll SR           COMIF         MS32_TIM_ClearFlag_COM
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_ClearFlag_COM(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_ClearFlag_COM(TIM_TypeDef *TIMx) {
N  WRITE_REG(TIMx->SR, ~(TIM_SR_COMIF));
X  ((TIMx->SR) = (~((0x1UL << (5U)))));
N}
N
N/**
N  * @brief  Indicate whether commutation interrupt flag (COMIF) is set (commutation interrupt is pending).
N  * @rmtoll SR           COMIF         MS32_TIM_IsActiveFlag_COM
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsActiveFlag_COM(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsActiveFlag_COM(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->SR, TIM_SR_COMIF) == (TIM_SR_COMIF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (5U)))) == ((0x1UL << (5U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the trigger interrupt flag (TIF).
N  * @rmtoll SR           TIF           MS32_TIM_ClearFlag_TRIG
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_ClearFlag_TRIG(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_ClearFlag_TRIG(TIM_TypeDef *TIMx) {
N  WRITE_REG(TIMx->SR, ~(TIM_SR_TIF));
X  ((TIMx->SR) = (~((0x1UL << (6U)))));
N}
N
N/**
N  * @brief  Indicate whether trigger interrupt flag (TIF) is set (trigger interrupt is pending).
N  * @rmtoll SR           TIF           MS32_TIM_IsActiveFlag_TRIG
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsActiveFlag_TRIG(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsActiveFlag_TRIG(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->SR, TIM_SR_TIF) == (TIM_SR_TIF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the break interrupt flag (BIF).
N  * @rmtoll SR           BIF           MS32_TIM_ClearFlag_BRK
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_ClearFlag_BRK(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_ClearFlag_BRK(TIM_TypeDef *TIMx) {
N  WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
X  ((TIMx->SR) = (~((0x1UL << (7U)))));
N}
N
N/**
N  * @brief  Indicate whether break interrupt flag (BIF) is set (break interrupt is pending).
N  * @rmtoll SR           BIF           MS32_TIM_IsActiveFlag_BRK
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsActiveFlag_BRK(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsActiveFlag_BRK(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->SR, TIM_SR_BIF) == (TIM_SR_BIF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 1 over-capture interrupt flag (CC1OF).
N  * @rmtoll SR           CC1OF         MS32_TIM_ClearFlag_CC1OVR
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_ClearFlag_CC1OVR(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_ClearFlag_CC1OVR(TIM_TypeDef *TIMx) {
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1OF));
X  ((TIMx->SR) = (~((0x1UL << (9U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 1 over-capture interrupt flag (CC1OF) is set (Capture/Compare 1 interrupt is pending).
N  * @rmtoll SR           CC1OF         MS32_TIM_IsActiveFlag_CC1OVR
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsActiveFlag_CC1OVR(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsActiveFlag_CC1OVR(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC1OF) == (TIM_SR_CC1OF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (9U)))) == ((0x1UL << (9U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 2 over-capture interrupt flag (CC2OF).
N  * @rmtoll SR           CC2OF         MS32_TIM_ClearFlag_CC2OVR
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_ClearFlag_CC2OVR(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_ClearFlag_CC2OVR(TIM_TypeDef *TIMx) {
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC2OF));
X  ((TIMx->SR) = (~((0x1UL << (10U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 2 over-capture interrupt flag (CC2OF) is set (Capture/Compare 2 over-capture interrupt is pending).
N  * @rmtoll SR           CC2OF         MS32_TIM_IsActiveFlag_CC2OVR
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsActiveFlag_CC2OVR(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsActiveFlag_CC2OVR(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC2OF) == (TIM_SR_CC2OF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (10U)))) == ((0x1UL << (10U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 3 over-capture interrupt flag (CC3OF).
N  * @rmtoll SR           CC3OF         MS32_TIM_ClearFlag_CC3OVR
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_ClearFlag_CC3OVR(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_ClearFlag_CC3OVR(TIM_TypeDef *TIMx) {
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC3OF));
X  ((TIMx->SR) = (~((0x1UL << (11U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 3 over-capture interrupt flag (CC3OF) is set (Capture/Compare 3 over-capture interrupt is pending).
N  * @rmtoll SR           CC3OF         MS32_TIM_IsActiveFlag_CC3OVR
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsActiveFlag_CC3OVR(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsActiveFlag_CC3OVR(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC3OF) == (TIM_SR_CC3OF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (11U)))) == ((0x1UL << (11U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 4 over-capture interrupt flag (CC4OF).
N  * @rmtoll SR           CC4OF         MS32_TIM_ClearFlag_CC4OVR
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_ClearFlag_CC4OVR(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_ClearFlag_CC4OVR(TIM_TypeDef *TIMx) {
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC4OF));
X  ((TIMx->SR) = (~((0x1UL << (12U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 4 over-capture interrupt flag (CC4OF) is set (Capture/Compare 4 over-capture interrupt is pending).
N  * @rmtoll SR           CC4OF         MS32_TIM_IsActiveFlag_CC4OVR
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsActiveFlag_CC4OVR(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsActiveFlag_CC4OVR(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC4OF) == (TIM_SR_CC4OF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (12U)))) == ((0x1UL << (12U)))) ? 1UL : 0UL);
N}
N
N
N/** @defgroup TIM_EF_IT_Management IT-Management
N  * @{
N  */
N
N/**
N  * @brief  Enable update interrupt (UIE).
N  * @rmtoll DIER         UIE           MS32_TIM_EnableIT_UPDATE
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableIT_UPDATE(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableIT_UPDATE(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
X  ((TIMx->DIER) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable update interrupt (UIE).
N  * @rmtoll DIER         UIE           MS32_TIM_DisableIT_UPDATE
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableIT_UPDATE(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableIT_UPDATE(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_UIE);
X  ((TIMx->DIER) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Indicates whether the update interrupt (UIE) is enabled.
N  * @rmtoll DIER         UIE           MS32_TIM_IsEnabledIT_UPDATE
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledIT_UPDATE(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledIT_UPDATE(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_UIE) == (TIM_DIER_UIE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 1 interrupt (CC1IE).
N  * @rmtoll DIER         CC1IE         MS32_TIM_EnableIT_CC1
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableIT_CC1(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableIT_CC1(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->DIER, TIM_DIER_CC1IE);
X  ((TIMx->DIER) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable capture/compare 1  interrupt (CC1IE).
N  * @rmtoll DIER         CC1IE         MS32_TIM_DisableIT_CC1
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableIT_CC1(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableIT_CC1(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC1IE);
X  ((TIMx->DIER) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 1 interrupt (CC1IE) is enabled.
N  * @rmtoll DIER         CC1IE         MS32_TIM_IsEnabledIT_CC1
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledIT_CC1(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledIT_CC1(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC1IE) == (TIM_DIER_CC1IE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (1U)))) == ((0x1UL << (1U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 2 interrupt (CC2IE).
N  * @rmtoll DIER         CC2IE         MS32_TIM_EnableIT_CC2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableIT_CC2(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableIT_CC2(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->DIER, TIM_DIER_CC2IE);
X  ((TIMx->DIER) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Disable capture/compare 2  interrupt (CC2IE).
N  * @rmtoll DIER         CC2IE         MS32_TIM_DisableIT_CC2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableIT_CC2(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableIT_CC2(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC2IE);
X  ((TIMx->DIER) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 2 interrupt (CC2IE) is enabled.
N  * @rmtoll DIER         CC2IE         MS32_TIM_IsEnabledIT_CC2
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledIT_CC2(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledIT_CC2(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC2IE) == (TIM_DIER_CC2IE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (2U)))) == ((0x1UL << (2U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 3 interrupt (CC3IE).
N  * @rmtoll DIER         CC3IE         MS32_TIM_EnableIT_CC3
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableIT_CC3(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableIT_CC3(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->DIER, TIM_DIER_CC3IE);
X  ((TIMx->DIER) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Disable capture/compare 3  interrupt (CC3IE).
N  * @rmtoll DIER         CC3IE         MS32_TIM_DisableIT_CC3
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableIT_CC3(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableIT_CC3(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC3IE);
X  ((TIMx->DIER) &= ~((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 3 interrupt (CC3IE) is enabled.
N  * @rmtoll DIER         CC3IE         MS32_TIM_IsEnabledIT_CC3
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledIT_CC3(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledIT_CC3(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC3IE) == (TIM_DIER_CC3IE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (3U)))) == ((0x1UL << (3U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 4 interrupt (CC4IE).
N  * @rmtoll DIER         CC4IE         MS32_TIM_EnableIT_CC4
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableIT_CC4(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableIT_CC4(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->DIER, TIM_DIER_CC4IE);
X  ((TIMx->DIER) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Disable capture/compare 4  interrupt (CC4IE).
N  * @rmtoll DIER         CC4IE         MS32_TIM_DisableIT_CC4
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableIT_CC4(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableIT_CC4(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC4IE);
X  ((TIMx->DIER) &= ~((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 4 interrupt (CC4IE) is enabled.
N  * @rmtoll DIER         CC4IE         MS32_TIM_IsEnabledIT_CC4
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledIT_CC4(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledIT_CC4(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC4IE) == (TIM_DIER_CC4IE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (4U)))) == ((0x1UL << (4U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable commutation interrupt (COMIE).
N  * @rmtoll DIER         COMIE         MS32_TIM_EnableIT_COM
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableIT_COM(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableIT_COM(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->DIER, TIM_DIER_COMIE);
X  ((TIMx->DIER) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Disable commutation interrupt (COMIE).
N  * @rmtoll DIER         COMIE         MS32_TIM_DisableIT_COM
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableIT_COM(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableIT_COM(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_COMIE);
X  ((TIMx->DIER) &= ~((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Indicates whether the commutation interrupt (COMIE) is enabled.
N  * @rmtoll DIER         COMIE         MS32_TIM_IsEnabledIT_COM
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledIT_COM(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledIT_COM(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_COMIE) == (TIM_DIER_COMIE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (5U)))) == ((0x1UL << (5U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable trigger interrupt (TIE).
N  * @rmtoll DIER         TIE           MS32_TIM_EnableIT_TRIG
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableIT_TRIG(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableIT_TRIG(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->DIER, TIM_DIER_TIE);
X  ((TIMx->DIER) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Disable trigger interrupt (TIE).
N  * @rmtoll DIER         TIE           MS32_TIM_DisableIT_TRIG
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableIT_TRIG(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableIT_TRIG(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_TIE);
X  ((TIMx->DIER) &= ~((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Indicates whether the trigger interrupt (TIE) is enabled.
N  * @rmtoll DIER         TIE           MS32_TIM_IsEnabledIT_TRIG
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledIT_TRIG(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledIT_TRIG(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_TIE) == (TIM_DIER_TIE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable break interrupt (BIE).
N  * @rmtoll DIER         BIE           MS32_TIM_EnableIT_BRK
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableIT_BRK(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableIT_BRK(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->DIER, TIM_DIER_BIE);
X  ((TIMx->DIER) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable break interrupt (BIE).
N  * @rmtoll DIER         BIE           MS32_TIM_DisableIT_BRK
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableIT_BRK(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableIT_BRK(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_BIE);
X  ((TIMx->DIER) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Indicates whether the break interrupt (BIE) is enabled.
N  * @rmtoll DIER         BIE           MS32_TIM_IsEnabledIT_BRK
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledIT_BRK(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledIT_BRK(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_BIE) == (TIM_DIER_BIE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N
N
N/** @defgroup TIM_EF_DMA_Management DMA-Management
N  * @{
N  */
N
N/**
N  * @brief  Enable update DMA request (UDE).
N  * @rmtoll DIER         UDE           MS32_TIM_EnableDMAReq_UPDATE
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableDMAReq_UPDATE(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableDMAReq_UPDATE(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->DIER, TIM_DIER_UDE);
X  ((TIMx->DIER) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable update DMA request (UDE).
N  * @rmtoll DIER         UDE           MS32_TIM_DisableDMAReq_UPDATE
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableDMAReq_UPDATE(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableDMAReq_UPDATE(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_UDE);
X  ((TIMx->DIER) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Indicates whether the update DMA request  (UDE) is enabled.
N  * @rmtoll DIER         UDE           MS32_TIM_IsEnabledDMAReq_UPDATE
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledDMAReq_UPDATE(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledDMAReq_UPDATE(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_UDE) == (TIM_DIER_UDE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (8U)))) == ((0x1UL << (8U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 1 DMA request (CC1DE).
N  * @rmtoll DIER         CC1DE         MS32_TIM_EnableDMAReq_CC1
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableDMAReq_CC1(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableDMAReq_CC1(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->DIER, TIM_DIER_CC1DE);
X  ((TIMx->DIER) |= ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Disable capture/compare 1  DMA request (CC1DE).
N  * @rmtoll DIER         CC1DE         MS32_TIM_DisableDMAReq_CC1
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableDMAReq_CC1(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableDMAReq_CC1(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC1DE);
X  ((TIMx->DIER) &= ~((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 1 DMA request (CC1DE) is enabled.
N  * @rmtoll DIER         CC1DE         MS32_TIM_IsEnabledDMAReq_CC1
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledDMAReq_CC1(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledDMAReq_CC1(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC1DE) == (TIM_DIER_CC1DE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (9U)))) == ((0x1UL << (9U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 2 DMA request (CC2DE).
N  * @rmtoll DIER         CC2DE         MS32_TIM_EnableDMAReq_CC2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableDMAReq_CC2(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableDMAReq_CC2(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->DIER, TIM_DIER_CC2DE);
X  ((TIMx->DIER) |= ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Disable capture/compare 2  DMA request (CC2DE).
N  * @rmtoll DIER         CC2DE         MS32_TIM_DisableDMAReq_CC2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableDMAReq_CC2(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableDMAReq_CC2(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC2DE);
X  ((TIMx->DIER) &= ~((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 2 DMA request (CC2DE) is enabled.
N  * @rmtoll DIER         CC2DE         MS32_TIM_IsEnabledDMAReq_CC2
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledDMAReq_CC2(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledDMAReq_CC2(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC2DE) == (TIM_DIER_CC2DE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (10U)))) == ((0x1UL << (10U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 3 DMA request (CC3DE).
N  * @rmtoll DIER         CC3DE         MS32_TIM_EnableDMAReq_CC3
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableDMAReq_CC3(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableDMAReq_CC3(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->DIER, TIM_DIER_CC3DE);
X  ((TIMx->DIER) |= ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Disable capture/compare 3  DMA request (CC3DE).
N  * @rmtoll DIER         CC3DE         MS32_TIM_DisableDMAReq_CC3
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableDMAReq_CC3(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableDMAReq_CC3(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC3DE);
X  ((TIMx->DIER) &= ~((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 3 DMA request (CC3DE) is enabled.
N  * @rmtoll DIER         CC3DE         MS32_TIM_IsEnabledDMAReq_CC3
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledDMAReq_CC3(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledDMAReq_CC3(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC3DE) == (TIM_DIER_CC3DE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (11U)))) == ((0x1UL << (11U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 4 DMA request (CC4DE).
N  * @rmtoll DIER         CC4DE         MS32_TIM_EnableDMAReq_CC4
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableDMAReq_CC4(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableDMAReq_CC4(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->DIER, TIM_DIER_CC4DE);
X  ((TIMx->DIER) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Disable capture/compare 4  DMA request (CC4DE).
N  * @rmtoll DIER         CC4DE         MS32_TIM_DisableDMAReq_CC4
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableDMAReq_CC4(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableDMAReq_CC4(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC4DE);
X  ((TIMx->DIER) &= ~((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 4 DMA request (CC4DE) is enabled.
N  * @rmtoll DIER         CC4DE         MS32_TIM_IsEnabledDMAReq_CC4
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledDMAReq_CC4(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledDMAReq_CC4(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC4DE) == (TIM_DIER_CC4DE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (12U)))) == ((0x1UL << (12U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable commutation DMA request (COMDE).
N  * @rmtoll DIER         COMDE         MS32_TIM_EnableDMAReq_COM
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableDMAReq_COM(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableDMAReq_COM(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->DIER, TIM_DIER_COMDE);
X  ((TIMx->DIER) |= ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Disable commutation DMA request (COMDE).
N  * @rmtoll DIER         COMDE         MS32_TIM_DisableDMAReq_COM
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableDMAReq_COM(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableDMAReq_COM(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_COMDE);
X  ((TIMx->DIER) &= ~((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Indicates whether the commutation DMA request (COMDE) is enabled.
N  * @rmtoll DIER         COMDE         MS32_TIM_IsEnabledDMAReq_COM
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledDMAReq_COM(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledDMAReq_COM(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_COMDE) == (TIM_DIER_COMDE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (13U)))) == ((0x1UL << (13U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable trigger interrupt (TDE).
N  * @rmtoll DIER         TDE           MS32_TIM_EnableDMAReq_TRIG
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_EnableDMAReq_TRIG(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_EnableDMAReq_TRIG(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->DIER, TIM_DIER_TDE);
X  ((TIMx->DIER) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Disable trigger interrupt (TDE).
N  * @rmtoll DIER         TDE           MS32_TIM_DisableDMAReq_TRIG
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_DisableDMAReq_TRIG(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_DisableDMAReq_TRIG(TIM_TypeDef *TIMx) {
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_TDE);
X  ((TIMx->DIER) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Indicates whether the trigger interrupt (TDE) is enabled.
N  * @rmtoll DIER         TDE           MS32_TIM_IsEnabledDMAReq_TRIG
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_TIM_IsEnabledDMAReq_TRIG(TIM_TypeDef *TIMx) {
Xstatic __inline uint32_t MS32_TIM_IsEnabledDMAReq_TRIG(TIM_TypeDef *TIMx) {
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_TDE) == (TIM_DIER_TDE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (14U)))) == ((0x1UL << (14U)))) ? 1UL : 0UL);
N}
N
N
N/** @defgroup TIM_EF_EVENT_Management EVENT-Management
N  * @{
N  */
N
N/**
N  * @brief  Generate an update event.
N  * @rmtoll EGR          UG            MS32_TIM_GenerateEvent_UPDATE
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->EGR, TIM_EGR_UG);
X  ((TIMx->EGR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Generate Capture/Compare 1 event.
N  * @rmtoll EGR          CC1G          MS32_TIM_GenerateEvent_CC1
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_GenerateEvent_CC1(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_GenerateEvent_CC1(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->EGR, TIM_EGR_CC1G);
X  ((TIMx->EGR) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Generate Capture/Compare 2 event.
N  * @rmtoll EGR          CC2G          MS32_TIM_GenerateEvent_CC2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_GenerateEvent_CC2(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_GenerateEvent_CC2(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->EGR, TIM_EGR_CC2G);
X  ((TIMx->EGR) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Generate Capture/Compare 3 event.
N  * @rmtoll EGR          CC3G          MS32_TIM_GenerateEvent_CC3
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_GenerateEvent_CC3(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_GenerateEvent_CC3(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->EGR, TIM_EGR_CC3G);
X  ((TIMx->EGR) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Generate Capture/Compare 4 event.
N  * @rmtoll EGR          CC4G          MS32_TIM_GenerateEvent_CC4
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_GenerateEvent_CC4(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_GenerateEvent_CC4(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->EGR, TIM_EGR_CC4G);
X  ((TIMx->EGR) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Generate commutation event.
N  * @rmtoll EGR          COMG          MS32_TIM_GenerateEvent_COM
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_GenerateEvent_COM(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_GenerateEvent_COM(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->EGR, TIM_EGR_COMG);
X  ((TIMx->EGR) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Generate trigger event.
N  * @rmtoll EGR          TG            MS32_TIM_GenerateEvent_TRIG
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_GenerateEvent_TRIG(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_GenerateEvent_TRIG(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->EGR, TIM_EGR_TG);
X  ((TIMx->EGR) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Generate break event.
N  * @rmtoll EGR          BG            MS32_TIM_GenerateEvent_BRK
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_TIM_GenerateEvent_BRK(TIM_TypeDef *TIMx) {
Xstatic __inline void MS32_TIM_GenerateEvent_BRK(TIM_TypeDef *TIMx) {
N  SET_BIT(TIMx->EGR, TIM_EGR_BG);
X  ((TIMx->EGR) |= ((0x1UL << (7U))));
N}
N
N
N/** @defgroup TIM_EF_Init Initialisation and deinitialisation functions
N  * @{
N  */
NErrorStatus MS32_TIM_DeInit(TIM_TypeDef *TIMx);
Nvoid        MS32_TIM_StructInit(MS32_TIM_InitTypeDef *TimInitStr);
NErrorStatus MS32_TIM_Init(TIM_TypeDef *TIMx, MS32_TIM_InitTypeDef *TimInitStr);
Nvoid        MS32_TIM_ITConfig(TIM_TypeDef *TIMx, uint32_t InterruptFunc, uint32_t Priority);
N
Nvoid        MS32_TIM_OC_StructInit(MS32_TIM_OC_InitTypeDef *TimOcInitStr);
NErrorStatus MS32_TIM_OC_Init(TIM_TypeDef *TIMx, uint32_t Channel, MS32_TIM_OC_InitTypeDef *TimOcInitStr);
Nvoid        MS32_TIM_IC_StructInit(MS32_TIM_IC_InitTypeDef *TimIcInitStr);
NErrorStatus MS32_TIM_IC_Init(TIM_TypeDef *TIMx, uint32_t Channel, MS32_TIM_IC_InitTypeDef *TimIcInitStr);
NFlagStatus  MS32_TIM_GetStatusFlag(TIM_TypeDef *TIMx, uint32_t Flags);
Nvoid        MS32_TIM_ENCODER_StructInit(MS32_TIM_ENCODER_InitTypeDef *TIM_EncoderInitStruct);
NErrorStatus MS32_TIM_ENCODER_Init(TIM_TypeDef *TIMx, MS32_TIM_ENCODER_InitTypeDef *TIM_EncoderInitStruct);
Nvoid        MS32_TIM_HALLSENSOR_StructInit(MS32_TIM_HALLSENSOR_InitTypeDef *TIM_HallSensorInitStruct);
NErrorStatus MS32_TIM_HALLSENSOR_Init(TIM_TypeDef *TIMx, MS32_TIM_HALLSENSOR_InitTypeDef *TIM_HallSensorInitStruct);
Nvoid        MS32_TIM_BDTR_StructInit(MS32_TIM_BDTR_InitTypeDef *TIM_BDTRInitStruct);
NErrorStatus MS32_TIM_BDTR_Init(TIM_TypeDef *TIMx, MS32_TIM_BDTR_InitTypeDef *TIM_BDTRInitStruct);
N
N/** @defgroup TIM_EF_Application function
N  * @{
N  */
NFlagStatus MS32_TIM_GetStatusFlag(TIM_TypeDef *TIMx, uint32_t Flags);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_TIM_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 81 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_usart.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_usart.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_USART_H
N#define __MS32F0XX_USART_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/**
N  * @brief LL USART Init Structure definition
N  */
Ntypedef struct {
N  uint32_t BaudRate;                  /*!< This field defines expected Usart communication baud rate.
N                                           This feature can be modified afterwards using unitary function @ref MS32_USART_SetBaudRate().*/
N  uint32_t DataWidth;                 /*!< Specifies the number of data bits transmitted or received in a frame.
N                                           This parameter can be a value of @ref USART_EC_DATAWIDTH.
N                                           This feature can be modified afterwards using unitary function @ref MS32_USART_SetDataWidth().*/
N  uint32_t StopBits;                  /*!< Specifies the number of stop bits transmitted.
N                                           This parameter can be a value of @ref USART_EC_STOPBITS.
N                                           This feature can be modified afterwards using unitary function @ref MS32_USART_SetStopBitsLength().*/
N  uint32_t Parity;                    /*!< Specifies the parity mode.
N                                           This parameter can be a value of @ref USART_EC_PARITY.
N                                           This feature can be modified afterwards using unitary function @ref MS32_USART_SetParity().*/
N  uint32_t TransferDirection;         /*!< Specifies whether the Receive and/or Transmit mode is enabled or disabled.
N                                           This parameter can be a value of @ref USART_EC_DIRECTION.
N                                           This feature can be modified afterwards using unitary function @ref MS32_USART_SetTransferDirection().*/
N  uint32_t HardwareFlowControl;       /*!< Specifies whether the hardware flow control mode is enabled or disabled.
N                                           This parameter can be a value of @ref USART_EC_HWCONTROL.
N                                           This feature can be modified afterwards using unitary function @ref MS32_USART_SetHWFlowCtrl().*/
N  uint32_t OverSampling;              /*!< Specifies whether USART oversampling mode is 16 or 8.
N                                           This parameter can be a value of @ref USART_EC_OVERSAMPLING.
N                                           This feature can be modified afterwards using unitary function @ref MS32_USART_SetOverSampling().*/
N} MS32_USART_InitTypeDef;
N
N/**
N  * @brief LL USART Clock Init Structure definition
N  */
Ntypedef struct {
N  uint32_t ClockOutput;               /*!< Specifies whether the USART clock is enabled or disabled.
N                                           This parameter can be a value of @ref USART_EC_CLOCK.
N                                           USART HW configuration can be modified afterwards using unitary functions
N                                           @ref MS32_USART_EnableSCLKOutput() or @ref MS32_USART_DisableSCLKOutput().
N                                           For more details, refer to description of this function. */
N  uint32_t ClockPolarity;             /*!< Specifies the steady state of the serial clock.
N                                           This parameter can be a value of @ref USART_EC_POLARITY.
N                                           USART HW configuration can be modified afterwards using unitary functions @ref MS32_USART_SetClockPolarity().
N                                           For more details, refer to description of this function. */
N  uint32_t ClockPhase;                /*!< Specifies the clock transition on which the bit capture is made.
N                                           This parameter can be a value of @ref USART_EC_PHASE.
N                                           USART HW configuration can be modified afterwards using unitary functions @ref MS32_USART_SetClockPhase().
N                                           For more details, refer to description of this function. */
N  uint32_t LastBitClockPulse;         /*!< Specifies whether the clock pulse corresponding to the last transmitted
N                                           data bit (MSB) has to be output on the SCLK pin in synchronous mode.
N                                           This parameter can be a value of @ref USART_EC_LASTCLKPULSE.
N                                           USART HW configuration can be modified afterwards using unitary functions @ref MS32_USART_SetLastClkPulseOutput().
N                                           For more details, refer to description of this function. */
N} MS32_USART_ClockInitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup USART_EC_CLEAR_FLAG Clear Flags Defines
N  * @brief    Flags defines which can be used with MS32_USART_WriteReg function
N  * @{
N  */
N#define MS32_USART_ICR_PECF                       USART_ICR_PECF                /*!< Parity error flag */
N#define MS32_USART_ICR_FECF                       USART_ICR_FECF                /*!< Framing error flag */
N#define MS32_USART_ICR_NCF                        USART_ICR_NCF                 /*!< Noise error detected flag */
N#define MS32_USART_ICR_ORECF                      USART_ICR_ORECF               /*!< Overrun error flag */
N#define MS32_USART_ICR_IDLECF                     USART_ICR_IDLECF              /*!< Idle line detected flag */
N#define MS32_USART_ICR_TCCF                       USART_ICR_TCCF                /*!< Transmission complete flag */
N#define MS32_USART_ICR_LBDCF                      USART_ICR_LBDCF               /*!< LIN break detection flag */
N#define MS32_USART_ICR_CTSCF                      USART_ICR_CTSCF               /*!< CTS flag */
N#define MS32_USART_ICR_RTOCF                      USART_ICR_RTOCF               /*!< Receiver timeout flag */
N#define MS32_USART_ICR_EOBCF                      USART_ICR_EOBCF               /*!< End of block flag */
N#define MS32_USART_ICR_CMCF                       USART_ICR_CMCF                /*!< Character match flag */
N#define MS32_USART_ICR_WUCF                       USART_ICR_WUCF                /*!< Wakeup from Stop mode flag */
N
N#define MS32_USART_ICR_ALLIF                      (USART_ICR_PECF   | USART_ICR_FECF  | USART_ICR_NCF   | USART_ICR_ORECF |\
N                                                   USART_ICR_IDLECF | USART_ICR_TCCF  | USART_ICR_LBDCF | USART_ICR_CTSCF |\
N                                                   USART_ICR_RTOCF  | USART_ICR_EOBCF | USART_ICR_CMCF  | USART_ICR_WUCF)
X#define MS32_USART_ICR_ALLIF                      (USART_ICR_PECF   | USART_ICR_FECF  | USART_ICR_NCF   | USART_ICR_ORECF |                                                   USART_ICR_IDLECF | USART_ICR_TCCF  | USART_ICR_LBDCF | USART_ICR_CTSCF |                                                   USART_ICR_RTOCF  | USART_ICR_EOBCF | USART_ICR_CMCF  | USART_ICR_WUCF)
N
N
N/** @defgroup USART_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with MS32_USART_ReadReg function
N  * @{
N  */
N#define MS32_USART_ISR_PE                         USART_ISR_PE                  /*!< Parity error flag */
N#define MS32_USART_ISR_FE                         USART_ISR_FE                  /*!< Framing error flag */
N#define MS32_USART_ISR_NE                         USART_ISR_NE                  /*!< Noise detected flag */
N#define MS32_USART_ISR_ORE                        USART_ISR_ORE                 /*!< Overrun error flag */
N#define MS32_USART_ISR_IDLE                       USART_ISR_IDLE                /*!< Idle line detected flag */
N#define MS32_USART_ISR_RXNE                       USART_ISR_RXNE                /*!< Read data register not empty flag */
N#define MS32_USART_ISR_TC                         USART_ISR_TC                  /*!< Transmission complete flag */
N#define MS32_USART_ISR_TXE                        USART_ISR_TXE                 /*!< Transmit data register empty flag */
N#define MS32_USART_ISR_LBDF                       USART_ISR_LBDF                /*!< LIN break detection flag */
N#define MS32_USART_ISR_CTSIF                      USART_ISR_CTSIF               /*!< CTS interrupt flag */
N#define MS32_USART_ISR_CTS                        USART_ISR_CTS                 /*!< CTS flag */
N#define MS32_USART_ISR_RTOF                       USART_ISR_RTOF                /*!< Receiver timeout flag */
N#define MS32_USART_ISR_EOBF                       USART_ISR_EOBF                /*!< End of block flag */
N#define MS32_USART_ISR_ABRE                       USART_ISR_ABRE                /*!< Auto baud rate error flag */
N#define MS32_USART_ISR_ABRF                       USART_ISR_ABRF                /*!< Auto baud rate flag */
N#define MS32_USART_ISR_BUSY                       USART_ISR_BUSY                /*!< Busy flag */
N#define MS32_USART_ISR_CMF                        USART_ISR_CMF                 /*!< Character match flag */
N#define MS32_USART_ISR_SBKF                       USART_ISR_SBKF                /*!< Send break flag */
N#define MS32_USART_ISR_RWU                        USART_ISR_RWU                 /*!< Receiver wakeup from Mute mode flag */
N#define MS32_USART_ISR_WUF                        USART_ISR_WUF                 /*!< Wakeup from Stop mode flag */
N#define MS32_USART_ISR_TEACK                      USART_ISR_TEACK               /*!< Transmit enable acknowledge flag */
N#define MS32_USART_ISR_REACK                      USART_ISR_REACK               /*!< Receive enable acknowledge flag */
N
N
N/** @defgroup USART_EC_IT IT Defines
N  * @brief    IT defines which can be used with MS32_USART_ReadReg and  MS32_USART_WriteReg functions
N  * @{
N  */
N#define MS32_USART_CR1_IDLEIE                     USART_CR1_IDLEIE              /*!< IDLE interrupt enable */
N#define MS32_USART_CR1_RXNEIE                     USART_CR1_RXNEIE              /*!< Read data register not empty interrupt enable */
N#define MS32_USART_CR1_TCIE                       USART_CR1_TCIE                /*!< Transmission complete interrupt enable */
N#define MS32_USART_CR1_TXEIE                      USART_CR1_TXEIE               /*!< Transmit data register empty interrupt enable */
N#define MS32_USART_CR1_PEIE                       USART_CR1_PEIE                /*!< Parity error */
N#define MS32_USART_CR1_CMIE                       USART_CR1_CMIE                /*!< Character match interrupt enable */
N#define MS32_USART_CR1_RTOIE                      USART_CR1_RTOIE               /*!< Receiver timeout interrupt enable */
N#define MS32_USART_CR1_EOBIE                      USART_CR1_EOBIE               /*!< End of Block interrupt enable */
N#define MS32_USART_CR2_LBDIE                      USART_CR2_LBDIE               /*!< LIN break detection interrupt enable */
N#define MS32_USART_CR3_EIE                        USART_CR3_EIE                 /*!< Error interrupt enable */
N#define MS32_USART_CR3_CTSIE                      USART_CR3_CTSIE               /*!< CTS interrupt enable */
N#define MS32_USART_CR3_WUFIE                      USART_CR3_WUFIE               /*!< Wakeup from Stop mode interrupt enable */
N
N#define MS32_USART_CR1_ALLIE                      (USART_CR1_IDLEIE | USART_CR1_RXNEIE | USART_CR1_TCIE  | USART_CR1_TXEIE |\
N                                                   USART_CR1_PEIE   | USART_CR1_CMIE   | USART_CR1_RTOIE | USART_CR1_EOBIE)
X#define MS32_USART_CR1_ALLIE                      (USART_CR1_IDLEIE | USART_CR1_RXNEIE | USART_CR1_TCIE  | USART_CR1_TXEIE |                                                   USART_CR1_PEIE   | USART_CR1_CMIE   | USART_CR1_RTOIE | USART_CR1_EOBIE)
N#define MS32_USART_CR2_ALLIE                      USART_CR2_LBDIE
N#define MS32_USART_CR3_ALLIE                      (USART_CR3_EIE | USART_CR3_CTSIE | USART_CR3_WUFIE)
N
N
N/** @defgroup USART_EC_DIRECTION Communication Direction
N  * @{
N  */
N#define MS32_USART_DIRECTION_NONE                 0x00000000U                        /*!< Transmitter and Receiver are disabled */
N#define MS32_USART_DIRECTION_RX                   USART_CR1_RE                       /*!< Transmitter is disabled and Receiver is enabled */
N#define MS32_USART_DIRECTION_TX                   USART_CR1_TE                       /*!< Transmitter is enabled and Receiver is disabled */
N#define MS32_USART_DIRECTION_TX_RX                (USART_CR1_TE |USART_CR1_RE)       /*!< Transmitter and Receiver are enabled */
N
N
N/** @defgroup USART_EC_PARITY Parity Control
N  * @{
N  */
N#define MS32_USART_PARITY_NONE                    0x00000000U                          /*!< Parity control disabled */
N#define MS32_USART_PARITY_EVEN                    USART_CR1_PCE                        /*!< Parity control enabled and Even Parity is selected */
N#define MS32_USART_PARITY_ODD                     (USART_CR1_PCE | USART_CR1_PS)       /*!< Parity control enabled and Odd Parity is selected */
N
N
N/** @defgroup USART_EC_WAKEUP Wakeup
N  * @{
N  */
N#define MS32_USART_WAKEUP_IDLELINE                0x00000000U           /*!<  USART wake up from Mute mode on Idle Line */
N#define MS32_USART_WAKEUP_ADDRESSMARK             USART_CR1_WAKE        /*!<  USART wake up from Mute mode on Address Mark */
N
N
N/** @defgroup USART_EC_DATAWIDTH Datawidth
N  * @{
N  */
N#define MS32_USART_DATAWIDTH_8B                   0x00000000U             /*!< 8 bits word length : Start bit, 8 data bits, n stop bits */
N#define MS32_USART_DATAWIDTH_9B                   USART_CR1_M             /*!< 9 bits word length : Start bit, 9 data bits, n stop bits */
N
N
N/** @defgroup USART_EC_OVERSAMPLING Oversampling
N  * @{
N  */
N#define MS32_USART_OVERSAMPLING_16                0x00000000U            /*!< Oversampling by 16 */
N#define MS32_USART_OVERSAMPLING_8                 USART_CR1_OVER8        /*!< Oversampling by 8 */
N
N
N/** @defgroup USART_EC_CLOCK Clock Signal
N  * @{
N  */
N
N#define MS32_USART_CLOCK_DISABLE                  0x00000000U            /*!< Clock signal not provided */
N#define MS32_USART_CLOCK_ENABLE                   USART_CR2_CLKEN        /*!< Clock signal provided */
N
N
N/** @defgroup USART_EC_LASTCLKPULSE Last Clock Pulse
N  * @{
N  */
N#define MS32_USART_LASTCLKPULSE_NO_OUTPUT         0x00000000U           /*!< The clock pulse of the last data bit is not output to the SCLK pin */
N#define MS32_USART_LASTCLKPULSE_OUTPUT            USART_CR2_LBCL        /*!< The clock pulse of the last data bit is output to the SCLK pin */
N
N
N/** @defgroup USART_EC_PHASE Clock Phase
N  * @{
N  */
N#define MS32_USART_PHASE_1EDGE                    0x00000000U           /*!< The first clock transition is the first data capture edge */
N#define MS32_USART_PHASE_2EDGE                    USART_CR2_CPHA        /*!< The second clock transition is the first data capture edge */
N
N
N/** @defgroup USART_EC_POLARITY Clock Polarity
N  * @{
N  */
N#define MS32_USART_POLARITY_LOW                   0x00000000U           /*!< Steady low value on SCLK pin outside transmission window*/
N#define MS32_USART_POLARITY_HIGH                  USART_CR2_CPOL        /*!< Steady high value on SCLK pin outside transmission window */
N
N
N/** @defgroup USART_EC_STOPBITS Stop Bits
N  * @{
N  */
N#define MS32_USART_STOPBITS_0_5                   USART_CR2_STOP_0                           /*!< 0.5 stop bit */
N#define MS32_USART_STOPBITS_1                     0x00000000U                                /*!< 1 stop bit */
N#define MS32_USART_STOPBITS_1_5                   (USART_CR2_STOP_0 | USART_CR2_STOP_1)      /*!< 1.5 stop bits */
N#define MS32_USART_STOPBITS_2                     USART_CR2_STOP_1                           /*!< 2 stop bits */
N
N
N/** @defgroup USART_EC_TXRX TX RX Pins Swap
N  * @{
N  */
N#define MS32_USART_TXRX_STANDARD                  0x00000000U           /*!< TX/RX pins are used as defined in standard pinout */
N#define MS32_USART_TXRX_SWAPPED                   (USART_CR2_SWAP)      /*!< TX and RX pins functions are swapped.             */
N
N
N/** @defgroup USART_EC_RXPIN_LEVEL RX Pin Active Level Inversion
N  * @{
N  */
N#define MS32_USART_RXPIN_LEVEL_STANDARD           0x00000000U           /*!< RX pin signal works using the standard logic levels */
N#define MS32_USART_RXPIN_LEVEL_INVERTED           (USART_CR2_RXINV)     /*!< RX pin signal values are inverted.                  */
N
N
N/** @defgroup USART_EC_TXPIN_LEVEL TX Pin Active Level Inversion
N  * @{
N  */
N#define MS32_USART_TXPIN_LEVEL_STANDARD           0x00000000U           /*!< TX pin signal works using the standard logic levels */
N#define MS32_USART_TXPIN_LEVEL_INVERTED           (USART_CR2_TXINV)     /*!< TX pin signal values are inverted.                  */
N
N
N/** @defgroup USART_EC_BINARY_LOGIC Binary Data Inversion
N  * @{
N  */
N#define MS32_USART_BINARY_LOGIC_POSITIVE          0x00000000U           /*!< Logical data from the data register are send/received in positive/direct logic. (1=H, 0=L) */
N#define MS32_USART_BINARY_LOGIC_NEGATIVE          USART_CR2_DATAINV     /*!< Logical data from the data register are send/received in negative/inverse logic. (1=L, 0=H). The parity bit is also inverted. */
N
N
N/** @defgroup USART_EC_BITORDER Bit Order
N  * @{
N  */
N#define MS32_USART_BITORDER_LSBFIRST              0x00000000U           /*!< data is transmitted/received with data bit 0 first, following the start bit */
N#define MS32_USART_BITORDER_MSBFIRST              USART_CR2_MSBFIRST    /*!< data is transmitted/received with the MSB first, following the start bit */
N
N
N/** @defgroup USART_EC_AUTOBAUD_DETECT_ON Autobaud Detection
N  * @{
N  */
N#define MS32_USART_AUTOBAUD_DETECT_ON_STARTBIT    0x00000000U                                 /*!< Measurement of the start bit is used to detect the baud rate */
N#define MS32_USART_AUTOBAUD_DETECT_ON_FALLINGEDGE USART_CR2_ABRMODE_0                         /*!< Falling edge to falling edge measurement. Received frame must start with a single bit = 1 -> Frame = Start10xxxxxx */
N#define MS32_USART_AUTOBAUD_DETECT_ON_7F_FRAME    USART_CR2_ABRMODE_1                         /*!< 0x7F frame detection */
N#define MS32_USART_AUTOBAUD_DETECT_ON_55_FRAME    (USART_CR2_ABRMODE_1 | USART_CR2_ABRMODE_0) /*!< 0x55 frame detection */
N
N
N/** @defgroup USART_EC_ADDRESS_DETECT Address Length Detection
N  * @{
N  */
N#define MS32_USART_ADDRESS_DETECT_4B              0x00000000U           /*!< 4-bit address detection method selected */
N#define MS32_USART_ADDRESS_DETECT_7B              USART_CR2_ADDM7       /*!< 7-bit address detection (in 8-bit data mode) method selected */
N
N
N/** @defgroup USART_EC_HWCONTROL Hardware Control
N  * @{
N  */
N#define MS32_USART_HWCONTROL_NONE                 0x00000000U                          /*!< CTS and RTS hardware flow control disabled */
N#define MS32_USART_HWCONTROL_RTS                  USART_CR3_RTSE                       /*!< RTS output enabled, data is only requested when there is space in the receive buffer */
N#define MS32_USART_HWCONTROL_CTS                  USART_CR3_CTSE                       /*!< CTS mode enabled, data is only transmitted when the nCTS input is asserted (tied to 0) */
N#define MS32_USART_HWCONTROL_RTS_CTS              (USART_CR3_RTSE | USART_CR3_CTSE)    /*!< CTS and RTS hardware flow control enabled */
N
N
N/** @defgroup USART_EC_WAKEUP_ON Wakeup Activation
N  * @{
N  */
N#define MS32_USART_WAKEUP_ON_ADDRESS              0x00000000U                             /*!< Wake up active on address match */
N#define MS32_USART_WAKEUP_ON_STARTBIT             USART_CR3_WUS_1                         /*!< Wake up active on Start bit detection */
N#define MS32_USART_WAKEUP_ON_RXNE                 (USART_CR3_WUS_0 | USART_CR3_WUS_1)     /*!< Wake up active on RXNE */
N
N
N/** @defgroup USART_EC_IRDA_POWER IrDA Power
N  * @{
N  */
N#define MS32_USART_IRDA_POWER_NORMAL              0x00000000U           /*!< IrDA normal power mode */
N#define MS32_USART_IRDA_POWER_LOW                 USART_CR3_IRLP        /*!< IrDA low power mode */
N
N
N/** @defgroup USART_EC_LINBREAK_DETECT LIN Break Detection Length
N  * @{
N  */
N#define MS32_USART_LINBREAK_DETECT_10B            0x00000000U           /*!< 10-bit break detection method selected */
N#define MS32_USART_LINBREAK_DETECT_11B            USART_CR2_LBDL        /*!< 11-bit break detection method selected */
N
N
N/** @defgroup USART_EC_DE_POLARITY Driver Enable Polarity
N  * @{
N  */
N#define MS32_USART_DE_POLARITY_HIGH               0x00000000U           /*!< DE signal is active high */
N#define MS32_USART_DE_POLARITY_LOW                USART_CR3_DEP         /*!< DE signal is active low */
N
N
N/** @defgroup USART_EC_DMA_REG_DATA DMA Register Data
N  * @{
N  */
N#define MS32_USART_DMA_REG_DATA_TRANSMIT          0x00000000U          /*!< Get address of data register used for transmission */
N#define MS32_USART_DMA_REG_DATA_RECEIVE           0x00000001U          /*!< Get address of data register used for reception */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup USART_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in USART register
N  * @param  __INSTANCE__ USART Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_USART_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in USART register
N  * @param  __INSTANCE__ USART Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_USART_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N
N
N/** @defgroup USART_EM_Exported_Macros_Helper Exported_Macros_Helper
N  * @{
N  */
N
N/**
N  * @brief  Compute USARTDIV value according to Peripheral Clock and
N  *         expected Baud Rate in 8 bits sampling mode (32 bits value of USARTDIV is returned)
N  * @param  __PERIPHCLK__ Peripheral Clock frequency used for USART instance
N  * @param  __BAUDRATE__ Baud rate value to achieve
N  * @retval USARTDIV value to be used for BRR register filling in OverSampling_8 case
N  */
N#define __MS32_USART_DIV_SAMPLING8(__PERIPHCLK__, __BAUDRATE__) ((((__PERIPHCLK__)*2U)\
N                                                                + ((__BAUDRATE__)/2U))/(__BAUDRATE__))
X#define __MS32_USART_DIV_SAMPLING8(__PERIPHCLK__, __BAUDRATE__) ((((__PERIPHCLK__)*2U)                                                                + ((__BAUDRATE__)/2U))/(__BAUDRATE__))
N
N/**
N  * @brief  Compute USARTDIV value according to Peripheral Clock and
N  *         expected Baud Rate in 16 bits sampling mode (32 bits value of USARTDIV is returned)
N  * @param  __PERIPHCLK__ Peripheral Clock frequency used for USART instance
N  * @param  __BAUDRATE__ Baud rate value to achieve
N  * @retval USARTDIV value to be used for BRR register filling in OverSampling_16 case
N  */
N#define __MS32_USART_DIV_SAMPLING16(__PERIPHCLK__, __BAUDRATE__) (((__PERIPHCLK__) + ((__BAUDRATE__)/2U))/(__BAUDRATE__))
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup USART_EF_Configuration Configuration functions
N  * @{
N  */
N
N/**
N  * @brief  USART Enable
N  * @rmtoll CR1          UE            MS32_USART_Enable
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_Enable(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_Enable(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR1, USART_CR1_UE);
X  ((USARTx->CR1) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  USART Disable (all USART prescalers and outputs are disabled)
N  * @note   When USART is disabled, USART prescalers and outputs are stopped immediately,
N  *         and current operations are discarded. The configuration of the USART is kept, but all the status
N  *         flags, in the USARTx_ISR are set to their default values.
N  * @rmtoll CR1          UE            MS32_USART_Disable
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_Disable(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_Disable(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR1, USART_CR1_UE);
X  ((USARTx->CR1) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Indicate if USART is enabled
N  * @rmtoll CR1          UE            MS32_USART_IsEnabled
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabled(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabled(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR1, USART_CR1_UE) == (USART_CR1_UE)) ? 1UL : 0UL);
X  return ((((USARTx->CR1) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  USART enabled in STOP Mode.
N  * @note   When this function is enabled, USART is able to wake up the MCU from Stop mode, provided that
N  *         USART clock selection is HSI or LSE in RCC.
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR1          UESM          MS32_USART_EnableInStopMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableInStopMode(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableInStopMode(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR1, USART_CR1_UESM);
X  ((USARTx->CR1) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  USART disabled in STOP Mode.
N  * @note   When this function is disabled, USART is not able to wake up the MCU from Stop mode
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR1          UESM          MS32_USART_DisableInStopMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableInStopMode(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableInStopMode(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR1, USART_CR1_UESM);
X  ((USARTx->CR1) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Indicate if USART is enabled in STOP Mode (able to wake up MCU from Stop mode or not)
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR1          UESM          MS32_USART_IsEnabledInStopMode
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledInStopMode(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledInStopMode(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR1, USART_CR1_UESM) == (USART_CR1_UESM)) ? 1UL : 0UL);
X  return ((((USARTx->CR1) & ((0x1UL << (1U)))) == ((0x1UL << (1U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Receiver Enable (Receiver is enabled and begins searching for a start bit)
N  * @rmtoll CR1          RE            MS32_USART_EnableDirectionRx
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableDirectionRx(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableDirectionRx(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR1, USART_CR1_RE);
X  ((USARTx->CR1) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Receiver Disable
N  * @rmtoll CR1          RE            MS32_USART_DisableDirectionRx
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableDirectionRx(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableDirectionRx(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR1, USART_CR1_RE);
X  ((USARTx->CR1) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Transmitter Enable
N  * @rmtoll CR1          TE            MS32_USART_EnableDirectionTx
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableDirectionTx(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableDirectionTx(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR1, USART_CR1_TE);
X  ((USARTx->CR1) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Transmitter Disable
N  * @rmtoll CR1          TE            MS32_USART_DisableDirectionTx
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableDirectionTx(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableDirectionTx(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR1, USART_CR1_TE);
X  ((USARTx->CR1) &= ~((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Configure simultaneously enabled/disabled states
N  *         of Transmitter and Receiver
N  * @rmtoll CR1          RE            MS32_USART_SetTransferDirection\n
N  *         CR1          TE            MS32_USART_SetTransferDirection
N  * @param  USARTx USART Instance
N  * @param  TransferDirection This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_DIRECTION_NONE
N  *         @arg @ref MS32_USART_DIRECTION_RX
N  *         @arg @ref MS32_USART_DIRECTION_TX
N  *         @arg @ref MS32_USART_DIRECTION_TX_RX
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetTransferDirection(USART_TypeDef *USARTx, uint32_t TransferDirection) {
Xstatic __inline void MS32_USART_SetTransferDirection(USART_TypeDef *USARTx, uint32_t TransferDirection) {
N  MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x1UL << (2U)) | (0x1UL << (3U))))) | (TransferDirection))));
N}
N
N/**
N  * @brief  Return enabled/disabled states of Transmitter and Receiver
N  * @rmtoll CR1          RE            MS32_USART_GetTransferDirection\n
N  *         CR1          TE            MS32_USART_GetTransferDirection
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_DIRECTION_NONE
N  *         @arg @ref MS32_USART_DIRECTION_RX
N  *         @arg @ref MS32_USART_DIRECTION_TX
N  *         @arg @ref MS32_USART_DIRECTION_TX_RX
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetTransferDirection(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetTransferDirection(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_RE | USART_CR1_TE));
X  return (uint32_t)(((USARTx->CR1) & ((0x1UL << (2U)) | (0x1UL << (3U)))));
N}
N
N/**
N  * @brief  Configure Parity (enabled/disabled and parity mode if enabled).
N  * @note   This function selects if hardware parity control (generation and detection) is enabled or disabled.
N  *         When the parity control is enabled (Odd or Even), computed parity bit is inserted at the MSB position
N  *         (9th or 8th bit depending on data width) and parity is checked on the received data.
N  * @rmtoll CR1          PS            MS32_USART_SetParity\n
N  *         CR1          PCE           MS32_USART_SetParity
N  * @param  USARTx USART Instance
N  * @param  Parity This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_PARITY_NONE
N  *         @arg @ref MS32_USART_PARITY_EVEN
N  *         @arg @ref MS32_USART_PARITY_ODD
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetParity(USART_TypeDef *USARTx, uint32_t Parity) {
Xstatic __inline void MS32_USART_SetParity(USART_TypeDef *USARTx, uint32_t Parity) {
N  MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE, Parity);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x1UL << (9U)) | (0x1UL << (10U))))) | (Parity))));
N}
N
N/**
N  * @brief  Return Parity configuration (enabled/disabled and parity mode if enabled)
N  * @rmtoll CR1          PS            MS32_USART_GetParity\n
N  *         CR1          PCE           MS32_USART_GetParity
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_PARITY_NONE
N  *         @arg @ref MS32_USART_PARITY_EVEN
N  *         @arg @ref MS32_USART_PARITY_ODD
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetParity(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetParity(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE));
X  return (uint32_t)(((USARTx->CR1) & ((0x1UL << (9U)) | (0x1UL << (10U)))));
N}
N
N/**
N  * @brief  Set Receiver Wake Up method from Mute mode.
N  * @rmtoll CR1          WAKE          MS32_USART_SetWakeUpMethod
N  * @param  USARTx USART Instance
N  * @param  Method This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_WAKEUP_IDLELINE
N  *         @arg @ref MS32_USART_WAKEUP_ADDRESSMARK
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetWakeUpMethod(USART_TypeDef *USARTx, uint32_t Method) {
Xstatic __inline void MS32_USART_SetWakeUpMethod(USART_TypeDef *USARTx, uint32_t Method) {
N  MODIFY_REG(USARTx->CR1, USART_CR1_WAKE, Method);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x1UL << (11U))))) | (Method))));
N}
N
N/**
N  * @brief  Return Receiver Wake Up method from Mute mode
N  * @rmtoll CR1          WAKE          MS32_USART_GetWakeUpMethod
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_WAKEUP_IDLELINE
N  *         @arg @ref MS32_USART_WAKEUP_ADDRESSMARK
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetWakeUpMethod(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetWakeUpMethod(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_WAKE));
X  return (uint32_t)(((USARTx->CR1) & ((0x1UL << (11U)))));
N}
N
N/**
N  * @brief  Set Word length (i.e. nb of data bits, excluding start and stop bits)
N  * @rmtoll CR1          M0            MS32_USART_SetDataWidth\n
N  *         CR1          M1            MS32_USART_SetDataWidth
N  * @param  USARTx USART Instance
N  * @param  DataWidth This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_DATAWIDTH_7B (*)
N  *         @arg @ref MS32_USART_DATAWIDTH_8B
N  *         @arg @ref MS32_USART_DATAWIDTH_9B
N  *
N  *         (*) Values not available on all devices
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetDataWidth(USART_TypeDef *USARTx, uint32_t DataWidth) {
Xstatic __inline void MS32_USART_SetDataWidth(USART_TypeDef *USARTx, uint32_t DataWidth) {
N  MODIFY_REG(USARTx->CR1, USART_CR1_M, DataWidth);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x1UL << (12U))))) | (DataWidth))));
N}
N
N/**
N  * @brief  Return Word length (i.e. nb of data bits, excluding start and stop bits)
N  * @rmtoll CR1          M0            MS32_USART_GetDataWidth\n
N  *         CR1          M1            MS32_USART_GetDataWidth
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_DATAWIDTH_7B (*)
N  *         @arg @ref MS32_USART_DATAWIDTH_8B
N  *         @arg @ref MS32_USART_DATAWIDTH_9B
N  *
N  *         (*) Values not available on all devices
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetDataWidth(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetDataWidth(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_M));
X  return (uint32_t)(((USARTx->CR1) & ((0x1UL << (12U)))));
N}
N
N/**
N  * @brief  Allow switch between Mute Mode and Active mode
N  * @rmtoll CR1          MME           MS32_USART_EnableMuteMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableMuteMode(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableMuteMode(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR1, USART_CR1_MME);
X  ((USARTx->CR1) |= ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Prevent Mute Mode use. Set Receiver in active mode permanently.
N  * @rmtoll CR1          MME           MS32_USART_DisableMuteMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableMuteMode(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableMuteMode(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR1, USART_CR1_MME);
X  ((USARTx->CR1) &= ~((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Indicate if switch between Mute Mode and Active mode is allowed
N  * @rmtoll CR1          MME           MS32_USART_IsEnabledMuteMode
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledMuteMode(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledMuteMode(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR1, USART_CR1_MME) == (USART_CR1_MME)) ? 1UL : 0UL);
X  return ((((USARTx->CR1) & ((0x1UL << (13U)))) == ((0x1UL << (13U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set Oversampling to 8-bit or 16-bit mode
N  * @rmtoll CR1          OVER8         MS32_USART_SetOverSampling
N  * @param  USARTx USART Instance
N  * @param  OverSampling This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_OVERSAMPLING_16
N  *         @arg @ref MS32_USART_OVERSAMPLING_8
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetOverSampling(USART_TypeDef *USARTx, uint32_t OverSampling) {
Xstatic __inline void MS32_USART_SetOverSampling(USART_TypeDef *USARTx, uint32_t OverSampling) {
N  MODIFY_REG(USARTx->CR1, USART_CR1_OVER8, OverSampling);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x1UL << (15U))))) | (OverSampling))));
N}
N
N/**
N  * @brief  Return Oversampling mode
N  * @rmtoll CR1          OVER8         MS32_USART_GetOverSampling
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_OVERSAMPLING_16
N  *         @arg @ref MS32_USART_OVERSAMPLING_8
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetOverSampling(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetOverSampling(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_OVER8));
X  return (uint32_t)(((USARTx->CR1) & ((0x1UL << (15U)))));
N}
N
N/**
N  * @brief  Configure if Clock pulse of the last data bit is output to the SCLK pin or not
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          LBCL          MS32_USART_SetLastClkPulseOutput
N  * @param  USARTx USART Instance
N  * @param  LastBitClockPulse This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_LASTCLKPULSE_NO_OUTPUT
N  *         @arg @ref MS32_USART_LASTCLKPULSE_OUTPUT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetLastClkPulseOutput(USART_TypeDef *USARTx, uint32_t LastBitClockPulse) {
Xstatic __inline void MS32_USART_SetLastClkPulseOutput(USART_TypeDef *USARTx, uint32_t LastBitClockPulse) {
N  MODIFY_REG(USARTx->CR2, USART_CR2_LBCL, LastBitClockPulse);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (8U))))) | (LastBitClockPulse))));
N}
N
N/**
N  * @brief  Retrieve Clock pulse of the last data bit output configuration
N  *         (Last bit Clock pulse output to the SCLK pin or not)
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          LBCL          MS32_USART_GetLastClkPulseOutput
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_LASTCLKPULSE_NO_OUTPUT
N  *         @arg @ref MS32_USART_LASTCLKPULSE_OUTPUT
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetLastClkPulseOutput(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetLastClkPulseOutput(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_LBCL));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (8U)))));
N}
N
N/**
N  * @brief  Select the phase of the clock output on the SCLK pin in synchronous mode
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          CPHA          MS32_USART_SetClockPhase
N  * @param  USARTx USART Instance
N  * @param  ClockPhase This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_PHASE_1EDGE
N  *         @arg @ref MS32_USART_PHASE_2EDGE
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetClockPhase(USART_TypeDef *USARTx, uint32_t ClockPhase) {
Xstatic __inline void MS32_USART_SetClockPhase(USART_TypeDef *USARTx, uint32_t ClockPhase) {
N  MODIFY_REG(USARTx->CR2, USART_CR2_CPHA, ClockPhase);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (9U))))) | (ClockPhase))));
N}
N
N/**
N  * @brief  Return phase of the clock output on the SCLK pin in synchronous mode
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          CPHA          MS32_USART_GetClockPhase
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_PHASE_1EDGE
N  *         @arg @ref MS32_USART_PHASE_2EDGE
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetClockPhase(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetClockPhase(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_CPHA));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (9U)))));
N}
N
N/**
N  * @brief  Select the polarity of the clock output on the SCLK pin in synchronous mode
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          CPOL          MS32_USART_SetClockPolarity
N  * @param  USARTx USART Instance
N  * @param  ClockPolarity This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_POLARITY_LOW
N  *         @arg @ref MS32_USART_POLARITY_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetClockPolarity(USART_TypeDef *USARTx, uint32_t ClockPolarity) {
Xstatic __inline void MS32_USART_SetClockPolarity(USART_TypeDef *USARTx, uint32_t ClockPolarity) {
N  MODIFY_REG(USARTx->CR2, USART_CR2_CPOL, ClockPolarity);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (10U))))) | (ClockPolarity))));
N}
N
N/**
N  * @brief  Return polarity of the clock output on the SCLK pin in synchronous mode
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          CPOL          MS32_USART_GetClockPolarity
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_POLARITY_LOW
N  *         @arg @ref MS32_USART_POLARITY_HIGH
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetClockPolarity(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetClockPolarity(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_CPOL));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (10U)))));
N}
N
N/**
N  * @brief  Configure Clock signal format (Phase Polarity and choice about output of last bit clock pulse)
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clock Phase configuration using @ref MS32_USART_SetClockPhase() function
N  *         - Clock Polarity configuration using @ref MS32_USART_SetClockPolarity() function
N  *         - Output of Last bit Clock pulse configuration using @ref MS32_USART_SetLastClkPulseOutput() function
N  * @rmtoll CR2          CPHA          MS32_USART_ConfigClock\n
N  *         CR2          CPOL          MS32_USART_ConfigClock\n
N  *         CR2          LBCL          MS32_USART_ConfigClock
N  * @param  USARTx USART Instance
N  * @param  Phase This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_PHASE_1EDGE
N  *         @arg @ref MS32_USART_PHASE_2EDGE
N  * @param  Polarity This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_POLARITY_LOW
N  *         @arg @ref MS32_USART_POLARITY_HIGH
N  * @param  LBCPOutput This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_LASTCLKPULSE_NO_OUTPUT
N  *         @arg @ref MS32_USART_LASTCLKPULSE_OUTPUT
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ConfigClock(USART_TypeDef *USARTx, uint32_t Phase, uint32_t Polarity, uint32_t LBCPOutput) {
Xstatic __inline void MS32_USART_ConfigClock(USART_TypeDef *USARTx, uint32_t Phase, uint32_t Polarity, uint32_t LBCPOutput) {
N  MODIFY_REG(USARTx->CR2, USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_LBCL, Phase | Polarity | LBCPOutput);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (9U)) | (0x1UL << (10U)) | (0x1UL << (8U))))) | (Phase | Polarity | LBCPOutput))));
N}
N
N/**
N  * @brief  Enable Clock output on SCLK pin
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          CLKEN         MS32_USART_EnableSCLKOutput
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableSCLKOutput(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableSCLKOutput(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR2, USART_CR2_CLKEN);
X  ((USARTx->CR2) |= ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Disable Clock output on SCLK pin
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          CLKEN         MS32_USART_DisableSCLKOutput
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableSCLKOutput(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableSCLKOutput(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR2, USART_CR2_CLKEN);
X  ((USARTx->CR2) &= ~((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Indicate if Clock output on SCLK pin is enabled
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          CLKEN         MS32_USART_IsEnabledSCLKOutput
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledSCLKOutput(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledSCLKOutput(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR2, USART_CR2_CLKEN) == (USART_CR2_CLKEN)) ? 1UL : 0UL);
X  return ((((USARTx->CR2) & ((0x1UL << (11U)))) == ((0x1UL << (11U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set the length of the stop bits
N  * @rmtoll CR2          STOP          MS32_USART_SetStopBitsLength
N  * @param  USARTx USART Instance
N  * @param  StopBits This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_STOPBITS_0_5 (*)
N  *         @arg @ref MS32_USART_STOPBITS_1
N  *         @arg @ref MS32_USART_STOPBITS_1_5 (*)
N  *         @arg @ref MS32_USART_STOPBITS_2
N  *
N  *         (*) Values not available on all devices
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetStopBitsLength(USART_TypeDef *USARTx, uint32_t StopBits) {
Xstatic __inline void MS32_USART_SetStopBitsLength(USART_TypeDef *USARTx, uint32_t StopBits) {
N  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x3UL << (12U))))) | (StopBits))));
N}
N
N/**
N  * @brief  Retrieve the length of the stop bits
N  * @rmtoll CR2          STOP          MS32_USART_GetStopBitsLength
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_STOPBITS_0_5 (*)
N  *         @arg @ref MS32_USART_STOPBITS_1
N  *         @arg @ref MS32_USART_STOPBITS_1_5 (*)
N  *         @arg @ref MS32_USART_STOPBITS_2
N  *
N  *         (*) Values not available on all devices
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetStopBitsLength(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetStopBitsLength(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_STOP));
X  return (uint32_t)(((USARTx->CR2) & ((0x3UL << (12U)))));
N}
N
N/**
N  * @brief  Configure Character frame format (Datawidth, Parity control, Stop Bits)
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Data Width configuration using @ref MS32_USART_SetDataWidth() function
N  *         - Parity Control and mode configuration using @ref MS32_USART_SetParity() function
N  *         - Stop bits configuration using @ref MS32_USART_SetStopBitsLength() function
N  * @rmtoll CR1          PS            MS32_USART_ConfigCharacter\n
N  *         CR1          PCE           MS32_USART_ConfigCharacter\n
N  *         CR1          M0            MS32_USART_ConfigCharacter\n
N  *         CR1          M1            MS32_USART_ConfigCharacter\n
N  *         CR2          STOP          MS32_USART_ConfigCharacter
N  * @param  USARTx USART Instance
N  * @param  DataWidth This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_DATAWIDTH_7B (*)
N  *         @arg @ref MS32_USART_DATAWIDTH_8B
N  *         @arg @ref MS32_USART_DATAWIDTH_9B
N  * @param  Parity This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_PARITY_NONE
N  *         @arg @ref MS32_USART_PARITY_EVEN
N  *         @arg @ref MS32_USART_PARITY_ODD
N  * @param  StopBits This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_STOPBITS_0_5 (*)
N  *         @arg @ref MS32_USART_STOPBITS_1
N  *         @arg @ref MS32_USART_STOPBITS_1_5 (*)
N  *         @arg @ref MS32_USART_STOPBITS_2
N  *
N  *         (*) Values not available on all devices
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ConfigCharacter(USART_TypeDef *USARTx, uint32_t DataWidth, uint32_t Parity,
Xstatic __inline void MS32_USART_ConfigCharacter(USART_TypeDef *USARTx, uint32_t DataWidth, uint32_t Parity,
N                                              uint32_t StopBits) {
N  MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE | USART_CR1_M, Parity | DataWidth);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x1UL << (9U)) | (0x1UL << (10U)) | (0x1UL << (12U))))) | (Parity | DataWidth))));
N  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x3UL << (12U))))) | (StopBits))));
N}
N
N/**
N  * @brief  Configure TX/RX pins swapping setting.
N  * @rmtoll CR2          SWAP          MS32_USART_SetTXRXSwap
N  * @param  USARTx USART Instance
N  * @param  SwapConfig This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_TXRX_STANDARD
N  *         @arg @ref MS32_USART_TXRX_SWAPPED
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetTXRXSwap(USART_TypeDef *USARTx, uint32_t SwapConfig) {
Xstatic __inline void MS32_USART_SetTXRXSwap(USART_TypeDef *USARTx, uint32_t SwapConfig) {
N  MODIFY_REG(USARTx->CR2, USART_CR2_SWAP, SwapConfig);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (15U))))) | (SwapConfig))));
N}
N
N/**
N  * @brief  Retrieve TX/RX pins swapping configuration.
N  * @rmtoll CR2          SWAP          MS32_USART_GetTXRXSwap
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_TXRX_STANDARD
N  *         @arg @ref MS32_USART_TXRX_SWAPPED
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetTXRXSwap(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetTXRXSwap(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_SWAP));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (15U)))));
N}
N
N/**
N  * @brief  Configure RX pin active level logic
N  * @rmtoll CR2          RXINV         MS32_USART_SetRXPinLevel
N  * @param  USARTx USART Instance
N  * @param  PinInvMethod This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_RXPIN_LEVEL_STANDARD
N  *         @arg @ref MS32_USART_RXPIN_LEVEL_INVERTED
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetRXPinLevel(USART_TypeDef *USARTx, uint32_t PinInvMethod) {
Xstatic __inline void MS32_USART_SetRXPinLevel(USART_TypeDef *USARTx, uint32_t PinInvMethod) {
N  MODIFY_REG(USARTx->CR2, USART_CR2_RXINV, PinInvMethod);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (16U))))) | (PinInvMethod))));
N}
N
N/**
N  * @brief  Retrieve RX pin active level logic configuration
N  * @rmtoll CR2          RXINV         MS32_USART_GetRXPinLevel
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_RXPIN_LEVEL_STANDARD
N  *         @arg @ref MS32_USART_RXPIN_LEVEL_INVERTED
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetRXPinLevel(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetRXPinLevel(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_RXINV));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (16U)))));
N}
N
N/**
N  * @brief  Configure TX pin active level logic
N  * @rmtoll CR2          TXINV         MS32_USART_SetTXPinLevel
N  * @param  USARTx USART Instance
N  * @param  PinInvMethod This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_TXPIN_LEVEL_STANDARD
N  *         @arg @ref MS32_USART_TXPIN_LEVEL_INVERTED
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetTXPinLevel(USART_TypeDef *USARTx, uint32_t PinInvMethod) {
Xstatic __inline void MS32_USART_SetTXPinLevel(USART_TypeDef *USARTx, uint32_t PinInvMethod) {
N  MODIFY_REG(USARTx->CR2, USART_CR2_TXINV, PinInvMethod);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (17U))))) | (PinInvMethod))));
N}
N
N/**
N  * @brief  Retrieve TX pin active level logic configuration
N  * @rmtoll CR2          TXINV         MS32_USART_GetTXPinLevel
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_TXPIN_LEVEL_STANDARD
N  *         @arg @ref MS32_USART_TXPIN_LEVEL_INVERTED
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetTXPinLevel(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetTXPinLevel(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_TXINV));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (17U)))));
N}
N
N/**
N  * @brief  Configure Binary data logic.
N  * @note   Allow to define how Logical data from the data register are send/received :
N  *         either in positive/direct logic (1=H, 0=L) or in negative/inverse logic (1=L, 0=H)
N  * @rmtoll CR2          DATAINV       MS32_USART_SetBinaryDataLogic
N  * @param  USARTx USART Instance
N  * @param  DataLogic This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_BINARY_LOGIC_POSITIVE
N  *         @arg @ref MS32_USART_BINARY_LOGIC_NEGATIVE
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetBinaryDataLogic(USART_TypeDef *USARTx, uint32_t DataLogic) {
Xstatic __inline void MS32_USART_SetBinaryDataLogic(USART_TypeDef *USARTx, uint32_t DataLogic) {
N  MODIFY_REG(USARTx->CR2, USART_CR2_DATAINV, DataLogic);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (18U))))) | (DataLogic))));
N}
N
N/**
N  * @brief  Retrieve Binary data configuration
N  * @rmtoll CR2          DATAINV       MS32_USART_GetBinaryDataLogic
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_BINARY_LOGIC_POSITIVE
N  *         @arg @ref MS32_USART_BINARY_LOGIC_NEGATIVE
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetBinaryDataLogic(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetBinaryDataLogic(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_DATAINV));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (18U)))));
N}
N
N/**
N  * @brief  Configure transfer bit order (either Less or Most Significant Bit First)
N  * @note   MSB First means data is transmitted/received with the MSB first, following the start bit.
N  *         LSB First means data is transmitted/received with data bit 0 first, following the start bit.
N  * @rmtoll CR2          MSBFIRST      MS32_USART_SetTransferBitOrder
N  * @param  USARTx USART Instance
N  * @param  BitOrder This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_BITORDER_LSBFIRST
N  *         @arg @ref MS32_USART_BITORDER_MSBFIRST
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetTransferBitOrder(USART_TypeDef *USARTx, uint32_t BitOrder) {
Xstatic __inline void MS32_USART_SetTransferBitOrder(USART_TypeDef *USARTx, uint32_t BitOrder) {
N  MODIFY_REG(USARTx->CR2, USART_CR2_MSBFIRST, BitOrder);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (19U))))) | (BitOrder))));
N}
N
N/**
N  * @brief  Return transfer bit order (either Less or Most Significant Bit First)
N  * @note   MSB First means data is transmitted/received with the MSB first, following the start bit.
N  *         LSB First means data is transmitted/received with data bit 0 first, following the start bit.
N  * @rmtoll CR2          MSBFIRST      MS32_USART_GetTransferBitOrder
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_BITORDER_LSBFIRST
N  *         @arg @ref MS32_USART_BITORDER_MSBFIRST
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetTransferBitOrder(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetTransferBitOrder(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_MSBFIRST));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (19U)))));
N}
N
N/**
N  * @brief  Enable Auto Baud-Rate Detection
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll CR2          ABREN         MS32_USART_EnableAutoBaudRate
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableAutoBaudRate(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableAutoBaudRate(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR2, USART_CR2_ABREN);
X  ((USARTx->CR2) |= ((0x1UL << (20U))));
N}
N
N/**
N  * @brief  Disable Auto Baud-Rate Detection
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll CR2          ABREN         MS32_USART_DisableAutoBaudRate
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableAutoBaudRate(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableAutoBaudRate(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR2, USART_CR2_ABREN);
X  ((USARTx->CR2) &= ~((0x1UL << (20U))));
N}
N
N/**
N  * @brief  Indicate if Auto Baud-Rate Detection mechanism is enabled
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll CR2          ABREN         MS32_USART_IsEnabledAutoBaud
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledAutoBaud(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledAutoBaud(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR2, USART_CR2_ABREN) == (USART_CR2_ABREN)) ? 1UL : 0UL);
X  return ((((USARTx->CR2) & ((0x1UL << (20U)))) == ((0x1UL << (20U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set Auto Baud-Rate mode bits
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll CR2          ABRMODE       MS32_USART_SetAutoBaudRateMode
N  * @param  USARTx USART Instance
N  * @param  AutoBaudRateMode This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_AUTOBAUD_DETECT_ON_STARTBIT
N  *         @arg @ref MS32_USART_AUTOBAUD_DETECT_ON_FALLINGEDGE
N  *         @arg @ref MS32_USART_AUTOBAUD_DETECT_ON_7F_FRAME (*)
N  *         @arg @ref MS32_USART_AUTOBAUD_DETECT_ON_55_FRAME (*)
N  *
N  *         (*) Values not available on all devices
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetAutoBaudRateMode(USART_TypeDef *USARTx, uint32_t AutoBaudRateMode) {
Xstatic __inline void MS32_USART_SetAutoBaudRateMode(USART_TypeDef *USARTx, uint32_t AutoBaudRateMode) {
N  MODIFY_REG(USARTx->CR2, USART_CR2_ABRMODE, AutoBaudRateMode);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x3UL << (21U))))) | (AutoBaudRateMode))));
N}
N
N/**
N  * @brief  Return Auto Baud-Rate mode
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll CR2          ABRMODE       MS32_USART_GetAutoBaudRateMode
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_AUTOBAUD_DETECT_ON_STARTBIT
N  *         @arg @ref MS32_USART_AUTOBAUD_DETECT_ON_FALLINGEDGE
N  *         @arg @ref MS32_USART_AUTOBAUD_DETECT_ON_7F_FRAME (*)
N  *         @arg @ref MS32_USART_AUTOBAUD_DETECT_ON_55_FRAME (*)
N  *
N  *         (*) Values not available on all devices
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetAutoBaudRateMode(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetAutoBaudRateMode(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_ABRMODE));
X  return (uint32_t)(((USARTx->CR2) & ((0x3UL << (21U)))));
N}
N
N/**
N  * @brief  Enable Receiver Timeout
N  * @rmtoll CR2          RTOEN         MS32_USART_EnableRxTimeout
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableRxTimeout(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableRxTimeout(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR2, USART_CR2_RTOEN);
X  ((USARTx->CR2) |= ((0x1UL << (23U))));
N}
N
N/**
N  * @brief  Disable Receiver Timeout
N  * @rmtoll CR2          RTOEN         MS32_USART_DisableRxTimeout
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableRxTimeout(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableRxTimeout(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR2, USART_CR2_RTOEN);
X  ((USARTx->CR2) &= ~((0x1UL << (23U))));
N}
N
N/**
N  * @brief  Indicate if Receiver Timeout feature is enabled
N  * @rmtoll CR2          RTOEN         MS32_USART_IsEnabledRxTimeout
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledRxTimeout(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledRxTimeout(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR2, USART_CR2_RTOEN) == (USART_CR2_RTOEN)) ? 1UL : 0UL);
X  return ((((USARTx->CR2) & ((0x1UL << (23U)))) == ((0x1UL << (23U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set Address of the USART node.
N  * @note   This is used in multiprocessor communication during Mute mode or Stop mode,
N  *         for wake up with address mark detection.
N  * @note   4bits address node is used when 4-bit Address Detection is selected in ADDM7.
N  *         (b7-b4 should be set to 0)
N  *         8bits address node is used when 7-bit Address Detection is selected in ADDM7.
N  *         (This is used in multiprocessor communication during Mute mode or Stop mode,
N  *         for wake up with 7-bit address mark detection.
N  *         The MSB of the character sent by the transmitter should be equal to 1.
N  *         It may also be used for character detection during normal reception,
N  *         Mute mode inactive (for example, end of block detection in ModBus protocol).
N  *         In this case, the whole received character (8-bit) is compared to the ADD[7:0]
N  *         value and CMF flag is set on match)
N  * @rmtoll CR2          ADD           MS32_USART_ConfigNodeAddress\n
N  *         CR2          ADDM7         MS32_USART_ConfigNodeAddress
N  * @param  USARTx USART Instance
N  * @param  AddressLen This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_ADDRESS_DETECT_4B
N  *         @arg @ref MS32_USART_ADDRESS_DETECT_7B
N  * @param  NodeAddress 4 or 7 bit Address of the USART node.
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ConfigNodeAddress(USART_TypeDef *USARTx, uint32_t AddressLen, uint32_t NodeAddress) {
Xstatic __inline void MS32_USART_ConfigNodeAddress(USART_TypeDef *USARTx, uint32_t AddressLen, uint32_t NodeAddress) {
N  MODIFY_REG(USARTx->CR2, USART_CR2_ADD | USART_CR2_ADDM7,
N             (uint32_t)(AddressLen | (NodeAddress << USART_CR2_ADD_Pos)));
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0xFFUL << (24U)) | (0x1UL << (4U))))) | ((uint32_t)(AddressLen | (NodeAddress << (24U)))))));
N}
N
N/**
N  * @brief  Return 8 bit Address of the USART node as set in ADD field of CR2.
N  * @note   If 4-bit Address Detection is selected in ADDM7,
N  *         only 4bits (b3-b0) of returned value are relevant (b31-b4 are not relevant)
N  *         If 7-bit Address Detection is selected in ADDM7,
N  *         only 8bits (b7-b0) of returned value are relevant (b31-b8 are not relevant)
N  * @rmtoll CR2          ADD           MS32_USART_GetNodeAddress
N  * @param  USARTx USART Instance
N  * @retval Address of the USART node (Value between Min_Data=0 and Max_Data=255)
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetNodeAddress(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetNodeAddress(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_ADD) >> USART_CR2_ADD_Pos);
X  return (uint32_t)(((USARTx->CR2) & ((0xFFUL << (24U)))) >> (24U));
N}
N
N/**
N  * @brief  Return Length of Node Address used in Address Detection mode (7-bit or 4-bit)
N  * @rmtoll CR2          ADDM7         MS32_USART_GetNodeAddressLen
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_ADDRESS_DETECT_4B
N  *         @arg @ref MS32_USART_ADDRESS_DETECT_7B
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetNodeAddressLen(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetNodeAddressLen(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_ADDM7));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (4U)))));
N}
N
N/**
N  * @brief  Enable RTS HW Flow Control
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          RTSE          MS32_USART_EnableRTSHWFlowCtrl
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableRTSHWFlowCtrl(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableRTSHWFlowCtrl(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR3, USART_CR3_RTSE);
X  ((USARTx->CR3) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable RTS HW Flow Control
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          RTSE          MS32_USART_DisableRTSHWFlowCtrl
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableRTSHWFlowCtrl(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableRTSHWFlowCtrl(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR3, USART_CR3_RTSE);
X  ((USARTx->CR3) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Enable CTS HW Flow Control
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          CTSE          MS32_USART_EnableCTSHWFlowCtrl
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableCTSHWFlowCtrl(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableCTSHWFlowCtrl(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR3, USART_CR3_CTSE);
X  ((USARTx->CR3) |= ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Disable CTS HW Flow Control
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          CTSE          MS32_USART_DisableCTSHWFlowCtrl
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableCTSHWFlowCtrl(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableCTSHWFlowCtrl(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR3, USART_CR3_CTSE);
X  ((USARTx->CR3) &= ~((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Configure HW Flow Control mode (both CTS and RTS)
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          RTSE          MS32_USART_SetHWFlowCtrl\n
N  *         CR3          CTSE          MS32_USART_SetHWFlowCtrl
N  * @param  USARTx USART Instance
N  * @param  HardwareFlowControl This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_HWCONTROL_NONE
N  *         @arg @ref MS32_USART_HWCONTROL_RTS
N  *         @arg @ref MS32_USART_HWCONTROL_CTS
N  *         @arg @ref MS32_USART_HWCONTROL_RTS_CTS
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetHWFlowCtrl(USART_TypeDef *USARTx, uint32_t HardwareFlowControl) {
Xstatic __inline void MS32_USART_SetHWFlowCtrl(USART_TypeDef *USARTx, uint32_t HardwareFlowControl) {
N  MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
X  (((USARTx->CR3)) = ((((((USARTx->CR3))) & (~((0x1UL << (8U)) | (0x1UL << (9U))))) | (HardwareFlowControl))));
N}
N
N/**
N  * @brief  Return HW Flow Control configuration (both CTS and RTS)
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          RTSE          MS32_USART_GetHWFlowCtrl\n
N  *         CR3          CTSE          MS32_USART_GetHWFlowCtrl
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_HWCONTROL_NONE
N  *         @arg @ref MS32_USART_HWCONTROL_RTS
N  *         @arg @ref MS32_USART_HWCONTROL_CTS
N  *         @arg @ref MS32_USART_HWCONTROL_RTS_CTS
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetHWFlowCtrl(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetHWFlowCtrl(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE));
X  return (uint32_t)(((USARTx->CR3) & ((0x1UL << (8U)) | (0x1UL << (9U)))));
N}
N
N/**
N  * @brief  Enable One bit sampling method
N  * @rmtoll CR3          ONEBIT        MS32_USART_EnableOneBitSamp
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableOneBitSamp(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableOneBitSamp(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR3, USART_CR3_ONEBIT);
X  ((USARTx->CR3) |= ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Disable One bit sampling method
N  * @rmtoll CR3          ONEBIT        MS32_USART_DisableOneBitSamp
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableOneBitSamp(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableOneBitSamp(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR3, USART_CR3_ONEBIT);
X  ((USARTx->CR3) &= ~((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Indicate if One bit sampling method is enabled
N  * @rmtoll CR3          ONEBIT        MS32_USART_IsEnabledOneBitSamp
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledOneBitSamp(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledOneBitSamp(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR3, USART_CR3_ONEBIT) == (USART_CR3_ONEBIT)) ? 1UL : 0UL);
X  return ((((USARTx->CR3) & ((0x1UL << (11U)))) == ((0x1UL << (11U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable Overrun detection
N  * @rmtoll CR3          OVRDIS        MS32_USART_EnableOverrunDetect
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableOverrunDetect(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableOverrunDetect(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR3, USART_CR3_OVRDIS);
X  ((USARTx->CR3) &= ~((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Disable Overrun detection
N  * @rmtoll CR3          OVRDIS        MS32_USART_DisableOverrunDetect
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableOverrunDetect(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableOverrunDetect(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR3, USART_CR3_OVRDIS);
X  ((USARTx->CR3) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Indicate if Overrun detection is enabled
N  * @rmtoll CR3          OVRDIS        MS32_USART_IsEnabledOverrunDetect
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledOverrunDetect(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledOverrunDetect(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR3, USART_CR3_OVRDIS) != USART_CR3_OVRDIS) ? 1UL : 0UL);
X  return ((((USARTx->CR3) & ((0x1UL << (12U)))) != (0x1UL << (12U))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Select event type for Wake UP Interrupt Flag (WUS[1:0] bits)
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR3          WUS           MS32_USART_SetWKUPType
N  * @param  USARTx USART Instance
N  * @param  Type This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_WAKEUP_ON_ADDRESS
N  *         @arg @ref MS32_USART_WAKEUP_ON_STARTBIT
N  *         @arg @ref MS32_USART_WAKEUP_ON_RXNE
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetWKUPType(USART_TypeDef *USARTx, uint32_t Type) {
Xstatic __inline void MS32_USART_SetWKUPType(USART_TypeDef *USARTx, uint32_t Type) {
N  MODIFY_REG(USARTx->CR3, USART_CR3_WUS, Type);
X  (((USARTx->CR3)) = ((((((USARTx->CR3))) & (~((0x3UL << (20U))))) | (Type))));
N}
N
N/**
N  * @brief  Return event type for Wake UP Interrupt Flag (WUS[1:0] bits)
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR3          WUS           MS32_USART_GetWKUPType
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_WAKEUP_ON_ADDRESS
N  *         @arg @ref MS32_USART_WAKEUP_ON_STARTBIT
N  *         @arg @ref MS32_USART_WAKEUP_ON_RXNE
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetWKUPType(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetWKUPType(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_WUS));
X  return (uint32_t)(((USARTx->CR3) & ((0x3UL << (20U)))));
N}
N
N/**
N  * @brief  Configure USART BRR register for achieving expected Baud Rate value.
N  * @note   Compute and set USARTDIV value in BRR Register (full BRR content)
N  *         according to used Peripheral Clock, Oversampling mode, and expected Baud Rate values
N  * @note   Peripheral clock and Baud rate values provided as function parameters should be valid
N  *         (Baud rate value != 0)
N  * @note   In case of oversampling by 16 and 8, BRR content must be greater than or equal to 16d.
N  * @rmtoll BRR          BRR           MS32_USART_SetBaudRate
N  * @param  USARTx USART Instance
N  * @param  PeriphClk Peripheral Clock
N  * @param  OverSampling This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_OVERSAMPLING_16
N  *         @arg @ref MS32_USART_OVERSAMPLING_8
N  * @param  BaudRate Baud Rate
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling,
Xstatic __inline void MS32_USART_SetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling,
N                                          uint32_t BaudRate) {
N  uint32_t usartdiv;
N  register uint32_t brrtemp;
N
N  if (OverSampling == MS32_USART_OVERSAMPLING_8)
X  if (OverSampling == (0x1UL << (15U)))
N  {
N    usartdiv = (uint16_t)(__MS32_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
X    usartdiv = (uint16_t)(((((PeriphClk)*2U) + ((BaudRate)/2U))/(BaudRate)));
N    brrtemp = usartdiv & 0xFFF0U;
N    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
N    USARTx->BRR = brrtemp;
N  }
N  else
N  {
N    USARTx->BRR = (uint16_t)(__MS32_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
X    USARTx->BRR = (uint16_t)((((PeriphClk) + ((BaudRate)/2U))/(BaudRate)));
N  }
N}
N
N/**
N  * @brief  Return current Baud Rate value, according to USARTDIV present in BRR register
N  *         (full BRR content), and to used Peripheral Clock and Oversampling mode values
N  * @note   In case of non-initialized or invalid value stored in BRR register, value 0 will be returned.
N  * @note   In case of oversampling by 16 and 8, BRR content must be greater than or equal to 16d.
N  * @rmtoll BRR          BRR           MS32_USART_GetBaudRate
N  * @param  USARTx USART Instance
N  * @param  PeriphClk Peripheral Clock
N  * @param  OverSampling This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_OVERSAMPLING_16
N  *         @arg @ref MS32_USART_OVERSAMPLING_8
N  * @retval Baud Rate
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling) {
Xstatic __inline uint32_t MS32_USART_GetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling) {
N  register uint32_t usartdiv;
N  register uint32_t brrresult = 0x0U;
N
N  usartdiv = USARTx->BRR;
N
N  if (usartdiv == 0U)
N  {
N    /* Do not perform a division by 0 */
N  }
N  else if (OverSampling == MS32_USART_OVERSAMPLING_8)
X  else if (OverSampling == (0x1UL << (15U)))
N  {
N    usartdiv = (uint16_t)((usartdiv & 0xFFF0U) | ((usartdiv & 0x0007U) << 1U)) ;
N    if (usartdiv != 0U)
N    {
N      brrresult = (PeriphClk * 2U) / usartdiv;
N    }
N  }
N  else
N  {
N    if ((usartdiv & 0xFFFFU) != 0U)
N    {
N      brrresult = PeriphClk / usartdiv;
N    }
N  }
N  return (brrresult);
N}
N
N/**
N  * @brief  Set Receiver Time Out Value (expressed in nb of bits duration)
N  * @rmtoll RTOR         RTO           MS32_USART_SetRxTimeout
N  * @param  USARTx USART Instance
N  * @param  Timeout Value between Min_Data=0x00 and Max_Data=0x00FFFFFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetRxTimeout(USART_TypeDef *USARTx, uint32_t Timeout) {
Xstatic __inline void MS32_USART_SetRxTimeout(USART_TypeDef *USARTx, uint32_t Timeout) {
N  MODIFY_REG(USARTx->RTOR, USART_RTOR_RTO, Timeout);
X  (((USARTx->RTOR)) = ((((((USARTx->RTOR))) & (~((0xFFFFFFUL << (0U))))) | (Timeout))));
N}
N
N/**
N  * @brief  Get Receiver Time Out Value (expressed in nb of bits duration)
N  * @rmtoll RTOR         RTO           MS32_USART_GetRxTimeout
N  * @param  USARTx USART Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0x00FFFFFF
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetRxTimeout(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetRxTimeout(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->RTOR, USART_RTOR_RTO));
X  return (uint32_t)(((USARTx->RTOR) & ((0xFFFFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Set Block Length value in reception
N  * @rmtoll RTOR         BLEN          MS32_USART_SetBlockLength
N  * @param  USARTx USART Instance
N  * @param  BlockLength Value between Min_Data=0x00 and Max_Data=0xFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetBlockLength(USART_TypeDef *USARTx, uint32_t BlockLength) {
Xstatic __inline void MS32_USART_SetBlockLength(USART_TypeDef *USARTx, uint32_t BlockLength) {
N  MODIFY_REG(USARTx->RTOR, USART_RTOR_BLEN, BlockLength << USART_RTOR_BLEN_Pos);
X  (((USARTx->RTOR)) = ((((((USARTx->RTOR))) & (~((0xFFUL << (24U))))) | (BlockLength << (24U)))));
N}
N
N/**
N  * @brief  Get Block Length value in reception
N  * @rmtoll RTOR         BLEN          MS32_USART_GetBlockLength
N  * @param  USARTx USART Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetBlockLength(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetBlockLength(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->RTOR, USART_RTOR_BLEN) >> USART_RTOR_BLEN_Pos);
X  return (uint32_t)(((USARTx->RTOR) & ((0xFFUL << (24U)))) >> (24U));
N}
N
N
N/** @defgroup USART_EF_Configuration_IRDA Configuration functions related to Irda feature
N  * @{
N  */
N
N/**
N  * @brief  Enable IrDA mode
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @rmtoll CR3          IREN          MS32_USART_EnableIrda
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableIrda(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableIrda(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR3, USART_CR3_IREN);
X  ((USARTx->CR3) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable IrDA mode
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @rmtoll CR3          IREN          MS32_USART_DisableIrda
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableIrda(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableIrda(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR3, USART_CR3_IREN);
X  ((USARTx->CR3) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Indicate if IrDA mode is enabled
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @rmtoll CR3          IREN          MS32_USART_IsEnabledIrda
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledIrda(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledIrda(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR3, USART_CR3_IREN) == (USART_CR3_IREN)) ? 1UL : 0UL);
X  return ((((USARTx->CR3) & ((0x1UL << (1U)))) == ((0x1UL << (1U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Configure IrDA Power Mode (Normal or Low Power)
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @rmtoll CR3          IRLP          MS32_USART_SetIrdaPowerMode
N  * @param  USARTx USART Instance
N  * @param  PowerMode This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_IRDA_POWER_NORMAL
N  *         @arg @ref MS32_USART_IRDA_POWER_LOW
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetIrdaPowerMode(USART_TypeDef *USARTx, uint32_t PowerMode) {
Xstatic __inline void MS32_USART_SetIrdaPowerMode(USART_TypeDef *USARTx, uint32_t PowerMode) {
N  MODIFY_REG(USARTx->CR3, USART_CR3_IRLP, PowerMode);
X  (((USARTx->CR3)) = ((((((USARTx->CR3))) & (~((0x1UL << (2U))))) | (PowerMode))));
N}
N
N/**
N  * @brief  Retrieve IrDA Power Mode configuration (Normal or Low Power)
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @rmtoll CR3          IRLP          MS32_USART_GetIrdaPowerMode
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_IRDA_POWER_NORMAL
N  *         @arg @ref MS32_USART_PHASE_2EDGE
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetIrdaPowerMode(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetIrdaPowerMode(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_IRLP));
X  return (uint32_t)(((USARTx->CR3) & ((0x1UL << (2U)))));
N}
N
N/**
N  * @brief  Set Irda prescaler value, used for dividing the USART clock source
N  *         to achieve the Irda Low Power frequency (8 bits value)
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @rmtoll GTPR         PSC           MS32_USART_SetIrdaPrescaler
N  * @param  USARTx USART Instance
N  * @param  PrescalerValue Value between Min_Data=0x00 and Max_Data=0xFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetIrdaPrescaler(USART_TypeDef *USARTx, uint32_t PrescalerValue) {
Xstatic __inline void MS32_USART_SetIrdaPrescaler(USART_TypeDef *USARTx, uint32_t PrescalerValue) {
N  MODIFY_REG(USARTx->GTPR, (uint16_t)USART_GTPR_PSC, (uint16_t)PrescalerValue);
X  (((USARTx->GTPR)) = ((((((USARTx->GTPR))) & (~((uint16_t)(0xFFUL << (0U))))) | ((uint16_t)PrescalerValue))));
N}
N
N/**
N  * @brief  Return Irda prescaler value, used for dividing the USART clock source
N  *         to achieve the Irda Low Power frequency (8 bits value)
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @rmtoll GTPR         PSC           MS32_USART_GetIrdaPrescaler
N  * @param  USARTx USART Instance
N  * @retval Irda prescaler value (Value between Min_Data=0x00 and Max_Data=0xFF)
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetIrdaPrescaler(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetIrdaPrescaler(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->GTPR, USART_GTPR_PSC));
X  return (uint32_t)(((USARTx->GTPR) & ((0xFFUL << (0U)))));
N}
N
N
N/** @defgroup USART_EF_Configuration_Smartcard Configuration functions related to Smartcard feature
N  * @{
N  */
N
N/**
N  * @brief  Enable Smartcard NACK transmission
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          NACK          MS32_USART_EnableSmartcardNACK
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableSmartcardNACK(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableSmartcardNACK(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR3, USART_CR3_NACK);
X  ((USARTx->CR3) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Disable Smartcard NACK transmission
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          NACK          MS32_USART_DisableSmartcardNACK
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableSmartcardNACK(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableSmartcardNACK(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR3, USART_CR3_NACK);
X  ((USARTx->CR3) &= ~((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Indicate if Smartcard NACK transmission is enabled
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          NACK          MS32_USART_IsEnabledSmartcardNACK
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledSmartcardNACK(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledSmartcardNACK(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR3, USART_CR3_NACK) == (USART_CR3_NACK)) ? 1UL : 0UL);
X  return ((((USARTx->CR3) & ((0x1UL << (4U)))) == ((0x1UL << (4U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable Smartcard mode
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          SCEN          MS32_USART_EnableSmartcard
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableSmartcard(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableSmartcard(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR3, USART_CR3_SCEN);
X  ((USARTx->CR3) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Disable Smartcard mode
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          SCEN          MS32_USART_DisableSmartcard
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableSmartcard(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableSmartcard(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR3, USART_CR3_SCEN);
X  ((USARTx->CR3) &= ~((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Indicate if Smartcard mode is enabled
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          SCEN          MS32_USART_IsEnabledSmartcard
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledSmartcard(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledSmartcard(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR3, USART_CR3_SCEN) == (USART_CR3_SCEN)) ? 1UL : 0UL);
X  return ((((USARTx->CR3) & ((0x1UL << (5U)))) == ((0x1UL << (5U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set Smartcard Auto-Retry Count value (SCARCNT[2:0] bits)
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @note   This bit-field specifies the number of retries in transmit and receive, in Smartcard mode.
N  *         In transmission mode, it specifies the number of automatic retransmission retries, before
N  *         generating a transmission error (FE bit set).
N  *         In reception mode, it specifies the number or erroneous reception trials, before generating a
N  *         reception error (RXNE and PE bits set)
N  * @rmtoll CR3          SCARCNT       MS32_USART_SetSmartcardAutoRetryCount
N  * @param  USARTx USART Instance
N  * @param  AutoRetryCount Value between Min_Data=0 and Max_Data=7
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetSmartcardAutoRetryCount(USART_TypeDef *USARTx, uint32_t AutoRetryCount) {
Xstatic __inline void MS32_USART_SetSmartcardAutoRetryCount(USART_TypeDef *USARTx, uint32_t AutoRetryCount) {
N  MODIFY_REG(USARTx->CR3, USART_CR3_SCARCNT, AutoRetryCount << USART_CR3_SCARCNT_Pos);
X  (((USARTx->CR3)) = ((((((USARTx->CR3))) & (~((0x7UL << (17U))))) | (AutoRetryCount << (17U)))));
N}
N
N/**
N  * @brief  Return Smartcard Auto-Retry Count value (SCARCNT[2:0] bits)
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          SCARCNT       MS32_USART_GetSmartcardAutoRetryCount
N  * @param  USARTx USART Instance
N  * @retval Smartcard Auto-Retry Count value (Value between Min_Data=0 and Max_Data=7)
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetSmartcardAutoRetryCount(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetSmartcardAutoRetryCount(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_SCARCNT) >> USART_CR3_SCARCNT_Pos);
X  return (uint32_t)(((USARTx->CR3) & ((0x7UL << (17U)))) >> (17U));
N}
N
N/**
N  * @brief  Set Smartcard prescaler value, used for dividing the USART clock
N  *         source to provide the SMARTCARD Clock (5 bits value)
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll GTPR         PSC           MS32_USART_SetSmartcardPrescaler
N  * @param  USARTx USART Instance
N  * @param  PrescalerValue Value between Min_Data=0 and Max_Data=31
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetSmartcardPrescaler(USART_TypeDef *USARTx, uint32_t PrescalerValue) {
Xstatic __inline void MS32_USART_SetSmartcardPrescaler(USART_TypeDef *USARTx, uint32_t PrescalerValue) {
N  MODIFY_REG(USARTx->GTPR, (uint16_t)USART_GTPR_PSC, (uint16_t)PrescalerValue);
X  (((USARTx->GTPR)) = ((((((USARTx->GTPR))) & (~((uint16_t)(0xFFUL << (0U))))) | ((uint16_t)PrescalerValue))));
N}
N
N/**
N  * @brief  Return Smartcard prescaler value, used for dividing the USART clock
N  *         source to provide the SMARTCARD Clock (5 bits value)
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll GTPR         PSC           MS32_USART_GetSmartcardPrescaler
N  * @param  USARTx USART Instance
N  * @retval Smartcard prescaler value (Value between Min_Data=0 and Max_Data=31)
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetSmartcardPrescaler(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetSmartcardPrescaler(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->GTPR, USART_GTPR_PSC));
X  return (uint32_t)(((USARTx->GTPR) & ((0xFFUL << (0U)))));
N}
N
N/**
N  * @brief  Set Smartcard Guard time value, expressed in nb of baud clocks periods
N  *         (GT[7:0] bits : Guard time value)
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll GTPR         GT            MS32_USART_SetSmartcardGuardTime
N  * @param  USARTx USART Instance
N  * @param  GuardTime Value between Min_Data=0x00 and Max_Data=0xFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetSmartcardGuardTime(USART_TypeDef *USARTx, uint32_t GuardTime) {
Xstatic __inline void MS32_USART_SetSmartcardGuardTime(USART_TypeDef *USARTx, uint32_t GuardTime) {
N  MODIFY_REG(USARTx->GTPR, (uint16_t)USART_GTPR_GT, (uint16_t)(GuardTime << USART_GTPR_GT_Pos));
X  (((USARTx->GTPR)) = ((((((USARTx->GTPR))) & (~((uint16_t)(0xFFUL << (8U))))) | ((uint16_t)(GuardTime << (8U))))));
N}
N
N/**
N  * @brief  Return Smartcard Guard time value, expressed in nb of baud clocks periods
N  *         (GT[7:0] bits : Guard time value)
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll GTPR         GT            MS32_USART_GetSmartcardGuardTime
N  * @param  USARTx USART Instance
N  * @retval Smartcard Guard time value (Value between Min_Data=0x00 and Max_Data=0xFF)
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetSmartcardGuardTime(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetSmartcardGuardTime(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->GTPR, USART_GTPR_GT) >> USART_GTPR_GT_Pos);
X  return (uint32_t)(((USARTx->GTPR) & ((0xFFUL << (8U)))) >> (8U));
N}
N
N
N/** @defgroup USART_EF_Configuration_HalfDuplex Configuration functions related to Half Duplex feature
N  * @{
N  */
N
N/**
N  * @brief  Enable Single Wire Half-Duplex mode
N  * @note   Macro @ref IS_UART_HALFDUPLEX_INSTANCE(USARTx) can be used to check whether or not
N  *         Half-Duplex mode is supported by the USARTx instance.
N  * @rmtoll CR3          HDSEL         MS32_USART_EnableHalfDuplex
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableHalfDuplex(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableHalfDuplex(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR3, USART_CR3_HDSEL);
X  ((USARTx->CR3) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Disable Single Wire Half-Duplex mode
N  * @note   Macro @ref IS_UART_HALFDUPLEX_INSTANCE(USARTx) can be used to check whether or not
N  *         Half-Duplex mode is supported by the USARTx instance.
N  * @rmtoll CR3          HDSEL         MS32_USART_DisableHalfDuplex
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableHalfDuplex(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableHalfDuplex(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR3, USART_CR3_HDSEL);
X  ((USARTx->CR3) &= ~((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Indicate if Single Wire Half-Duplex mode is enabled
N  * @note   Macro @ref IS_UART_HALFDUPLEX_INSTANCE(USARTx) can be used to check whether or not
N  *         Half-Duplex mode is supported by the USARTx instance.
N  * @rmtoll CR3          HDSEL         MS32_USART_IsEnabledHalfDuplex
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledHalfDuplex(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledHalfDuplex(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR3, USART_CR3_HDSEL) == (USART_CR3_HDSEL)) ? 1UL : 0UL);
X  return ((((USARTx->CR3) & ((0x1UL << (3U)))) == ((0x1UL << (3U)))) ? 1UL : 0UL);
N}
N
N
N/** @defgroup USART_EF_Configuration_LIN Configuration functions related to LIN feature
N  * @{
N  */
N
N/**
N  * @brief  Set LIN Break Detection Length
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LBDL          MS32_USART_SetLINBrkDetectionLen
N  * @param  USARTx USART Instance
N  * @param  LINBDLength This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_LINBREAK_DETECT_10B
N  *         @arg @ref MS32_USART_LINBREAK_DETECT_11B
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetLINBrkDetectionLen(USART_TypeDef *USARTx, uint32_t LINBDLength) {
Xstatic __inline void MS32_USART_SetLINBrkDetectionLen(USART_TypeDef *USARTx, uint32_t LINBDLength) {
N  MODIFY_REG(USARTx->CR2, USART_CR2_LBDL, LINBDLength);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (5U))))) | (LINBDLength))));
N}
N
N/**
N  * @brief  Return LIN Break Detection Length
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LBDL          MS32_USART_GetLINBrkDetectionLen
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_LINBREAK_DETECT_10B
N  *         @arg @ref MS32_USART_LINBREAK_DETECT_11B
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetLINBrkDetectionLen(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetLINBrkDetectionLen(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_LBDL));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (5U)))));
N}
N
N/**
N  * @brief  Enable LIN mode
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LINEN         MS32_USART_EnableLIN
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableLIN(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableLIN(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR2, USART_CR2_LINEN);
X  ((USARTx->CR2) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Disable LIN mode
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LINEN         MS32_USART_DisableLIN
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableLIN(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableLIN(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR2, USART_CR2_LINEN);
X  ((USARTx->CR2) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Indicate if LIN mode is enabled
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LINEN         MS32_USART_IsEnabledLIN
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledLIN(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledLIN(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR2, USART_CR2_LINEN) == (USART_CR2_LINEN)) ? 1UL : 0UL);
X  return ((((USARTx->CR2) & ((0x1UL << (14U)))) == ((0x1UL << (14U)))) ? 1UL : 0UL);
N}
N
N
N/** @defgroup USART_EF_Configuration_DE Configuration functions related to Driver Enable feature
N  * @{
N  */
N
N/**
N  * @brief  Set DEDT (Driver Enable De-Assertion Time), Time value expressed on 5 bits ([4:0] bits).
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR1          DEDT          MS32_USART_SetDEDeassertionTime
N  * @param  USARTx USART Instance
N  * @param  Time Value between Min_Data=0 and Max_Data=31
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetDEDeassertionTime(USART_TypeDef *USARTx, uint32_t Time) {
Xstatic __inline void MS32_USART_SetDEDeassertionTime(USART_TypeDef *USARTx, uint32_t Time) {
N  MODIFY_REG(USARTx->CR1, USART_CR1_DEDT, Time << USART_CR1_DEDT_Pos);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x1FUL << (16U))))) | (Time << (16U)))));
N}
N
N/**
N  * @brief  Return DEDT (Driver Enable De-Assertion Time)
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR1          DEDT          MS32_USART_GetDEDeassertionTime
N  * @param  USARTx USART Instance
N  * @retval Time value expressed on 5 bits ([4:0] bits) : Value between Min_Data=0 and Max_Data=31
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetDEDeassertionTime(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetDEDeassertionTime(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_DEDT) >> USART_CR1_DEDT_Pos);
X  return (uint32_t)(((USARTx->CR1) & ((0x1FUL << (16U)))) >> (16U));
N}
N
N/**
N  * @brief  Set DEAT (Driver Enable Assertion Time), Time value expressed on 5 bits ([4:0] bits).
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR1          DEAT          MS32_USART_SetDEAssertionTime
N  * @param  USARTx USART Instance
N  * @param  Time Value between Min_Data=0 and Max_Data=31
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetDEAssertionTime(USART_TypeDef *USARTx, uint32_t Time) {
Xstatic __inline void MS32_USART_SetDEAssertionTime(USART_TypeDef *USARTx, uint32_t Time) {
N  MODIFY_REG(USARTx->CR1, USART_CR1_DEAT, Time << USART_CR1_DEAT_Pos);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x1FUL << (21U))))) | (Time << (21U)))));
N}
N
N/**
N  * @brief  Return DEAT (Driver Enable Assertion Time)
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR1          DEAT          MS32_USART_GetDEAssertionTime
N  * @param  USARTx USART Instance
N  * @retval Time value expressed on 5 bits ([4:0] bits) : Value between Min_Data=0 and Max_Data=31
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetDEAssertionTime(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetDEAssertionTime(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_DEAT) >> USART_CR1_DEAT_Pos);
X  return (uint32_t)(((USARTx->CR1) & ((0x1FUL << (21U)))) >> (21U));
N}
N
N/**
N  * @brief  Enable Driver Enable (DE) Mode
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR3          DEM           MS32_USART_EnableDEMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableDEMode(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableDEMode(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR3, USART_CR3_DEM);
X  ((USARTx->CR3) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Disable Driver Enable (DE) Mode
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR3          DEM           MS32_USART_DisableDEMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableDEMode(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableDEMode(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR3, USART_CR3_DEM);
X  ((USARTx->CR3) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Indicate if Driver Enable (DE) Mode is enabled
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR3          DEM           MS32_USART_IsEnabledDEMode
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledDEMode(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledDEMode(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR3, USART_CR3_DEM) == (USART_CR3_DEM)) ? 1UL : 0UL);
X  return ((((USARTx->CR3) & ((0x1UL << (14U)))) == ((0x1UL << (14U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Select Driver Enable Polarity
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR3          DEP           MS32_USART_SetDESignalPolarity
N  * @param  USARTx USART Instance
N  * @param  Polarity This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_DE_POLARITY_HIGH
N  *         @arg @ref MS32_USART_DE_POLARITY_LOW
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_SetDESignalPolarity(USART_TypeDef *USARTx, uint32_t Polarity) {
Xstatic __inline void MS32_USART_SetDESignalPolarity(USART_TypeDef *USARTx, uint32_t Polarity) {
N  MODIFY_REG(USARTx->CR3, USART_CR3_DEP, Polarity);
X  (((USARTx->CR3)) = ((((((USARTx->CR3))) & (~((0x1UL << (15U))))) | (Polarity))));
N}
N
N/**
N  * @brief  Return Driver Enable Polarity
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR3          DEP           MS32_USART_GetDESignalPolarity
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_USART_DE_POLARITY_HIGH
N  *         @arg @ref MS32_USART_DE_POLARITY_LOW
N  */
N__STATIC_INLINE uint32_t MS32_USART_GetDESignalPolarity(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_GetDESignalPolarity(USART_TypeDef *USARTx) {
N  return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_DEP));
X  return (uint32_t)(((USARTx->CR3) & ((0x1UL << (15U)))));
N}
N
N
N/** @defgroup USART_EF_AdvancedConfiguration Advanced Configurations services
N  * @{
N  */
N
N/**
N  * @brief  Perform basic configuration of USART for enabling use in Asynchronous Mode (UART)
N  * @note   In UART mode, the following bits must be kept cleared:
N  *           - LINEN bit in the USART_CR2 register (if LIN feature is supported),
N  *           - CLKEN bit in the USART_CR2 register,
N  *           - SCEN bit in the USART_CR3 register (if Smartcard feature is supported),
N  *           - IREN bit in the USART_CR3 register (if Irda feature is supported),
N  *           - HDSEL bit in the USART_CR3 register.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clear LINEN in CR2 using @ref MS32_USART_DisableLIN() function (if LIN feature is supported)
N  *         - Clear CLKEN in CR2 using @ref MS32_USART_DisableSCLKOutput() function
N  *         - Clear SCEN in CR3 using @ref MS32_USART_DisableSmartcard() function (if Smartcard feature is supported)
N  *         - Clear IREN in CR3 using @ref MS32_USART_DisableIrda() function (if Irda feature is supported)
N  *         - Clear HDSEL in CR3 using @ref MS32_USART_DisableHalfDuplex() function
N  * @note   Other remaining configurations items related to Asynchronous Mode
N  *         (as Baud Rate, Word length, Parity, ...) should be set using
N  *         dedicated functions
N  * @rmtoll CR2          LINEN         MS32_USART_ConfigAsyncMode\n
N  *         CR2          CLKEN         MS32_USART_ConfigAsyncMode\n
N  *         CR3          SCEN          MS32_USART_ConfigAsyncMode\n
N  *         CR3          IREN          MS32_USART_ConfigAsyncMode\n
N  *         CR3          HDSEL         MS32_USART_ConfigAsyncMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ConfigAsyncMode(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ConfigAsyncMode(USART_TypeDef *USARTx) {
N  /* In Asynchronous mode, the following bits must be kept cleared:
N  - LINEN (if LIN feature is supported), CLKEN bits in the USART_CR2 register,
N  - SCEN (if Smartcard feature is supported), IREN (if Irda feature is supported) and HDSEL bits in the USART_CR3 register.
N  */
N  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
X  ((USARTx->CR2) &= ~(((0x1UL << (14U)) | (0x1UL << (11U)))));
N  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
X  ((USARTx->CR3) &= ~(((0x1UL << (5U)) | (0x1UL << (1U)) | (0x1UL << (3U)))));
N}
N
N/**
N  * @brief  Perform basic configuration of USART for enabling use in Synchronous Mode
N  * @note   In Synchronous mode, the following bits must be kept cleared:
N  *           - LINEN bit in the USART_CR2 register (if LIN feature is supported),
N  *           - SCEN bit in the USART_CR3 register (if Smartcard feature is supported),
N  *           - IREN bit in the USART_CR3 register (if Irda feature is supported),
N  *           - HDSEL bit in the USART_CR3 register.
N  *         This function also sets the USART in Synchronous mode.
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clear LINEN in CR2 using @ref MS32_USART_DisableLIN() function (if LIN feature is supported)
N  *         - Clear IREN in CR3 using @ref MS32_USART_DisableIrda() function (if Irda feature is supported)
N  *         - Clear SCEN in CR3 using @ref MS32_USART_DisableSmartcard() function (if Smartcard feature is supported)
N  *         - Clear HDSEL in CR3 using @ref MS32_USART_DisableHalfDuplex() function
N  *         - Set CLKEN in CR2 using @ref MS32_USART_EnableSCLKOutput() function
N  * @note   Other remaining configurations items related to Synchronous Mode
N  *         (as Baud Rate, Word length, Parity, Clock Polarity, ...) should be set using
N  *         dedicated functions
N  * @rmtoll CR2          LINEN         MS32_USART_ConfigSyncMode\n
N  *         CR2          CLKEN         MS32_USART_ConfigSyncMode\n
N  *         CR3          SCEN          MS32_USART_ConfigSyncMode\n
N  *         CR3          IREN          MS32_USART_ConfigSyncMode\n
N  *         CR3          HDSEL         MS32_USART_ConfigSyncMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ConfigSyncMode(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ConfigSyncMode(USART_TypeDef *USARTx) {
N  /* In Synchronous mode, the following bits must be kept cleared:
N  - LINEN (if LIN feature is supported) bit in the USART_CR2 register,
N  - SCEN (if Smartcard feature is supported), IREN (if Irda feature is supported) and HDSEL bits in the USART_CR3 register.
N  */
N  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN));
X  ((USARTx->CR2) &= ~(((0x1UL << (14U)))));
N  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
X  ((USARTx->CR3) &= ~(((0x1UL << (5U)) | (0x1UL << (1U)) | (0x1UL << (3U)))));
N  /* set the UART/USART in Synchronous mode */
N  SET_BIT(USARTx->CR2, USART_CR2_CLKEN);
X  ((USARTx->CR2) |= ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Perform basic configuration of USART for enabling use in LIN Mode
N  * @note   In LIN mode, the following bits must be kept cleared:
N  *           - STOP and CLKEN bits in the USART_CR2 register,
N  *           - SCEN bit in the USART_CR3 register (if Smartcard feature is supported),
N  *           - IREN bit in the USART_CR3 register (if Irda feature is supported),
N  *           - HDSEL bit in the USART_CR3 register.
N  *         This function also set the UART/USART in LIN mode.
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clear CLKEN in CR2 using @ref MS32_USART_DisableSCLKOutput() function
N  *         - Clear STOP in CR2 using @ref MS32_USART_SetStopBitsLength() function
N  *         - Clear SCEN in CR3 using @ref MS32_USART_DisableSmartcard() function (if Smartcard feature is supported)
N  *         - Clear IREN in CR3 using @ref MS32_USART_DisableIrda() function (if Irda feature is supported)
N  *         - Clear HDSEL in CR3 using @ref MS32_USART_DisableHalfDuplex() function
N  *         - Set LINEN in CR2 using @ref MS32_USART_EnableLIN() function
N  * @note   Other remaining configurations items related to LIN Mode
N  *         (as Baud Rate, Word length, LIN Break Detection Length, ...) should be set using
N  *         dedicated functions
N  * @rmtoll CR2          CLKEN         MS32_USART_ConfigLINMode\n
N  *         CR2          STOP          MS32_USART_ConfigLINMode\n
N  *         CR2          LINEN         MS32_USART_ConfigLINMode\n
N  *         CR3          IREN          MS32_USART_ConfigLINMode\n
N  *         CR3          SCEN          MS32_USART_ConfigLINMode\n
N  *         CR3          HDSEL         MS32_USART_ConfigLINMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ConfigLINMode(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ConfigLINMode(USART_TypeDef *USARTx) {
N  /* In LIN mode, the following bits must be kept cleared:
N  - STOP and CLKEN bits in the USART_CR2 register,
N  - IREN (if Irda feature is supported) , SCEN (if Smartcard feature is supported)and HDSEL bits in the USART_CR3 register.
N  */
N  CLEAR_BIT(USARTx->CR2, (USART_CR2_CLKEN | USART_CR2_STOP));
X  ((USARTx->CR2) &= ~(((0x1UL << (11U)) | (0x3UL << (12U)))));
N  CLEAR_BIT(USARTx->CR3, (USART_CR3_IREN | USART_CR3_SCEN | USART_CR3_HDSEL));
X  ((USARTx->CR3) &= ~(((0x1UL << (1U)) | (0x1UL << (5U)) | (0x1UL << (3U)))));
N
N  /* Set the UART/USART in LIN mode */
N  SET_BIT(USARTx->CR2, USART_CR2_LINEN);
X  ((USARTx->CR2) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Perform basic configuration of USART for enabling use in Half Duplex Mode
N  * @note   In Half Duplex mode, the following bits must be kept cleared:
N  *           - LINEN bit in the USART_CR2 register (if LIN feature is supported),
N  *           - CLKEN bit in the USART_CR2 register,
N  *           - SCEN bit in the USART_CR3 register (if Smartcard feature is supported),
N  *           - IREN bit in the USART_CR3 register (if Irda feature is supported),
N  *         This function also sets the UART/USART in Half Duplex mode.
N  * @note   Macro @ref IS_UART_HALFDUPLEX_INSTANCE(USARTx) can be used to check whether or not
N  *         Half-Duplex mode is supported by the USARTx instance.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clear LINEN in CR2 using @ref MS32_USART_DisableLIN() function (if LIN feature is supported)
N  *         - Clear CLKEN in CR2 using @ref MS32_USART_DisableSCLKOutput() function
N  *         - Clear SCEN in CR3 using @ref MS32_USART_DisableSmartcard() function (if Smartcard feature is supported)
N  *         - Clear IREN in CR3 using @ref MS32_USART_DisableIrda() function (if Irda feature is supported)
N  *         - Set HDSEL in CR3 using @ref MS32_USART_EnableHalfDuplex() function
N  * @note   Other remaining configurations items related to Half Duplex Mode
N  *         (as Baud Rate, Word length, Parity, ...) should be set using
N  *         dedicated functions
N  * @rmtoll CR2          LINEN         MS32_USART_ConfigHalfDuplexMode\n
N  *         CR2          CLKEN         MS32_USART_ConfigHalfDuplexMode\n
N  *         CR3          HDSEL         MS32_USART_ConfigHalfDuplexMode\n
N  *         CR3          SCEN          MS32_USART_ConfigHalfDuplexMode\n
N  *         CR3          IREN          MS32_USART_ConfigHalfDuplexMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ConfigHalfDuplexMode(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ConfigHalfDuplexMode(USART_TypeDef *USARTx) {
N  /* In Half Duplex mode, the following bits must be kept cleared:
N  - LINEN (if LIN feature is supported) and CLKEN bits in the USART_CR2 register,
N  - SCEN (if Smartcard feature is supported) and IREN (if Irda feature is supported) bits in the USART_CR3 register.
N  */
N  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
X  ((USARTx->CR2) &= ~(((0x1UL << (14U)) | (0x1UL << (11U)))));
N  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN));
X  ((USARTx->CR3) &= ~(((0x1UL << (5U)) | (0x1UL << (1U)))));
N  /* set the UART/USART in Half Duplex mode */
N  SET_BIT(USARTx->CR3, USART_CR3_HDSEL);
X  ((USARTx->CR3) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Perform basic configuration of USART for enabling use in Smartcard Mode
N  * @note   In Smartcard mode, the following bits must be kept cleared:
N  *           - LINEN bit in the USART_CR2 register (if LIN feature is supported),
N  *           - IREN bit in the USART_CR3 register (if Irda feature is supported),
N  *           - HDSEL bit in the USART_CR3 register.
N  *         This function also configures Stop bits to 1.5 bits and
N  *         sets the USART in Smartcard mode (SCEN bit).
N  *         Clock Output is also enabled (CLKEN).
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clear LINEN in CR2 using @ref MS32_USART_DisableLIN() function (if LIN feature is supported)
N  *         - Clear IREN in CR3 using @ref MS32_USART_DisableIrda() function (if Irda feature is supported)
N  *         - Clear HDSEL in CR3 using @ref MS32_USART_DisableHalfDuplex() function
N  *         - Configure STOP in CR2 using @ref MS32_USART_SetStopBitsLength() function
N  *         - Set CLKEN in CR2 using @ref MS32_USART_EnableSCLKOutput() function
N  *         - Set SCEN in CR3 using @ref MS32_USART_EnableSmartcard() function
N  * @note   Other remaining configurations items related to Smartcard Mode
N  *         (as Baud Rate, Word length, Parity, ...) should be set using
N  *         dedicated functions
N  * @rmtoll CR2          LINEN         MS32_USART_ConfigSmartcardMode\n
N  *         CR2          STOP          MS32_USART_ConfigSmartcardMode\n
N  *         CR2          CLKEN         MS32_USART_ConfigSmartcardMode\n
N  *         CR3          HDSEL         MS32_USART_ConfigSmartcardMode\n
N  *         CR3          SCEN          MS32_USART_ConfigSmartcardMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ConfigSmartcardMode(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ConfigSmartcardMode(USART_TypeDef *USARTx) {
N  /* In Smartcard mode, the following bits must be kept cleared:
N  - LINEN (if LIN feature is supported) bit in the USART_CR2 register,
N  - IREN (if Irda feature is supported) and HDSEL bits in the USART_CR3 register.
N  */
N  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN));
X  ((USARTx->CR2) &= ~(((0x1UL << (14U)))));
N  CLEAR_BIT(USARTx->CR3, (USART_CR3_IREN | USART_CR3_HDSEL));
X  ((USARTx->CR3) &= ~(((0x1UL << (1U)) | (0x1UL << (3U)))));
N  /* Configure Stop bits to 1.5 bits */
N  /* Synchronous mode is activated by default */
N  SET_BIT(USARTx->CR2, (USART_CR2_STOP_0 | USART_CR2_STOP_1 | USART_CR2_CLKEN));
X  ((USARTx->CR2) |= (((0x1UL << (12U)) | (0x2UL << (12U)) | (0x1UL << (11U)))));
N  /* set the UART/USART in Smartcard mode */
N  SET_BIT(USARTx->CR3, USART_CR3_SCEN);
X  ((USARTx->CR3) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Perform basic configuration of USART for enabling use in Irda Mode
N  * @note   In IRDA mode, the following bits must be kept cleared:
N  *           - LINEN bit in the USART_CR2 register (if LIN feature is supported),
N  *           - STOP and CLKEN bits in the USART_CR2 register,
N  *           - SCEN bit in the USART_CR3 register (if Smartcard feature is supported),
N  *           - HDSEL bit in the USART_CR3 register.
N  *         This function also sets the UART/USART in IRDA mode (IREN bit).
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clear LINEN in CR2 using @ref MS32_USART_DisableLIN() function (if LIN feature is supported)
N  *         - Clear CLKEN in CR2 using @ref MS32_USART_DisableSCLKOutput() function
N  *         - Clear SCEN in CR3 using @ref MS32_USART_DisableSmartcard() function (if Smartcard feature is supported)
N  *         - Clear HDSEL in CR3 using @ref MS32_USART_DisableHalfDuplex() function
N  *         - Configure STOP in CR2 using @ref MS32_USART_SetStopBitsLength() function
N  *         - Set IREN in CR3 using @ref MS32_USART_EnableIrda() function
N  * @note   Other remaining configurations items related to Irda Mode
N  *         (as Baud Rate, Word length, Power mode, ...) should be set using
N  *         dedicated functions
N  * @rmtoll CR2          LINEN         MS32_USART_ConfigIrdaMode\n
N  *         CR2          CLKEN         MS32_USART_ConfigIrdaMode\n
N  *         CR2          STOP          MS32_USART_ConfigIrdaMode\n
N  *         CR3          SCEN          MS32_USART_ConfigIrdaMode\n
N  *         CR3          HDSEL         MS32_USART_ConfigIrdaMode\n
N  *         CR3          IREN          MS32_USART_ConfigIrdaMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ConfigIrdaMode(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ConfigIrdaMode(USART_TypeDef *USARTx) {
N  /* In IRDA mode, the following bits must be kept cleared:
N  - LINEN (if LIN feature is supported), STOP and CLKEN bits in the USART_CR2 register,
N  - SCEN (if Smartcard feature is supported) and HDSEL bits in the USART_CR3 register.
N  */
N  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN | USART_CR2_STOP));
X  ((USARTx->CR2) &= ~(((0x1UL << (14U)) | (0x1UL << (11U)) | (0x3UL << (12U)))));
N  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL));
X  ((USARTx->CR3) &= ~(((0x1UL << (5U)) | (0x1UL << (3U)))));
N  /* set the UART/USART in IRDA mode */
N  SET_BIT(USARTx->CR3, USART_CR3_IREN);
X  ((USARTx->CR3) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Perform basic configuration of USART for enabling use in Multi processor Mode
N  *         (several USARTs connected in a network, one of the USARTs can be the master,
N  *         its TX output connected to the RX inputs of the other slaves USARTs).
N  * @note   In MultiProcessor mode, the following bits must be kept cleared:
N  *           - LINEN bit in the USART_CR2 register (if LIN feature is supported),
N  *           - CLKEN bit in the USART_CR2 register,
N  *           - SCEN bit in the USART_CR3 register (if Smartcard feature is supported),
N  *           - IREN bit in the USART_CR3 register (if Irda feature is supported),
N  *           - HDSEL bit in the USART_CR3 register.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clear LINEN in CR2 using @ref MS32_USART_DisableLIN() function (if LIN feature is supported)
N  *         - Clear CLKEN in CR2 using @ref MS32_USART_DisableSCLKOutput() function
N  *         - Clear SCEN in CR3 using @ref MS32_USART_DisableSmartcard() function (if Smartcard feature is supported)
N  *         - Clear IREN in CR3 using @ref MS32_USART_DisableIrda() function (if Irda feature is supported)
N  *         - Clear HDSEL in CR3 using @ref MS32_USART_DisableHalfDuplex() function
N  * @note   Other remaining configurations items related to Multi processor Mode
N  *         (as Baud Rate, Wake Up Method, Node address, ...) should be set using
N  *         dedicated functions
N  * @rmtoll CR2          LINEN         MS32_USART_ConfigMultiProcessMode\n
N  *         CR2          CLKEN         MS32_USART_ConfigMultiProcessMode\n
N  *         CR3          SCEN          MS32_USART_ConfigMultiProcessMode\n
N  *         CR3          HDSEL         MS32_USART_ConfigMultiProcessMode\n
N  *         CR3          IREN          MS32_USART_ConfigMultiProcessMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ConfigMultiProcessMode(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ConfigMultiProcessMode(USART_TypeDef *USARTx) {
N  /* In Multi Processor mode, the following bits must be kept cleared:
N  - LINEN (if LIN feature is supported) and CLKEN bits in the USART_CR2 register,
N  - IREN (if Irda feature is supported), SCEN (if Smartcard feature is supported) and HDSEL bits in the USART_CR3 register.
N  */
N  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
X  ((USARTx->CR2) &= ~(((0x1UL << (14U)) | (0x1UL << (11U)))));
N  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
X  ((USARTx->CR3) &= ~(((0x1UL << (5U)) | (0x1UL << (3U)) | (0x1UL << (1U)))));
N}
N
N
N
N/** @defgroup USART_EF_FLAG_Management FLAG_Management
N  * @{
N  */
N
N/**
N  * @brief  Check if the USART Parity Error Flag is set or not
N  * @rmtoll ISR          PE            MS32_USART_IsActiveFlag_PE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_PE(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_PE(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_PE) == (USART_ISR_PE)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Framing Error Flag is set or not
N  * @rmtoll ISR          FE            MS32_USART_IsActiveFlag_FE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_FE(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_FE(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_FE) == (USART_ISR_FE)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (1U)))) == ((0x1UL << (1U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Noise error detected Flag is set or not
N  * @rmtoll ISR          NE            MS32_USART_IsActiveFlag_NE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_NE(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_NE(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_NE) == (USART_ISR_NE)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (2U)))) == ((0x1UL << (2U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART OverRun Error Flag is set or not
N  * @rmtoll ISR          ORE           MS32_USART_IsActiveFlag_ORE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_ORE(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_ORE(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_ORE) == (USART_ISR_ORE)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (3U)))) == ((0x1UL << (3U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART IDLE line detected Flag is set or not
N  * @rmtoll ISR          IDLE          MS32_USART_IsActiveFlag_IDLE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_IDLE(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_IDLE(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_IDLE) == (USART_ISR_IDLE)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (4U)))) == ((0x1UL << (4U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Read Data Register Not Empty Flag is set or not
N  * @rmtoll ISR          RXNE          MS32_USART_IsActiveFlag_RXNE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_RXNE(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_RXNE(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_RXNE) == (USART_ISR_RXNE)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (5U)))) == ((0x1UL << (5U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Transmission Complete Flag is set or not
N  * @rmtoll ISR          TC            MS32_USART_IsActiveFlag_TC
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_TC(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_TC(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_TC) == (USART_ISR_TC)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Transmit Data Register Empty Flag is set or not
N  * @rmtoll ISR          TXE           MS32_USART_IsActiveFlag_TXE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_TXE(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_TXE(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_TXE) == (USART_ISR_TXE)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART LIN Break Detection Flag is set or not
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll ISR          LBDF          MS32_USART_IsActiveFlag_LBD
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_LBD(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_LBD(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_LBDF) == (USART_ISR_LBDF)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (8U)))) == ((0x1UL << (8U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART CTS interrupt Flag is set or not
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll ISR          CTSIF         MS32_USART_IsActiveFlag_nCTS
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_nCTS(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_nCTS(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_CTSIF) == (USART_ISR_CTSIF)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (9U)))) == ((0x1UL << (9U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART CTS Flag is set or not
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll ISR          CTS           MS32_USART_IsActiveFlag_CTS
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_CTS(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_CTS(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_CTS) == (USART_ISR_CTS)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (10U)))) == ((0x1UL << (10U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Receiver Time Out Flag is set or not
N  * @rmtoll ISR          RTOF          MS32_USART_IsActiveFlag_RTO
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_RTO(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_RTO(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_RTOF) == (USART_ISR_RTOF)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (11U)))) == ((0x1UL << (11U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART End Of Block Flag is set or not
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll ISR          EOBF          MS32_USART_IsActiveFlag_EOB
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_EOB(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_EOB(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_EOBF) == (USART_ISR_EOBF)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (12U)))) == ((0x1UL << (12U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Auto-Baud Rate Error Flag is set or not
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll ISR          ABRE          MS32_USART_IsActiveFlag_ABRE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_ABRE(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_ABRE(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_ABRE) == (USART_ISR_ABRE)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (14U)))) == ((0x1UL << (14U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Auto-Baud Rate Flag is set or not
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll ISR          ABRF          MS32_USART_IsActiveFlag_ABR
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_ABR(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_ABR(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_ABRF) == (USART_ISR_ABRF)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (15U)))) == ((0x1UL << (15U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Busy Flag is set or not
N  * @rmtoll ISR          BUSY          MS32_USART_IsActiveFlag_BUSY
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_BUSY(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_BUSY(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_BUSY) == (USART_ISR_BUSY)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (16U)))) == ((0x1UL << (16U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Character Match Flag is set or not
N  * @rmtoll ISR          CMF           MS32_USART_IsActiveFlag_CM
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_CM(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_CM(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_CMF) == (USART_ISR_CMF)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (17U)))) == ((0x1UL << (17U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Send Break Flag is set or not
N  * @rmtoll ISR          SBKF          MS32_USART_IsActiveFlag_SBK
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_SBK(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_SBK(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_SBKF) == (USART_ISR_SBKF)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (18U)))) == ((0x1UL << (18U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Receive Wake Up from mute mode Flag is set or not
N  * @rmtoll ISR          RWU           MS32_USART_IsActiveFlag_RWU
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_RWU(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_RWU(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_RWU) == (USART_ISR_RWU)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (19U)))) == ((0x1UL << (19U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Wake Up from stop mode Flag is set or not
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll ISR          WUF           MS32_USART_IsActiveFlag_WKUP
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_WKUP(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_WKUP(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_WUF) == (USART_ISR_WUF)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (20U)))) == ((0x1UL << (20U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Transmit Enable Acknowledge Flag is set or not
N  * @rmtoll ISR          TEACK         MS32_USART_IsActiveFlag_TEACK
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_TEACK(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_TEACK(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_TEACK) == (USART_ISR_TEACK)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (21U)))) == ((0x1UL << (21U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Receive Enable Acknowledge Flag is set or not
N  * @rmtoll ISR          REACK         MS32_USART_IsActiveFlag_REACK
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsActiveFlag_REACK(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsActiveFlag_REACK(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->ISR, USART_ISR_REACK) == (USART_ISR_REACK)) ? 1UL : 0UL);
X  return ((((USARTx->ISR) & ((0x1UL << (22U)))) == ((0x1UL << (22U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear Parity Error Flag
N  * @rmtoll ICR          PECF          MS32_USART_ClearFlag_PE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ClearFlag_PE(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ClearFlag_PE(USART_TypeDef *USARTx) {
N  WRITE_REG(USARTx->ICR, USART_ICR_PECF);
X  ((USARTx->ICR) = ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Clear Framing Error Flag
N  * @rmtoll ICR          FECF          MS32_USART_ClearFlag_FE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ClearFlag_FE(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ClearFlag_FE(USART_TypeDef *USARTx) {
N  WRITE_REG(USARTx->ICR, USART_ICR_FECF);
X  ((USARTx->ICR) = ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Clear Noise Error detected Flag
N  * @rmtoll ICR          NCF           MS32_USART_ClearFlag_NE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ClearFlag_NE(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ClearFlag_NE(USART_TypeDef *USARTx) {
N  WRITE_REG(USARTx->ICR, USART_ICR_NCF);
X  ((USARTx->ICR) = ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Clear OverRun Error Flag
N  * @rmtoll ICR          ORECF         MS32_USART_ClearFlag_ORE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ClearFlag_ORE(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ClearFlag_ORE(USART_TypeDef *USARTx) {
N  WRITE_REG(USARTx->ICR, USART_ICR_ORECF);
X  ((USARTx->ICR) = ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Clear IDLE line detected Flag
N  * @rmtoll ICR          IDLECF        MS32_USART_ClearFlag_IDLE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ClearFlag_IDLE(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ClearFlag_IDLE(USART_TypeDef *USARTx) {
N  WRITE_REG(USARTx->ICR, USART_ICR_IDLECF);
X  ((USARTx->ICR) = ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Clear Transmission Complete Flag
N  * @rmtoll ICR          TCCF          MS32_USART_ClearFlag_TC
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ClearFlag_TC(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ClearFlag_TC(USART_TypeDef *USARTx) {
N  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
X  ((USARTx->ICR) = ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Clear LIN Break Detection Flag
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll ICR          LBDCF         MS32_USART_ClearFlag_LBD
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ClearFlag_LBD(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ClearFlag_LBD(USART_TypeDef *USARTx) {
N  WRITE_REG(USARTx->ICR, USART_ICR_LBDCF);
X  ((USARTx->ICR) = ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Clear CTS Interrupt Flag
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll ICR          CTSCF         MS32_USART_ClearFlag_nCTS
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ClearFlag_nCTS(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ClearFlag_nCTS(USART_TypeDef *USARTx) {
N  WRITE_REG(USARTx->ICR, USART_ICR_CTSCF);
X  ((USARTx->ICR) = ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Clear Receiver Time Out Flag
N  * @rmtoll ICR          RTOCF         MS32_USART_ClearFlag_RTO
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ClearFlag_RTO(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ClearFlag_RTO(USART_TypeDef *USARTx) {
N  WRITE_REG(USARTx->ICR, USART_ICR_RTOCF);
X  ((USARTx->ICR) = ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Clear End Of Block Flag
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll ICR          EOBCF         MS32_USART_ClearFlag_EOB
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ClearFlag_EOB(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ClearFlag_EOB(USART_TypeDef *USARTx) {
N  WRITE_REG(USARTx->ICR, USART_ICR_EOBCF);
X  ((USARTx->ICR) = ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Clear Character Match Flag
N  * @rmtoll ICR          CMCF          MS32_USART_ClearFlag_CM
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ClearFlag_CM(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ClearFlag_CM(USART_TypeDef *USARTx) {
N  WRITE_REG(USARTx->ICR, USART_ICR_CMCF);
X  ((USARTx->ICR) = ((0x1UL << (17U))));
N}
N
N/**
N  * @brief  Clear Wake Up from stop mode Flag
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll ICR          WUCF          MS32_USART_ClearFlag_WKUP
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_ClearFlag_WKUP(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_ClearFlag_WKUP(USART_TypeDef *USARTx) {
N  WRITE_REG(USARTx->ICR, USART_ICR_WUCF);
X  ((USARTx->ICR) = ((0x1UL << (20U))));
N}
N
N
N/** @defgroup USART_EF_IT_Management IT_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable IDLE Interrupt
N  * @rmtoll CR1          IDLEIE        MS32_USART_EnableIT_IDLE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableIT_IDLE(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableIT_IDLE(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
X  ((USARTx->CR1) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Enable RX Not Empty Interrupt
N  * @rmtoll CR1          RXNEIE        MS32_USART_EnableIT_RXNE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableIT_RXNE(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableIT_RXNE(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
X  ((USARTx->CR1) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Enable Transmission Complete Interrupt
N  * @rmtoll CR1          TCIE          MS32_USART_EnableIT_TC
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableIT_TC(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableIT_TC(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR1, USART_CR1_TCIE);
X  ((USARTx->CR1) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Enable TX Empty Interrupt
N  * @rmtoll CR1          TXEIE         MS32_USART_EnableIT_TXE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableIT_TXE(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableIT_TXE(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR1, USART_CR1_TXEIE);
X  ((USARTx->CR1) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Enable Parity Error Interrupt
N  * @rmtoll CR1          PEIE          MS32_USART_EnableIT_PE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableIT_PE(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableIT_PE(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR1, USART_CR1_PEIE);
X  ((USARTx->CR1) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Enable Character Match Interrupt
N  * @rmtoll CR1          CMIE          MS32_USART_EnableIT_CM
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableIT_CM(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableIT_CM(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR1, USART_CR1_CMIE);
X  ((USARTx->CR1) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Enable Receiver Timeout Interrupt
N  * @rmtoll CR1          RTOIE         MS32_USART_EnableIT_RTO
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableIT_RTO(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableIT_RTO(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR1, USART_CR1_RTOIE);
X  ((USARTx->CR1) |= ((0x1UL << (26U))));
N}
N
N/**
N  * @brief  Enable End Of Block Interrupt
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR1          EOBIE         MS32_USART_EnableIT_EOB
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableIT_EOB(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableIT_EOB(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR1, USART_CR1_EOBIE);
X  ((USARTx->CR1) |= ((0x1UL << (27U))));
N}
N
N/**
N  * @brief  Enable LIN Break Detection Interrupt
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LBDIE         MS32_USART_EnableIT_LBD
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableIT_LBD(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableIT_LBD(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR2, USART_CR2_LBDIE);
X  ((USARTx->CR2) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Enable Error Interrupt
N  * @note   When set, Error Interrupt Enable Bit is enabling interrupt generation in case of a framing
N  *         error, overrun error or noise flag (FE=1 or ORE=1 or NF=1 in the USARTx_ISR register).
N  *           0: Interrupt is inhibited
N  *           1: An interrupt is generated when FE=1 or ORE=1 or NF=1 in the USARTx_ISR register.
N  * @rmtoll CR3          EIE           MS32_USART_EnableIT_ERROR
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableIT_ERROR(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableIT_ERROR(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR3, USART_CR3_EIE);
X  ((USARTx->CR3) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Enable CTS Interrupt
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          CTSIE         MS32_USART_EnableIT_CTS
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableIT_CTS(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableIT_CTS(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR3, USART_CR3_CTSIE);
X  ((USARTx->CR3) |= ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Enable Wake Up from Stop Mode Interrupt
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR3          WUFIE         MS32_USART_EnableIT_WKUP
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableIT_WKUP(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableIT_WKUP(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR3, USART_CR3_WUFIE);
X  ((USARTx->CR3) |= ((0x1UL << (22U))));
N}
N
N/**
N  * @brief  Disable IDLE Interrupt
N  * @rmtoll CR1          IDLEIE        MS32_USART_DisableIT_IDLE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableIT_IDLE(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableIT_IDLE(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
X  ((USARTx->CR1) &= ~((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Disable RX Not Empty Interrupt
N  * @rmtoll CR1          RXNEIE        MS32_USART_DisableIT_RXNE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableIT_RXNE(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableIT_RXNE(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
X  ((USARTx->CR1) &= ~((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Disable Transmission Complete Interrupt
N  * @rmtoll CR1          TCIE          MS32_USART_DisableIT_TC
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableIT_TC(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableIT_TC(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
X  ((USARTx->CR1) &= ~((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Disable TX Empty Interrupt
N  * @rmtoll CR1          TXEIE         MS32_USART_DisableIT_TXE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableIT_TXE(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableIT_TXE(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR1, USART_CR1_TXEIE);
X  ((USARTx->CR1) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable Parity Error Interrupt
N  * @rmtoll CR1          PEIE          MS32_USART_DisableIT_PE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableIT_PE(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableIT_PE(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
X  ((USARTx->CR1) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable Character Match Interrupt
N  * @rmtoll CR1          CMIE          MS32_USART_DisableIT_CM
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableIT_CM(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableIT_CM(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR1, USART_CR1_CMIE);
X  ((USARTx->CR1) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Disable Receiver Timeout Interrupt
N  * @rmtoll CR1          RTOIE         MS32_USART_DisableIT_RTO
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableIT_RTO(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableIT_RTO(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR1, USART_CR1_RTOIE);
X  ((USARTx->CR1) &= ~((0x1UL << (26U))));
N}
N
N/**
N  * @brief  Disable End Of Block Interrupt
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR1          EOBIE         MS32_USART_DisableIT_EOB
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableIT_EOB(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableIT_EOB(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR1, USART_CR1_EOBIE);
X  ((USARTx->CR1) &= ~((0x1UL << (27U))));
N}
N
N/**
N  * @brief  Disable LIN Break Detection Interrupt
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LBDIE         MS32_USART_DisableIT_LBD
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableIT_LBD(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableIT_LBD(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR2, USART_CR2_LBDIE);
X  ((USARTx->CR2) &= ~((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Disable Error Interrupt
N  * @note   When set, Error Interrupt Enable Bit is enabling interrupt generation in case of a framing
N  *         error, overrun error or noise flag (FE=1 or ORE=1 or NF=1 in the USARTx_ISR register).
N  *           0: Interrupt is inhibited
N  *           1: An interrupt is generated when FE=1 or ORE=1 or NF=1 in the USARTx_ISR register.
N  * @rmtoll CR3          EIE           MS32_USART_DisableIT_ERROR
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableIT_ERROR(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableIT_ERROR(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
X  ((USARTx->CR3) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable CTS Interrupt
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          CTSIE         MS32_USART_DisableIT_CTS
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableIT_CTS(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableIT_CTS(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR3, USART_CR3_CTSIE);
X  ((USARTx->CR3) &= ~((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Disable Wake Up from Stop Mode Interrupt
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR3          WUFIE         MS32_USART_DisableIT_WKUP
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableIT_WKUP(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableIT_WKUP(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR3, USART_CR3_WUFIE);
X  ((USARTx->CR3) &= ~((0x1UL << (22U))));
N}
N
N/**
N  * @brief  Check if the USART IDLE Interrupt  source is enabled or disabled.
N  * @rmtoll CR1          IDLEIE        MS32_USART_IsEnabledIT_IDLE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledIT_IDLE(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledIT_IDLE(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE)) ? 1UL : 0UL);
X  return ((((USARTx->CR1) & ((0x1UL << (4U)))) == ((0x1UL << (4U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART RX Not Empty Interrupt is enabled or disabled.
N  * @rmtoll CR1          RXNEIE        MS32_USART_IsEnabledIT_RXNE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledIT_RXNE(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledIT_RXNE(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR1, USART_CR1_RXNEIE) == (USART_CR1_RXNEIE)) ? 1U : 0U);
X  return ((((USARTx->CR1) & ((0x1UL << (5U)))) == ((0x1UL << (5U)))) ? 1U : 0U);
N}
N
N/**
N  * @brief  Check if the USART Transmission Complete Interrupt is enabled or disabled.
N  * @rmtoll CR1          TCIE          MS32_USART_IsEnabledIT_TC
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledIT_TC(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledIT_TC(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR1, USART_CR1_TCIE) == (USART_CR1_TCIE)) ? 1UL : 0UL);
X  return ((((USARTx->CR1) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART TX Empty Interrupt is enabled or disabled.
N  * @rmtoll CR1          TXEIE         MS32_USART_IsEnabledIT_TXE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledIT_TXE(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledIT_TXE(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR1, USART_CR1_TXEIE) == (USART_CR1_TXEIE)) ? 1U : 0U);
X  return ((((USARTx->CR1) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1U : 0U);
N}
N
N/**
N  * @brief  Check if the USART Parity Error Interrupt is enabled or disabled.
N  * @rmtoll CR1          PEIE          MS32_USART_IsEnabledIT_PE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledIT_PE(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledIT_PE(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR1, USART_CR1_PEIE) == (USART_CR1_PEIE)) ? 1UL : 0UL);
X  return ((((USARTx->CR1) & ((0x1UL << (8U)))) == ((0x1UL << (8U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Character Match Interrupt is enabled or disabled.
N  * @rmtoll CR1          CMIE          MS32_USART_IsEnabledIT_CM
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledIT_CM(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledIT_CM(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR1, USART_CR1_CMIE) == (USART_CR1_CMIE)) ? 1UL : 0UL);
X  return ((((USARTx->CR1) & ((0x1UL << (14U)))) == ((0x1UL << (14U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Receiver Timeout Interrupt is enabled or disabled.
N  * @rmtoll CR1          RTOIE         MS32_USART_IsEnabledIT_RTO
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledIT_RTO(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledIT_RTO(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR1, USART_CR1_RTOIE) == (USART_CR1_RTOIE)) ? 1UL : 0UL);
X  return ((((USARTx->CR1) & ((0x1UL << (26U)))) == ((0x1UL << (26U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART End Of Block Interrupt is enabled or disabled.
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR1          EOBIE         MS32_USART_IsEnabledIT_EOB
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledIT_EOB(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledIT_EOB(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR1, USART_CR1_EOBIE) == (USART_CR1_EOBIE)) ? 1UL : 0UL);
X  return ((((USARTx->CR1) & ((0x1UL << (27U)))) == ((0x1UL << (27U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART LIN Break Detection Interrupt is enabled or disabled.
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LBDIE         MS32_USART_IsEnabledIT_LBD
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledIT_LBD(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledIT_LBD(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR2, USART_CR2_LBDIE) == (USART_CR2_LBDIE)) ? 1UL : 0UL);
X  return ((((USARTx->CR2) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Error Interrupt is enabled or disabled.
N  * @rmtoll CR3          EIE           MS32_USART_IsEnabledIT_ERROR
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledIT_ERROR(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledIT_ERROR(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR3, USART_CR3_EIE) == (USART_CR3_EIE)) ? 1UL : 0UL);
X  return ((((USARTx->CR3) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART CTS Interrupt is enabled or disabled.
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          CTSIE         MS32_USART_IsEnabledIT_CTS
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledIT_CTS(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledIT_CTS(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR3, USART_CR3_CTSIE) == (USART_CR3_CTSIE)) ? 1UL : 0UL);
X  return ((((USARTx->CR3) & ((0x1UL << (10U)))) == ((0x1UL << (10U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if the USART Wake Up from Stop Mode Interrupt is enabled or disabled.
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR3          WUFIE         MS32_USART_IsEnabledIT_WKUP
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledIT_WKUP(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledIT_WKUP(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR3, USART_CR3_WUFIE) == (USART_CR3_WUFIE)) ? 1UL : 0UL);
X  return ((((USARTx->CR3) & ((0x1UL << (22U)))) == ((0x1UL << (22U)))) ? 1UL : 0UL);
N}
N
N
N/** @defgroup USART_EF_DMA_Management DMA_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable DMA Mode for reception
N  * @rmtoll CR3          DMAR          MS32_USART_EnableDMAReq_RX
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableDMAReq_RX(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableDMAReq_RX(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR3, USART_CR3_DMAR);
X  ((USARTx->CR3) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Disable DMA Mode for reception
N  * @rmtoll CR3          DMAR          MS32_USART_DisableDMAReq_RX
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableDMAReq_RX(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableDMAReq_RX(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR3, USART_CR3_DMAR);
X  ((USARTx->CR3) &= ~((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Check if DMA Mode is enabled for reception
N  * @rmtoll CR3          DMAR          MS32_USART_IsEnabledDMAReq_RX
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledDMAReq_RX(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledDMAReq_RX(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR3, USART_CR3_DMAR) == (USART_CR3_DMAR)) ? 1UL : 0UL);
X  return ((((USARTx->CR3) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable DMA Mode for transmission
N  * @rmtoll CR3          DMAT          MS32_USART_EnableDMAReq_TX
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableDMAReq_TX(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableDMAReq_TX(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR3, USART_CR3_DMAT);
X  ((USARTx->CR3) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable DMA Mode for transmission
N  * @rmtoll CR3          DMAT          MS32_USART_DisableDMAReq_TX
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableDMAReq_TX(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableDMAReq_TX(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
X  ((USARTx->CR3) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Check if DMA Mode is enabled for transmission
N  * @rmtoll CR3          DMAT          MS32_USART_IsEnabledDMAReq_TX
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledDMAReq_TX(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledDMAReq_TX(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR3, USART_CR3_DMAT) == (USART_CR3_DMAT)) ? 1UL : 0UL);
X  return ((((USARTx->CR3) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable DMA Disabling on Reception Error
N  * @rmtoll CR3          DDRE          MS32_USART_EnableDMADeactOnRxErr
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_EnableDMADeactOnRxErr(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_EnableDMADeactOnRxErr(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->CR3, USART_CR3_DDRE);
X  ((USARTx->CR3) |= ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Disable DMA Disabling on Reception Error
N  * @rmtoll CR3          DDRE          MS32_USART_DisableDMADeactOnRxErr
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_DisableDMADeactOnRxErr(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_DisableDMADeactOnRxErr(USART_TypeDef *USARTx) {
N  CLEAR_BIT(USARTx->CR3, USART_CR3_DDRE);
X  ((USARTx->CR3) &= ~((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Indicate if DMA Disabling on Reception Error is disabled
N  * @rmtoll CR3          DDRE          MS32_USART_IsEnabledDMADeactOnRxErr
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_USART_IsEnabledDMADeactOnRxErr(USART_TypeDef *USARTx) {
Xstatic __inline uint32_t MS32_USART_IsEnabledDMADeactOnRxErr(USART_TypeDef *USARTx) {
N  return ((READ_BIT(USARTx->CR3, USART_CR3_DDRE) == (USART_CR3_DDRE)) ? 1UL : 0UL);
X  return ((((USARTx->CR3) & ((0x1UL << (13U)))) == ((0x1UL << (13U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get the data register address used for DMA transfer
N  * @rmtoll RDR          RDR           MS32_USART_DMA_GetRegAddr\n
N  * @rmtoll TDR          TDR           MS32_USART_DMA_GetRegAddr
N  * @param  USARTx USART Instance
N  * @param  Direction This parameter can be one of the following values:
N  *         @arg @ref MS32_USART_DMA_REG_DATA_TRANSMIT
N  *         @arg @ref MS32_USART_DMA_REG_DATA_RECEIVE
N  * @retval Address of data register
N  */
N__STATIC_INLINE uint32_t MS32_USART_DMA_GetRegAddr(USART_TypeDef *USARTx, uint32_t Direction) {
Xstatic __inline uint32_t MS32_USART_DMA_GetRegAddr(USART_TypeDef *USARTx, uint32_t Direction) {
N  register uint32_t data_reg_addr;
N
N  if (Direction == MS32_USART_DMA_REG_DATA_TRANSMIT) {
X  if (Direction == 0x00000000U) {
N    /* return address of TDR register */
N    data_reg_addr = (uint32_t) &(USARTx->TDR);
N  } else  {
N    /* return address of RDR register */
N    data_reg_addr = (uint32_t) &(USARTx->RDR);
N  }
N
N  return data_reg_addr;
N}
N
N
N/** @defgroup USART_EF_Data_Management Data_Management
N  * @{
N  */
N
N/**
N  * @brief  Read Receiver Data register (Receive Data value, 8 bits)
N  * @rmtoll RDR          RDR           MS32_USART_ReceiveData8
N  * @param  USARTx USART Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint8_t MS32_USART_ReceiveData8(USART_TypeDef *USARTx) {
Xstatic __inline uint8_t MS32_USART_ReceiveData8(USART_TypeDef *USARTx) {
N  return (uint8_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR) & 0xFFU);
X  return (uint8_t)(((USARTx->RDR) & (((uint16_t)0x01FFU))) & 0xFFU);
N}
N
N/**
N  * @brief  Read Receiver Data register (Receive Data value, 9 bits)
N  * @rmtoll RDR          RDR           MS32_USART_ReceiveData9
N  * @param  USARTx USART Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0x1FF
N  */
N__STATIC_INLINE uint16_t MS32_USART_ReceiveData9(USART_TypeDef *USARTx) {
Xstatic __inline uint16_t MS32_USART_ReceiveData9(USART_TypeDef *USARTx) {
N  return (uint16_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR));
X  return (uint16_t)(((USARTx->RDR) & (((uint16_t)0x01FFU))));
N}
N
N/**
N  * @brief  Write in Transmitter Data Register (Transmit Data value, 8 bits)
N  * @rmtoll TDR          TDR           MS32_USART_TransmitData8
N  * @param  USARTx USART Instance
N  * @param  Value between Min_Data=0x00 and Max_Data=0xFF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_TransmitData8(USART_TypeDef *USARTx, uint8_t Value) {
Xstatic __inline void MS32_USART_TransmitData8(USART_TypeDef *USARTx, uint8_t Value) {
N  USARTx->TDR = Value;
N}
N
N/**
N  * @brief  Write in Transmitter Data Register (Transmit Data value, 9 bits)
N  * @rmtoll TDR          TDR           MS32_USART_TransmitData9
N  * @param  USARTx USART Instance
N  * @param  Value between Min_Data=0x00 and Max_Data=0x1FF
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_TransmitData9(USART_TypeDef *USARTx, uint16_t Value) {
Xstatic __inline void MS32_USART_TransmitData9(USART_TypeDef *USARTx, uint16_t Value) {
N  USARTx->TDR = (uint16_t)(Value & 0x1FFUL);
N}
N
N
N/** @defgroup USART_EF_Execution Execution
N  * @{
N  */
N
N/**
N  * @brief  Request an Automatic Baud Rate measurement on next received data frame
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll RQR          ABRRQ         MS32_USART_RequestAutoBaudRate
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_RequestAutoBaudRate(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_RequestAutoBaudRate(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->RQR, (uint16_t)USART_RQR_ABRRQ);
X  ((USARTx->RQR) |= ((uint16_t)(0x1UL << (0U))));
N}
N
N/**
N  * @brief  Request Break sending
N  * @rmtoll RQR          SBKRQ         MS32_USART_RequestBreakSending
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_RequestBreakSending(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_RequestBreakSending(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->RQR, (uint16_t)USART_RQR_SBKRQ);
X  ((USARTx->RQR) |= ((uint16_t)(0x1UL << (1U))));
N}
N
N/**
N  * @brief  Put USART in mute mode and set the RWU flag
N  * @rmtoll RQR          MMRQ          MS32_USART_RequestEnterMuteMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_RequestEnterMuteMode(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_RequestEnterMuteMode(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->RQR, (uint16_t)USART_RQR_MMRQ);
X  ((USARTx->RQR) |= ((uint16_t)(0x1UL << (2U))));
N}
N
N/**
N  * @brief  Request a Receive Data flush
N  * @note   Allows to discard the received data without reading them, and avoid an overrun
N  *         condition.
N  * @rmtoll RQR          RXFRQ         MS32_USART_RequestRxDataFlush
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_RequestRxDataFlush(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_RequestRxDataFlush(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->RQR, (uint16_t)USART_RQR_RXFRQ);
X  ((USARTx->RQR) |= ((uint16_t)(0x1UL << (3U))));
N}
N
N/**
N  * @brief  Request a Transmit data flush
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll RQR          TXFRQ         MS32_USART_RequestTxDataFlush
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_USART_RequestTxDataFlush(USART_TypeDef *USARTx) {
Xstatic __inline void MS32_USART_RequestTxDataFlush(USART_TypeDef *USARTx) {
N  SET_BIT(USARTx->RQR, (uint16_t)USART_RQR_TXFRQ);
X  ((USARTx->RQR) |= ((uint16_t)(0x1UL << (4U))));
N}
N
N
N/** @defgroup USART_EF_Init Initialization and de-initialization functions
N  * @{
N  */
NErrorStatus MS32_USART_DeInit          (USART_TypeDef *USARTx);
NErrorStatus MS32_USART_Init            (USART_TypeDef *USARTx, MS32_USART_InitTypeDef *UsartInitStr);
Nvoid        MS32_USART_StructInit      (MS32_USART_InitTypeDef *UsartInitStr);
NErrorStatus MS32_USART_ClockInit       (USART_TypeDef *USARTx, MS32_USART_ClockInitTypeDef *UsartClkInitStr);
Nvoid        MS32_USART_ClockStructInit (MS32_USART_ClockInitTypeDef *UsartClkInitStr);
Nvoid        MS32_USART_ITConfig        (USART_TypeDef *USARTx, uint32_t InterruptFunc, uint32_t Priority);
N
N/** @defgroup USART_EF_Application function
N  * @{
N  */
NFlagStatus MS32_USART_GetStatusFlag (USART_TypeDef *USARTx, uint32_t Flags);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_USART_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 82 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_utils.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_utils.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_UTILS_H
N#define __MS32F0XX_UTILS_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup UTILS_LL_Private_Constants UTILS Private Constants
N  * @{
N  */
N
N/* Max delay can be used in MS32_mDelay */
N#define MS32_MAX_DELAY                  0xFFFFFFFFU
N
N/**
N * @brief Unique device ID register base address
N */
N#define UID_BASE_ADDRESS              UID_BASE
N
N/**
N * @brief Flash size data register base address
N */
N#define FLASHSIZE_BASE_ADDRESS        FLASHSIZE_BASE
N
N
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/**
N  * @brief  UTILS PLL structure definition
N  */
Ntypedef struct {
N  uint32_t PLLMul;   /*!< Multiplication factor for PLL VCO input clock.
N                          This parameter can be a value of @ref RCC_LL_EC_PLL_MUL
N
N                          This feature can be modified afterwards using unitary function
N                          @ref MS32_RCC_PLL_ConfigDomain_SYS(). */
N
N  uint32_t Prediv;   /*!< Division factor for HSE used as PLL clock source.
N                          This parameter can be a value of @ref RCC_LL_EC_PREDIV_DIV
N
N                          This feature can be modified afterwards using unitary function
N                          @ref MS32_RCC_PLL_ConfigDomain_SYS(). */
N} MS32_UTILS_PLLInitTypeDef;
N
N/**
N  * @brief  UTILS System, AHB and APB buses clock configuration structure definition
N  */
Ntypedef struct {
N  uint32_t AHBCLKDivider;         /*!< The AHB clock (HCLK) divider. This clock is derived from the system clock (SYSCLK).
N                                       This parameter can be a value of @ref RCC_LL_EC_SYSCLK_DIV
N
N                                       This feature can be modified afterwards using unitary function
N                                       @ref MS32_RCC_SetAHBPrescaler(). */
N
N  uint32_t APB1CLKDivider;        /*!< The APB1 clock (PCLK1) divider. This clock is derived from the AHB clock (HCLK).
N                                       This parameter can be a value of @ref RCC_LL_EC_APB1_DIV
N
N                                       This feature can be modified afterwards using unitary function
N                                       @ref MS32_RCC_SetAPB1Prescaler(). */
N} MS32_UTILS_ClkInitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup UTILS_EC_HSE_BYPASS HSE Bypass activation
N  * @{
N  */
N#define MS32_UTILS_HSEBYPASS_OFF        0x00000000U       /*!< HSE Bypass is not enabled                */
N#define MS32_UTILS_HSEBYPASS_ON         0x00000001U       /*!< HSE Bypass is enabled                    */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup UTILS_EF_DEVICE_ELECTRONIC_SIGNATURE DEVICE ELECTRONIC SIGNATURE
N  * @{
N  */
N
N/**
N  * @brief  Get Word0 of the unique device identifier (UID based on 96 bits)
N  * @retval UID[31:0]: X and Y coordinates on the wafer expressed in BCD format
N  */
N__STATIC_INLINE uint32_t MS32_GetUID_Word0(void) {
Xstatic __inline uint32_t MS32_GetUID_Word0(void) {
N  return (uint32_t)(READ_REG(*((uint32_t *)UID_BASE_ADDRESS)));
X  return (uint32_t)(((*((uint32_t *)0x1FFFF7ACUL))));
N}
N
N/**
N  * @brief  Get Word1 of the unique device identifier (UID based on 96 bits)
N  * @retval UID[63:32]: Wafer number (UID[39:32]) & LOT_NUM[23:0] (UID[63:40])
N  */
N__STATIC_INLINE uint32_t MS32_GetUID_Word1(void) {
Xstatic __inline uint32_t MS32_GetUID_Word1(void) {
N  return (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE_ADDRESS + 4U))));
X  return (uint32_t)(((*((uint32_t *)(0x1FFFF7ACUL + 4U)))));
N}
N
N/**
N  * @brief  Get Word2 of the unique device identifier (UID based on 96 bits)
N  * @retval UID[95:64]: Lot number (ASCII encoded) - LOT_NUM[55:24]
N  */
N__STATIC_INLINE uint32_t MS32_GetUID_Word2(void) {
Xstatic __inline uint32_t MS32_GetUID_Word2(void) {
N  return (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE_ADDRESS + 8U))));
X  return (uint32_t)(((*((uint32_t *)(0x1FFFF7ACUL + 8U)))));
N}
N
N/**
N  * @brief  Get Flash memory size
N  * @note   This bitfield indicates the size of the device Flash memory expressed in
N  *         Kbytes. As an example, 0x040 corresponds to 64 Kbytes.
N  * @retval FLASH_SIZE[15:0]: Flash memory size
N  */
N__STATIC_INLINE uint32_t MS32_GetFlashSize(void) {
Xstatic __inline uint32_t MS32_GetFlashSize(void) {
N  return (uint16_t)(READ_REG(*((uint32_t *)FLASHSIZE_BASE_ADDRESS)));
X  return (uint16_t)(((*((uint32_t *)0x1FFFF7CCUL))));
N}
N
N
N/** @defgroup UTILS_LL_EF_DELAY DELAY
N  * @{
N  */
N
N/**
N  * @brief  This function configures the Cortex-M SysTick source of the time base.
N  * @param  HCLKFrequency HCLK frequency in Hz (can be calculated thanks to RCC helper macro)
N  * @note   When a RTOS is used, it is recommended to avoid changing the SysTick
N  *         configuration by calling this function, for a delay use rather osDelay RTOS service.
N  * @param  Ticks Number of ticks
N  * @retval None
N  */
N__STATIC_INLINE void MS32_InitTick(uint32_t HCLKFrequency, uint32_t Ticks) {
Xstatic __inline void MS32_InitTick(uint32_t HCLKFrequency, uint32_t Ticks) {
N  /* Configure the SysTick to have interrupt in 1ms time base */
N  SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);   
N  SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                        
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_ENABLE_Msk;                   /* Enable the Systick Timer */
X                   (1UL );                    
N}
N
N
N/** @defgroup UTILS_EF_SYSTEM SYSTEM
N  * @{
N  */
Nvoid        MS32_Init1msTick(uint32_t HCLKFrequency);
Nvoid        MS32_mDelay(uint32_t Delay);
Nvoid        MS32_SetSystemCoreClock(uint32_t HCLKFrequency);
NErrorStatus MS32_PLL_ConfigSystemClock_HSI(MS32_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct,
N                                           MS32_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct);
NErrorStatus MS32_PLL_ConfigSystemClock_HSE(uint32_t HSEFrequency, uint32_t HSEBypass,
N                                           MS32_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct, MS32_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_UTILS_H */
N
N/******************************** END OF FILE *********************************/
L 83 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N  #include "ms32f0xx_wwdg.h"
L 1 "..\..\library\ms32f0xx\include\ms32f0xx_wwdg.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MS32F0XX_WWDG_H
N#define __MS32F0XX_WWDG_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ms32f0xx.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup WWDG_Exported_Types WWDG Exported Types
N  * @{
N  */
N
N/**
N  * @brief  WWDG Init structure definition
N  */
Ntypedef struct {
N  uint32_t Prescaler;     /*!< Specifies the prescaler value of the WWDG.
N                               This parameter can be a value of @ref WWDG_Prescaler */
N  uint32_t Window;        /*!< Specifies the WWDG window value to be compared to the downcounter.
N                               This parameter must be a number Min_Data = 0x40 and Max_Data = 0x7F */
N  uint32_t Counter;       /*!< Specifies the WWDG free-running downcounter value.
N                               This parameter must be a number between Min_Data = 0x40 and Max_Data = 0x7F */
N} MS32_WWDG_InitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup WWDG_Exported_Constants WWDG Exported Constants
N  * @{
N  */
N
N/** @defgroup WWDG_Flag_definition WWDG Flag definition
N  * @brief WWDG Flag definition
N  * @{
N  */
N#define MS32_WWDG_FLAG_EWIF                 WWDG_SR_EWIF /*!< Early wakeup interrupt flag */
N
N
N/** @defgroup WWDG_Prescaler  PRESCALER
N  * @{
N  */
N#define MS32_WWDG_PRESCALER_1               (0x00000000U)                         /*!< WWDG counter clock = (PCLK1/4096)/1 */
N#define MS32_WWDG_PRESCALER_2               WWDG_CFR_WDGTB_0                      /*!< WWDG counter clock = (PCLK1/4096)/2 */
N#define MS32_WWDG_PRESCALER_4               WWDG_CFR_WDGTB_1                      /*!< WWDG counter clock = (PCLK1/4096)/4 */
N#define MS32_WWDG_PRESCALER_8               (WWDG_CFR_WDGTB_0 | WWDG_CFR_WDGTB_1) /*!< WWDG counter clock = (PCLK1/4096)/8 */
N
N
N/** @defgroup WWDG_EWI_Mode WWDG Early Wakeup Interrupt Mode
N  * @{
N  */
N#define MS32_WWDG_EWI_DISABLE               (0x00000000U)     /*!< EWI Disable */
N#define MS32_WWDG_EWI_ENABLE                WWDG_CFR_EWI      /*!< EWI Enable */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup WWDG_EM_WRITE_READ Common Write and read registers macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in WWDG register
N  * @param  __INSTANCE__ WWDG Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define MS32_WWDG_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in WWDG register
N  * @param  __INSTANCE__ WWDG Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define MS32_WWDG_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup WWDG_EF_Configuration Configuration
N  * @{
N  */
N
N/**
N  * @brief  Enable Window Watchdog. The watchdog is always disabled after a reset.
N  * @note   It is enabled by setting the WDGA bit in the WWDG_CR register,
N  *         then it cannot be disabled again except by a reset.
N  *         This bit is set by software and only cleared by hardware after a reset.
N  *         When WDGA = 1, the watchdog can generate a reset.
N  * @rmtoll CR           WDGA          MS32_WWDG_Enable
N  * @param  WWDGx WWDG Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_WWDG_Enable(WWDG_TypeDef *WWDGx) {
Xstatic __inline void MS32_WWDG_Enable(WWDG_TypeDef *WWDGx) {
N  SET_BIT(WWDGx->CR, WWDG_CR_WDGA);
X  ((WWDGx->CR) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Checks if Window Watchdog is enabled
N  * @rmtoll CR           WDGA          MS32_WWDG_IsEnabled
N  * @param  WWDGx WWDG Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_WWDG_IsEnabled(WWDG_TypeDef *WWDGx) {
Xstatic __inline uint32_t MS32_WWDG_IsEnabled(WWDG_TypeDef *WWDGx) {
N  return ((READ_BIT(WWDGx->CR, WWDG_CR_WDGA) == (WWDG_CR_WDGA)) ? 1UL : 0UL);
X  return ((((WWDGx->CR) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set the Watchdog counter value to provided value (7-bits T[6:0])
N  * @note   When writing to the WWDG_CR register, always write 1 in the MSB b6 to avoid generating an immediate reset
N  *         This counter is decremented every (4096 x 2expWDGTB) PCLK cycles
N  *         A reset is produced when it rolls over from 0x40 to 0x3F (bit T6 becomes cleared)
N  *         Setting the counter lower then 0x40 causes an immediate reset (if WWDG enabled)
N  * @rmtoll CR           T             MS32_WWDG_SetCounter
N  * @param  WWDGx WWDG Instance
N  * @param  Counter 0..0x7F (7 bit counter value)
N  * @retval None
N  */
N__STATIC_INLINE void MS32_WWDG_SetCounter(WWDG_TypeDef *WWDGx, uint32_t Counter) {
Xstatic __inline void MS32_WWDG_SetCounter(WWDG_TypeDef *WWDGx, uint32_t Counter) {
N  MODIFY_REG(WWDGx->CR, WWDG_CR_T, Counter);
X  (((WWDGx->CR)) = ((((((WWDGx->CR))) & (~((0x7FUL << (0U))))) | (Counter))));
N}
N
N/**
N  * @brief  Return current Watchdog Counter Value (7 bits counter value)
N  * @rmtoll CR           T             MS32_WWDG_GetCounter
N  * @param  WWDGx WWDG Instance
N  * @retval 7 bit Watchdog Counter value
N  */
N__STATIC_INLINE uint32_t MS32_WWDG_GetCounter(WWDG_TypeDef *WWDGx) {
Xstatic __inline uint32_t MS32_WWDG_GetCounter(WWDG_TypeDef *WWDGx) {
N  return (READ_BIT(WWDGx->CR, WWDG_CR_T));
X  return (((WWDGx->CR) & ((0x7FUL << (0U)))));
N}
N
N/**
N  * @brief  Set the time base of the prescaler (WDGTB).
N  * @note   Prescaler is used to apply ratio on PCLK clock, so that Watchdog counter
N  *         is decremented every (4096 x 2expWDGTB) PCLK cycles
N  * @rmtoll CFR          WDGTB         MS32_WWDG_SetPrescaler
N  * @param  WWDGx WWDG Instance
N  * @param  Prescaler This parameter can be one of the following values:
N  *         @arg @ref MS32_WWDG_PRESCALER_1
N  *         @arg @ref MS32_WWDG_PRESCALER_2
N  *         @arg @ref MS32_WWDG_PRESCALER_4
N  *         @arg @ref MS32_WWDG_PRESCALER_8
N  * @retval None
N  */
N__STATIC_INLINE void MS32_WWDG_SetPrescaler(WWDG_TypeDef *WWDGx, uint32_t Prescaler) {
Xstatic __inline void MS32_WWDG_SetPrescaler(WWDG_TypeDef *WWDGx, uint32_t Prescaler) {
N  MODIFY_REG(WWDGx->CFR, WWDG_CFR_WDGTB, Prescaler);
X  (((WWDGx->CFR)) = ((((((WWDGx->CFR))) & (~((0x3UL << (7U))))) | (Prescaler))));
N}
N
N/**
N  * @brief  Return current Watchdog Prescaler Value
N  * @rmtoll CFR          WDGTB         MS32_WWDG_GetPrescaler
N  * @param  WWDGx WWDG Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref MS32_WWDG_PRESCALER_1
N  *         @arg @ref MS32_WWDG_PRESCALER_2
N  *         @arg @ref MS32_WWDG_PRESCALER_4
N  *         @arg @ref MS32_WWDG_PRESCALER_8
N  */
N__STATIC_INLINE uint32_t MS32_WWDG_GetPrescaler(WWDG_TypeDef *WWDGx) {
Xstatic __inline uint32_t MS32_WWDG_GetPrescaler(WWDG_TypeDef *WWDGx) {
N  return (READ_BIT(WWDGx->CFR, WWDG_CFR_WDGTB));
X  return (((WWDGx->CFR) & ((0x3UL << (7U)))));
N}
N
N/**
N  * @brief  Set the Watchdog Window value to be compared to the downcounter (7-bits W[6:0]).
N  * @note   This window value defines when write in the WWDG_CR register
N  *         to program Watchdog counter is allowed.
N  *         Watchdog counter value update must occur only when the counter value
N  *         is lower than the Watchdog window register value.
N  *         Otherwise, a MCU reset is generated if the 7-bit Watchdog counter value
N  *         (in the control register) is refreshed before the downcounter has reached
N  *         the watchdog window register value.
N  *         Physically is possible to set the Window lower then 0x40 but it is not recommended.
N  *         To generate an immediate reset, it is possible to set the Counter lower than 0x40.
N  * @rmtoll CFR          W             MS32_WWDG_SetWindow
N  * @param  WWDGx WWDG Instance
N  * @param  Window 0x00..0x7F (7 bit Window value)
N  * @retval None
N  */
N__STATIC_INLINE void MS32_WWDG_SetWindow(WWDG_TypeDef *WWDGx, uint32_t Window) {
Xstatic __inline void MS32_WWDG_SetWindow(WWDG_TypeDef *WWDGx, uint32_t Window) {
N  MODIFY_REG(WWDGx->CFR, WWDG_CFR_W, Window);
X  (((WWDGx->CFR)) = ((((((WWDGx->CFR))) & (~((0x7FUL << (0U))))) | (Window))));
N}
N
N/**
N  * @brief  Return current Watchdog Window Value (7 bits value)
N  * @rmtoll CFR          W             MS32_WWDG_GetWindow
N  * @param  WWDGx WWDG Instance
N  * @retval 7 bit Watchdog Window value
N  */
N__STATIC_INLINE uint32_t MS32_WWDG_GetWindow(WWDG_TypeDef *WWDGx) {
Xstatic __inline uint32_t MS32_WWDG_GetWindow(WWDG_TypeDef *WWDGx) {
N  return (READ_BIT(WWDGx->CFR, WWDG_CFR_W));
X  return (((WWDGx->CFR) & ((0x7FUL << (0U)))));
N}
N
N
N/** @defgroup WWDG_EF_FLAG_Management FLAG_Management
N  * @{
N  */
N
N/**
N  * @brief  Indicates if the WWDG Early Wakeup Interrupt Flag is set or not.
N  * @note   This bit is set by hardware when the counter has reached the value 0x40.
N  *         It must be cleared by software by writing 0.
N  *         A write of 1 has no effect. This bit is also set if the interrupt is not enabled.
N  * @rmtoll SR           EWIF          MS32_WWDG_IsActiveFlag_EWKUP
N  * @param  WWDGx WWDG Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_WWDG_IsActiveFlag_EWKUP(WWDG_TypeDef *WWDGx) {
Xstatic __inline uint32_t MS32_WWDG_IsActiveFlag_EWKUP(WWDG_TypeDef *WWDGx) {
N  return ((READ_BIT(WWDGx->SR, WWDG_SR_EWIF) == (WWDG_SR_EWIF)) ? 1UL : 0UL);
X  return ((((WWDGx->SR) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear WWDG Early Wakeup Interrupt Flag (EWIF)
N  * @rmtoll SR           EWIF          MS32_WWDG_ClearFlag_EWKUP
N  * @param  WWDGx WWDG Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_WWDG_ClearFlag_EWKUP(WWDG_TypeDef *WWDGx) {
Xstatic __inline void MS32_WWDG_ClearFlag_EWKUP(WWDG_TypeDef *WWDGx) {
N  CLEAR_BIT(WWDGx->SR, WWDG_SR_EWIF);
X  ((WWDGx->SR) &= ~((0x1UL << (0U))));
N}
N
N
N/** @defgroup WWDG_EF_IT_Management IT_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable the Early Wakeup Interrupt.
N  * @note   When set, an interrupt occurs whenever the counter reaches value 0x40.
N  *         This interrupt is only cleared by hardware after a reset
N  * @rmtoll CFR          EWI           MS32_WWDG_EnableIT_EWKUP
N  * @param  WWDGx WWDG Instance
N  * @retval None
N  */
N__STATIC_INLINE void MS32_WWDG_EnableIT_EWKUP(WWDG_TypeDef *WWDGx) {
Xstatic __inline void MS32_WWDG_EnableIT_EWKUP(WWDG_TypeDef *WWDGx) {
N  SET_BIT(WWDGx->CFR, WWDG_CFR_EWI);
X  ((WWDGx->CFR) |= ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Check if Early Wakeup Interrupt is enabled
N  * @rmtoll CFR          EWI           MS32_WWDG_IsEnabledIT_EWKUP
N  * @param  WWDGx WWDG Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t MS32_WWDG_IsEnabledIT_EWKUP(WWDG_TypeDef *WWDGx) {
Xstatic __inline uint32_t MS32_WWDG_IsEnabledIT_EWKUP(WWDG_TypeDef *WWDGx) {
N  return ((READ_BIT(WWDGx->CFR, WWDG_CFR_EWI) == (WWDG_CFR_EWI)) ? 1UL : 0UL);
X  return ((((WWDGx->CFR) & ((0x1UL << (9U)))) == ((0x1UL << (9U)))) ? 1UL : 0UL);
N}
N
N
N/** @defgroup WWDG_EF_Init Initialization and de-initialization functions
N  * @{
N  */
NErrorStatus MS32_WWDG_DeInit     (void);
Nvoid        MS32_WWDG_StructInit (MS32_WWDG_InitTypeDef *WwdgInitStr);
NErrorStatus MS32_WWDG_Init       (MS32_WWDG_InitTypeDef *WwdgInitStr);
Nvoid        MS32_WWDG_ITConfig   (uint32_t InterruptFunc, uint32_t Priority);
N
N/** @defgroup WWDG_EF_Application function
N  * @{
N  */
NErrorStatus MS32_WWDG_Refresh       (uint8_t Counter);
NFlagStatus  MS32_WWDG_GetStatusFlag (void);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_WWDG_H */
N
N/******************************** END OF FILE *********************************/
L 84 "..\..\chip\ms32f0xx\include\ms32f0xx.h" 2
N#endif
N
N/* Exported functions ------------------------------------------------------- */
N
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __MS32F0XX_H */
N
N/******************************** END OF FILE *********************************/
L 11 "..\..\library\ms32f0xx\include\ms32f0xx_bus.h" 2
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup BUS_EC_AHB1_GRP1_PERIPH  AHB1 GRP1 PERIPH
N  * @{
N  */
N#define MS32_AHB1_GRP1_PERIPH_ALL            (uint32_t)0xFFFFFFFFU
N#define MS32_AHB1_GRP1_PERIPH_DMA1           RCC_AHBENR_DMAEN
N#define MS32_AHB1_GRP1_PERIPH_SRAM           RCC_AHBENR_SRAMEN
N#define MS32_AHB1_GRP1_PERIPH_FLITF          RCC_AHBENR_FLITFEN
N#define MS32_AHB1_GRP1_PERIPH_CRC            RCC_AHBENR_CRCEN
N#define MS32_AHB1_GRP1_PERIPH_GPIOA          RCC_AHBENR_GPIOAEN
N#define MS32_AHB1_GRP1_PERIPH_GPIOB          RCC_AHBENR_GPIOBEN
N#define MS32_AHB1_GRP1_PERIPH_GPIOC          RCC_AHBENR_GPIOCEN
N#define MS32_AHB1_GRP1_PERIPH_GPIOF          RCC_AHBENR_GPIOFEN
N
N
N/** @defgroup BUS_EC_APB1_GRP1_PERIPH  APB1 GRP1 PERIPH
N  * @{
N  */
N#define MS32_APB1_GRP1_PERIPH_ALL            (uint32_t)0xFFFFFFFFU
N#define MS32_APB1_GRP1_PERIPH_TIM2           RCC_APB1ENR_TIM2EN
N#define MS32_APB1_GRP1_PERIPH_TIM3           RCC_APB1ENR_TIM3EN
N#define MS32_APB1_GRP1_PERIPH_TIM14          RCC_APB1ENR_TIM14EN
N#define MS32_APB1_GRP1_PERIPH_WWDG           RCC_APB1ENR_WWDGEN
N#define MS32_APB1_GRP1_PERIPH_I2C1           RCC_APB1ENR_I2C1EN
N#define MS32_APB1_GRP1_PERIPH_PWR            RCC_APB1ENR_PWREN
N
N
N/** @defgroup BUS_EC_APB1_GRP2_PERIPH  APB1 GRP2 PERIPH
N  * @{
N  */
N#define MS32_APB1_GRP2_PERIPH_ALL            (uint32_t)0xFFFFFFFFU
N#define MS32_APB1_GRP2_PERIPH_SYSCFG         RCC_APB2ENR_SYSCFGCOMPEN
N#define MS32_APB1_GRP2_PERIPH_ADC1           RCC_APB2ENR_ADCEN
N#define MS32_APB1_GRP2_PERIPH_TIM1           RCC_APB2ENR_TIM1EN
N#define MS32_APB1_GRP2_PERIPH_SPI1           RCC_APB2ENR_SPI1EN
N#define MS32_APB1_GRP2_PERIPH_USART1         RCC_APB2ENR_USART1EN
N#define MS32_APB1_GRP2_PERIPH_TIM16          RCC_APB2ENR_TIM16EN
N#define MS32_APB1_GRP2_PERIPH_TIM17          RCC_APB2ENR_TIM17EN
N#define MS32_APB1_GRP2_PERIPH_DBGMCU         RCC_APB2ENR_DBGMCUEN
N
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup BUS_MS32_EF_AHB1 AHB1
N  * @{
N  */
N
N/**
N  * @brief  Enable AHB1 peripherals clock.
N  * @rmtoll AHBENR       DMA1EN        MS32_AHB1_GRP1_EnableClock\n
N  *         AHBENR       SRAMEN        MS32_AHB1_GRP1_EnableClock\n
N  *         AHBENR       FLITFEN       MS32_AHB1_GRP1_EnableClock\n
N  *         AHBENR       CRCEN         MS32_AHB1_GRP1_EnableClock\n
N  *         AHBENR       GPIOAEN       MS32_AHB1_GRP1_EnableClock\n
N  *         AHBENR       GPIOBEN       MS32_AHB1_GRP1_EnableClock\n
N  *         AHBENR       GPIOCEN       MS32_AHB1_GRP1_EnableClock\n
N  *         AHBENR       GPIOFEN       MS32_AHB1_GRP1_EnableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_DMA1
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_SRAM
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_FLITF
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_CRC
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOA
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOB
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOC
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOF
N  * @retval None
N*/
N__STATIC_INLINE void MS32_AHB1_GRP1_EnableClock(uint32_t Periphs) {
Xstatic __inline void MS32_AHB1_GRP1_EnableClock(uint32_t Periphs) {
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(RCC->AHBENR, Periphs);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->AHBENR) |= (Periphs));
N  /* Delay after an RCC peripheral clock enabling */
N  tmpreg = READ_BIT(RCC->AHBENR, Periphs);
X  tmpreg = ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->AHBENR) & (Periphs));
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Check if AHB1 peripheral clock is enabled or not
N  * @rmtoll AHBENR       DMA1EN        MS32_AHB1_GRP1_IsEnabledClock\n
N  *         AHBENR       SRAMEN        MS32_AHB1_GRP1_IsEnabledClock\n
N  *         AHBENR       FLITFEN       MS32_AHB1_GRP1_IsEnabledClock\n
N  *         AHBENR       CRCEN         MS32_AHB1_GRP1_IsEnabledClock\n
N  *         AHBENR       GPIOAEN       MS32_AHB1_GRP1_IsEnabledClock\n
N  *         AHBENR       GPIOBEN       MS32_AHB1_GRP1_IsEnabledClock\n
N  *         AHBENR       GPIOCEN       MS32_AHB1_GRP1_IsEnabledClock\n
N  *         AHBENR       GPIOFEN       MS32_AHB1_GRP1_IsEnabledClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_DMA1
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_SRAM
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_FLITF
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_CRC
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOA
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOB
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOC
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOF
N  * @retval State of Periphs (1 or 0).
N*/
N__STATIC_INLINE uint32_t MS32_AHB1_GRP1_IsEnabledClock(uint32_t Periphs) {
Xstatic __inline uint32_t MS32_AHB1_GRP1_IsEnabledClock(uint32_t Periphs) {
N  return (READ_BIT(RCC->AHBENR, Periphs) == Periphs);
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->AHBENR) & (Periphs)) == Periphs);
N}
N
N/**
N  * @brief  Disable AHB1 peripherals clock.
N  * @rmtoll AHBENR       DMA1EN        MS32_AHB1_GRP1_DisableClock\n
N  *         AHBENR       SRAMEN        MS32_AHB1_GRP1_DisableClock\n
N  *         AHBENR       FLITFEN       MS32_AHB1_GRP1_DisableClock\n
N  *         AHBENR       CRCEN         MS32_AHB1_GRP1_DisableClock\n
N  *         AHBENR       GPIOAEN       MS32_AHB1_GRP1_DisableClock\n
N  *         AHBENR       GPIOBEN       MS32_AHB1_GRP1_DisableClock\n
N  *         AHBENR       GPIOCEN       MS32_AHB1_GRP1_DisableClock\n
N  *         AHBENR       GPIOFEN       MS32_AHB1_GRP1_DisableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_DMA1
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_SRAM
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_FLITF
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_CRC
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOA
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOB
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOC
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOF
N  * @retval None
N*/
N__STATIC_INLINE void MS32_AHB1_GRP1_DisableClock(uint32_t Periphs) {
Xstatic __inline void MS32_AHB1_GRP1_DisableClock(uint32_t Periphs) {
N  CLEAR_BIT(RCC->AHBENR, Periphs);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->AHBENR) &= ~(Periphs));
N}
N
N/**
N  * @brief  Force AHB1 peripherals reset.
N  * @rmtoll AHBRSTR      GPIOARST      MS32_AHB1_GRP1_ForceReset\n
N  *         AHBRSTR      GPIOBRST      MS32_AHB1_GRP1_ForceReset\n
N  *         AHBRSTR      GPIOCRST      MS32_AHB1_GRP1_ForceReset\n
N  *         AHBRSTR      GPIOFRST      MS32_AHB1_GRP1_ForceReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_ALL
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOA
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOB
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOC
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOF
N  * @retval None
N*/
N__STATIC_INLINE void MS32_AHB1_GRP1_ForceReset(uint32_t Periphs) {
Xstatic __inline void MS32_AHB1_GRP1_ForceReset(uint32_t Periphs) {
N  SET_BIT(RCC->AHBRSTR, Periphs);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->AHBRSTR) |= (Periphs));
N}
N
N/**
N  * @brief  Release AHB1 peripherals reset.
N  * @rmtoll AHBRSTR      GPIOARST      MS32_AHB1_GRP1_ReleaseReset\n
N  *         AHBRSTR      GPIOBRST      MS32_AHB1_GRP1_ReleaseReset\n
N  *         AHBRSTR      GPIOCRST      MS32_AHB1_GRP1_ReleaseReset
N  *         AHBRSTR      GPIOFRST      MS32_AHB1_GRP1_ReleaseReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_ALL
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOA
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOB
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOC
N  *         @arg @ref MS32_AHB1_GRP1_PERIPH_GPIOF
N  * @retval None
N*/
N__STATIC_INLINE void MS32_AHB1_GRP1_ReleaseReset(uint32_t Periphs) {
Xstatic __inline void MS32_AHB1_GRP1_ReleaseReset(uint32_t Periphs) {
N  CLEAR_BIT(RCC->AHBRSTR, Periphs);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->AHBRSTR) &= ~(Periphs));
N}
N
N
N/** @defgroup BUS_MS32_EF_APB1_GRP1 APB1 GRP1
N  * @{
N  */
N
N/**
N  * @brief  Enable APB1 peripherals clock (available in register 1).
N  * @rmtoll APB1ENR      TIM2EN        MS32_APB1_GRP1_EnableClock\n
N  *         APB1ENR      TIM3EN        MS32_APB1_GRP1_EnableClock\n
N  *         APB1ENR      TIM14EN       MS32_APB1_GRP1_EnableClock\n
N  *         APB1ENR      WWDGEN        MS32_APB1_GRP1_EnableClock\n
N  *         APB1ENR      I2C1EN        MS32_APB1_GRP1_EnableClock\n
N  *         APB1ENR      PWREN         MS32_APB1_GRP1_EnableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM2
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM3
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM14
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_WWDG
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_I2C1
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_PWR
N  * @retval None
N*/
N__STATIC_INLINE void MS32_APB1_GRP1_EnableClock(uint32_t Periphs) {
Xstatic __inline void MS32_APB1_GRP1_EnableClock(uint32_t Periphs) {
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(RCC->APB1ENR, Periphs);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->APB1ENR) |= (Periphs));
N  /* Delay after an RCC peripheral clock enabling */
N  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
X  tmpreg = ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->APB1ENR) & (Periphs));
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Check if APB1 peripheral clock is enabled or not (available in register 1).
N  * @rmtoll APB1ENR      TIM2EN        MS32_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR      TIM3EN        MS32_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR      TIM14EN       MS32_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR      WWDGEN        MS32_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR      I2C1EN        MS32_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR      PWREN         MS32_APB1_GRP1_IsEnabledClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM2
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM3
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM14
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_WWDG
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_I2C1
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_PWR
N  * @retval State of Periphs (1 or 0).
N*/
N__STATIC_INLINE uint32_t MS32_APB1_GRP1_IsEnabledClock(uint32_t Periphs) {
Xstatic __inline uint32_t MS32_APB1_GRP1_IsEnabledClock(uint32_t Periphs) {
N  return (READ_BIT(RCC->APB1ENR, Periphs) == Periphs);
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->APB1ENR) & (Periphs)) == Periphs);
N}
N
N/**
N  * @brief  Disable APB1 peripherals clock (available in register 1).
N  * @rmtoll APB1ENR      TIM2EN        MS32_APB1_GRP1_DisableClock\n
N  *         APB1ENR      TIM3EN        MS32_APB1_GRP1_DisableClock\n
N  *         APB1ENR      TIM14EN       MS32_APB1_GRP1_DisableClock\n
N  *         APB1ENR      WWDGEN        MS32_APB1_GRP1_DisableClock\n
N  *         APB1ENR      I2C1EN        MS32_APB1_GRP1_DisableClock\n
N  *         APB1ENR      PWREN         MS32_APB1_GRP1_DisableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM2
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM3
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM14
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_WWDG
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_I2C1
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_PWR
N  * @retval None
N*/
N__STATIC_INLINE void MS32_APB1_GRP1_DisableClock(uint32_t Periphs) {
Xstatic __inline void MS32_APB1_GRP1_DisableClock(uint32_t Periphs) {
N  CLEAR_BIT(RCC->APB1ENR, Periphs);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->APB1ENR) &= ~(Periphs));
N}
N
N/**
N  * @brief  Force APB1 peripherals reset (available in register 1).
N  * @rmtoll APB1RSTR     TIM2RST       MS32_APB1_GRP1_ForceReset\n
N  *         APB1RSTR     TIM3RST       MS32_APB1_GRP1_ForceReset\n
N  *         APB1RSTR     TIM14RST      MS32_APB1_GRP1_ForceReset\n
N  *         APB1RSTR     WWDGRST       MS32_APB1_GRP1_ForceReset\n
N  *         APB1RSTR     I2C1RST       MS32_APB1_GRP1_ForceReset\n
N  *         APB1RSTR     PWRRST        MS32_APB1_GRP1_ForceReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_ALL
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM2
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM3
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM14
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_WWDG
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_I2C1
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_PWR
N  * @retval None
N*/
N__STATIC_INLINE void MS32_APB1_GRP1_ForceReset(uint32_t Periphs) {
Xstatic __inline void MS32_APB1_GRP1_ForceReset(uint32_t Periphs) {
N  SET_BIT(RCC->APB1RSTR, Periphs);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->APB1RSTR) |= (Periphs));
N}
N
N/**
N  * @brief  Release APB1 peripherals reset (available in register 1).
N  * @rmtoll APB1RSTR     TIM2RST       MS32_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR     TIM3RST       MS32_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR     TIM14RST      MS32_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR     WWDGRST       MS32_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR     I2C1RST       MS32_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR     PWRRST        MS32_APB1_GRP1_ReleaseReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_ALL
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM2
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM3
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_TIM14
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_WWDG
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_I2C1
N  *         @arg @ref MS32_APB1_GRP1_PERIPH_PWR
N  * @retval None
N*/
N__STATIC_INLINE void MS32_APB1_GRP1_ReleaseReset(uint32_t Periphs) {
Xstatic __inline void MS32_APB1_GRP1_ReleaseReset(uint32_t Periphs) {
N  CLEAR_BIT(RCC->APB1RSTR, Periphs);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->APB1RSTR) &= ~(Periphs));
N}
N
N
N/** @defgroup BUS_MS32_EF_APB1_GRP2 APB1 GRP2
N  * @{
N  */
N
N/**
N  * @brief  Enable APB1 peripherals clock (available in register 2).
N  * @rmtoll APB2ENR      SYSCFGEN      MS32_APB1_GRP2_EnableClock\n
N  *         APB2ENR      ADC1EN        MS32_APB1_GRP2_EnableClock\n
N  *         APB2ENR      TIM1EN        MS32_APB1_GRP2_EnableClock\n
N  *         APB2ENR      SPI1EN        MS32_APB1_GRP2_EnableClock\n
N  *         APB2ENR      USART1EN      MS32_APB1_GRP2_EnableClock\n
N  *         APB2ENR      TIM16EN       MS32_APB1_GRP2_EnableClock\n
N  *         APB2ENR      TIM17EN       MS32_APB1_GRP2_EnableClock\n
N  *         APB2ENR      DBGMCUEN      MS32_APB1_GRP2_EnableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_SYSCFG
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_ADC1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_SPI1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_USART1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM16
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM17
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_DBGMCU
N  * @retval None
N*/
N__STATIC_INLINE void MS32_APB1_GRP2_EnableClock(uint32_t Periphs) {
Xstatic __inline void MS32_APB1_GRP2_EnableClock(uint32_t Periphs) {
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(RCC->APB2ENR, Periphs);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->APB2ENR) |= (Periphs));
N  /* Delay after an RCC peripheral clock enabling */
N  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
X  tmpreg = ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->APB2ENR) & (Periphs));
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Check if APB1 peripheral clock is enabled or not (available in register 2).
N  * @rmtoll APB2ENR      SYSCFGEN      MS32_APB1_GRP2_IsEnabledClock\n
N  *         APB2ENR      ADC1EN        MS32_APB1_GRP2_IsEnabledClock\n
N  *         APB2ENR      TIM1EN        MS32_APB1_GRP2_IsEnabledClock\n
N  *         APB2ENR      SPI1EN        MS32_APB1_GRP2_IsEnabledClock\n
N  *         APB2ENR      USART1EN      MS32_APB1_GRP2_IsEnabledClock\n
N  *         APB2ENR      TIM16EN       MS32_APB1_GRP2_IsEnabledClock\n
N  *         APB2ENR      TIM17EN       MS32_APB1_GRP2_IsEnabledClock\n
N  *         APB2ENR      DBGMCUEN      MS32_APB1_GRP2_IsEnabledClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_SYSCFG
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_ADC1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_SPI1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_USART1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM16
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM17
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_DBGMCU
N  * @retval State of Periphs (1 or 0).
N*/
N__STATIC_INLINE uint32_t MS32_APB1_GRP2_IsEnabledClock(uint32_t Periphs) {
Xstatic __inline uint32_t MS32_APB1_GRP2_IsEnabledClock(uint32_t Periphs) {
N  return (READ_BIT(RCC->APB2ENR, Periphs) == Periphs);
X  return (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->APB2ENR) & (Periphs)) == Periphs);
N}
N
N/**
N  * @brief  Disable APB1 peripherals clock (available in register 2).
N  * @rmtoll APB2ENR      SYSCFGEN      MS32_APB1_GRP2_DisableClock\n
N  *         APB2ENR      ADC1EN        MS32_APB1_GRP2_DisableClock\n
N  *         APB2ENR      TIM1EN        MS32_APB1_GRP2_DisableClock\n
N  *         APB2ENR      SPI1EN        MS32_APB1_GRP2_DisableClock\n
N  *         APB2ENR      USART1EN      MS32_APB1_GRP2_DisableClock\n
N  *         APB2ENR      TIM16EN       MS32_APB1_GRP2_DisableClock\n
N  *         APB2ENR      TIM17EN       MS32_APB1_GRP2_DisableClock\n
N  *         APB2ENR      DBGMCUEN      MS32_APB1_GRP2_DisableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_SYSCFG
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_ADC1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_SPI1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_USART1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM16
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM17
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_DBGMCU
N  * @retval None
N*/
N__STATIC_INLINE void MS32_APB1_GRP2_DisableClock(uint32_t Periphs) {
Xstatic __inline void MS32_APB1_GRP2_DisableClock(uint32_t Periphs) {
N  CLEAR_BIT(RCC->APB2ENR, Periphs);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->APB2ENR) &= ~(Periphs));
N}
N
N/**
N  * @brief  Force APB1 peripherals reset (available in register 2).
N  * @rmtoll APB2RSTR     SYSCFGRST     MS32_APB1_GRP2_ForceReset\n
N  *         APB2RSTR     ADC1RST       MS32_APB1_GRP2_ForceReset\n
N  *         APB2RSTR     TIM1RST       MS32_APB1_GRP2_ForceReset\n
N  *         APB2RSTR     SPI1RST       MS32_APB1_GRP2_ForceReset\n
N  *         APB2RSTR     USART1RST     MS32_APB1_GRP2_ForceReset\n
N  *         APB2RSTR     TIM16RST      MS32_APB1_GRP2_ForceReset\n
N  *         APB2RSTR     TIM17RST      MS32_APB1_GRP2_ForceReset\n
N  *         APB2RSTR     DBGMCURST     MS32_APB1_GRP2_ForceReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_ALL
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_SYSCFG
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_ADC1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_SPI1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_USART1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM16
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM17
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_DBGMCU
N  * @retval None
N*/
N__STATIC_INLINE void MS32_APB1_GRP2_ForceReset(uint32_t Periphs) {
Xstatic __inline void MS32_APB1_GRP2_ForceReset(uint32_t Periphs) {
N  SET_BIT(RCC->APB2RSTR, Periphs);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->APB2RSTR) |= (Periphs));
N}
N
N/**
N  * @brief  Release APB1 peripherals reset (available in register 2).
N  * @rmtoll APB2RSTR     SYSCFGRST     MS32_APB1_GRP2_ReleaseReset\n
N  *         APB2RSTR     ADC1RST       MS32_APB1_GRP2_ReleaseReset\n
N  *         APB2RSTR     TIM1RST       MS32_APB1_GRP2_ReleaseReset\n
N  *         APB2RSTR     SPI1RST       MS32_APB1_GRP2_ReleaseReset\n
N  *         APB2RSTR     USART1RST     MS32_APB1_GRP2_ReleaseReset\n
N  *         APB2RSTR     TIM16RST      MS32_APB1_GRP2_ReleaseReset\n
N  *         APB2RSTR     TIM17RST      MS32_APB1_GRP2_ReleaseReset\n
N  *         APB2RSTR     DBGMCURST     MS32_APB1_GRP2_ReleaseReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_ALL
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_SYSCFG
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_ADC1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_SPI1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_USART1
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM16
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_TIM17
N  *         @arg @ref MS32_APB1_GRP2_PERIPH_DBGMCU
N  * @retval None
N*/
N__STATIC_INLINE void MS32_APB1_GRP2_ReleaseReset(uint32_t Periphs) {
Xstatic __inline void MS32_APB1_GRP2_ReleaseReset(uint32_t Periphs) {
N  CLEAR_BIT(RCC->APB2RSTR, Periphs);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->APB2RSTR) &= ~(Periphs));
N}
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MS32F0XX_BUS_H */
N
N/******************************** END OF FILE *********************************/
L 3 "..\..\library\ms32f0xx\source\ms32f0xx_rcc.c" 2
N#include "ms32f0xx_gpio.h"
N#include "ms32f0xx_pwr.h"
N#include "ms32f0xx_rcc.h"
N#include "ms32f0xx_system.h"
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RCC_Over_Time RCC Private Constants
N  * @{
N  */
N#define HSI_READY_TIME        (96)       /* = 2us / (1 / 48MHz) */ 
N#define HSE_READY_TIME        (96000)    /* = 2000us / (1 / 48MHz) */  
N#define LSI_READY_TIME        (4080)     /* = 85us / (1 / 48MHz) */
N#define LSE_READY_TIME        (96000000) /* = 2000000us / (1 / 48MHz) */
N#define PLL_READY_TIME        (9600)     /* = 200us / (1 / 48MHz) */
N#define PRE_READY_TIME        (100)
N#define SYSCLK_SW_TIME        (100)
N
N
N/** @defgroup RCC_Freq RCC Private Constants
N  * @{
N  */
N#define SYSCLK_DELAY_FREQ1    (24000000)
N
N
N/** @defgroup FUNC_FLAG Defines
N  * @{
N  */
N#define CLEAR_FLAG_OFFSET     (RCC_CIR_LSIRDYC_Pos - RCC_CIR_LSIRDYF_Pos)
N
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup RCC_Private_Macros RCC Private Macros
N  * @{
N  */
N#define MCO_CLK_ENABLE()     MS32_AHB1_GRP1_EnableClock(MS32_AHB1_GRP1_PERIPH_GPIOA)
N#define MCO_GPIO_PORT        GPIOA
N#define MCO_PIN              MS32_GPIO_PIN_8
N#define MCO_AF               MS32_GPIO_AF_0
N
N
N/* Private function prototypes -----------------------------------------------*/
N/** @defgroup RCC_Private_Functions RCC Private functions
N  * @{
N  */
Nstatic uint32_t RCC_GetSystemClockFreq     (uint32_t SYSCLK_Sws);
Nstatic uint32_t RCC_GetHCLKClockFreq       (uint32_t SYSCLK_Frequency);
Nstatic uint32_t RCC_GetPCLK1ClockFreq      (uint32_t HCLK_Frequency);
Nstatic uint32_t RCC_PLL_GetFreqDomain_SYS  (void);
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup RCC_EF_Init
N  * @{
N  */
N
N/**
N  * @brief  Reset the RCC clock configuration to the default reset state.
N  * @note   The default reset state of the clock configuration is given below:
N  *         - HSI ON and used as system clock source
N  *         - HSE and PLL OFF
N  *         - AHB and APB1 prescaler set to 1.
N  *         - CSS, MCO OFF
N  *         - All interrupts disabled
N  * @note   This function doesn't modify the configuration of the
N  *         - Peripheral clocks
N  *         - LSI, LSE and RTC clocks
N  * @retval An ErrorStatus enumeration value:
N  *          - SUCCESS: RCC registers are de-initialized
N  *          - ERROR: not applicable
N  */
NErrorStatus MS32_RCC_DeInit(void) {
N  __IO uint32_t vl_mask;
X  volatile uint32_t vl_mask;
N
N  /* Set HSION bit */
N  MS32_RCC_HSI_Enable();
N
N  /* Wait for HSI READY bit */
N  while(MS32_RCC_HSI_IsReady() != 1U) {
N    ;
N  }
N
N  /* Reset SW, HPRE, PPRE and MCOSEL bits */
N  vl_mask = 0xFFFFFFFFU;
N  CLEAR_BIT(vl_mask, (RCC_CFGR_SW | RCC_CFGR_HPRE | RCC_CFGR_PPRE | RCC_CFGR_MCO));
X  ((vl_mask) &= ~(((0x3UL << (0U)) | (0xFUL << (4U)) | (0x7UL << (8U)) | (0xFUL << (24U)))));
N
N  /* Write new value in CFGR register */
N  MS32_RCC_WriteReg(CFGR, vl_mask);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR) = ((vl_mask)));
N
N  /* Wait till system clock source is ready */
N  while(MS32_RCC_GetSysClkSource() != MS32_RCC_SYS_CLKSOURCE_STATUS_HSI) {
X  while(MS32_RCC_GetSysClkSource() != (0x00000000U)) {
N    ;
N  }
N
N  /* Read CR register */
N  vl_mask = MS32_RCC_ReadReg(CR);
X  vl_mask = ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR));
N
N  /* Reset HSEON, CSSON, PLLON bits */
N  CLEAR_BIT(vl_mask, (RCC_CR_PLLON | RCC_CR_CSSON | RCC_CR_HSEON));
X  ((vl_mask) &= ~(((0x1UL << (24U)) | (0x1UL << (19U)) | (0x1UL << (16U)))));
N
N  /* Write new value in CR register */
N  MS32_RCC_WriteReg(CR, vl_mask);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CR) = ((vl_mask)));
N
N  /* Wait for PLL READY bit to be reset */
N  while(MS32_RCC_PLL_IsReady() != 0U) {
N    ;
N  }
N
N  /* Reset HSEBYP bit */
N  MS32_RCC_HSE_DisableBypass();
N
N  /* Reset CFGR register */
N  MS32_RCC_WriteReg(CFGR, 0x00000000U);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR) = ((0x00000000U)));
N
N  /* Reset CFGR2 register */
N  MS32_RCC_WriteReg(CFGR2, 0x00000000U);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR2) = ((0x00000000U)));
N
N  /* Reset CFGR3 register */
N  MS32_RCC_WriteReg(CFGR3, 0x00000000U);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CFGR3) = ((0x00000000U)));
N
N  /* Clear pending flags */
N  vl_mask = (MS32_RCC_CIR_LSIRDYC | MS32_RCC_CIR_LSERDYC | MS32_RCC_CIR_HSIRDYC | MS32_RCC_CIR_HSERDYC |\
N             MS32_RCC_CIR_PLLRDYC | MS32_RCC_CIR_CSSC);
X  vl_mask = ((0x1UL << (16U)) | (0x1UL << (17U)) | (0x1UL << (18U)) | (0x1UL << (19U)) |             (0x1UL << (20U)) | (0x1UL << (23U)));
N
N  /* Write new value in CIR register */
N  MS32_RCC_WriteReg(CIR, vl_mask);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) = ((vl_mask)));
N
N  /* Disable all interrupts */
N  MS32_RCC_WriteReg(CIR, 0x00000000U);
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) = ((0x00000000U)));
N
N  /* Clear reset flags */
N  MS32_RCC_ClearResetFlags();
N
N  return SUCCESS;
N}
N
N
N/** @defgroup RCC_EF_Config
N  * @{
N  */
N
N/**
N  * @brief  Initializes the RCC Oscillators according to the specified parameters in the
N  *         MS32_RCC_OscInitTypeDef.
N  * @param  OscInitStr pointer to an MS32_RCC_OscInitTypeDef structure that
N  *         contains the configuration information for the RCC Oscillators.
N  * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not
N  *         supported by this macro. User should request a transition to LSE Off
N  *         first and then LSE On or LSE Bypass.
N  * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not
N  *         supported by this macro. User should request a transition to HSE Off
N  *         first and then HSE On or HSE Bypass.
N  * @retval An ErrorStatus enumeration value:
N  *          - SUCCESS: HSI/HSE/LSI/LSE are initialized
N  *          - ERROR: not applicable
N  */
NErrorStatus MS32_RCC_OscConfig(MS32_RCC_OscInitTypeDef *OscInitStr) {
N  ErrorStatus state = SUCCESS;
N  uint32_t    wait_time;
N  __IO uint8_t pwr_clk_en_bk, rtc_dm_acc_bk;
X  volatile uint8_t pwr_clk_en_bk, rtc_dm_acc_bk;
N
N  /*------------------------------- HSI Configuration ------------------------*/
N  wait_time = HSI_READY_TIME;
X  wait_time = (96);
N  switch (OscInitStr->HSIState) {
N    case MS32_RCC_HSI_OFF:
X    case (0x00000000U):
N      if ((MS32_RCC_GetSysClkSource() != MS32_RCC_SYS_CLKSOURCE_STATUS_HSI) \
N        && (MS32_RCC_PLL_GetMainSource() != MS32_RCC_PLLSOURCE_HSI_DIV_2)) {
X      if ((MS32_RCC_GetSysClkSource() != (0x00000000U))         && (MS32_RCC_PLL_GetMainSource() != (0x00000000U))) {
N        MS32_RCC_HSI_Disable();
N        while (MS32_RCC_HSI_IsReady() && (--wait_time));
N      } else {
N        state = ERROR;
N      }
N      break;
N    case MS32_RCC_HSI_ON:
X    case (0x1UL << (0U)):
N      MS32_RCC_HSI_Enable();
N      while (!MS32_RCC_HSI_IsReady() && (--wait_time));
N      break;
N    default:
N      state = ERROR;
N      break;
N  }
N  if (!wait_time) {
N    state = ERROR;
N  }
N
N  /*------------------------------- HSE Configuration ------------------------*/
N  wait_time = HSE_READY_TIME;
X  wait_time = (96000);
N  switch (OscInitStr->HSEState) {
N    case MS32_RCC_HSE_OFF:
X    case (0x00000000U):
N      if ((MS32_RCC_GetSysClkSource() != MS32_RCC_SYS_CLKSOURCE_STATUS_HSE) \
N        && (MS32_RCC_PLL_GetMainSource() != MS32_RCC_PLLSOURCE_HSE)) {
X      if ((MS32_RCC_GetSysClkSource() != (0x00000004U))         && (MS32_RCC_PLL_GetMainSource() != (0x00010000U))) {
N        MS32_RCC_HSE_Disable();
N        while (MS32_RCC_HSE_IsReady() && (--wait_time));
N        if (wait_time) {
N          MS32_RCC_HSE_DisableBypass();
N        }
N      } else {
N        state = ERROR;
N      }
N      break;
N    case MS32_RCC_HSE_BYPASS:
X    case ((0x1UL << (16U)) | (0x1UL << (18U))):
N      MS32_RCC_HSE_EnableBypass();
N    case MS32_RCC_HSE_ON:
X    case (0x1UL << (16U)):
N      MS32_RCC_HSE_Enable();
N      if (OscInitStr->HSEState == MS32_RCC_HSE_ON) {
X      if (OscInitStr->HSEState == (0x1UL << (16U))) {
N        while (!MS32_RCC_HSE_IsReady() && (--wait_time));
N      }
N      break;
N    default:
N      state = ERROR;
N      break;
N  }
N  if (!wait_time) {
N    state = ERROR;
N  }
N
N  /*------------------------------- LSI Configuration ------------------------*/
N  wait_time = LSI_READY_TIME;
X  wait_time = (4080);
N  switch (OscInitStr->LSIState) {
N    case MS32_RCC_LSI_OFF:
X    case (0x00000000U):
N      MS32_RCC_LSI_Disable();
N      while (MS32_RCC_LSI_IsReady() && (--wait_time));
N      break;
N    case MS32_RCC_LSI_ON:
X    case (0x1UL << (0U)):
N      MS32_RCC_LSI_Enable();
N      wait_time = LSI_READY_TIME;
X      wait_time = (4080);
N      while (!MS32_RCC_LSI_IsReady() && (--wait_time));
N      break;
N    default:
N      state = ERROR;
N      break;
N  }
N  if (!wait_time) {
N    state = ERROR;
N  }
N
N  /*------------------------------- LSE Configuration ------------------------*/
N  wait_time = LSE_READY_TIME;
X  wait_time = (96000000);
N  pwr_clk_en_bk = MS32_APB1_GRP1_IsEnabledClock(MS32_APB1_GRP1_PERIPH_PWR);
X  pwr_clk_en_bk = MS32_APB1_GRP1_IsEnabledClock((0x1UL << (28U)));
N  rtc_dm_acc_bk = MS32_PWR_IsEnabledBkUpAccess();
N  MS32_APB1_GRP1_EnableClock(MS32_APB1_GRP1_PERIPH_PWR);
X  MS32_APB1_GRP1_EnableClock((0x1UL << (28U)));
N  MS32_PWR_EnableBkUpAccess();
N  switch (OscInitStr->LSEState) {
N    case MS32_RCC_LSE_OFF:
X    case (0x00000000U):
N      MS32_RCC_LSE_Disable();
N      while (MS32_RCC_LSE_IsReady() && (--wait_time));
N      if (wait_time) {
N        MS32_RCC_LSE_DisableBypass();
N      }
N      break;
N    case MS32_RCC_LSE_BYPASS:
X    case ((0x1UL << (0U)) | (0x1UL << (2U))):
N      MS32_RCC_LSE_EnableBypass();
N    case MS32_RCC_LSE_ON_DRV_L:
X    case ((0x1UL << (0U)) | (0x00000000U)):
N    case MS32_RCC_LSE_ON_DRV_ML:
X    case ((0x1UL << (0U)) | (0x2UL << (3U))):
N    case MS32_RCC_LSE_ON_DRV_MH:
X    case ((0x1UL << (0U)) | (0x1UL << (3U))):
N    case MS32_RCC_LSE_ON_DRV_H:
X    case ((0x1UL << (0U)) | (0x3UL << (3U))):
N      MS32_RCC_LSE_SetDriveCapability(OscInitStr->LSEState & RCC_BDCR_LSEDRV);
X      MS32_RCC_LSE_SetDriveCapability(OscInitStr->LSEState & (0x3UL << (3U)));
N      MS32_RCC_LSE_Enable();
N      while (!MS32_RCC_LSE_IsReady() && (--wait_time));
N      break;
N    default:
N      state = ERROR;
N      break;
N  }
N  if (!rtc_dm_acc_bk) {
N    MS32_PWR_DisableBkUpAccess();
N  }
N  if (!pwr_clk_en_bk) {
N    MS32_APB1_GRP1_DisableClock(MS32_APB1_GRP1_PERIPH_PWR);
X    MS32_APB1_GRP1_DisableClock((0x1UL << (28U)));
N  }
N  if (!wait_time) {
N    state = ERROR;
N  }
N
N  return state;
N}
N
N/**
N  * @brief  Configures the OscInitStr according to the internal 
N  *         RCC configuration registers.
N  * @param  OscInitStr pointer to an MS32_RCC_PllInitTypeDef structure that 
N  *         will be configured.
N  * @retval None
N  */
Nvoid MS32_RCC_GetOscConfig(MS32_RCC_OscInitTypeDef *OscInitStr) {
N  /* Get the HSI configuration -----------------------------------------------*/
N  if (MS32_RCC_HSI_IsReady()) {
N    OscInitStr->HSIState = MS32_RCC_HSI_ON;
X    OscInitStr->HSIState = (0x1UL << (0U));
N  } else {
N    OscInitStr->HSIState = MS32_RCC_HSI_OFF;
X    OscInitStr->HSIState = (0x00000000U);
N  }
N
N  /* Get the HSE configuration -----------------------------------------------*/
N  if (MS32_RCC_HSE_IsBypass()) {
N    OscInitStr->HSEState = MS32_RCC_HSE_BYPASS;
X    OscInitStr->HSEState = ((0x1UL << (16U)) | (0x1UL << (18U)));
N  } else if(MS32_RCC_HSE_IsReady()) {
N    OscInitStr->HSEState = MS32_RCC_HSE_ON;
X    OscInitStr->HSEState = (0x1UL << (16U));
N  } else {
N    OscInitStr->HSEState = MS32_RCC_HSE_OFF;
X    OscInitStr->HSEState = (0x00000000U);
N  }
N  
N  /* Get the LSI configuration -----------------------------------------------*/
N  if(MS32_RCC_LSI_IsReady()) {
N    OscInitStr->LSIState = MS32_RCC_LSI_ON;
X    OscInitStr->LSIState = (0x1UL << (0U));
N  } else {
N    OscInitStr->LSIState = MS32_RCC_LSI_OFF;
X    OscInitStr->LSIState = (0x00000000U);
N  }
N
N  /* Get the LSE configuration -----------------------------------------------*/
N  if (MS32_RCC_LSE_IsBypass()) {
N    OscInitStr->LSEState = MS32_RCC_LSE_BYPASS;
X    OscInitStr->LSEState = ((0x1UL << (0U)) | (0x1UL << (2U)));
N  } else if(MS32_RCC_LSE_IsReady()) {
N    OscInitStr->LSEState = MS32_RCC_LSE_GetDriveCapability() | RCC_BDCR_LSEON;
X    OscInitStr->LSEState = MS32_RCC_LSE_GetDriveCapability() | (0x1UL << (0U));
N  } else {
N    OscInitStr->LSEState = MS32_RCC_LSE_OFF;
X    OscInitStr->LSEState = (0x00000000U);
N  }
N}
N
N/**
N  * @brief  Initializes the RCC PLL according to the specified parameters in the
N  *         MS32_RCC_PllInitTypeDef.
N  * @param  PllInitStr pointer to an MS32_RCC_PllInitTypeDef structure that
N  *         contains the configuration information for the RCC PLL.
N  * @retval An ErrorStatus enumeration value:
N  *          - SUCCESS: PLL are initialized
N  *          - ERROR: not applicable
N  */
NErrorStatus MS32_RCC_PllConfig(MS32_RCC_PllInitTypeDef *PllInitStr) {
N  ErrorStatus status = SUCCESS;
N  uint32_t    wait_time;
N
N  wait_time = PLL_READY_TIME;
X  wait_time = (9600);
N  switch (PllInitStr->PLLState) {
N    case MS32_RCC_PLL_OFF:
X    case (0x00000000U):
N      if (MS32_RCC_GetSysClkSource() != MS32_RCC_SYS_CLKSOURCE_STATUS_PLL) {
X      if (MS32_RCC_GetSysClkSource() != (0x00000008U)) {
N        MS32_RCC_PLL_Disable();
N        while (MS32_RCC_PLL_IsReady() && (--wait_time));
N      } else {
N        status = ERROR;
N      }
N      break;
N    case MS32_RCC_PLL_ON:
X    case (0x1UL << (24U)):
N      if (MS32_RCC_PLL_IsReady()) {
N        /* Check whether PLL clock used as system clock or not, when PLL is ready */
N        if (MS32_RCC_GetSysClkSource() != MS32_RCC_SYS_CLKSOURCE_STATUS_PLL) {
X        if (MS32_RCC_GetSysClkSource() != (0x00000008U)) {
N          /* PLL disable */
N          MS32_RCC_PLL_Disable();
N          while (MS32_RCC_PLL_IsReady() && (--wait_time));
N          if (!wait_time) {
N            status = ERROR;
N          }
N        } else {
N          status = ERROR;
N        }
N      }
N      /* Set PLL config and enable PLL */
N      if (status == SUCCESS) {
N        MS32_RCC_PLL_SetMainSource(PllInitStr->PLLSource);
N        MS32_RCC_PLL_SetMultiplicator(PllInitStr->PLLMUL);
N        MS32_RCC_PLL_SetPrediv(PllInitStr->PREDIV);
N        MS32_RCC_PLL_Enable();
N        wait_time = PLL_READY_TIME;
X        wait_time = (9600);
N        while (!MS32_RCC_PLL_IsReady() && (--wait_time));
N      }
N      break;
N    default:
N      status = ERROR;
N      break;
N  }
N  if (!wait_time) {
N    status = ERROR;
N  }
N
N  return status;
N}
N
N/**
N  * @brief  Configures the PllInitStr according to the internal 
N  *         RCC configuration registers.
N  * @param  PllInitStr pointer to an MS32_RCC_PllInitTypeDef structure that 
N  *         will be configured.
N  * @retval None
N  */
Nvoid MS32_RCC_GetPllConfig(MS32_RCC_PllInitTypeDef *PllInitStr) {
N  /* Get the PLL configuration -----------------------------------------------*/
N  if (MS32_RCC_PLL_IsReady()) {
N    PllInitStr->PLLState = MS32_RCC_PLL_ON;
X    PllInitStr->PLLState = (0x1UL << (24U));
N  } else {
N    PllInitStr->PLLState = MS32_RCC_PLL_OFF;
X    PllInitStr->PLLState = (0x00000000U);
N  }
N
N  /* Get the PLL clock source ------------------------------------------------*/
N  PllInitStr->PLLSource = MS32_RCC_PLL_GetMainSource();
N
N  /* Get the PLL multiplicator -----------------------------------------------*/
N  PllInitStr->PLLMUL = MS32_RCC_PLL_GetMultiplicator();
N
N  /* Get the PLL clock prediv ------------------------------------------------*/
N  PllInitStr->PREDIV = MS32_RCC_PLL_GetPrediv();
N}
N
N/**
N  * @brief  Initializes the RCC clock according to the specified parameters in the
N  *         MS32_RCC_ClkInitTypeDef.
N  * @param  ClkInitStr pointer to an MS32_RCC_ClkInitTypeDef structure that
N  *         contains the configuration information for the RCC peripheral.
N  * @note   Code enable latency and prefetch when system clock greater than 24MHz.
N  *         Code disable latency and prefetch when system clock less than or equal to 24MHz.
N  * @retval An ErrorStatus enumeration value:
N  *          - SUCCESS: clock are initialized
N  *          - ERROR: not applicable
N  */
NErrorStatus MS32_RCC_ClockConfig(MS32_RCC_ClkInitTypeDef *ClkInitStr) {
N  ErrorStatus status = SUCCESS;
N  uint32_t    sysclk, ahb_clk, wait_time;
N
N  /*----------------------------- SYSCLK Configuration -----------------------*/
N	ahb_clk = 0xFFFFFFFF;
N  switch (ClkInitStr->SYSCLKSource) {
N    case MS32_RCC_SYSCLK_SOURCE_HSI:
X    case (0x00000000U):
N      sysclk = MS32_RCC_SYS_CLKSOURCE_STATUS_HSI;
X      sysclk = (0x00000000U);
N      break;
N    case MS32_RCC_SYSCLK_SOURCE_HSE:
X    case (0x00000001U):
N      sysclk = MS32_RCC_SYS_CLKSOURCE_STATUS_HSE;
X      sysclk = (0x00000004U);
N      break;
N    case MS32_RCC_SYSCLK_SOURCE_PLL:
X    case (0x00000002U):
N      sysclk = MS32_RCC_SYS_CLKSOURCE_STATUS_PLL;
X      sysclk = (0x00000008U);
N      break;
N    default:
N      ahb_clk = 0;
N      break;
N  }
N  /* Calculate system clock */
N  if (ahb_clk) {
N    ahb_clk = __MS32_RCC_CALC_HCLK_FREQ(RCC_GetSystemClockFreq(sysclk), ClkInitStr->AHBCLKDivider);
X    ahb_clk = ((RCC_GetSystemClockFreq(sysclk)) >> AHBPrescTable[((ClkInitStr->AHBCLKDivider) & (0xFUL << (4U))) >> (4U)]);
N    /* Greater than 24000000 */
N    if (ahb_clk > SYSCLK_DELAY_FREQ1) {
X    if (ahb_clk > (24000000)) {
N      /* Flash delay one time */
N      MS32_FLASH_SetLatency(MS32_FLASH_LATENCY_1);
X      MS32_FLASH_SetLatency((0x1UL << (0U)));
N      /* Enable prefetch */
N      MS32_FLASH_EnablePrefetch();
N      wait_time = PRE_READY_TIME;
X      wait_time = (100);
N      while (!MS32_FLASH_IsPrefetchEnabled() && (--wait_time));
N      if (wait_time) {
N				/* Change system clock */
N        MS32_RCC_SetSysClkSource(ClkInitStr->SYSCLKSource);
N        wait_time = SYSCLK_SW_TIME;
X        wait_time = (100);
N        while ((MS32_RCC_GetSysClkSource() != sysclk) && (--wait_time));
N        if (wait_time) {
N          /* Set AHB and APB clock */
N          MS32_RCC_SetAHBPrescaler(ClkInitStr->AHBCLKDivider);
N          MS32_RCC_SetAPB1Prescaler(ClkInitStr->APB1CLKDivider);
N        } else {
N          status = ERROR;
N        }
N      } else {
N        status = ERROR;
N      }
N    /* Less than or equal to 24000000 */
N    } else {
N			/* Set AHB and APB clock */
N			MS32_RCC_SetAHBPrescaler(ClkInitStr->AHBCLKDivider);
N			MS32_RCC_SetAPB1Prescaler(ClkInitStr->APB1CLKDivider);
N			/* Change system clock */
N      MS32_RCC_SetSysClkSource(ClkInitStr->SYSCLKSource);
N      wait_time = SYSCLK_SW_TIME;
X      wait_time = (100);
N      while ((MS32_RCC_GetSysClkSource() != sysclk) && (--wait_time));
N      if (wait_time) {
N        /* Disable prefetch */
N        MS32_FLASH_DisablePrefetch();
N        wait_time = PRE_READY_TIME;
X        wait_time = (100);
N        while (MS32_FLASH_IsPrefetchEnabled() && (--wait_time));
N        if (wait_time) {
N          /* Flash delay no time */
N          MS32_FLASH_SetLatency(MS32_FLASH_LATENCY_0);
X          MS32_FLASH_SetLatency((0x00000000U));
N        } else {
N          status = ERROR;
N        }
N      } else {
N        status = ERROR;
N      }
N    }
N  } else {
N    status = ERROR;
N  }
N
N  return status;
N}
N
N/**
N  * @brief  Configures the ClkInitStr according to the internal 
N  *         RCC configuration registers.
N  * @param  ClkInitStr pointer to an MS32_RCC_ClkInitTypeDef structure that 
N  *         will be configured.
N  * @retval None
N  */
Nvoid MS32_RCC_GetClockConfig(MS32_RCC_ClkInitTypeDef *ClkInitStr) {
N  /* Get system clock configuration ------------------------------------------*/
N  switch (MS32_RCC_GetSysClkSource()) {
N    case MS32_RCC_SYS_CLKSOURCE_STATUS_HSI:
X    case (0x00000000U):
N      ClkInitStr->SYSCLKSource = MS32_RCC_SYSCLK_SOURCE_HSI;
X      ClkInitStr->SYSCLKSource = (0x00000000U);
N      break;
N    case MS32_RCC_SYS_CLKSOURCE_STATUS_HSE:
X    case (0x00000004U):
N      ClkInitStr->SYSCLKSource = MS32_RCC_SYSCLK_SOURCE_HSE;
X      ClkInitStr->SYSCLKSource = (0x00000001U);
N      break;
N    case MS32_RCC_SYS_CLKSOURCE_STATUS_PLL:
X    case (0x00000008U):
N      ClkInitStr->SYSCLKSource = MS32_RCC_SYSCLK_SOURCE_PLL;
X      ClkInitStr->SYSCLKSource = (0x00000002U);
N      break;
N    default:
N      break;
N  }
N
N  /* Get the PLL clock source ------------------------------------------------*/
N  ClkInitStr->AHBCLKDivider = MS32_RCC_GetAHBPrescaler();
N
N  /* Get the PLL multiplicator -----------------------------------------------*/
N  ClkInitStr->APB1CLKDivider = MS32_RCC_GetAPB1Prescaler();
N}
N
N/**
N  * @brief  Selects the clock source to output on MCO pin.
N  * @note   MCO pin should be configured in alternate function mode.
N  * @note   This function include gpio configuration.
N  * @param  McoSource specifies the clock source to output.
N  *          This parameter can be one of the following values:
N  *            @arg @ref MS32_MCO_SOURCE_NOCLOCK  No clock selected
N  *            @arg @ref MS32_MCO_SOURCE_HSI16    internal RC 16M selected as MCO clock
N  *            @arg @ref MS32_MCO_SOURCE_LSI      LSI selected as MCO clock
N  *            @arg @ref MS32_MCO_SOURCE_LSE      LSE selected as MCO clock
N  *            @arg @ref MS32_MCO_SOURCE_SYSCLK   System Clock selected as MCO clock
N  *            @arg @ref MS32_MCO_SOURCE_HSI      HSI selected as MCO clock
N  *            @arg @ref MS32_MCO_SOURCE_HSE      HSE selected as MCO clock
N  *            @arg @ref MS32_MCO_SOURCE_PLL_DIV2 PLLCLK Divided by 2 selected as MCO clock
N  *            @arg @ref MS32_MCO_SOURCE_PLL      PLLCLK selected as MCO clock
N  * @param  McoDiv specifies the MCO DIV.
N  *          This parameter can be one of the following values:
N  *            @arg @ref MS32_MCO_DIV1   no division applied to MCO clock
N  *            @arg @ref MS32_MCO_DIV2   division by 2 applied to MCO clock
N  *            @arg @ref MS32_MCO_DIV4   division by 4 applied to MCO clock
N  *            @arg @ref MS32_MCO_DIV8   division by 8 applied to MCO clock
N  *            @arg @ref MS32_MCO_DIV16  division by 16 applied to MCO clock
N  *            @arg @ref MS32_MCO_DIV32  division by 32 applied to MCO clock
N  *            @arg @ref MS32_MCO_DIV64  division by 64 applied to MCO clock
N  *            @arg @ref MS32_MCO_DIV128 division by 128 applied to MCO clock
N  * @retval None
N  */
Nvoid MS32_RCC_MCOConfig(uint32_t McoSource, uint32_t McoDiv) {
N  MS32_GPIO_InitTypeDef gpio_init_str;
N
N  /* MCO Clock Enable */
N  MCO_CLK_ENABLE();
X  MS32_AHB1_GRP1_EnableClock((0x1UL << (17U)));
N  /* Configure the MCO pin in alternate function mode */
N  gpio_init_str.Mode      = MS32_GPIO_MODE_ALTERNATE;
X  gpio_init_str.Mode      = (0x2UL << (0U));
N  gpio_init_str.Speed     = MS32_GPIO_SPEED_FREQ_HIGH;
X  gpio_init_str.Speed     = (0x3UL << (0U));
N  gpio_init_str.Pull      = MS32_GPIO_PULL_NO;
X  gpio_init_str.Pull      = (0x00000000U);
N  gpio_init_str.Pin       = MCO_PIN;
X  gpio_init_str.Pin       = (0x00000100U);
N  gpio_init_str.Alternate = MCO_AF;
X  gpio_init_str.Alternate = (0x0000000U);
N  MS32_GPIO_Init(MCO_GPIO_PORT, &gpio_init_str);
X  MS32_GPIO_Init(((GPIO_TypeDef *) ((0x40000000UL + 0x08000000UL) + 0x00000000UL)), &gpio_init_str);
N
N  /* Configure the MCO clock source */
N  MS32_RCC_ConfigMCO(McoSource, McoDiv);
N}
N
N/**
N  * @brief  Enable/disable the Clock Security System.
N  * @note   If a failure is detected on the HSE oscillator clock, this oscillator
N  *         is automatically disabled and an interrupt is generated to inform the
N  *         software about the failure (Clock Security System Interrupt, CSSI),
N  *         allowing the MCU to perform rescue operations. The CSSI is linked to 
N  *         the Cortex-M0 NMI (Non-Maskable Interrupt) exception vector. 
N  * @param  CssState specifies the HSE CSS.
N  *          This parameter can be one of the following values:
N  *            @arg @ref ENABLE  enable the Clock Security System
N  *            @arg @ref DISABLE disable the Clock Security System 
N  * @retval None
N  */
Nvoid MS32_RCC_CSS(FunctionalState CssState) {
N  if (CssState == ENABLE) {
N    MS32_RCC_HSE_EnableCSS();
N  } else {
N    MS32_RCC_HSE_DisableCSS();
N  }
N}
N
N/**
N  * @brief  Initializes the RCC interrupt according to the specified parameters.
N  * @param  InterruptFunc  contains the configuration information for the RCC interrupt.
N  *         This parameter can be one or more of the following values:
N  *         @arg @ref MS32_RCC_IT_LSIRDYIE  LSI Ready Interrupt Enable
N  *         @arg @ref MS32_RCC_IT_LSERDYIE  LSE Ready Interrupt Enable
N  *         @arg @ref MS32_RCC_IT_HSIRDYIE  HSI Ready Interrupt Enable
N  *         @arg @ref MS32_RCC_IT_HSERDYIE  HSE Ready Interrupt Enable
N  *         @arg @ref MS32_RCC_IT_PLLRDYIE  PLL Ready Interrupt Enable
N  * @param  Priority  the interrupt priority 
N  *         This parameter can be a value of 0x0~0x3
N  * @retval None
N  */
Nvoid MS32_RCC_ITConfig(uint32_t InterruptFunc, uint32_t Priority) {
N  /*-------------------------------- ALL Interrrupt --------------------------*/
N  SET_BIT(RCC->CIR, (MS32_RCC_FLAG_ALLRDY << CLEAR_FLAG_OFFSET));
X  ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) |= ((((0x1UL << (0U)) | (0x1UL << (1U)) | (0x1UL << (2U)) | (0x1UL << (3U)) | (0x1UL << (4U))) << ((16U) - (0U)))));
N  MODIFY_REG(RCC->CIR, MS32_RCC_IT_ALLRDYIE, InterruptFunc);
X  (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR)) = ((((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR))) & (~(((0x1UL << (8U)) | (0x1UL << (9U)) | (0x1UL << (10U)) | (0x1UL << (11U)) | (0x1UL << (12U)))))) | (InterruptFunc))));
N
N  /*----------------------------- NVIC configuration -------------------------*/
N  if (READ_BIT(RCC->CIR, MS32_RCC_IT_ALLRDYIE)) {
X  if (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) & (((0x1UL << (8U)) | (0x1UL << (9U)) | (0x1UL << (10U)) | (0x1UL << (11U)) | (0x1UL << (12U)))))) {
N    NVIC_EnableIRQ(RCC_IRQn);
X    __NVIC_EnableIRQ(RCC_IRQn);
N    NVIC_SetPriority(RCC_IRQn, Priority);
X    __NVIC_SetPriority(RCC_IRQn, Priority);
N  } else {
N    NVIC_DisableIRQ(RCC_IRQn);
X    __NVIC_DisableIRQ(RCC_IRQn);
N  }
N}
N
N/**
N  * @brief  Get the interrupt and error flags according to the internal 
N  *         RCC CIR registers.
N  * @param  Flags specifies the function flags.
N  *          This parameter can be one of the following values:
N  *            @arg @ref MS32_FLAG_LSIRDY  the LSI ready flag
N  *            @arg @ref MS32_FLAG_LSERDY  the LSE ready flag
N  *            @arg @ref MS32_FLAG_HSIRDY  the HSI ready flag
N  *            @arg @ref MS32_FLAG_HSERDY  the HSE ready flag
N  *            @arg @ref MS32_FLAG_PLLRDY  the PLL ready flag
N  *            @arg @ref MS32_FLAG_CSS     the Clock Security System flag
N  * @note   Clear flags After getting the interrupt or error flags equal to set. 
N  * @retval A FlagStatus enumeration value:
N  *          - SET:   flag set(equal to "1")
N  *          - RESET: flag no set(equal to "0")
N  */
NFlagStatus MS32_RCC_GetStatusFlag(uint32_t Flags) {
N  FlagStatus flags;
N
N  if (READ_BIT(RCC->CIR, Flags)) {
X  if (((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) & (Flags))) {
N    flags = SET;
N    SET_BIT(RCC->CIR, (Flags << CLEAR_FLAG_OFFSET));
X    ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CIR) |= ((Flags << ((16U) - (0U)))));
N  } else {
N    flags = RESET;
N  }
N
N  return flags;
N}
N
N/**
N  * @brief  Get the reset flags according to the internal 
N  *         RCC CSR registers.
N  * @param  FlagClrCtrl specifies whether clear reset all flag or net.
N  *          This parameter can be one of the following values:
N  *            @arg @ref ENABLE   clear all reset flag
N  *            @arg @ref DISABLE  no action
N  * @retval All Flags value(registor):
N  *          This parameter can be one or more of the following values:
N  *          - MS32_FLAG_OBLRSTF:    OBL reset flag
N  *          - MS32_FLAG_PINRSTF:    PIN reset flag
N  *          - MS32_FLAG_PORRSTF:    POR/PDR reset flag
N  *          - MS32_FLAG_SFTRSTF:    Software Reset flag
N  *          - MS32_FLAG_IWDGRSTF:   Independent Watchdog reset flag
N  *          - MS32_FLAG_WWDGRSTF:   Window watchdog reset flag
N  *          - MS32_FLAG_LPWRRSTF:   Low-Power reset flag
N  *          - MS32_FLAG_V15PWRRSTF: Reset flag of the 1.5 V domain
N  */
Nuint32_t MS32_RCC_GetResetFlag(FunctionalState FlagClrCtrl) {
N  uint32_t flags;
N
N  flags = READ_BIT(RCC->CSR, MS32_RCC_FLAG_ALLRSTF);
X  flags = ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x00001000UL))->CSR) & (((0x1UL << (25U)) | (0x1UL << (26U)) | (0x1UL << (27U)) | (0x1UL << (28U)) | (0x1UL << (29U)) | (0x1UL << (30U)) | (0x1UL << (31U)) | (0x1UL << (23U)))));
N  if (FlagClrCtrl == ENABLE) {
N    MS32_RCC_ClearResetFlags();
N  }
N  return flags;
N}
N
N
N/** @defgroup RCC_EF_Get_Freq
N  * @{
N  */
N/**
N  * @brief  Return the frequencies of different on chip clocks;  System, AHB and APB1 buses clocks
N  * @note   Each time SYSCLK, HCLK and/or PCLK1 clock changes, this function
N  *         must be called to update structure fields. Otherwise, any
N  *         configuration based on this function will be incorrect.
N  * @param  RCC_Clocks pointer to a @ref MS32_RCC_ClocksTypeDef structure which will hold the clocks frequencies
N  * @retval None
N  */
Nvoid MS32_RCC_GetSystemClocksFreq(MS32_RCC_ClocksTypeDef *RccClocks) {
N  /* Get SYSCLK frequency */
N  RccClocks->SYSCLK_Frequency = RCC_GetSystemClockFreq(MS32_RCC_GetSysClkSource());
N
N  /* HCLK clock frequency */
N  RccClocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RccClocks->SYSCLK_Frequency);
N
N  /* PCLK1 clock frequency */
N  RccClocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RccClocks->HCLK_Frequency);
N}
N
N/**
N  * @brief  Return USARTx clock frequency
N  * @param  UsartxSource This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_USART1_CLKSOURCE
N  * @retval USART clock frequency (in Hz)
N  *         @arg @ref MS32_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI or LSE) is not ready
N  */
Nuint32_t MS32_RCC_GetUSARTClockFreq(uint32_t UsartxSource) {
N  uint32_t usart_frequency = MS32_RCC_PERIPH_FREQUENCY_NO;
X  uint32_t usart_frequency = 0x00000000U;
N
N  if (UsartxSource == MS32_RCC_USART1_CLKSOURCE) {
X  if (UsartxSource == (uint32_t)0U) {
N    /* USART1CLK clock frequency */
N    switch (MS32_RCC_GetUSARTClockSource(UsartxSource)) {
N      case MS32_RCC_USART1_CLKSOURCE_SYSCLK: /* USART1 Clock is System Clock */
X      case (uint32_t)(((uint32_t)0U << 24) | (0x00000001U)):  
N        usart_frequency = RCC_GetSystemClockFreq(MS32_RCC_GetSysClkSource());
N        break;
N
N      case MS32_RCC_USART1_CLKSOURCE_HSI:    /* USART1 Clock is HSI Osc. */
X      case (uint32_t)(((uint32_t)0U << 24) | (0x00000003U)):     
N        if (MS32_RCC_HSI_IsReady()) {
N          usart_frequency = HSI_VALUE;
X          usart_frequency = 8000000U;
N        }
N        break;
N
N      case MS32_RCC_USART1_CLKSOURCE_LSE:    /* USART1 Clock is LSE Osc. */
X      case (uint32_t)(((uint32_t)0U << 24) | (0x00000002U)):     
N        if (MS32_RCC_LSE_IsReady()) {
N          usart_frequency = LSE_VALUE;
X          usart_frequency = 32768U;
N        }
N        break;
N
N      case MS32_RCC_USART1_CLKSOURCE_PCLK1:  /* USART1 Clock is PCLK1 */
X      case (uint32_t)(((uint32_t)0U << 24) | (0x00000000U)):   
N      default:
N        usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq(MS32_RCC_GetSysClkSource())));
N        break;
N    }
N  }
N  return usart_frequency;
N}
N
N/**
N  * @brief  Return I2Cx clock frequency
N  * @param  I2cxSource This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_I2C1_CLKSOURCE
N  * @retval I2C clock frequency (in Hz)
N  *         @arg @ref MS32_RCC_PERIPH_FREQUENCY_NO indicates that HSI oscillator is not ready
N  */
Nuint32_t MS32_RCC_GetI2CClockFreq(uint32_t I2cxSource) {
N  uint32_t i2c_frequency = MS32_RCC_PERIPH_FREQUENCY_NO;
X  uint32_t i2c_frequency = 0x00000000U;
N
N  /* I2C1 CLK clock frequency */
N  if (I2cxSource == MS32_RCC_I2C1_CLKSOURCE) {
X  if (I2cxSource == (0x1UL << (4U))) {
N    switch (MS32_RCC_GetI2CClockSource(I2cxSource)) {
N      case MS32_RCC_I2C1_CLKSOURCE_SYSCLK: /* I2C1 Clock is System Clock */
X      case (0x1UL << (4U)):  
N        i2c_frequency = RCC_GetSystemClockFreq(MS32_RCC_GetSysClkSource());
N        break;
N
N      case MS32_RCC_I2C1_CLKSOURCE_HSI:    /* I2C1 Clock is HSI Osc. */
X      case (0x00000000U):     
N      default:
N        if (MS32_RCC_HSI_IsReady()) {
N          i2c_frequency = HSI_VALUE;
X          i2c_frequency = 8000000U;
N        }
N        break;
N    }
N  }
N
N  return i2c_frequency;
N}
N
N
N/** @addtogroup RCC_MS32_Private_Functions
N  * @{
N  */
N
N/**
N  * @brief  Return SYSTEM clock frequency
N  * @param  SYSCLK_Sws This parameter can be one of the following values:
N  *         @arg @ref MS32_RCC_SYS_CLKSOURCE_STATUS_HSI
N  *         @arg @ref MS32_RCC_SYS_CLKSOURCE_STATUS_HSE
N  *         @arg @ref MS32_RCC_SYS_CLKSOURCE_STATUS_PLL
N  * @retval SYSTEM clock frequency (in Hz)
N  */
Nstatic uint32_t RCC_GetSystemClockFreq(uint32_t SYSCLK_Sws) {
N  uint32_t frequency = 0U;
N
N  /* Get SYSCLK source -------------------------------------------------------*/
N  switch (SYSCLK_Sws) {
N    case MS32_RCC_SYS_CLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
X    case (0x00000000U):   
N      frequency = HSI_VALUE;
X      frequency = 8000000U;
N      break;
N
N    case MS32_RCC_SYS_CLKSOURCE_STATUS_HSE:  /* HSE used as system clock source */
X    case (0x00000004U):   
N      frequency = HSE_VALUE;
X      frequency = 8000000U;
N      break;
N
N    case MS32_RCC_SYS_CLKSOURCE_STATUS_PLL:  /* PLL used as system clock source */
X    case (0x00000008U):   
N      frequency = RCC_PLL_GetFreqDomain_SYS();
N      break;
N
N    default:
N      frequency = HSI_VALUE;
X      frequency = 8000000U;
N      break;
N  }
N
N  return frequency;
N}
N
N/**
N  * @brief  Return HCLK clock frequency
N  * @param  SYSCLK_Frequency SYSCLK clock frequency
N  * @retval HCLK clock frequency (in Hz)
N  */
Nstatic uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency) {
N  /* HCLK clock frequency */
N  return __MS32_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, MS32_RCC_GetAHBPrescaler());
X  return ((SYSCLK_Frequency) >> AHBPrescTable[((MS32_RCC_GetAHBPrescaler()) & (0xFUL << (4U))) >> (4U)]);
N}
N
N/**
N  * @brief  Return PCLK1 clock frequency
N  * @param  HCLK_Frequency HCLK clock frequency
N  * @retval PCLK1 clock frequency (in Hz)
N  */
Nstatic uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency) {
N  /* PCLK1 clock frequency */
N  return __MS32_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, MS32_RCC_GetAPB1Prescaler());
X  return ((HCLK_Frequency) >> APBPrescTable[(MS32_RCC_GetAPB1Prescaler()) >> (8U)]);
N}
N
N/**
N  * @brief  Return PLL clock frequency used for system domain
N  * @retval PLL clock frequency (in Hz)
N  */
Nstatic uint32_t RCC_PLL_GetFreqDomain_SYS(void) {
N  uint32_t pllinputfreq = 0U, pllsource = 0U;
N
N  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL divider) * PLL Multiplicator */
N
N  /* Get PLL source */
N  pllsource = MS32_RCC_PLL_GetMainSource();
N
N  switch (pllsource) {
N    case MS32_RCC_PLLSOURCE_HSI_DIV_2: /* HSI used as PLL clock source */
X    case (0x00000000U):  
N      pllinputfreq = HSI_VALUE >> 1U;
X      pllinputfreq = 8000000U >> 1U;
N      break;
N
N    case MS32_RCC_PLLSOURCE_HSE:       /* HSE used as PLL clock source */
X    case (0x00010000U):        
N      pllinputfreq = HSE_VALUE;
X      pllinputfreq = 8000000U;
N      break;
N
N    default:
N      pllinputfreq = HSI_VALUE >> 1U;
X      pllinputfreq = 8000000U >> 1U;
N      break;
N  }
N
N  return __MS32_RCC_CALC_PLLCLK_FREQ((pllinputfreq / (MS32_RCC_PLL_GetPrediv() + 1U)), MS32_RCC_PLL_GetMultiplicator());
X  return (((pllinputfreq / (MS32_RCC_PLL_GetPrediv() + 1U))) * ((((MS32_RCC_PLL_GetMultiplicator()) & (0xFUL << (18U))) >> (uint32_t)18U) + 2U));
N}
N
N
N/******************************** END OF FILE *********************************/
